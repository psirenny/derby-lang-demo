require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({"racer":[function(require,module,exports){
module.exports=require('IocUA/');
},{}],"IocUA/":[function(require,module,exports){
var Racer = require('./Racer');
module.exports = new Racer;

},{"./Racer":1}],"derby":[function(require,module,exports){
module.exports=require('0klAo3');
},{}],"0klAo3":[function(require,module,exports){
(function(__dirname){var racer = require('racer');
var derby = module.exports = Object.create(racer);

var derbyPlugin = (racer.util.isServer) ?
  __dirname + '/derby.server' :
  require('./derby.browser');

// TODO: Remove or implement
derby.get = function() {}

derby
  // Server-side or browser-side methods
  .use(derbyPlugin);

})("/node_modules/derby/lib")
},{"racer":"IocUA/","./derby.browser":2}],3:[function(require,module,exports){
module.exports = function (app) {
  app.ready(function (model) {
    model.on('change', '_session.locale', function (locale) {
      var origin = model.get('$config.origin');
      $.post(origin + '/language/changeLocale', {locale: locale});
    });
  });
}
},{}],4:[function(require,module,exports){
module.exports = function (app) {
  app.get('/', function (page, model) {
    page.render('home');
  });

  app.get('/403', function (page) {
    page.render('403');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/404', function (page) {
    page.render('404');
  });

  app.get('/500', function (page) {
    page.render('500');
  });
};
},{}],5:[function(require,module,exports){
module.exports = function (app) {
  app.view.fn('link', function (href, text) {
    if (!href) return '';
    return '<a href="' + href + '">' + (text || href) + '</a>';
  });
};
},{}],6:[function(require,module,exports){
var racer = require('racer');
var BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;

racer.Model.prototype._createSocket = function(bundle) {
  var options = bundle.racerBrowserChannel;
  var base = options.base || 'http://localhost:3000/channel';
  if (bundle.mount) base = bundle.mount + base;
  return new BCSocket(base, options);
};

},{"racer":"IocUA/","browserchannel/dist/bcsocket-uncompressed":7}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],9:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],7:[function(require,module,exports){
(function(){
function e() {
  return function() {
  }
}
function m(a) {
  return function(b) {
    this[a] = b
  }
}
function aa(a) {
  return function() {
    return this[a]
  }
}
function ba(a) {
  return function() {
    return a
  }
}
var p, ca = ca || {}, q = this;
function da(a) {
  a = a.split(".");
  for(var b = q, c;c = a.shift();) {
    if(null != b[c]) {
      b = b[c]
    }else {
      return null
    }
  }
  return b
}
function ea() {
}
function fa(a) {
  var b = typeof a;
  if("object" == b) {
    if(a) {
      if(a instanceof Array) {
        return"array"
      }
      if(a instanceof Object) {
        return b
      }
      var c = Object.prototype.toString.call(a);
      if("[object Window]" == c) {
        return"object"
      }
      if("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return"array"
      }
      if("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return"function"
      }
    }else {
      return"null"
    }
  }else {
    if("function" == b && "undefined" == typeof a.call) {
      return"object"
    }
  }
  return b
}
function s(a) {
  return"array" == fa(a)
}
function ga(a) {
  var b = fa(a);
  return"array" == b || "object" == b && "number" == typeof a.length
}
function u(a) {
  return"string" == typeof a
}
function ha(a) {
  return"function" == fa(a)
}
function v(a) {
  return a[ia] || (a[ia] = ++ja)
}
var ia = "closure_uid_" + (1E9 * Math.random() >>> 0), ja = 0;
function ka(a, b, c) {
  return a.call.apply(a.bind, arguments)
}
function la(a, b, c) {
  if(!a) {
    throw Error();
  }
  if(2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c)
    }
  }
  return function() {
    return a.apply(b, arguments)
  }
}
function w(a, b, c) {
  w = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
  return w.apply(null, arguments)
}
var x = Date.now || function() {
  return+new Date
};
function y(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.ra = b.prototype;
  a.prototype = new c
}
;function ma(a, b) {
  for(var c = 1;c < arguments.length;c++) {
    var d = String(arguments[c]).replace(/\$/g, "$$$$");
    a = a.replace(/\%s/, d)
  }
  return a
}
function na(a) {
  if(!oa.test(a)) {
    return a
  }
  -1 != a.indexOf("&") && (a = a.replace(pa, "&amp;"));
  -1 != a.indexOf("<") && (a = a.replace(qa, "&lt;"));
  -1 != a.indexOf(">") && (a = a.replace(ra, "&gt;"));
  -1 != a.indexOf('"') && (a = a.replace(sa, "&quot;"));
  return a
}
var pa = /&/g, qa = /</g, ra = />/g, sa = /\"/g, oa = /[&<>\"]/;
var z, ta, ua, va;
function wa() {
  return q.navigator ? q.navigator.userAgent : null
}
va = ua = ta = z = !1;
var xa;
if(xa = wa()) {
  var ya = q.navigator;
  z = 0 == xa.indexOf("Opera");
  ta = !z && -1 != xa.indexOf("MSIE");
  ua = !z && -1 != xa.indexOf("WebKit");
  va = !z && !ua && "Gecko" == ya.product
}
var za = z, A = ta, Aa = va, B = ua, Ba = q.navigator, Ca = -1 != (Ba && Ba.platform || "").indexOf("Mac");
function Da() {
  var a = q.document;
  return a ? a.documentMode : void 0
}
var Ea;
a: {
  var Fa = "", Ga;
  if(za && q.opera) {
    var Ha = q.opera.version, Fa = "function" == typeof Ha ? Ha() : Ha
  }else {
    if(Aa ? Ga = /rv\:([^\);]+)(\)|;)/ : A ? Ga = /MSIE\s+([^\);]+)(\)|;)/ : B && (Ga = /WebKit\/(\S+)/), Ga) {
      var Ia = Ga.exec(wa()), Fa = Ia ? Ia[1] : ""
    }
  }
  if(A) {
    var Ja = Da();
    if(Ja > parseFloat(Fa)) {
      Ea = String(Ja);
      break a
    }
  }
  Ea = Fa
}
var Ka = {};
function C(a) {
  var b;
  if(!(b = Ka[a])) {
    b = 0;
    for(var c = String(Ea).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), d = String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), f = Math.max(c.length, d.length), g = 0;0 == b && g < f;g++) {
      var h = c[g] || "", n = d[g] || "", k = RegExp("(\\d*)(\\D*)", "g"), t = RegExp("(\\d*)(\\D*)", "g");
      do {
        var l = k.exec(h) || ["", "", ""], r = t.exec(n) || ["", "", ""];
        if(0 == l[0].length && 0 == r[0].length) {
          break
        }
        b = ((0 == l[1].length ? 0 : parseInt(l[1], 10)) < (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? -1 : (0 == l[1].length ? 0 : parseInt(l[1], 10)) > (0 == r[1].length ? 0 : parseInt(r[1], 10)) ? 1 : 0) || ((0 == l[2].length) < (0 == r[2].length) ? -1 : (0 == l[2].length) > (0 == r[2].length) ? 1 : 0) || (l[2] < r[2] ? -1 : l[2] > r[2] ? 1 : 0)
      }while(0 == b)
    }
    b = Ka[a] = 0 <= b
  }
  return b
}
var La = q.document, Ma = La && A ? Da() || ("CSS1Compat" == La.compatMode ? parseInt(Ea, 10) : 5) : void 0;
function Na(a) {
  Error.captureStackTrace ? Error.captureStackTrace(this, Na) : this.stack = Error().stack || "";
  a && (this.message = String(a))
}
y(Na, Error);
Na.prototype.name = "CustomError";
function Oa(a, b) {
  b.unshift(a);
  Na.call(this, ma.apply(null, b));
  b.shift();
  this.Jc = a
}
y(Oa, Na);
Oa.prototype.name = "AssertionError";
function Pa(a, b) {
  throw new Oa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
}
;var Qa = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
function Ra(a) {
  var b = Sa, c;
  for(c in b) {
    a.call(void 0, b[c], c, b)
  }
}
function Ta(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = a[d]
  }
  return b
}
function Ua(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = d
  }
  return b
}
var Va = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a, b) {
  for(var c, d, f = 1;f < arguments.length;f++) {
    d = arguments[f];
    for(c in d) {
      a[c] = d[c]
    }
    for(var g = 0;g < Va.length;g++) {
      c = Va[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c])
    }
  }
}
;var D = Array.prototype, Xa = D.indexOf ? function(a, b, c) {
  return D.indexOf.call(a, b, c)
} : function(a, b, c) {
  c = null == c ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
  if(u(a)) {
    return u(b) && 1 == b.length ? a.indexOf(b, c) : -1
  }
  for(;c < a.length;c++) {
    if(c in a && a[c] === b) {
      return c
    }
  }
  return-1
}, Ya = D.forEach ? function(a, b, c) {
  D.forEach.call(a, b, c)
} : function(a, b, c) {
  for(var d = a.length, f = u(a) ? a.split("") : a, g = 0;g < d;g++) {
    g in f && b.call(c, f[g], g, a)
  }
};
function Za(a) {
  return D.concat.apply(D, arguments)
}
function $a(a) {
  var b = a.length;
  if(0 < b) {
    for(var c = Array(b), d = 0;d < b;d++) {
      c[d] = a[d]
    }
    return c
  }
  return[]
}
;function ab(a) {
  if("function" == typeof a.N) {
    return a.N()
  }
  if(u(a)) {
    return a.split("")
  }
  if(ga(a)) {
    for(var b = [], c = a.length, d = 0;d < c;d++) {
      b.push(a[d])
    }
    return b
  }
  return Ta(a)
}
function E(a, b, c) {
  if("function" == typeof a.forEach) {
    a.forEach(b, c)
  }else {
    if(ga(a) || u(a)) {
      Ya(a, b, c)
    }else {
      var d;
      if("function" == typeof a.ka) {
        d = a.ka()
      }else {
        if("function" != typeof a.N) {
          if(ga(a) || u(a)) {
            d = [];
            for(var f = a.length, g = 0;g < f;g++) {
              d.push(g)
            }
          }else {
            d = Ua(a)
          }
        }else {
          d = void 0
        }
      }
      for(var f = ab(a), g = f.length, h = 0;h < g;h++) {
        b.call(c, f[h], d && d[h], a)
      }
    }
  }
}
;function bb(a, b) {
  this.O = {};
  this.j = [];
  var c = arguments.length;
  if(1 < c) {
    if(c % 2) {
      throw Error("Uneven number of arguments");
    }
    for(var d = 0;d < c;d += 2) {
      this.set(arguments[d], arguments[d + 1])
    }
  }else {
    if(a) {
      a instanceof bb ? (c = a.ka(), d = a.N()) : (c = Ua(a), d = Ta(a));
      for(var f = 0;f < c.length;f++) {
        this.set(c[f], d[f])
      }
    }
  }
}
p = bb.prototype;
p.f = 0;
p.bc = 0;
p.N = function() {
  cb(this);
  for(var a = [], b = 0;b < this.j.length;b++) {
    a.push(this.O[this.j[b]])
  }
  return a
};
p.ka = function() {
  cb(this);
  return this.j.concat()
};
p.ia = function(a) {
  return db(this.O, a)
};
p.remove = function(a) {
  return db(this.O, a) ? (delete this.O[a], this.f--, this.bc++, this.j.length > 2 * this.f && cb(this), !0) : !1
};
function cb(a) {
  if(a.f != a.j.length) {
    for(var b = 0, c = 0;b < a.j.length;) {
      var d = a.j[b];
      db(a.O, d) && (a.j[c++] = d);
      b++
    }
    a.j.length = c
  }
  if(a.f != a.j.length) {
    for(var f = {}, c = b = 0;b < a.j.length;) {
      d = a.j[b], db(f, d) || (a.j[c++] = d, f[d] = 1), b++
    }
    a.j.length = c
  }
}
p.get = function(a, b) {
  return db(this.O, a) ? this.O[a] : b
};
p.set = function(a, b) {
  db(this.O, a) || (this.f++, this.j.push(a), this.bc++);
  this.O[a] = b
};
p.n = function() {
  return new bb(this)
};
function db(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b)
}
;function F(a, b) {
  var c;
  if(a instanceof F) {
    this.D = void 0 !== b ? b : a.D, eb(this, a.qa), c = a.ab, H(this), this.ab = c, fb(this, a.ja), gb(this, a.Ba), hb(this, a.H), ib(this, a.R.n()), c = a.Ma, H(this), this.Ma = c
  }else {
    if(a && (c = String(a).match(Qa))) {
      this.D = !!b;
      eb(this, c[1] || "", !0);
      var d = c[2] || "";
      H(this);
      this.ab = d ? decodeURIComponent(d) : "";
      fb(this, c[3] || "", !0);
      gb(this, c[4]);
      hb(this, c[5] || "", !0);
      ib(this, c[6] || "", !0);
      c = c[7] || "";
      H(this);
      this.Ma = c ? decodeURIComponent(c) : ""
    }else {
      this.D = !!b, this.R = new jb(null, 0, this.D)
    }
  }
}
p = F.prototype;
p.qa = "";
p.ab = "";
p.ja = "";
p.Ba = null;
p.H = "";
p.Ma = "";
p.mc = !1;
p.D = !1;
p.toString = function() {
  var a = [], b = this.qa;
  b && a.push(kb(b, lb), ":");
  if(b = this.ja) {
    a.push("//");
    var c = this.ab;
    c && a.push(kb(c, lb), "@");
    a.push(encodeURIComponent(String(b)));
    b = this.Ba;
    null != b && a.push(":", String(b))
  }
  if(b = this.H) {
    this.ja && "/" != b.charAt(0) && a.push("/"), a.push(kb(b, "/" == b.charAt(0) ? mb : nb))
  }
  (b = this.R.toString()) && a.push("?", b);
  (b = this.Ma) && a.push("#", kb(b, ob));
  return a.join("")
};
p.n = function() {
  return new F(this)
};
function eb(a, b, c) {
  H(a);
  a.qa = c ? b ? decodeURIComponent(b) : "" : b;
  a.qa && (a.qa = a.qa.replace(/:$/, ""))
}
function fb(a, b, c) {
  H(a);
  a.ja = c ? b ? decodeURIComponent(b) : "" : b
}
function gb(a, b) {
  H(a);
  if(b) {
    b = Number(b);
    if(isNaN(b) || 0 > b) {
      throw Error("Bad port number " + b);
    }
    a.Ba = b
  }else {
    a.Ba = null
  }
}
function hb(a, b, c) {
  H(a);
  a.H = c ? b ? decodeURIComponent(b) : "" : b
}
function ib(a, b, c) {
  H(a);
  b instanceof jb ? (a.R = b, a.R.qb(a.D)) : (c || (b = kb(b, pb)), a.R = new jb(b, 0, a.D))
}
function I(a, b, c) {
  H(a);
  a.R.set(b, c)
}
function qb(a, b, c) {
  H(a);
  s(c) || (c = [String(c)]);
  rb(a.R, b, c)
}
function J(a) {
  H(a);
  I(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ x()).toString(36));
  return a
}
function H(a) {
  if(a.mc) {
    throw Error("Tried to modify a read-only Uri");
  }
}
p.qb = function(a) {
  this.D = a;
  this.R && this.R.qb(a);
  return this
};
function sb(a, b, c, d) {
  var f = new F(null, void 0);
  a && eb(f, a);
  b && fb(f, b);
  c && gb(f, c);
  d && hb(f, d);
  return f
}
function kb(a, b) {
  return u(a) ? encodeURI(a).replace(b, tb) : null
}
function tb(a) {
  a = a.charCodeAt(0);
  return"%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16)
}
var lb = /[#\/\?@]/g, nb = /[\#\?:]/g, mb = /[\#\?]/g, pb = /[\#\?@]/g, ob = /#/g;
function jb(a, b, c) {
  this.C = a || null;
  this.D = !!c
}
function K(a) {
  if(!a.i && (a.i = new bb, a.f = 0, a.C)) {
    for(var b = a.C.split("&"), c = 0;c < b.length;c++) {
      var d = b[c].indexOf("="), f = null, g = null;
      0 <= d ? (f = b[c].substring(0, d), g = b[c].substring(d + 1)) : f = b[c];
      f = decodeURIComponent(f.replace(/\+/g, " "));
      f = L(a, f);
      a.add(f, g ? decodeURIComponent(g.replace(/\+/g, " ")) : "")
    }
  }
}
p = jb.prototype;
p.i = null;
p.f = null;
p.add = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  var c = this.i.get(a);
  c || this.i.set(a, c = []);
  c.push(b);
  this.f++;
  return this
};
p.remove = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a) ? (this.C = null, this.f -= this.i.get(a).length, this.i.remove(a)) : !1
};
p.ia = function(a) {
  K(this);
  a = L(this, a);
  return this.i.ia(a)
};
p.ka = function() {
  K(this);
  for(var a = this.i.N(), b = this.i.ka(), c = [], d = 0;d < b.length;d++) {
    for(var f = a[d], g = 0;g < f.length;g++) {
      c.push(b[d])
    }
  }
  return c
};
p.N = function(a) {
  K(this);
  var b = [];
  if(a) {
    this.ia(a) && (b = Za(b, this.i.get(L(this, a))))
  }else {
    a = this.i.N();
    for(var c = 0;c < a.length;c++) {
      b = Za(b, a[c])
    }
  }
  return b
};
p.set = function(a, b) {
  K(this);
  this.C = null;
  a = L(this, a);
  this.ia(a) && (this.f -= this.i.get(a).length);
  this.i.set(a, [b]);
  this.f++;
  return this
};
p.get = function(a, b) {
  var c = a ? this.N(a) : [];
  return 0 < c.length ? String(c[0]) : b
};
function rb(a, b, c) {
  a.remove(b);
  0 < c.length && (a.C = null, a.i.set(L(a, b), $a(c)), a.f += c.length)
}
p.toString = function() {
  if(this.C) {
    return this.C
  }
  if(!this.i) {
    return""
  }
  for(var a = [], b = this.i.ka(), c = 0;c < b.length;c++) {
    for(var d = b[c], f = encodeURIComponent(String(d)), d = this.N(d), g = 0;g < d.length;g++) {
      var h = f;
      "" !== d[g] && (h += "=" + encodeURIComponent(String(d[g])));
      a.push(h)
    }
  }
  return this.C = a.join("&")
};
p.n = function() {
  var a = new jb;
  a.C = this.C;
  this.i && (a.i = this.i.n(), a.f = this.f);
  return a
};
function L(a, b) {
  var c = String(b);
  a.D && (c = c.toLowerCase());
  return c
}
p.qb = function(a) {
  a && !this.D && (K(this), this.C = null, E(this.i, function(a, c) {
    var d = c.toLowerCase();
    c != d && (this.remove(c), rb(this, d, a))
  }, this));
  this.D = a
};
function ub() {
}
ub.prototype.Ga = null;
var vb;
function wb() {
}
y(wb, ub);
function xb(a) {
  return(a = yb(a)) ? new ActiveXObject(a) : new XMLHttpRequest
}
function zb(a) {
  var b = {};
  yb(a) && (b[0] = !0, b[1] = !0);
  return b
}
function yb(a) {
  if(!a.Gb && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
    for(var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0;c < b.length;c++) {
      var d = b[c];
      try {
        return new ActiveXObject(d), a.Gb = d
      }catch(f) {
      }
    }
    throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
  }
  return a.Gb
}
vb = new wb;
function M() {
  0 != Ab && (this.Gc = Error().stack, Bb[v(this)] = this)
}
var Ab = 0, Bb = {};
M.prototype.yb = !1;
M.prototype.Ia = function() {
  if(!this.yb && (this.yb = !0, this.u(), 0 != Ab)) {
    var a = v(this);
    delete Bb[a]
  }
};
M.prototype.u = function() {
  if(this.Nb) {
    for(;this.Nb.length;) {
      this.Nb.shift()()
    }
  }
};
function N(a, b) {
  this.type = a;
  this.currentTarget = this.target = b
}
p = N.prototype;
p.u = e();
p.Ia = e();
p.na = !1;
p.defaultPrevented = !1;
p.Wa = !0;
p.preventDefault = function() {
  this.defaultPrevented = !0;
  this.Wa = !1
};
var Cb = 0;
function Db() {
}
p = Db.prototype;
p.key = 0;
p.ea = !1;
p.Ha = !1;
p.Oa = function(a, b, c, d, f, g) {
  if(ha(a)) {
    this.Ib = !0
  }else {
    if(a && a.handleEvent && ha(a.handleEvent)) {
      this.Ib = !1
    }else {
      throw Error("Invalid listener argument");
    }
  }
  this.W = a;
  this.Ub = b;
  this.src = c;
  this.type = d;
  this.capture = !!f;
  this.lb = g;
  this.Ha = !1;
  this.key = ++Cb;
  this.ea = !1
};
p.handleEvent = function(a) {
  return this.Ib ? this.W.call(this.lb || this.src, a) : this.W.handleEvent.call(this.W, a)
};
var Eb = !A || A && 9 <= Ma, Fb = A && !C("9");
!B || C("528");
Aa && C("1.9b") || A && C("8") || za && C("9.5") || B && C("528");
Aa && !C("8") || A && C("9");
function Gb(a) {
  Gb[" "](a);
  return a
}
Gb[" "] = ea;
function Hb(a, b) {
  a && this.Oa(a, b)
}
y(Hb, N);
p = Hb.prototype;
p.target = null;
p.relatedTarget = null;
p.offsetX = 0;
p.offsetY = 0;
p.clientX = 0;
p.clientY = 0;
p.screenX = 0;
p.screenY = 0;
p.button = 0;
p.keyCode = 0;
p.charCode = 0;
p.ctrlKey = !1;
p.altKey = !1;
p.shiftKey = !1;
p.metaKey = !1;
p.yc = !1;
p.zb = null;
p.Oa = function(a, b) {
  var c = this.type = a.type;
  N.call(this, c);
  this.target = a.target || a.srcElement;
  this.currentTarget = b;
  var d = a.relatedTarget;
  if(d) {
    if(Aa) {
      var f;
      a: {
        try {
          Gb(d.nodeName);
          f = !0;
          break a
        }catch(g) {
        }
        f = !1
      }
      f || (d = null)
    }
  }else {
    "mouseover" == c ? d = a.fromElement : "mouseout" == c && (d = a.toElement)
  }
  this.relatedTarget = d;
  this.offsetX = B || void 0 !== a.offsetX ? a.offsetX : a.layerX;
  this.offsetY = B || void 0 !== a.offsetY ? a.offsetY : a.layerY;
  this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX;
  this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY;
  this.screenX = a.screenX || 0;
  this.screenY = a.screenY || 0;
  this.button = a.button;
  this.keyCode = a.keyCode || 0;
  this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);
  this.ctrlKey = a.ctrlKey;
  this.altKey = a.altKey;
  this.shiftKey = a.shiftKey;
  this.metaKey = a.metaKey;
  this.yc = Ca ? a.metaKey : a.ctrlKey;
  this.state = a.state;
  this.zb = a;
  a.defaultPrevented && this.preventDefault();
  delete this.na
};
p.preventDefault = function() {
  Hb.ra.preventDefault.call(this);
  var a = this.zb;
  if(a.preventDefault) {
    a.preventDefault()
  }else {
    if(a.returnValue = !1, Fb) {
      try {
        if(a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {
          a.keyCode = -1
        }
      }catch(b) {
      }
    }
  }
};
p.u = e();
var Sa = {}, O = {}, P = {}, Ib = {};
function Jb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Jb(a, b[g], c, d, f)
    }
    return null
  }
  a: {
    if(!b) {
      throw Error("Invalid event type");
    }
    d = !!d;
    var h = O;
    b in h || (h[b] = {f:0, t:0});
    h = h[b];
    d in h || (h[d] = {f:0, t:0}, h.f++);
    var h = h[d], g = v(a), n;
    h.t++;
    if(h[g]) {
      n = h[g];
      for(var k = 0;k < n.length;k++) {
        if(h = n[k], h.W == c && h.lb == f) {
          if(h.ea) {
            break
          }
          n[k].Ha = !1;
          a = n[k];
          break a
        }
      }
    }else {
      n = h[g] = [], h.f++
    }
    k = Kb();
    h = new Db;
    h.Oa(c, k, a, b, d, f);
    h.Ha = !1;
    k.src = a;
    k.W = h;
    n.push(h);
    P[g] || (P[g] = []);
    P[g].push(h);
    a.addEventListener ? a != q && a.wb || a.addEventListener(b, k, d) : a.attachEvent(b in Ib ? Ib[b] : Ib[b] = "on" + b, k);
    a = h
  }
  b = a.key;
  Sa[b] = a;
  return b
}
function Kb() {
  var a = Lb, b = Eb ? function(c) {
    return a.call(b.src, b.W, c)
  } : function(c) {
    c = a.call(b.src, b.W, c);
    if(!c) {
      return c
    }
  };
  return b
}
function Mb(a, b, c, d, f) {
  if(s(b)) {
    for(var g = 0;g < b.length;g++) {
      Mb(a, b[g], c, d, f)
    }
  }else {
    d = !!d;
    a: {
      g = O;
      if(b in g && (g = g[b], d in g && (g = g[d], a = v(a), g[a]))) {
        a = g[a];
        break a
      }
      a = null
    }
    if(a) {
      for(g = 0;g < a.length;g++) {
        if(a[g].W == c && a[g].capture == d && a[g].lb == f) {
          Nb(a[g].key);
          break
        }
      }
    }
  }
}
function Nb(a) {
  var b = Sa[a];
  if(!b || b.ea) {
    return!1
  }
  var c = b.src, d = b.type, f = b.Ub, g = b.capture;
  c.removeEventListener ? c != q && c.wb || c.removeEventListener(d, f, g) : c.detachEvent && c.detachEvent(d in Ib ? Ib[d] : Ib[d] = "on" + d, f);
  c = v(c);
  if(P[c]) {
    var f = P[c], h = Xa(f, b);
    0 <= h && D.splice.call(f, h, 1);
    0 == f.length && delete P[c]
  }
  b.ea = !0;
  if(b = O[d][g][c]) {
    b.Mb = !0, Ob(d, g, c, b)
  }
  delete Sa[a];
  return!0
}
function Ob(a, b, c, d) {
  if(!d.Qa && d.Mb) {
    for(var f = 0, g = 0;f < d.length;f++) {
      d[f].ea ? d[f].Ub.src = null : (f != g && (d[g] = d[f]), g++)
    }
    d.length = g;
    d.Mb = !1;
    0 == g && (delete O[a][b][c], O[a][b].f--, 0 == O[a][b].f && (delete O[a][b], O[a].f--), 0 == O[a].f && delete O[a])
  }
}
function Pb(a) {
  var b = 0;
  if(null != a) {
    if(a = v(a), P[a]) {
      a = P[a];
      for(var c = a.length - 1;0 <= c;c--) {
        Nb(a[c].key), b++
      }
    }
  }else {
    Ra(function(a, c) {
      Nb(c);
      b++
    })
  }
}
function Qb(a, b, c, d, f) {
  var g = 1;
  b = v(b);
  if(a[b]) {
    var h = --a.t, n = a[b];
    n.Qa ? n.Qa++ : n.Qa = 1;
    try {
      for(var k = n.length, t = 0;t < k;t++) {
        var l = n[t];
        l && !l.ea && (g &= !1 !== Rb(l, f))
      }
    }finally {
      a.t = Math.max(h, a.t), n.Qa--, Ob(c, d, b, n)
    }
  }
  return Boolean(g)
}
function Rb(a, b) {
  a.Ha && Nb(a.key);
  return a.handleEvent(b)
}
function Lb(a, b) {
  if(a.ea) {
    return!0
  }
  var c = a.type, d = O;
  if(!(c in d)) {
    return!0
  }
  var d = d[c], f, g;
  if(!Eb) {
    f = b || da("window.event");
    var h = !0 in d, n = !1 in d;
    if(h) {
      if(0 > f.keyCode || void 0 != f.returnValue) {
        return!0
      }
      a: {
        var k = !1;
        if(0 == f.keyCode) {
          try {
            f.keyCode = -1;
            break a
          }catch(t) {
            k = !0
          }
        }
        if(k || void 0 == f.returnValue) {
          f.returnValue = !0
        }
      }
    }
    k = new Hb;
    k.Oa(f, this);
    f = !0;
    try {
      if(h) {
        for(var l = [], r = k.currentTarget;r;r = r.parentNode) {
          l.push(r)
        }
        g = d[!0];
        g.t = g.f;
        for(var G = l.length - 1;!k.na && 0 <= G && g.t;G--) {
          k.currentTarget = l[G], f &= Qb(g, l[G], c, !0, k)
        }
        if(n) {
          for(g = d[!1], g.t = g.f, G = 0;!k.na && G < l.length && g.t;G++) {
            k.currentTarget = l[G], f &= Qb(g, l[G], c, !1, k)
          }
        }
      }else {
        f = Rb(a, k)
      }
    }finally {
      l && (l.length = 0)
    }
    return f
  }
  c = new Hb(b, this);
  return f = Rb(a, c)
}
;function Sb() {
  M.call(this)
}
y(Sb, M);
p = Sb.prototype;
p.wb = !0;
p.pb = null;
p.addEventListener = function(a, b, c, d) {
  Jb(this, a, b, c, d)
};
p.removeEventListener = function(a, b, c, d) {
  Mb(this, a, b, c, d)
};
p.dispatchEvent = function(a) {
  var b = a.type || a, c = O;
  if(b in c) {
    if(u(a)) {
      a = new N(a, this)
    }else {
      if(a instanceof N) {
        a.target = a.target || this
      }else {
        var d = a;
        a = new N(b, this);
        Wa(a, d)
      }
    }
    var d = 1, f, c = c[b], b = !0 in c, g;
    if(b) {
      f = [];
      for(g = this;g;g = g.pb) {
        f.push(g)
      }
      g = c[!0];
      g.t = g.f;
      for(var h = f.length - 1;!a.na && 0 <= h && g.t;h--) {
        a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !0, a) && !1 != a.Wa
      }
    }
    if(!1 in c) {
      if(g = c[!1], g.t = g.f, b) {
        for(h = 0;!a.na && h < f.length && g.t;h++) {
          a.currentTarget = f[h], d &= Qb(g, f[h], a.type, !1, a) && !1 != a.Wa
        }
      }else {
        for(f = this;!a.na && f && g.t;f = f.pb) {
          a.currentTarget = f, d &= Qb(g, f, a.type, !1, a) && !1 != a.Wa
        }
      }
    }
    a = Boolean(d)
  }else {
    a = !0
  }
  return a
};
p.u = function() {
  Sb.ra.u.call(this);
  Pb(this);
  this.pb = null
};
function Tb(a, b) {
  M.call(this);
  this.da = a || 1;
  this.Ea = b || q;
  this.eb = w(this.Ec, this);
  this.ob = x()
}
y(Tb, Sb);
p = Tb.prototype;
p.enabled = !1;
p.r = null;
p.setInterval = function(a) {
  this.da = a;
  this.r && this.enabled ? (this.stop(), this.start()) : this.r && this.stop()
};
p.Ec = function() {
  if(this.enabled) {
    var a = x() - this.ob;
    0 < a && a < 0.8 * this.da ? this.r = this.Ea.setTimeout(this.eb, this.da - a) : (this.dispatchEvent(Ub), this.enabled && (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x()))
  }
};
p.start = function() {
  this.enabled = !0;
  this.r || (this.r = this.Ea.setTimeout(this.eb, this.da), this.ob = x())
};
p.stop = function() {
  this.enabled = !1;
  this.r && (this.Ea.clearTimeout(this.r), this.r = null)
};
p.u = function() {
  Tb.ra.u.call(this);
  this.stop();
  delete this.Ea
};
var Ub = "tick";
function Vb(a) {
  M.call(this);
  this.e = a;
  this.j = []
}
y(Vb, M);
var Wb = [];
function Xb(a, b, c, d) {
  s(c) || (Wb[0] = c, c = Wb);
  for(var f = 0;f < c.length;f++) {
    var g = Jb(b, c[f], d || a, !1, a.e || a);
    a.j.push(g)
  }
}
Vb.prototype.u = function() {
  Vb.ra.u.call(this);
  Ya(this.j, Nb);
  this.j.length = 0
};
Vb.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Yb(a, b, c) {
  M.call(this);
  this.nc = a;
  this.da = b;
  this.e = c;
  this.hc = w(this.tc, this)
}
y(Yb, M);
p = Yb.prototype;
p.Xa = !1;
p.Tb = 0;
p.r = null;
p.stop = function() {
  this.r && (q.clearTimeout(this.r), this.r = null, this.Xa = !1)
};
p.u = function() {
  Yb.ra.u.call(this);
  this.stop()
};
p.tc = function() {
  this.r = null;
  this.Xa && !this.Tb && (this.Xa = !1, Zb(this))
};
function Zb(a) {
  var b;
  b = a.hc;
  var c = a.da;
  if(!ha(b)) {
    if(b && "function" == typeof b.handleEvent) {
      b = w(b.handleEvent, b)
    }else {
      throw Error("Invalid listener argument");
    }
  }
  b = 2147483647 < c ? -1 : q.setTimeout(b, c || 0);
  a.r = b;
  a.nc.call(a.e)
}
;function Q(a, b, c, d, f) {
  this.b = a;
  this.a = b;
  this.Z = c;
  this.B = d;
  this.Ca = f || 1;
  this.Da = $b;
  this.jb = new Vb(this);
  this.Sa = new Tb;
  this.Sa.setInterval(ac)
}
p = Q.prototype;
p.v = null;
p.J = !1;
p.ua = null;
p.sb = null;
p.pa = null;
p.sa = null;
p.T = null;
p.w = null;
p.X = null;
p.l = null;
p.Fa = 0;
p.K = null;
p.ta = null;
p.p = null;
p.h = -1;
p.Xb = !0;
p.aa = !1;
p.oa = 0;
p.Ta = null;
var $b = 45E3, ac = 250;
function bc(a, b) {
  switch(a) {
    case 0:
      return"Non-200 return code (" + b + ")";
    case 1:
      return"XMLHTTP failure (no data)";
    case 2:
      return"HttpConnection timeout";
    default:
      return"Unknown error"
  }
}
var cc = {}, dc = {};
function ec() {
  return!A || A && 10 <= Ma
}
p = Q.prototype;
p.Y = m("v");
p.setTimeout = m("Da");
p.$b = m("oa");
function fc(a, b, c) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = c;
  a.xb = !0;
  gc(a, null)
}
function hc(a, b, c, d, f) {
  a.sa = 1;
  a.T = J(b.n());
  a.X = null;
  a.xb = c;
  f && (a.Xb = !1);
  gc(a, d)
}
function gc(a, b) {
  a.pa = x();
  ic(a);
  a.w = a.T.n();
  qb(a.w, "t", a.Ca);
  a.Fa = 0;
  a.l = a.b.hb(a.b.Ya() ? b : null);
  0 < a.oa && (a.Ta = new Yb(w(a.dc, a, a.l), a.oa));
  Xb(a.jb, a.l, "readystatechange", a.Ac);
  var c;
  if(a.v) {
    c = a.v;
    var d = {}, f;
    for(f in c) {
      d[f] = c[f]
    }
    c = d
  }else {
    c = {}
  }
  a.X ? (a.ta = "POST", c["Content-Type"] = "application/x-www-form-urlencoded", a.l.send(a.w, a.ta, a.X, c)) : (a.ta = "GET", a.Xb && !B && (c.Connection = "close"), a.l.send(a.w, a.ta, null, c));
  a.b.G(jc);
  if(d = a.X) {
    for(c = "", d = d.split("&"), f = 0;f < d.length;f++) {
      var g = d[f].split("=");
      if(1 < g.length) {
        var h = g[0], g = g[1], n = h.split("_");
        c = 2 <= n.length && "type" == n[1] ? c + (h + "=" + g + "&") : c + (h + "=redacted&")
      }
    }
  }else {
    c = null
  }
  a.a.info("XMLHTTP REQ (" + a.B + ") [attempt " + a.Ca + "]: " + a.ta + "\n" + a.w + "\n" + c)
}
p.Ac = function(a) {
  a = a.target;
  var b = this.Ta;
  b && 3 == R(a) ? (this.a.debug("Throttling readystatechange."), b.r || b.Tb ? b.Xa = !0 : Zb(b)) : this.dc(a)
};
p.dc = function(a) {
  try {
    if(a == this.l) {
      a: {
        var b = R(this.l), c = this.l.la, d = kc(this.l);
        if(!ec() || B && !C("420+")) {
          if(4 > b) {
            break a
          }
        }else {
          if(3 > b || 3 == b && !za && !lc(this.l)) {
            break a
          }
        }
        this.aa || (4 != b || c == mc) || (c == nc || 0 >= d ? this.b.G(oc) : this.b.G(pc));
        qc(this);
        var f = kc(this.l);
        this.h = f;
        var g = lc(this.l);
        g || this.a.debug("No response text for uri " + this.w + " status " + f);
        this.J = 200 == f;
        this.a.info("XMLHTTP RESP (" + this.B + ") [ attempt " + this.Ca + "]: " + this.ta + "\n" + this.w + "\n" + b + " " + f);
        this.J ? (4 == b && S(this), this.xb ? (rc(this, b, g), za && 3 == b && (Xb(this.jb, this.Sa, Ub, this.zc), this.Sa.start())) : (sc(this.a, this.B, g, null), tc(this, g)), this.J && !this.aa && (4 == b ? this.b.ma(this) : (this.J = !1, ic(this)))) : (400 == f && 0 < g.indexOf("Unknown SID") ? (this.p = 3, T(uc), this.a.$("XMLHTTP Unknown SID (" + this.B + ")")) : (this.p = 0, T(vc), this.a.$("XMLHTTP Bad status " + f + " (" + this.B + ")")), S(this), wc(this))
      }
    }else {
      this.a.$("Called back with an unexpected xmlhttp")
    }
  }catch(h) {
    this.a.debug("Failed call to OnXmlHttpReadyStateChanged_"), this.l && lc(this.l) ? xc(this.a, h, "ResponseText: " + lc(this.l)) : xc(this.a, h, "No response text")
  }finally {
  }
};
function rc(a, b, c) {
  for(var d = !0;!a.aa && a.Fa < c.length;) {
    var f = yc(a, c);
    if(f == dc) {
      4 == b && (a.p = 4, T(zc), d = !1);
      sc(a.a, a.B, null, "[Incomplete Response]");
      break
    }else {
      if(f == cc) {
        a.p = 4;
        T(Ac);
        sc(a.a, a.B, c, "[Invalid Chunk]");
        d = !1;
        break
      }else {
        sc(a.a, a.B, f, null), tc(a, f)
      }
    }
  }
  4 == b && 0 == c.length && (a.p = 1, T(Bc), d = !1);
  a.J = a.J && d;
  d || (sc(a.a, a.B, c, "[Invalid Chunked Response]"), S(a), wc(a))
}
p.zc = function() {
  var a = R(this.l), b = lc(this.l);
  this.Fa < b.length && (qc(this), rc(this, a, b), this.J && 4 != a && ic(this))
};
function yc(a, b) {
  var c = a.Fa, d = b.indexOf("\n", c);
  if(-1 == d) {
    return dc
  }
  c = Number(b.substring(c, d));
  if(isNaN(c)) {
    return cc
  }
  d += 1;
  if(d + c > b.length) {
    return dc
  }
  var f = b.substr(d, c);
  a.Fa = d + c;
  return f
}
function Cc(a, b) {
  a.pa = x();
  ic(a);
  var c = b ? window.location.hostname : "";
  a.w = a.T.n();
  I(a.w, "DOMAIN", c);
  I(a.w, "t", a.Ca);
  try {
    a.K = new ActiveXObject("htmlfile")
  }catch(d) {
    a.a.I("ActiveX blocked");
    S(a);
    a.p = 7;
    T(Dc);
    wc(a);
    return
  }
  var f = "<html><body>";
  b && (f += '<script>document.domain="' + c + '"\x3c/script>');
  f += "</body></html>";
  a.K.open();
  a.K.write(f);
  a.K.close();
  a.K.parentWindow.m = w(a.wc, a);
  a.K.parentWindow.d = w(a.Sb, a, !0);
  a.K.parentWindow.rpcClose = w(a.Sb, a, !1);
  c = a.K.createElement("div");
  a.K.parentWindow.document.body.appendChild(c);
  c.innerHTML = '<iframe src="' + a.w + '"></iframe>';
  a.a.info("TRIDENT REQ (" + a.B + ") [ attempt " + a.Ca + "]: GET\n" + a.w);
  a.b.G(jc)
}
p.wc = function(a) {
  U(w(this.vc, this, a), 0)
};
p.vc = function(a) {
  if(!this.aa) {
    var b = this.a;
    b.info("TRIDENT TEXT (" + this.B + "): " + Ec(b, a));
    qc(this);
    tc(this, a);
    ic(this)
  }
};
p.Sb = function(a) {
  U(w(this.uc, this, a), 0)
};
p.uc = function(a) {
  this.aa || (this.a.info("TRIDENT TEXT (" + this.B + "): " + a ? "success" : "failure"), S(this), this.J = a, this.b.ma(this), this.b.G(Fc))
};
p.lc = function() {
  qc(this);
  this.b.ma(this)
};
p.cancel = function() {
  this.aa = !0;
  S(this)
};
function ic(a) {
  a.sb = x() + a.Da;
  Gc(a, a.Da)
}
function Gc(a, b) {
  if(null != a.ua) {
    throw Error("WatchDog timer not null");
  }
  a.ua = U(w(a.xc, a), b)
}
function qc(a) {
  a.ua && (q.clearTimeout(a.ua), a.ua = null)
}
p.xc = function() {
  this.ua = null;
  var a = x();
  0 <= a - this.sb ? (this.J && this.a.I("Received watchdog timeout even though request loaded successfully"), this.a.info("TIMEOUT: " + this.w), 2 != this.sa && this.b.G(oc), S(this), this.p = 2, T(Hc), wc(this)) : (this.a.$("WatchDog timer called too early"), Gc(this, this.sb - a))
};
function wc(a) {
  a.b.Hb() || a.aa || a.b.ma(a)
}
function S(a) {
  qc(a);
  var b = a.Ta;
  b && "function" == typeof b.Ia && b.Ia();
  a.Ta = null;
  a.Sa.stop();
  b = a.jb;
  Ya(b.j, Nb);
  b.j.length = 0;
  a.l && (b = a.l, a.l = null, b.abort(), b.Ia());
  a.K && (a.K = null)
}
p.Eb = aa("p");
function tc(a, b) {
  try {
    a.b.Pb(a, b), a.b.G(Fc)
  }catch(c) {
    xc(a.a, c, "Error in httprequest callback")
  }
}
;function Ic(a) {
  a = String(a);
  if(/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) {
    try {
      return eval("(" + a + ")")
    }catch(b) {
    }
  }
  throw Error("Invalid JSON string: " + a);
}
function Jc(a) {
  return eval("(" + a + ")")
}
function Kc(a) {
  var b = [];
  Lc(new Mc(void 0), a, b);
  return b.join("")
}
function Mc(a) {
  this.Va = a
}
function Lc(a, b, c) {
  switch(typeof b) {
    case "string":
      Nc(b, c);
      break;
    case "number":
      c.push(isFinite(b) && !isNaN(b) ? b : "null");
      break;
    case "boolean":
      c.push(b);
      break;
    case "undefined":
      c.push("null");
      break;
    case "object":
      if(null == b) {
        c.push("null");
        break
      }
      if(s(b)) {
        var d = b.length;
        c.push("[");
        for(var f = "", g = 0;g < d;g++) {
          c.push(f), f = b[g], Lc(a, a.Va ? a.Va.call(b, String(g), f) : f, c), f = ","
        }
        c.push("]");
        break
      }
      c.push("{");
      d = "";
      for(g in b) {
        Object.prototype.hasOwnProperty.call(b, g) && (f = b[g], "function" != typeof f && (c.push(d), Nc(g, c), c.push(":"), Lc(a, a.Va ? a.Va.call(b, g, f) : f, c), d = ","))
      }
      c.push("}");
      break;
    case "function":
      break;
    default:
      throw Error("Unknown type: " + typeof b);
  }
}
var Oc = {'"':'\\"', "\\":"\\\\", "/":"\\/", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\u000b"}, Pc = /\uffff/.test("\uffff") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
function Nc(a, b) {
  b.push('"', a.replace(Pc, function(a) {
    if(a in Oc) {
      return Oc[a]
    }
    var b = a.charCodeAt(0), f = "\\u";
    16 > b ? f += "000" : 256 > b ? f += "00" : 4096 > b && (f += "0");
    return Oc[a] = f + b.toString(16)
  }), '"')
}
;function Qc(a) {
  return Rc(a || arguments.callee.caller, [])
}
function Rc(a, b) {
  var c = [];
  if(0 <= Xa(b, a)) {
    c.push("[...circular reference...]")
  }else {
    if(a && 50 > b.length) {
      c.push(Sc(a) + "(");
      for(var d = a.arguments, f = 0;f < d.length;f++) {
        0 < f && c.push(", ");
        var g;
        g = d[f];
        switch(typeof g) {
          case "object":
            g = g ? "object" : "null";
            break;
          case "string":
            break;
          case "number":
            g = String(g);
            break;
          case "boolean":
            g = g ? "true" : "false";
            break;
          case "function":
            g = (g = Sc(g)) ? g : "[fn]";
            break;
          default:
            g = typeof g
        }
        40 < g.length && (g = g.substr(0, 40) + "...");
        c.push(g)
      }
      b.push(a);
      c.push(")\n");
      try {
        c.push(Rc(a.caller, b))
      }catch(h) {
        c.push("[exception trying to get caller]\n")
      }
    }else {
      a ? c.push("[...long stack...]") : c.push("[end]")
    }
  }
  return c.join("")
}
function Sc(a) {
  if(Tc[a]) {
    return Tc[a]
  }
  a = String(a);
  if(!Tc[a]) {
    var b = /function ([^\(]+)/.exec(a);
    Tc[a] = b ? b[1] : "[Anonymous]"
  }
  return Tc[a]
}
var Tc = {};
function Uc(a, b, c, d, f) {
  this.reset(a, b, c, d, f)
}
Uc.prototype.Cc = 0;
Uc.prototype.Bb = null;
Uc.prototype.Ab = null;
var Vc = 0;
Uc.prototype.reset = function(a, b, c, d, f) {
  this.Cc = "number" == typeof f ? f : Vc++;
  this.Qc = d || x();
  this.za = a;
  this.oc = b;
  this.Ic = c;
  delete this.Bb;
  delete this.Ab
};
Uc.prototype.Yb = m("za");
function V(a) {
  this.pc = a
}
V.prototype.Ra = null;
V.prototype.za = null;
V.prototype.fb = null;
V.prototype.Fb = null;
function Wc(a, b) {
  this.name = a;
  this.value = b
}
Wc.prototype.toString = aa("name");
var Xc = new Wc("SEVERE", 1E3), Yc = new Wc("WARNING", 900), Zc = new Wc("INFO", 800), $c = new Wc("CONFIG", 700), ad = new Wc("FINE", 500);
p = V.prototype;
p.getParent = aa("Ra");
p.Yb = m("za");
function bd(a) {
  if(a.za) {
    return a.za
  }
  if(a.Ra) {
    return bd(a.Ra)
  }
  Pa("Root logger has no level set.");
  return null
}
p.log = function(a, b, c) {
  if(a.value >= bd(this).value) {
    for(a = this.kc(a, b, c), b = "log:" + a.oc, q.console && (q.console.timeStamp ? q.console.timeStamp(b) : q.console.markTimeline && q.console.markTimeline(b)), q.msWriteProfilerMark && q.msWriteProfilerMark(b), b = this;b;) {
      c = b;
      var d = a;
      if(c.Fb) {
        for(var f = 0, g = void 0;g = c.Fb[f];f++) {
          g(d)
        }
      }
      b = b.getParent()
    }
  }
};
p.kc = function(a, b, c) {
  var d = new Uc(a, String(b), this.pc);
  if(c) {
    d.Bb = c;
    var f;
    var g = arguments.callee.caller;
    try {
      var h;
      var n = da("window.location.href");
      if(u(c)) {
        h = {message:c, name:"Unknown error", lineNumber:"Not available", fileName:n, stack:"Not available"}
      }else {
        var k, t, l = !1;
        try {
          k = c.lineNumber || c.Hc || "Not available"
        }catch(r) {
          k = "Not available", l = !0
        }
        try {
          t = c.fileName || c.filename || c.sourceURL || q.$googDebugFname || n
        }catch(G) {
          t = "Not available", l = !0
        }
        h = !l && c.lineNumber && c.fileName && c.stack ? c : {message:c.message, name:c.name, lineNumber:k, fileName:t, stack:c.stack || "Not available"}
      }
      f = "Message: " + na(h.message) + '\nUrl: <a href="view-source:' + h.fileName + '" target="_new">' + h.fileName + "</a>\nLine: " + h.lineNumber + "\n\nBrowser stack:\n" + na(h.stack + "-> ") + "[end]\n\nJS stack traversal:\n" + na(Qc(g) + "-> ")
    }catch(Sd) {
      f = "Exception trying to expose exception! You win, we lose. " + Sd
    }
    d.Ab = f
  }
  return d
};
p.I = function(a, b) {
  this.log(Xc, a, b)
};
p.$ = function(a, b) {
  this.log(Yc, a, b)
};
p.info = function(a, b) {
  this.log(Zc, a, b)
};
function W(a, b) {
  a.log(ad, b, void 0)
}
var cd = {}, dd = null;
function ed(a) {
  dd || (dd = new V(""), cd[""] = dd, dd.Yb($c));
  var b;
  if(!(b = cd[a])) {
    b = new V(a);
    var c = a.lastIndexOf("."), d = a.substr(c + 1), c = ed(a.substr(0, c));
    c.fb || (c.fb = {});
    c.fb[d] = b;
    b.Ra = c;
    cd[a] = b
  }
  return b
}
;function X() {
  this.q = ed("goog.net.BrowserChannel")
}
function sc(a, b, c, d) {
  a.info("XMLHTTP TEXT (" + b + "): " + Ec(a, c) + (d ? " " + d : ""))
}
X.prototype.debug = function(a) {
  this.info(a)
};
function xc(a, b, c) {
  a.I((c || "Exception") + b)
}
X.prototype.info = function(a) {
  this.q.info(a)
};
X.prototype.$ = function(a) {
  this.q.$(a)
};
X.prototype.I = function(a) {
  this.q.I(a)
};
function Ec(a, b) {
  if(!b || b == fd) {
    return b
  }
  try {
    var c = Jc(b);
    if(c) {
      for(var d = 0;d < c.length;d++) {
        if(s(c[d])) {
          var f = c[d];
          if(!(2 > f.length)) {
            var g = f[1];
            if(s(g) && !(1 > g.length)) {
              var h = g[0];
              if("noop" != h && "stop" != h) {
                for(var n = 1;n < g.length;n++) {
                  g[n] = ""
                }
              }
            }
          }
        }
      }
    }
    return Kc(c)
  }catch(k) {
    return a.debug("Exception parsing expected JS array - probably was not JS"), b
  }
}
;function gd(a, b) {
  this.Oc = new Mc(a);
  this.P = b ? Jc : Ic
}
gd.prototype.parse = function(a) {
  return this.P(a)
};
var mc = 7, nc = 8;
function hd(a) {
  M.call(this);
  this.headers = new bb;
  this.va = a || null
}
y(hd, Sb);
hd.prototype.q = ed("goog.net.XhrIo");
var id = /^https?$/i;
p = hd.prototype;
p.S = !1;
p.g = null;
p.bb = null;
p.Pa = "";
p.Jb = "";
p.la = 0;
p.p = "";
p.ib = !1;
p.Na = !1;
p.mb = !1;
p.ca = !1;
p.$a = 0;
p.fa = null;
p.Wb = "";
p.cc = !1;
p.send = function(a, b, c, d) {
  if(this.g) {
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.Pa + "; newUri=" + a);
  }
  b = b ? b.toUpperCase() : "GET";
  this.Pa = a;
  this.p = "";
  this.la = 0;
  this.Jb = b;
  this.ib = !1;
  this.S = !0;
  this.g = this.va ? xb(this.va) : xb(vb);
  this.bb = this.va ? this.va.Ga || (this.va.Ga = zb(this.va)) : vb.Ga || (vb.Ga = zb(vb));
  this.g.onreadystatechange = w(this.Ob, this);
  try {
    W(this.q, Y(this, "Opening Xhr")), this.mb = !0, this.g.open(b, a, !0), this.mb = !1
  }catch(f) {
    W(this.q, Y(this, "Error opening Xhr: " + f.message));
    jd(this, f);
    return
  }
  a = c || "";
  var g = this.headers.n();
  d && E(d, function(a, b) {
    g.set(b, a)
  });
  d = q.FormData && a instanceof q.FormData;
  "POST" != b || (g.ia("Content-Type") || d) || g.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  E(g, function(a, b) {
    this.g.setRequestHeader(b, a)
  }, this);
  this.Wb && (this.g.responseType = this.Wb);
  "withCredentials" in this.g && (this.g.withCredentials = this.cc);
  try {
    this.fa && (q.clearTimeout(this.fa), this.fa = null), 0 < this.$a && (W(this.q, Y(this, "Will abort after " + this.$a + "ms if incomplete")), this.fa = q.setTimeout(w(this.Da, this), this.$a)), W(this.q, Y(this, "Sending request")), this.Na = !0, this.g.send(a), this.Na = !1
  }catch(h) {
    W(this.q, Y(this, "Send error: " + h.message)), jd(this, h)
  }
};
p.Da = function() {
  "undefined" != typeof ca && this.g && (this.p = "Timed out after " + this.$a + "ms, aborting", this.la = nc, W(this.q, Y(this, this.p)), this.dispatchEvent("timeout"), this.abort(nc))
};
function jd(a, b) {
  a.S = !1;
  a.g && (a.ca = !0, a.g.abort(), a.ca = !1);
  a.p = b;
  a.la = 5;
  kd(a);
  ld(a)
}
function kd(a) {
  a.ib || (a.ib = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"))
}
p.abort = function(a) {
  this.g && this.S && (W(this.q, Y(this, "Aborting")), this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1, this.la = a || mc, this.dispatchEvent("complete"), this.dispatchEvent("abort"), ld(this))
};
p.u = function() {
  this.g && (this.S && (this.S = !1, this.ca = !0, this.g.abort(), this.ca = !1), ld(this, !0));
  hd.ra.u.call(this)
};
p.Ob = function() {
  this.mb || this.Na || this.ca ? md(this) : this.sc()
};
p.sc = function() {
  md(this)
};
function md(a) {
  if(a.S && "undefined" != typeof ca) {
    if(a.bb[1] && 4 == R(a) && 2 == kc(a)) {
      W(a.q, Y(a, "Local request error detected and ignored"))
    }else {
      if(a.Na && 4 == R(a)) {
        q.setTimeout(w(a.Ob, a), 0)
      }else {
        if(a.dispatchEvent("readystatechange"), 4 == R(a)) {
          W(a.q, Y(a, "Request complete"));
          a.S = !1;
          try {
            var b = kc(a), c, d;
            a: {
              switch(b) {
                case 200:
                ;
                case 201:
                ;
                case 202:
                ;
                case 204:
                ;
                case 206:
                ;
                case 304:
                ;
                case 1223:
                  d = !0;
                  break a;
                default:
                  d = !1
              }
            }
            if(!(c = d)) {
              var f;
              if(f = 0 === b) {
                var g = String(a.Pa).match(Qa)[1] || null;
                if(!g && self.location) {
                  var h = self.location.protocol, g = h.substr(0, h.length - 1)
                }
                f = !id.test(g ? g.toLowerCase() : "")
              }
              c = f
            }
            if(c) {
              a.dispatchEvent("complete"), a.dispatchEvent("success")
            }else {
              a.la = 6;
              var n;
              try {
                n = 2 < R(a) ? a.g.statusText : ""
              }catch(k) {
                W(a.q, "Can not get status: " + k.message), n = ""
              }
              a.p = n + " [" + kc(a) + "]";
              kd(a)
            }
          }finally {
            ld(a)
          }
        }
      }
    }
  }
}
function ld(a, b) {
  if(a.g) {
    var c = a.g, d = a.bb[0] ? ea : null;
    a.g = null;
    a.bb = null;
    a.fa && (q.clearTimeout(a.fa), a.fa = null);
    b || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d
    }catch(f) {
      a.q.I("Problem encountered resetting onreadystatechange: " + f.message)
    }
  }
}
p.isActive = function() {
  return!!this.g
};
function R(a) {
  return a.g ? a.g.readyState : 0
}
function kc(a) {
  try {
    return 2 < R(a) ? a.g.status : -1
  }catch(b) {
    return a.q.$("Can not get status: " + b.message), -1
  }
}
function lc(a) {
  try {
    return a.g ? a.g.responseText : ""
  }catch(b) {
    return W(a.q, "Can not get responseText: " + b.message), ""
  }
}
p.Eb = function() {
  return u(this.p) ? this.p : String(this.p)
};
function Y(a, b) {
  return b + " [" + a.Jb + " " + a.Pa + " " + kc(a) + "]"
}
;function nd() {
  this.Vb = x()
}
new nd;
nd.prototype.set = m("Vb");
nd.prototype.reset = function() {
  this.set(x())
};
nd.prototype.get = aa("Vb");
function od(a, b, c, d, f) {
  (new X).debug("TestLoadImageWithRetries: " + f);
  if(0 == d) {
    c(!1)
  }else {
    var g = f || 0;
    d--;
    pd(a, b, function(f) {
      f ? c(!0) : q.setTimeout(function() {
        od(a, b, c, d, g)
      }, g)
    })
  }
}
function pd(a, b, c) {
  function d(a, b) {
    return function() {
      try {
        f.debug("TestLoadImage: " + b), g.onload = null, g.onerror = null, g.onabort = null, g.ontimeout = null, q.clearTimeout(h), c(a)
      }catch(d) {
        xc(f, d)
      }
    }
  }
  var f = new X;
  f.debug("TestLoadImage: loading " + a);
  var g = new Image, h = null;
  g.onload = d(!0, "loaded");
  g.onerror = d(!1, "error");
  g.onabort = d(!1, "abort");
  g.ontimeout = d(!1, "timeout");
  h = q.setTimeout(function() {
    if(g.ontimeout) {
      g.ontimeout()
    }
  }, b);
  g.src = a
}
;function qd(a, b) {
  this.b = a;
  this.a = b;
  this.P = new gd(null, !0)
}
p = qd.prototype;
p.v = null;
p.A = null;
p.Ua = !1;
p.ac = null;
p.Ka = null;
p.nb = null;
p.H = null;
p.c = null;
p.h = -1;
p.L = null;
p.wa = null;
p.Y = m("v");
p.Zb = m("P");
p.gb = function(a) {
  this.H = a;
  a = rd(this.b, this.H);
  T(sd);
  this.ac = x();
  var b = this.b.Cb;
  null != b ? (this.L = this.b.correctHostPrefix(b[0]), (this.wa = b[1]) ? (this.c = 1, td(this)) : (this.c = 2, ud(this))) : (qb(a, "MODE", "init"), this.A = new Q(this, this.a, void 0, void 0, void 0), this.A.Y(this.v), hc(this.A, a, !1, null, !0), this.c = 0)
};
function td(a) {
  var b = vd(a.b, a.wa, "/mail/images/cleardot.gif");
  J(b);
  od(b.toString(), 5E3, w(a.ic, a), 3, 2E3);
  a.G(jc)
}
p.ic = function(a) {
  if(a) {
    this.c = 2, ud(this)
  }else {
    T(wd);
    var b = this.b;
    b.a.debug("Test Connection Blocked");
    b.h = b.U.h;
    Z(b, 9)
  }
  a && this.G(pc)
};
function ud(a) {
  a.a.debug("TestConnection: starting stage 2");
  a.A = new Q(a, a.a, void 0, void 0, void 0);
  a.A.Y(a.v);
  var b = xd(a.b, a.L, a.H);
  T(yd);
  if(ec()) {
    qb(b, "TYPE", "xmlhttp"), hc(a.A, b, !1, a.L, !1)
  }else {
    qb(b, "TYPE", "html");
    var c = a.A;
    a = Boolean(a.L);
    c.sa = 3;
    c.T = J(b.n());
    Cc(c, a)
  }
}
p.hb = function(a) {
  return this.b.hb(a)
};
p.abort = function() {
  this.A && (this.A.cancel(), this.A = null);
  this.h = -1
};
p.Hb = ba(!1);
p.Pb = function(a, b) {
  this.h = a.h;
  if(0 == this.c) {
    if(this.a.debug("TestConnection: Got data for stage 1"), b) {
      try {
        var c = this.P.parse(b)
      }catch(d) {
        xc(this.a, d);
        zd(this.b, this);
        return
      }
      this.L = this.b.correctHostPrefix(c[0]);
      this.wa = c[1]
    }else {
      this.a.debug("TestConnection: Null responseText"), zd(this.b, this)
    }
  }else {
    if(2 == this.c) {
      if(this.Ua) {
        T(Ad), this.nb = x()
      }else {
        if("11111" == b) {
          if(T(Bd), this.Ua = !0, this.Ka = x(), c = this.Ka - this.ac, ec() || 500 > c) {
            this.h = 200, this.A.cancel(), this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)
          }
        }else {
          T(Ed), this.Ka = this.nb = x(), this.Ua = !1
        }
      }
    }
  }
};
p.ma = function() {
  this.h = this.A.h;
  if(!this.A.J) {
    this.a.debug("TestConnection: request failed, in state " + this.c), 0 == this.c ? T(Fd) : 2 == this.c && T(Gd), zd(this.b, this)
  }else {
    if(0 == this.c) {
      this.a.debug("TestConnection: request complete for initial check"), this.wa ? (this.c = 1, td(this)) : (this.c = 2, ud(this))
    }else {
      if(2 == this.c) {
        this.a.debug("TestConnection: request complete for stage 2");
        var a = !1;
        (a = ec() ? this.Ua : 200 > this.nb - this.Ka ? !1 : !0) ? (this.a.debug("Test connection succeeded; using streaming connection"), T(Cd), Dd(this.b, this, !0)) : (this.a.debug("Test connection failed; not using streaming"), T(Hd), Dd(this.b, this, !1))
      }
    }
  }
};
p.Ya = function() {
  return this.b.Ya()
};
p.isActive = function() {
  return this.b.isActive()
};
p.G = function(a) {
  this.b.G(a)
};
function Id(a, b) {
  this.vb = a || null;
  this.c = Jd;
  this.s = [];
  this.Q = [];
  this.a = new X;
  this.P = new gd(null, !0);
  this.Cb = b || null
}
function Kd(a, b) {
  this.Lb = a;
  this.map = b;
  this.Fc = null
}
p = Id.prototype;
p.v = null;
p.xa = null;
p.o = null;
p.k = null;
p.H = null;
p.La = null;
p.ub = null;
p.L = null;
p.fc = !0;
p.Aa = 0;
p.qc = 0;
p.Ja = !1;
p.e = null;
p.F = null;
p.M = null;
p.ba = null;
p.U = null;
p.rb = null;
p.ec = !0;
p.ya = -1;
p.Kb = -1;
p.h = -1;
p.V = 0;
p.ga = 0;
p.gc = 5E3;
p.Bc = 1E4;
p.kb = 2;
p.Db = 2E4;
p.oa = 0;
p.Za = !1;
p.ha = 8;
var Jd = 1, Ld = new Sb;
function Md(a, b) {
  N.call(this, "statevent", a);
  this.Pc = b
}
y(Md, N);
function Nd(a, b, c, d) {
  N.call(this, "timingevent", a);
  this.size = b;
  this.Nc = c;
  this.Mc = d
}
y(Nd, N);
var jc = 1, pc = 2, oc = 3, Fc = 4;
function Od(a, b) {
  N.call(this, "serverreachability", a);
  this.Lc = b
}
y(Od, N);
var sd = 3, wd = 4, yd = 5, Bd = 6, Ad = 7, Ed = 8, Fd = 9, Gd = 10, Hd = 11, Cd = 12, uc = 13, vc = 14, zc = 15, Ac = 16, Bc = 17, Hc = 18, Dc = 22, fd = "y2f%";
p = Id.prototype;
p.gb = function(a, b, c, d, f) {
  this.a.debug("connect()");
  T(0);
  this.H = b;
  this.xa = c || {};
  d && void 0 !== f && (this.xa.OSID = d, this.xa.OAID = f);
  this.a.debug("connectTest_()");
  Pd(this) && (this.U = new qd(this, this.a), this.U.Y(this.v), this.U.Zb(this.P), this.U.gb(a))
};
p.disconnect = function() {
  this.a.debug("disconnect()");
  Qd(this);
  if(3 == this.c) {
    var a = this.Aa++, b = this.La.n();
    I(b, "SID", this.Z);
    I(b, "RID", a);
    I(b, "TYPE", "terminate");
    Rd(this, b);
    a = new Q(this, this.a, this.Z, a, void 0);
    a.sa = 2;
    a.T = J(b.n());
    b = new Image;
    b.src = a.T;
    b.onload = b.onerror = w(a.lc, a);
    a.pa = x();
    ic(a)
  }
  Td(this)
};
function Qd(a) {
  a.U && (a.U.abort(), a.U = null);
  a.k && (a.k.cancel(), a.k = null);
  a.M && (q.clearTimeout(a.M), a.M = null);
  Ud(a);
  a.o && (a.o.cancel(), a.o = null);
  a.F && (q.clearTimeout(a.F), a.F = null)
}
p.Y = m("v");
p.$b = m("oa");
p.Hb = function() {
  return 0 == this.c
};
p.Zb = m("P");
function Vd(a) {
  a.o || a.F || (a.F = U(w(a.Rb, a), 0), a.V = 0)
}
p.Rb = function(a) {
  this.F = null;
  this.a.debug("startForwardChannel_");
  if(Pd(this)) {
    if(this.c == Jd) {
      if(a) {
        this.a.I("Not supposed to retry the open")
      }else {
        this.a.debug("open_()");
        this.Aa = Math.floor(1E5 * Math.random());
        a = this.Aa++;
        var b = new Q(this, this.a, "", a, void 0);
        b.Y(this.v);
        var c = Wd(this), d = this.La.n();
        I(d, "RID", a);
        this.vb && I(d, "CVER", this.vb);
        Rd(this, d);
        fc(b, d, c);
        this.o = b;
        this.c = 2
      }
    }else {
      3 == this.c && (a ? Xd(this, a) : 0 == this.s.length ? this.a.debug("startForwardChannel_ returned: nothing to send") : this.o ? this.a.I("startForwardChannel_ returned: connection already in progress") : (Xd(this), this.a.debug("startForwardChannel_ finished, sent request")))
    }
  }
};
function Xd(a, b) {
  var c, d;
  b ? 6 < a.ha ? (a.s = a.Q.concat(a.s), a.Q.length = 0, c = a.Aa - 1, d = Wd(a)) : (c = b.B, d = b.X) : (c = a.Aa++, d = Wd(a));
  var f = a.La.n();
  I(f, "SID", a.Z);
  I(f, "RID", c);
  I(f, "AID", a.ya);
  Rd(a, f);
  c = new Q(a, a.a, a.Z, c, a.V + 1);
  c.Y(a.v);
  c.setTimeout(Math.round(0.5 * a.Db) + Math.round(0.5 * a.Db * Math.random()));
  a.o = c;
  fc(c, f, d)
}
function Rd(a, b) {
  if(a.e) {
    var c = a.e.getAdditionalParams(a);
    c && E(c, function(a, c) {
      I(b, c, a)
    })
  }
}
function Wd(a) {
  var b = Math.min(a.s.length, 1E3), c = ["count=" + b], d;
  6 < a.ha && 0 < b ? (d = a.s[0].Lb, c.push("ofs=" + d)) : d = 0;
  for(var f = 0;f < b;f++) {
    var g = a.s[f].Lb, h = a.s[f].map, g = 6 >= a.ha ? f : g - d;
    try {
      E(h, function(a, b) {
        c.push("req" + g + "_" + b + "=" + encodeURIComponent(a))
      })
    }catch(n) {
      c.push("req" + g + "_type=" + encodeURIComponent("_badmap")), a.e && a.e.badMapError(a, h)
    }
  }
  a.Q = a.Q.concat(a.s.splice(0, b));
  return c.join("&")
}
function Yd(a) {
  a.k || a.M || (a.tb = 1, a.M = U(w(a.Qb, a), 0), a.ga = 0)
}
function Zd(a) {
  if(a.k || a.M) {
    return a.a.I("Request already in progress"), !1
  }
  if(3 <= a.ga) {
    return!1
  }
  a.a.debug("Going to retry GET");
  a.tb++;
  a.M = U(w(a.Qb, a), $d(a, a.ga));
  a.ga++;
  return!0
}
p.Qb = function() {
  this.M = null;
  if(Pd(this)) {
    this.a.debug("Creating new HttpRequest");
    this.k = new Q(this, this.a, this.Z, "rpc", this.tb);
    this.k.Y(this.v);
    this.k.$b(this.oa);
    var a = this.ub.n();
    I(a, "RID", "rpc");
    I(a, "SID", this.Z);
    I(a, "CI", this.rb ? "0" : "1");
    I(a, "AID", this.ya);
    Rd(this, a);
    if(ec()) {
      I(a, "TYPE", "xmlhttp"), hc(this.k, a, !0, this.L, !1)
    }else {
      I(a, "TYPE", "html");
      var b = this.k, c = Boolean(this.L);
      b.sa = 3;
      b.T = J(a.n());
      Cc(b, c)
    }
    this.a.debug("New Request created")
  }
};
function Pd(a) {
  if(a.e) {
    var b = a.e.okToMakeRequest(a);
    if(0 != b) {
      return a.a.debug("Handler returned error code from okToMakeRequest"), Z(a, b), !1
    }
  }
  return!0
}
function Dd(a, b, c) {
  a.a.debug("Test Connection Finished");
  a.rb = a.ec && c;
  a.h = b.h;
  a.a.debug("connectChannel_()");
  a.jc(Jd, 0);
  a.La = rd(a, a.H);
  Vd(a)
}
function zd(a, b) {
  a.a.debug("Test Connection Failed");
  a.h = b.h;
  Z(a, 2)
}
p.Pb = function(a, b) {
  if(0 != this.c && (this.k == a || this.o == a)) {
    if(this.h = a.h, this.o == a && 3 == this.c) {
      if(7 < this.ha) {
        var c;
        try {
          c = this.P.parse(b)
        }catch(d) {
          c = null
        }
        if(s(c) && 3 == c.length) {
          var f = c;
          if(0 == f[0]) {
            a: {
              if(this.a.debug("Server claims our backchannel is missing."), this.M) {
                this.a.debug("But we are currently starting the request.")
              }else {
                if(this.k) {
                  if(this.k.pa + 3E3 < this.o.pa) {
                    Ud(this), this.k.cancel(), this.k = null
                  }else {
                    break a
                  }
                }else {
                  this.a.$("We do not have a BackChannel established")
                }
                Zd(this);
                T(19)
              }
            }
          }else {
            this.Kb = f[1], c = this.Kb - this.ya, 0 < c && (f = f[2], this.a.debug(f + " bytes (in " + c + " arrays) are outstanding on the BackChannel"), 37500 > f && (this.rb && 0 == this.ga) && !this.ba && (this.ba = U(w(this.rc, this), 6E3)))
          }
        }else {
          this.a.debug("Bad POST response data returned"), Z(this, 11)
        }
      }else {
        b != fd && (this.a.debug("Bad data returned - missing/invald magic cookie"), Z(this, 11))
      }
    }else {
      if(this.k == a && Ud(this), !/^[\s\xa0]*$/.test(b)) {
        c = this.P.parse(b);
        for(var f = this.e && this.e.channelHandleMultipleArrays ? [] : null, g = 0;g < c.length;g++) {
          var h = c[g];
          this.ya = h[0];
          h = h[1];
          2 == this.c ? "c" == h[0] ? (this.Z = h[1], this.L = this.correctHostPrefix(h[2]), h = h[3], this.ha = null != h ? h : 6, this.c = 3, this.e && this.e.channelOpened(this), this.ub = xd(this, this.L, this.H), Yd(this)) : "stop" == h[0] && Z(this, 7) : 3 == this.c && ("stop" == h[0] ? (f && f.length && (this.e.channelHandleMultipleArrays(this, f), f.length = 0), Z(this, 7)) : "noop" != h[0] && (f ? f.push(h) : this.e && this.e.channelHandleArray(this, h)), this.ga = 0)
        }
        f && f.length && this.e.channelHandleMultipleArrays(this, f)
      }
    }
  }
};
p.correctHostPrefix = function(a) {
  return this.fc ? this.e ? this.e.correctHostPrefix(a) : a : null
};
p.rc = function() {
  null != this.ba && (this.ba = null, this.k.cancel(), this.k = null, Zd(this), T(20))
};
function Ud(a) {
  null != a.ba && (q.clearTimeout(a.ba), a.ba = null)
}
p.ma = function(a) {
  this.a.debug("Request complete");
  var b;
  if(this.k == a) {
    Ud(this), this.k = null, b = 2
  }else {
    if(this.o == a) {
      this.o = null, b = 1
    }else {
      return
    }
  }
  this.h = a.h;
  if(0 != this.c) {
    if(a.J) {
      1 == b ? (b = x() - a.pa, Ld.dispatchEvent(new Nd(Ld, a.X ? a.X.length : 0, b, this.V)), Vd(this), this.Q.length = 0) : Yd(this)
    }else {
      var c = a.Eb();
      if(3 == c || 7 == c || 0 == c && 0 < this.h) {
        this.a.debug("Not retrying due to error type")
      }else {
        this.a.debug("Maybe retrying, last error: " + bc(c, this.h));
        var d;
        if(d = 1 == b) {
          this.o || this.F ? (this.a.I("Request already in progress"), d = !1) : this.c == Jd || this.V >= (this.Ja ? 0 : this.kb) ? d = !1 : (this.a.debug("Going to retry POST"), this.F = U(w(this.Rb, this, a), $d(this, this.V)), this.V++, d = !0)
        }
        if(d || 2 == b && Zd(this)) {
          return
        }
        this.a.debug("Exceeded max number of retries")
      }
      this.a.debug("Error: HTTP request failed");
      switch(c) {
        case 1:
          Z(this, 5);
          break;
        case 4:
          Z(this, 10);
          break;
        case 3:
          Z(this, 6);
          break;
        case 7:
          Z(this, 12);
          break;
        default:
          Z(this, 2)
      }
    }
  }
};
function $d(a, b) {
  var c = a.gc + Math.floor(Math.random() * a.Bc);
  a.isActive() || (a.a.debug("Inactive channel"), c *= 2);
  return c * b
}
p.jc = function(a) {
  if(!(0 <= Xa(arguments, this.c))) {
    throw Error("Unexpected channel state: " + this.c);
  }
};
function Z(a, b) {
  a.a.info("Error code " + b);
  if(2 == b || 9 == b) {
    var c = null;
    a.e && (c = a.e.getNetworkTestImageUri(a));
    var d = w(a.Dc, a);
    c || (c = new F("http://www.google.com/images/cleardot.gif"), J(c));
    pd(c.toString(), 1E4, d)
  }else {
    T(2)
  }
  ae(a, b)
}
p.Dc = function(a) {
  a ? (this.a.info("Successfully pinged google.com"), T(2)) : (this.a.info("Failed to ping google.com"), T(1), ae(this, 8))
};
function ae(a, b) {
  a.a.debug("HttpChannel: error - " + b);
  a.c = 0;
  a.e && a.e.channelError(a, b);
  Td(a);
  Qd(a)
}
function Td(a) {
  a.c = 0;
  a.h = -1;
  if(a.e) {
    if(0 == a.Q.length && 0 == a.s.length) {
      a.e.channelClosed(a)
    }else {
      a.a.debug("Number of undelivered maps, pending: " + a.Q.length + ", outgoing: " + a.s.length);
      var b = $a(a.Q), c = $a(a.s);
      a.Q.length = 0;
      a.s.length = 0;
      a.e.channelClosed(a, b, c)
    }
  }
}
function rd(a, b) {
  var c = vd(a, null, b);
  a.a.debug("GetForwardChannelUri: " + c);
  return c
}
function xd(a, b, c) {
  b = vd(a, a.Ya() ? b : null, c);
  a.a.debug("GetBackChannelUri: " + b);
  return b
}
function vd(a, b, c) {
  var d = c instanceof F ? c.n() : new F(c, void 0);
  if("" != d.ja) {
    b && fb(d, b + "." + d.ja), gb(d, d.Ba)
  }else {
    var f = window.location, d = sb(f.protocol, b ? b + "." + f.hostname : f.hostname, f.port, c)
  }
  a.xa && E(a.xa, function(a, b) {
    I(d, b, a)
  });
  I(d, "VER", a.ha);
  Rd(a, d);
  return d
}
p.hb = function(a) {
  if(a && !this.Za) {
    throw Error("Can't create secondary domain capable XhrIo object.");
  }
  a = new hd;
  a.cc = this.Za;
  return a
};
p.isActive = function() {
  return!!this.e && this.e.isActive(this)
};
function U(a, b) {
  if(!ha(a)) {
    throw Error("Fn must not be null and must be a function");
  }
  return q.setTimeout(function() {
    a()
  }, b)
}
p.G = function(a) {
  Ld.dispatchEvent(new Od(Ld, a))
};
function T(a) {
  Ld.dispatchEvent(new Md(Ld, a))
}
p.Ya = function() {
  return this.Za || !ec()
};
function be() {
}
p = be.prototype;
p.channelHandleMultipleArrays = null;
p.okToMakeRequest = ba(0);
p.channelOpened = e();
p.channelHandleArray = e();
p.channelError = e();
p.channelClosed = e();
p.getAdditionalParams = function() {
  return{}
};
p.getNetworkTestImageUri = ba(null);
p.isActive = ba(!0);
p.badMapError = e();
p.correctHostPrefix = function(a) {
  return a
};
var $, ce, de = [].slice;
ce = {0:"Ok", 4:"User is logging out", 6:"Unknown session ID", 7:"Stopped by server", 8:"General network error", 2:"Request failed", 9:"Blocked by a network administrator", 5:"No data from server", 10:"Got bad data from the server", 11:"Got a bad response from the server"};
$ = function(a, b) {
  var c, d, f, g, h, n, k, t, l, r;
  t = this;
  a || (a = "channel");
  a.match(/:\/\//) && a.replace(/^ws/, "http");
  b || (b = {});
  s(b || "string" === typeof b) && (b = {});
  n = b.reconnectTime || 3E3;
  r = function(a) {
    t.readyState = t.readyState = a
  };
  r(this.CLOSED);
  l = null;
  g = b.Kc;
  c = function() {
    var a, b;
    b = arguments[0];
    a = 2 <= arguments.length ? de.call(arguments, 1) : [];
    try {
      return"function" === typeof t[b] ? t[b].apply(t, a) : void 0
    }catch(c) {
      throw a = c, "undefined" !== typeof console && null !== console && console.error(a.stack), a;
    }
  };
  d = new be;
  d.channelOpened = function() {
    g = l;
    r($.OPEN);
    return c("onopen")
  };
  f = null;
  d.channelError = function(a, b) {
    var d;
    d = ce[b];
    f = b;
    r($.cb);
    try {
      return c("onerror", d, b)
    }catch(g) {
    }
  };
  k = null;
  d.channelClosed = function(a, d, g) {
    if(t.readyState !== $.CLOSED) {
      l = null;
      a = f ? ce[f] : "Closed";
      r($.CLOSED);
      try {
        c("onclose", a, d, g)
      }catch(ee) {
      }
      b.reconnect && (7 !== f && 0 !== f) && (d = 6 === f ? 0 : n, clearTimeout(k), k = setTimeout(h, d));
      return f = null
    }
  };
  d.channelHandleArray = function(a, b) {
    return c("onmessage", b)
  };
  h = function() {
    if(l) {
      throw Error("Reconnect() called from invalid state");
    }
    r($.CONNECTING);
    c("onconnecting");
    clearTimeout(k);
    l = new Id(b.appVersion, null != g ? g.Cb : void 0);
    b.crossDomainXhr && (l.Za = !0);
    l.e = d;
    f = null;
    if(b.failFast) {
      var h = l;
      h.Ja = !0;
      h.a.info("setFailFast: true");
      (h.o || h.F) && h.V > (h.Ja ? 0 : h.kb) && (h.a.info("Retry count " + h.V + " > new maxRetries " + (h.Ja ? 0 : h.kb) + ". Fail immediately!"), h.o ? (h.o.cancel(), h.ma(h.o)) : (q.clearTimeout(h.F), h.F = null, Z(h, 2)))
    }
    return l.gb("" + a + "/test", "" + a + "/bind", b.extraParams, null != g ? g.Z : void 0, null != g ? g.ya : void 0)
  };
  this.open = function() {
    if(t.readyState !== t.CLOSED) {
      throw Error("Already open");
    }
    return h()
  };
  this.close = function() {
    clearTimeout(k);
    f = 0;
    if(t.readyState !== $.CLOSED) {
      return r($.cb), l.disconnect()
    }
  };
  this.sendMap = function(a) {
    var b;
    if((b = t.readyState) === $.cb || b === $.CLOSED) {
      throw Error("Cannot send to a closed connection");
    }
    b = l;
    if(0 == b.c) {
      throw Error("Invalid operation: sending map when state is closed");
    }
    1E3 == b.s.length && b.a.I("Already have 1000 queued maps upon queueing " + Kc(a));
    b.s.push(new Kd(b.qc++, a));
    2 != b.c && 3 != b.c || Vd(b)
  };
  this.send = function(a) {
    return this.sendMap({JSON:Kc(a)})
  };
  h();
  return this
};
$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;
$.prototype.OPEN = $.OPEN = $.OPEN = 1;
$.prototype.CLOSING = $.CLOSING = $.cb = 2;
$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;
("undefined" !== typeof exports && null !== exports ? exports : window).BCSocket = $;

})();

},{}],1:[function(require,module,exports){
(function(process,__dirname){var EventEmitter = require('events').EventEmitter;
var Model = require('./Model');
var util = require('./util');

module.exports = Racer;

function Racer() {
  EventEmitter.call(this);
}

util.mergeInto(Racer.prototype, EventEmitter.prototype);

// Make classes accessible for use by plugins and tests
Racer.prototype.Model = Model;
Racer.prototype.util = util;

// Support plugins on racer instances
Racer.prototype.use = util.use;

Racer.prototype.init = function(data) {
  var racer = this;

  process.env.NODE_ENV = data.nodeEnv;

  // Init is executed async so that plugins can extend Racer even if they are
  // included after the main entry point in the bundle
  process.nextTick(function() {
    var model = new Model;

    model._createConnection(data);

    racer.emit('model', model);

    // Re-create documents for all model data
    for (var collectionName in data.collections) {
      var collection = data.collections[collectionName];
      for (var id in collection) {
        var doc = model.getOrCreateDoc(collectionName, id, collection[id]);
        if (doc.shareDoc) {
          model._loadVersions[collectionName + '.' + id] = doc.shareDoc.version;
        }
      }
    }

    // TODO: Support re-init when there are contexts other than root
    var context = data.contexts.root;
    // Re-subscribe to document subscriptions
    for (var path in context.subscribedDocs) {
      var segments = path.split('.');
      model.subscribeDoc(segments[0], segments[1]);
      model._subscribedDocs[path] = context.subscribedDocs[path];
    }
    // Init fetchedDocs counts
    for (var path in context.fetchedDocs) {
      model._fetchedDocs[path] = context.fetchedDocs[path];
    }

    var silentModel = model.silent();
    // Re-create refs
    for (var i = 0; i < data.refs.length; i++) {
      var item = data.refs[i];
      silentModel.ref(item[0], item[1]);
    }
    // Re-create refLists
    for (var i = 0; i < data.refLists.length; i++) {
      var item = data.refLists[i];
      silentModel.refList(item[0], item[1], item[2], item[3]);
    }
    // Re-create fns
    for (var i = 0; i < data.fns.length; i++) {
      var item = data.fns[i];
      silentModel.start.apply(silentModel, item);
    }
    // Re-create filters
    for (var i = 0; i < data.filters.length; i++) {
      var item = data.filters[i];
      var filter = model._filters.add(item[0], item[1], item[2]);
      filter.ref(item[3]);
    }
    // Init and re-subscribe queries as appropriate
    model._initQueries(data.queries);

    racer._model = model;
    racer.emit('ready', model);
  });
  return this;
};

Racer.prototype.ready = function(cb) {
  if (this._model) {
    // Callback async in case the code depends on scripts included after in
    // the bundle and is gated by a ready
    process.nextTick(function() {
      cb(this._model);
    });
    return;
  }
  this.once('ready', cb);
};

util.serverRequire(__dirname + '/Racer.server.js');

})(require("__browserify_process"),"/node_modules/derby/node_modules/racer/lib")
},{"events":9,"./util":10,"./Model":11,"__browserify_process":8}],12:[function(require,module,exports){
var app = require('derby')
  .createApp(module)
  .use(require('../../ui'))
  .use(require('derby-ui-github-buttons'));

require('derby-lang').app(app);
require('./events')(app);
require('./routes')(app);
require('./viewFns')(app);
},{"derby":"0klAo3","./events":3,"./routes":4,"./viewFns":5,"../../ui":13,"derby-ui-github-buttons":14,"derby-lang":15}],13:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  scripts: {
    connectionAlert: require('./connectionAlert')
  }
};

module.exports = function (app, options) {
  app.createLibrary(config, options);
};
})("/ui/index.js")
},{"./connectionAlert":16}],16:[function(require,module,exports){
exports.setup = function(library) {
  library.view.fn('sentenceCase', function(text) {
    return text && (text.charAt(0).toUpperCase() + text.slice(1));
  });
};

exports.reconnect = function() {
  var model = this.model;
  model.set('hideReconnect', true);
  setTimeout(function() {
    model.set('hideReconnect', false);
  }, 1000);
  model.reconnect();
};

exports.reload = function() {
  window.location.reload();
};
},{}],17:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var racer = require('racer');
var component = require('./component');
var View = require('./View');
var viewModel = require('./viewModel');
var isServer = racer.util.isServer;
var paths = require('./paths');

exports.create = createApp;

function createApp(derby, appModule) {
  var app = racer.util.mergeInto(appModule.exports, EventEmitter.prototype)

  app.use = racer.util.use;
  component(app);
  app.filename = appModule.filename;
  app.view = new View(app._libraries, app, appModule.filename);
  app.fn = appFn;

  function appFn(value, fn) {
    if (typeof value === 'string') {
      // Don't bind the function on the server, since each
      // render gets passed a new model as part of the app
      paths.pathMerge(app, value, fn, bindPage);
    } else {
      paths.treeMerge(app, value, bindPage);
    }
    return app;
  }

  if (!isServer) {
    var bindPage = function(fn) {
      return function() {
        return fn.apply(app.page, arguments);
      };
    };
  }

  app._viewModels = {};
  app.viewModel = viewModel.construct.bind(app);

  return app;
}

},{"events":9,"racer":"IocUA/","./component":18,"./View":19,"./viewModel":20,"./paths":21}],2:[function(require,module,exports){
(function(global){var racer = require('racer')
  , tracks = require('tracks')
  , sharedCreateApp = require('./app').create
  , derbyModel = require('./derby.Model')
  , Dom = require('./Dom')
  , viewModel = require('./viewModel')
  , refresh = require('./refresh')

module.exports = derbyBrowser;

function derbyBrowser(derby) {
  // This assumes that only a single instance of this module can run at a time,
  // which is reasonable in the browser. This is written like this so that
  // the DERBY global can be used to initialize templates and data.
  global.DERBY = derby;
  derby.createApp = createApp;
  derby.init = init;
}

function createApp(appModule) {
  if (derbyBrowser.created) {
    throw new Error('derby.createApp() called multiple times in the browser');
  } else {
    derbyBrowser.created = true;
  }

  var app = sharedCreateApp(this, appModule)
  global.DERBY.app = app;

  racer.once('model', function(model) {
    app.emit('model', model);
  });

  // Adds get, post, put, del, enter, and exit methods
  // as well as history to app
  tracks.setup(app, createPage, onRoute);

  onRenderError = function(err, url) {
    setTimeout(function() {
      window.location = url;
    }, 0);
    throw err;
  }

  function Page(app) {
    this.app = app;
    this.model = app.model;
    this.dom = app.dom;
    this.history = app.history;
    this._viewModels = [];
    this._routing = false;
  }
  Page.prototype.render = function(ns, ctx) {
    try {
      if (typeof ns === 'object') {
        ctx = ns;
        ns = '';
      }
      ctx || (ctx = {});
      ctx.$url = this.params.url;
      app.view.render(this.model, ns, ctx);
      this._routing = false;
      tracks.render(this, {
        url: this.params.url
      , previous: this.params.previous
      , method: 'enter'
      , noNavigate: true
      });
    } catch (err) {
      onRenderError(err, this.params.url);
    }
  };
  Page.prototype.init = viewModel.pageInit;

  function createPage() {
    return new Page(app);
  }
  function onRoute(callback, page, params, next, isTransitional, done) {
    if (!app._initialized) return;
    try {
      if (isTransitional) {
        if (callback.length === 4) {
          callback(page.model, params, next, done);
          return true;
        } else {
          callback(page.model, params, next);
          return;
        }
      }

      if (params.method === 'enter' || params.method === 'exit') {
        callback.call(app, page.model, params);
        next();
        return;
      }

      if (!page._routing) {
        tracks.render(page, {
          url: page.params.previous
        , method: 'exit'
        , noNavigate: true
        });
        app.view._beforeRoute();
      }
      page._routing = true;
      callback(page, page.model, params, next);
    } catch (err) {
      onRenderError(err, page.params.url);
    }
  }

  app.ready = function(fn) {
    if (app._initialized) return fn.call(app.page, app.model);
    app.once('ready', function() {
      fn.call(app.page, app.model);
    });
  };
  return app;
}

function init(modelBundle, ctx) {
  var app = global.DERBY.app
    , ns = ctx.$ns
    , renderHash = ctx.$renderHash
    , derby = this

  // The ready event is fired after the model data is initialized
  racer.ready(function(model) {
    var dom = new Dom(model);

    app.model = model;
    app.dom = dom;

    // Calling history.page() creates the initial page, which is only
    // created one time on the client
    // TODO: This is a rather obtuse mechanism
    var page = app.history.page();
    app.page = page;
    page.model = model;
    page.dom = dom;

    // Reinitialize any viewModels which were already initialized
    // during rendering on the server
    if (ctx.$viewModels) {
      for (var i = 0; i < ctx.$viewModels.length; i++) {
        var item = ctx.$viewModels[i];
        var viewModel = app._viewModels[item[0]];
        item[1].unshift(page);
        viewModel.init.apply(viewModel, item[1]);
      }
    }

    derbyModel.init(derby, app);
    // Catch errors thrown when rendering and then throw from a setTimeout.
    // This way, the remaining init code can run and the app still connects
    try {
      // Render immediately upon initialization so that the page is in
      // EXACTLY the same state it was when rendered on the server
      app.view.render(model, ns, ctx, renderHash);
    } catch (err) {
      setTimeout(function() {
        throw err;
      }, 0);
    }
    app._initialized = true;

    app.emit('ready');

    tracks.render(app.history.page(), {
      url: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
    , method: 'enter'
    , noNavigate: true
    });

    // Delaying here to make sure that all ready callbacks are called before
    // the create functions run on various components
    setTimeout(function() {
      app.view._afterRender(ns, ctx);
    }, 0);

    if (ctx.$scriptPath) {
      model.channel.send('derby:app', ctx.$scriptPath);
      refresh.autoRefresh(app.view, model);
    }
  });
  racer.init(modelBundle);
}

})(window)
},{"racer":"IocUA/","./app":17,"./derby.Model":22,"./Dom":23,"./viewModel":20,"./refresh":24,"tracks":25}],22:[function(require,module,exports){
(function(){var EventDispatcher = require('./EventDispatcher')
var PathMap = require('./PathMap')
var Model = require('racer').Model
var valueBinding = require('./View').valueBinding
var arraySlice = [].slice;

exports.init = init;

// Add support for creating a model alias from a DOM node or jQuery object
Model.prototype.__at = Model.prototype.at;
Model.prototype.at = function(node) {
  var isNode = node && (node.parentNode || node.jquery && (node = node[0]));
  if (!isNode) return this.__at(node);

  updateMarkers();

  var blockPaths = this.root.__blockPaths
    , pathMap = this.root.__pathMap
    , child, i, id, last, path, blockPath, children, len;
  while (node) {
    if (node.$derbyMarkerParent && last) {
      node = last;
      while (node = node.previousSibling) {
        if (!(id = node.$derbyMarkerId)) continue;
        blockPath = blockPaths[id];
        if (node.$derbyMarkerEnd || !blockPath) break;

        path = pathMap.paths[blockPath.id];
        if ((blockPath.type === 'each') && last) {
          i = 0;
          while (node = node.nextSibling) {
            if (node === last) {
              path = path + '.' + i;
              break;
            }
            i++;
          }
        }
        return this.scope(path);
      }
      last = last.parentNode;
      node = last.parentNode;
      continue;
    }
    if ((id = node.id) && (blockPath = blockPaths[id])) {
      path = pathMap.paths[blockPath.id];
      if ((blockPath.type === 'each') && last) {
        children = node.childNodes;
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if (child === last) {
            path = path + '.' + i;
            break;
          }
        }
      }
      return this.scope(path);
    }
    last = node;
    node = node.parentNode;
  }

  // Just return the root scope if a path can't be found
  return this.scope();
}

function updateMarkers() {
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document.body, 128, null, false)
    , comment, id;
  while (comment = commentIterator.nextNode()) {
    if (comment.$derbyChecked) continue;
    comment.$derbyChecked = true;
    id = comment.data;
    if (id.charAt(0) !== '$') continue;
    if (id.charAt(1) === '$') {
      comment.$derbyMarkerEnd = true;
      id = id.slice(1);
    }
    comment.$derbyMarkerId = id;
    comment.parentNode.$derbyMarkerParent = true;
  }
}

function init(derby, app) {
  var model = app.model;
  var dom = app.dom;
  var pathMap = model.__pathMap = new PathMap;
  var events = model.__events = new EventDispatcher({
    onTrigger: derbyModelTrigger
  , onCleanup: derbyModelEventsCleanup
  });

  function derbyModelEventsCleanup(pathId, listener) {
    var id = listener[0];
    return !dom.item(id);
  }

  function derbyModelTrigger(pathId, listener, type, pass, value, index, arg) {
    var id = listener[0]
      , el = dom.item(id);

    // Ignore if the element can't be found, and cleanup after some delay
    if (!el) return events.delayedCleanup(pathId);

    var method = listener[1]
      , property = listener[2]
      , partial = listener.partial
      , path = pathMap.paths[pathId]
      , triggerId;

    // Handle text OT events
    if (type === 'stringInsert' || type === 'stringRemove') {
      if (method !== 'propOt' || el === pass.$el) return;
      method = type;
    }
    // Ignore side-effect change events that were already handled
    if (method === 'propOt' && (pass.$original === 'stringInsert' || pass.$original === 'stringRemove')) return;

    if (partial) {
      triggerId = id;
      if (method === 'html' && type) {
        if (partial.type === 'each') {
          // Handle array updates
          method = type;
          if (type === 'insert') {
            triggerId = null;
          } else if (type === 'remove') {
            partial = null;
          } else if (type === 'move') {
            partial = null;
          }
        } else {
          value = model.get(path);
        }
      }
    }
    if (listener.getValue) {
      value = listener.getValue(model, path);
    }
    if (partial) {
      // TODO Get rid of model.__fnCtx cache
      // Was causing issues with not emitting "init:child" or "create:child"
      // when dynamically rendering a component inside a parent component
      // within an each block.
      delete model.__fnCtx;

      if (method === 'insert') {
        var values = value;
        value = '';
        for (var i = 0, len = values.length; i < len; i++) {
          value += partial(listener.ctx, model, triggerId, values[i], index + i, listener) || '<!--empty-->';
        }
      } else {
        value = partial(listener.ctx, model, triggerId, value, index, listener);
      }
    }
    value = valueBinding(value);
    dom.update(el, method, pass.ignore, value, property, index, arg);
    // HACK: Use of global
    DERBY.app.view._flushUncreated();
  }

  var types = Object.keys(Model.MUTATOR_EVENTS);
  types.push('all');
  types.forEach(function(type) {
    var beforeType = 'beforeBinding:' + type;
    model.on(type, function(segments, eventArgs) {
      model.emit(beforeType, segments, eventArgs);
    });
  });

  model.on('change', '**', function derbyOnChange(path, value, previous, pass) {
    // For set operations on array items, also emit a remove and insert in case the
    // array is bound
    if (/\.\d+$/.test(path)) {
      var i = path.lastIndexOf('.');
      var arrayPath = path.slice(0, i);
      var index = +path.slice(i + 1);
      triggerEach(arrayPath, 'remove', pass, index);
      triggerEach(arrayPath, 'insert', pass, [value], index);
    }
    triggerEach(path, 'html', pass, value);
  });

  model.on('load', '**', function derbyOnLoad(path, value, pass) {
    triggerEach(path, 'html', pass, value);
  });

  model.on('unload', '**', function derbyOnLoad(path, previous, pass) {
    triggerEach(path, 'html', pass, void 0);
  });

  model.on('insert', '**', function derbyOnInsert(path, index, values, pass) {
    pathMap.onInsert(path, index, values.length);
    triggerEach(path, 'insert', pass, values, index);
  });

  model.on('remove', '**', function derbyOnRemove(path, index, removed, pass) {
    var howMany = removed.length;
    var end = index + howMany;
    pathMap.onRemove(path, index, howMany);

    for (var i = index; i < end; i++) {
      var id = pathMap.ids[path];
      if (id) events.trigger(id, 'remove', pass, index);
    }
    triggerParents(path, pass);
  });

  model.on('move', '**', function derbyOnMove(path, from, to, howMany, pass) {
    pathMap.onMove(path, from, to, howMany);
    triggerEach(path, 'move', pass, from, to, howMany);
  });

  model.on('stringInsert', '**', function derbyOnStringInsert(path, index, inserted, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringInsert', pass, value, index, inserted);
  });

  model.on('stringRemove', '**', function derbyOnStringRemove(path, index, howMany, pass) {
    var value = model.get(path);
    var id = pathMap.ids[path];
    events.trigger(id, 'stringRemove', pass, value, index, howMany);
  });

  function triggerEach(path, type, pass, arg0, arg1, arg2) {
    // Trigger an event on the path if it has a pathMap ID
    var id = pathMap.ids[path];
    if (id) events.trigger(id, type, pass, arg0, arg1, arg2);
    // Trigger a pattern event for the path and each of its parent paths
    // This is used by view helper functions to match updates on a path
    // or any of its child segments
    triggerParents(path, pass);
  }

  function triggerParents(path, pass) {
    var segments = path.split('.');
    for (var i = 1, len = segments.length; i <= len; i++) {
      var pattern = segments.slice(0, i).join('.') + '*';
      var id = pathMap.ids[pattern];
      if (id) events.trigger(id, null, pass);
    }
  }

  return model;
}

})()
},{"racer":"IocUA/","./EventDispatcher":26,"./PathMap":27,"./View":19}],20:[function(require,module,exports){
var paths = require('./paths');

module.exports = {
  construct: construct
};

function ViewModel(name, proto) {
  this.name = name;
  this.proto = proto;
}
ViewModel.prototype.init = function(page) {
  var args = Array.prototype.slice.call(arguments, 1);
  // ViewModels are actually just scoped models for now
  var _super = page.model.at(this.name);
  var viewModel = _super._child();

  // Mixin viewModel specific methods
  viewModel._super = _super;
  viewModel.page = page;
  viewModel.model = page.model;
  for (key in this.proto) {
    if (key === 'init') continue;
    viewModel[key] = this.proto[key].bind(viewModel);
  }
  if (this.proto.init) {
    // Keep track of viewModels that were created so that
    // they can be recreated on the client if first rendered
    // on the server
    page._viewModels.push([this.name, args]);
    this.proto.init.apply(viewModel, args);
  }

  // Make viewModel available on the page for use in
  // event callbacks and other functions
  var segments = this.name.split('.');
  var last = segments.pop();
  var node = paths.traverseNode(page, segments);
  node[last] = viewModel;

  return viewModel;
}

function construct(name, proto) {
  // Keep a map of defined viewModels so that they can
  // be reinitialized from their name on the client
  var viewModel = this._viewModels[name] = new ViewModel(name, proto);
  return viewModel;
}

},{"./paths":21}],11:[function(require,module,exports){
(function(__dirname){module.exports = require('./Model');
var util = require('../util');

// Extend model on both server and client //
require('./events');
require('./paths');
require('./collections');
require('./mutators');
require('./setDiff');

require('./connection');
require('./subscriptions');
require('./Query');
require('./contexts');

require('./fn');
require('./filter');
require('./refList');
require('./ref');

// Extend model for server //
util.serverRequire(__dirname + '/bundle');
util.serverRequire(__dirname + '/connection.server');

})("/node_modules/derby/node_modules/racer/lib/Model")
},{"./Model":28,"../util":10,"./events":29,"./paths":30,"./collections":31,"./mutators":32,"./setDiff":33,"./connection":34,"./subscriptions":35,"./Query":36,"./contexts":37,"./fn":38,"./filter":39,"./refList":40,"./ref":41}],21:[function(require,module,exports){
module.exports = {
  traverseNode: traverseNode
, pathMerge: pathMerge
, treeMerge: treeMerge
};

function traverseNode(node, segments) {
  var i, len, segment
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    node = node[segment] || (node[segment] = {});
  }
  return node;
}

// Recursively set nested objects based on a path
function pathMerge(node, path, value, nodeFn) {
  var segments = path.split('.')
    , last, i, len, segment
  if (typeof value === 'object') {
    node = traverseNode(node, segments);
    treeMerge(node, value, nodeFn);
    return;
  }
  last = segments.pop();
  node = traverseNode(node, segments);
  node[last] = (nodeFn) ? nodeFn(value) : value;
}

// Recursively set objects such that the non-objects are
// merged with the corresponding structure of the base node
function treeMerge(node, tree, nodeFn) {
  var key, child, value
  for (key in tree) {
    value = tree[key];
    if (typeof value === 'object') {
      child = node[key] || (node[key] = {});
      treeMerge(child, value, nodeFn);
      continue;
    }
    node[key] = (nodeFn) ? nodeFn(value) : value;
  }
}

},{}],26:[function(require,module,exports){
function empty() {}
function EventDispatcherNames() {}
function EventDispatcherListeners() {}
function CleanupPendingMap() {}

module.exports = EventDispatcher;

function EventDispatcher(options) {
  this._onTrigger = options && options.onTrigger || empty;
  this._onBind = options && options.onBind || empty;
  this._onCleanup = options && options.onCleanup;
  this._cleanupPending = new CleanupPendingMap();
  this.clear();
}

EventDispatcher.prototype.clear = function() {
  this.names = new EventDispatcherNames();
};

EventDispatcher.prototype.bind = function(name, listener, arg0) {
  this._onBind(name, listener, arg0);
  var obj = this.names[name] || (this.names[name] = new EventDispatcherListeners());
  obj[JSON.stringify(listener)] = listener;
  return obj;
};

EventDispatcher.prototype.trigger = function(name, value, arg0, arg1, arg2, arg3, arg4, arg5) {
  if (!name) return;
  var listeners = this.names[name];
  var onTrigger = this._onTrigger;
  var count = 0;
  var key, listener;
  for (key in listeners) {
    listener = listeners[key];
    count++;
    if (false !== onTrigger(name, listener, value, arg0, arg1, arg2, arg3, arg4, arg5)) {
      continue;
    }
    delete listeners[key];
    count--;
  }
  if (!count) delete this.names[name];
  return count;
};

EventDispatcher.prototype.delayedCleanup = function(name) {
  if (this._cleanupPending[name]) return;
  this._cleanupPending[name] = true;
  var eventDispatcher = this;
  setTimeout(function() {
    delete eventDispatcher._cleanupPending[name];
    eventDispatcher.cleanup(name);
  }, 0);
};

EventDispatcher.prototype.cleanup = function(name) {
  var listeners = this.names[name];
  var hasKeys = false;
  var key, remove;
  for (key in listeners) {
    remove = this._onCleanup(name, listeners[key]);
    if (remove) {
      delete listeners[key];
    } else {
      hasKeys = true;
    }
  }
  if (!hasKeys) delete this.names[name];
};

},{}],27:[function(require,module,exports){
module.exports = PathMap;

function PathMap() {
  this.clear();
  this.count = 0;
}

PathMap.prototype.clear = function() {
  this.ids = {};
  this.paths = {};
  this.arrays = {};
};

PathMap.prototype.id = function(path) {
  // Return the path for an id, or create a new id and index it
  var id = this.ids[path];
  if (id) return id;
  id = (++this.count).toString();
  this.paths[id] = path;
  this._indexArray(path, id);
  this.ids[path] = id;
  return id;
};

PathMap.prototype._indexArray = function(path, id) {
  var arr, index, match, nested, remainder, set, setArrays;
  while (match = /^(.+)\.(\d+)(\*?(?:\..+|$))/.exec(path)) {
    path = match[1];
    index = +match[2];
    remainder = match[3];
    arr = this.arrays[path] || (this.arrays[path] = []);
    set = arr[index] || (arr[index] = {});
    if (nested) {
      setArrays = set.arrays || (set.arrays = {});
      setArrays[remainder] = true;
    } else {
      set[id] = remainder;
    }
    nested = true;
  }
};

PathMap.prototype._incrItems = function(path, map, start, end, byNum, oldArrays, oldPath) {
  var arrayMap, arrayPath, arrayPathTo, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < end; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      remainder = ids[id];
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = (oldPath || path) + '.' + i + remainder;
          arrayMap = oldArrays[arrayPath] || this.arrays[arrayPath];
          if (arrayMap) {
            arrayPathTo = path + '.' + (i + byNum) + remainder;
            this.arrays[arrayPathTo] = arrayMap;
            this._incrItems(arrayPathTo, arrayMap, 0, arrayMap.length, 0, oldArrays, arrayPath);
          }
        }
        continue;
      }

      itemPath = path + '.' + (i + byNum) + remainder;
      this.paths[id] = itemPath;
      this.ids[itemPath] = +id;
    }
  }
};

PathMap.prototype._delItems = function(path, map, start, end, len, oldArrays) {
  var arrayLen, arrayMap, arrayPath, i, id, ids, itemPath, remainder;
  if (oldArrays == null) oldArrays = {};

  for (i = start; i < len; i++) {
    ids = map[i];
    if (!ids) continue;

    for (id in ids) {
      if (id === 'arrays') {
        for (remainder in ids[id]) {
          arrayPath = path + '.' + i + remainder;
          if (arrayMap = this.arrays[arrayPath]) {
            arrayLen = arrayMap.length;
            this._delItems(arrayPath, arrayMap, 0, arrayLen, arrayLen, oldArrays);
            oldArrays[arrayPath] = arrayMap;
            delete this.arrays[arrayPath];
          }
        }
        continue;
      }

      itemPath = this.paths[id];
      delete this.ids[itemPath];
      if (i > end) continue;
      delete this.paths[id];
    }
  }

  return oldArrays;
};

PathMap.prototype.onRemove = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for removed items
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Decrement indicies of later items
  this._incrItems(path, map, end, len, -howMany, oldArrays);
  map.splice(start, howMany);
};

PathMap.prototype.onInsert = function(path, start, howMany) {
  var map = this.arrays[path]
    , end, len, oldArrays;
  if (!map) return;
  end = start + howMany;
  len = map.length;
  // Delete indicies for items in inserted positions
  oldArrays = this._delItems(path, map, start, end + 1, len);
  // Increment indicies of later items
  this._incrItems(path, map, start, len, howMany, oldArrays);
  while (howMany--) {
    map.splice(start, 0, {});
  }
};

PathMap.prototype.onMove = function(path, from, to, howMany) {
  var map = this.arrays[path]
    , afterFrom, afterTo, items, oldArrays;
  if (!map) return;
  afterFrom = from + howMany;
  afterTo = to + howMany;
  // Adjust paths for items between from and to
  if (from > to) {
    oldArrays = this._delItems(path, map, to, afterFrom, afterFrom);
    this._incrItems(path, map, to, from, howMany, oldArrays);
  } else {
    oldArrays = this._delItems(path, map, from, afterTo, afterTo);
    this._incrItems(path, map, afterFrom, afterTo, -howMany, oldArrays);
  }
  // Adjust paths for the moved item(s)
  this._incrItems(path, map, from, afterFrom, to - from, oldArrays);
  // Fix the array index
  items = map.splice(from, howMany);
  map.splice.apply(map, [to, 0].concat(items));
};

},{}],42:[function(require,module,exports){
module.exports = {
  onStringInsert: onStringInsert
, onStringRemove: onStringRemove
, onTextInput: onTextInput
};

function onStringInsert(el, previous, index, text) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor + text.length : cursor;
  }
  var newText = previous.slice(0, index) + text + previous.slice(index);
  replaceText(el, newText, transformCursor);
}

function onStringRemove(el, previous, index, howMany) {
  function transformCursor(cursor) {
    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;
  }
  var newText = previous.slice(0, index) + previous.slice(index + howMany);
  replaceText(el, newText, transformCursor);
}

function replaceText(el, newText, transformCursor) {
  var selectionStart = transformCursor(el.selectionStart);
  var selectionEnd = transformCursor(el.selectionEnd);

  var scrollTop = el.scrollTop;
  el.value = newText;
  if (el.scrollTop !== scrollTop) {
    el.scrollTop = scrollTop;
  }
  if (document.activeElement === el) {
    el.selectionStart = selectionStart;
    el.selectionEnd = selectionEnd;
  }
}

function onTextInput(model, path, value) {
  var previous = model.get(path) || '';
  if (previous === value) return;
  var start = 0;
  while (previous.charAt(start) == value.charAt(start)) {
    start++;
  }
  var end = 0;
  while (
    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&
    end + start < previous.length &&
    end + start < value.length
  ) {
    end++;
  }

  if (previous.length !== start + end) {
    var howMany = previous.length - start - end;
    model.stringRemove(path, start, howMany);
  }
  if (value.length !== start + end) {
    var inserted = value.slice(start, value.length - end);
    model.stringInsert(path, start, inserted);
  }
}

},{}],14:[function(require,module,exports){
(function(__filename){var config = {
  filename: __filename,
  ns: 'ghbtns',
  scripts: {
    button: require('./button')
  }
};

module.exports = function(app, options) {
  app.createLibrary(config, options);
}
})("/node_modules/derby-ui-github-buttons/index.js")
},{"./button":43}],15:[function(require,module,exports){
exports.app = require('./lib/app');
exports.server = require('./lib/server');
},{"./lib/app":44,"./lib/server":45}],46:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":8}],10:[function(require,module,exports){
(function(process){var deepIs = require('deep-is');

var isServer = process.title !== 'browser';
var isProduction = process.env.NODE_ENV === 'production';

module.exports = {
  isServer: isServer
, isProduction: isProduction

, asyncGroup: asyncGroup
, contains: contains
, copyObject: copyObject
, deepCopy: deepCopy
, deepEqual: deepIs
, equal: equal
, equalsNaN: equalsNaN
, lookup: lookup
, mergeInto: mergeInto
, mayImpact: mayImpact
, mayImpactAny: mayImpactAny
, serverRequire: serverRequire
, use: use
};

function asyncGroup(cb) {
  var group = new AsyncGroup(cb);
  return function asyncGroupAdd() {
    return group.add();
  };
}

/**
 * @constructor
 * @param {Function} cb(err)
 */
function AsyncGroup(cb) {
  this.cb = cb;
  this.isDone = false;
  this.count = 0;
}
AsyncGroup.prototype.add = function() {
  this.count++;
  var self = this;
  return function(err) {
    self.count--;
    if (self.isDone) return;
    if (err) {
      self.isDone = true;
      self.cb(err);
      return;
    }
    if (self.count > 0) return;
    self.isDone = true;
    self.cb();
  };
};

function contains(segments, testSegments) {
  for (var i = 0; i < segments.length; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function copyObject(object) {
  var out = new object.constructor;
  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      out[key] = object[key];
    }
  }
  return out;
}

function deepCopy(value) {
  if (value instanceof Date) return new Date(value);
  if (typeof value === 'object') {
    if (value === null) return null;
    var copy;
    if (Array.isArray(value)) {
      copy = [];
      for (var i = value.length; i--;) {
        copy[i] = deepCopy(value[i]);
      }
      return copy;
    }
    copy = new value.constructor;
    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        copy[key] = deepCopy(value[key]);
      }
    }
    return copy;
  }
  return value;
}

function equal(a, b) {
  return (a === b) || (equalsNaN(a) && equalsNaN(b));
}

function equalsNaN(x) {
  return x !== x;
}

function lookup(segments, value) {
  if (!segments) return value;

  for (var i = 0, len = segments.length; i < len; i++) {
    if (value == null) return value;
    value = value[segments[i]];
  }
  return value;
}

function mayImpactAny(segmentsList, testSegments) {
  for (var i = 0, len = segmentsList.length; i < len; i++) {
    if (mayImpact(segmentsList[i], testSegments)) return true;
  }
  return false;
}

function mayImpact(segments, testSegments) {
  var len = Math.min(segments.length, testSegments.length);
  for (var i = 0; i < len; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function mergeInto(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

function serverRequire(name) {
  if (!isServer) return;
  // Tricks Browserify into not logging a warning
  var _require = require;
  return _require(name);
}

function use(plugin, options) {
  // Server-side plugins may be included via filename
  if (typeof plugin === 'string') {
    if (!isServer) return this;
    plugin = serverRequire(plugin);
  }

  // Don't include a plugin more than once
  var plugins = this._plugins || (this._plugins = []);
  if (plugins.indexOf(plugin) === -1) {
    plugins.push(plugin);
    plugin(this, options);
  }
  return this;
}

})(require("__browserify_process"))
},{"deep-is":47,"__browserify_process":8}],18:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter
  , path = require('path')
  , util = require('racer').util
  , View = require('./View')
  , arraySlice = Array.prototype.slice

module.exports = componentPlugin;

function componentPlugin(app) {
  app._libraries = [];
  app._libraries.map = {};
  app.createLibrary = createLibrary;
}

function ComponentProto() {}
util.mergeInto(ComponentProto.prototype, EventEmitter.prototype);

ComponentProto.prototype.emitCancellable = function() {
  var cancelled = false
    , args = arraySlice.call(arguments)

  function cancel() {
    cancelled = true;
  }

  args.push(cancel);
  this.emit.apply(this, args);
  return cancelled;
};

ComponentProto.prototype.emitDelayable = function() {
  var delayed = false
    , args = arraySlice.call(arguments, 0, -1)
    , callback = arguments[arguments.length - 1]

  function delay() {
    delayed = true;
  }

  args.push(delay, callback);
  this.emit.apply(this, args);
  if (!delayed) callback();
  return delayed;
};

function createLibrary(config, options) {
  if (!config || !config.filename) {
    throw new Error ('Configuration argument with a filename is required');
  }
  if (!options) options = {};
  var root = path.dirname(config.filename);
  var ns = options.ns || config.ns || path.basename(root);
  var scripts = config.scripts || {};
  var view = new View;
  var constructors = {};
  var library = {
    ns: ns
  , root: root
  , view: view
  , constructors: constructors
  , styles: config.styles
  };

  view.parent = this;
  view._selfNs = 'lib';
  view._selfLibrary = library;

  for (var name in scripts) {
    var script = scripts[name];
    script.setup && script.setup(library);

    var Component = function(model, scope) {
      this.view = view;
      this.model = model;
      this.scope = scope;
      this.history = null;
      this.dom = null;

      // Don't limit the number of listeners
      this.setMaxListeners(0);

      var component = this;
      model.__on = model._on;
      model._on = function(name, listener) {
        component.on('destroy', function() {
          model.removeListener(name, listener);
        })
        return model.__on(name, listener);
      };
      component.on('destroy', function() {
        model.silent().del();
      });
    }
    var proto = Component.prototype = new ComponentProto();
    util.mergeInto(proto, script);

    Component.view = view;
    Component.ns = Component.prototype.ns = ns;
    Component.name = Component.prototype.name = name;

    // Note that component names are all lowercased
    constructors[name.toLowerCase()] = Component;
  }

  var replaced = false;
  for (var i = this._libraries.length; i--;) {
    if (this._libraries[i].ns === ns) {
      this._libraries[i] = library;
      replaced = true;
    }
  }
  if (!replaced) {
    this._libraries.push(library);
  }
  this._libraries.map[ns] = library;
  return library;
}

},{"events":9,"path":46,"racer":"IocUA/","./View":19}],25:[function(require,module,exports){
var Route = require('../vendor/express/router/route')
var History = require('./History')
var router = module.exports = require('./router')
var compose = require('./compose')

router.setup = setup

function setup(app, createPage, onRoute) {
  var routes = {
    queue: {}
  , transitional: {}
  , onRoute: onRoute
  }
  app.history = new History(createPage, routes)

  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {
    var queue = routes.queue[method] = []
    var transitional = routes.transitional[method] = []
    var transitionalCalls = []

    app[method] = function(pattern, callback) {
      if (Array.isArray(pattern)) {
        pattern.forEach(function(item) {
          app[method](item, callback)
        })
        return app
      }

      if (router.isTransitional(pattern)) {
        var from = pattern.from
        var to = pattern.to
        var forward = pattern.forward || (callback && callback.forward) || callback
        var back = pattern.back || (callback && callback.back)
        transitionalCalls.push({
          from: from
        , to: to
        , forward: forward
        , back: back
        })

        var fromRoute = new Route(method, from, back)
        var toRoute = new Route(method, to, forward)
        fromRoute.isTransitional = true
        toRoute.isTransitional = true
        transitional.push({
          from: fromRoute
        , to: toRoute
        })
        if (back) transitional.push({
          from: toRoute
        , to: fromRoute
        })

        compose.transition(app[method], transitionalCalls, from, to, forward, back)
        return app
      }

      queue.push(new Route(method, pattern, callback))
      return app
    }
  })
}

},{"../vendor/express/router/route":48,"./History":49,"./router":50,"./compose":51}],23:[function(require,module,exports){
var racer = require('racer')
  , domShim = require('dom-shim')
  , EventDispatcher = require('./EventDispatcher')
  , viewPath = require('./viewPath')
  , escapeHtml = require('html-util').escapeHtml
  , textOt = require('./textOt')
  , merge = racer.util.merge
  , markers = {}
  , markersDirty = true
  , globalElements = {
      $_win: window
    , $_doc: document
    }
  , addListener, removeListener;

module.exports = Dom;

function Dom(model) {
  var dom = this
  var fns = this.fns

  // Map dom event name -> true
  var listenerAdded = {};
  var captureListenerAdded = {}

  // DOM listener capturing allows blur and focus to be delegated
  // http:http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
  var captureEvents = this._captureEvents = new EventDispatcher({
    onTrigger: onCaptureTrigger
  , onBind: onCaptureBind
  });
  function onCaptureTrigger(name, listener, e) {
    var id = listener.id
      , el = document.getElementById(id);

    // Remove listener if element isn't found
    if (!el) return false;

    if (el.tagName === 'HTML' || el.contains(e.target)) {
      onDomTrigger(name, listener, id, e, el);
    }
  }
  function onCaptureBind(name, listener) {
    if (captureListenerAdded[name]) return;
    addListener(document, name, captureTrigger, true);
    captureListenerAdded[name] = true;
  }

  var events = this._events = new EventDispatcher({
    onTrigger: onDomTrigger
  , onBind: onDomBind
  });
  function onDomTrigger(name, listener, id, e, el, next) {
    var delay = listener.delay
      , finish = listener.fn;

    e.path = function(name) {
      if (!name) return model.__pathMap.paths[listener.pathId];
      return viewPath.ctxPath(listener.view, listener.ctx, name);
    };
    e.get = function(name) {
      var path = e.path(name);
      return viewPath.dataValue(listener.view, listener.ctx, model, path);
    };
    e.at = function(name) {
      return model.at(e.path(name));
    };

    if (!finish) {
      // Update the model when the element's value changes
      finish = function() {
        var value = dom.getMethods[listener.method](el, listener.property)
          , setValue = listener.setValue;

        // Allow the listener to override the setting function
        if (setValue) {
          setValue(model, value);
          return;
        }

        // Remove this listener if its path id is no longer registered
        var path = model.__pathMap.paths[listener.pathId];
        if (!path) return false;

        // Set the value if changed
        if (model.get(path) === value) return;

        var setterModel = model.pass({$e: e, $el: el});
        if (listener.method === 'propOt') {
          return textOt.onTextInput(setterModel, path, value);
        }
        setterModel.set(path, value);
      }
    }

    if (delay != null) {
      setTimeout(finish, delay, e, el, next, dom);
    } else {
      finish(e, el, next, dom);
    }
  }
  function onDomBind(name, listener, eventName) {
    if (listenerAdded[eventName]) return;
    addListener(document, eventName, triggerDom, true);
    listenerAdded[eventName] = true;
  }

  function triggerDom(e, el, noBubble, continued) {
    if (!el) el = e.target;
    var prefix = e.type + ':'
      , id;

    // Next can be called from a listener to continue bubbling
    function next() {
      triggerDom(e, el.parentNode, false, true);
    }
    next.firstTrigger = !continued;
    if (noBubble && (id = el.id)) {
      return events.trigger(prefix + id, id, e, el, next);
    }
    while (true) {
      while (!(id = el.id)) {
        if (!(el = el.parentNode)) return;
      }
      // Stop bubbling once the event is handled
      if (events.trigger(prefix + id, id, e, el, next)) return;
      if (!(el = el.parentNode)) return;
    }
  }

  function captureTrigger(e) {
    captureEvents.trigger(e.type, e);
  }

  this.trigger = triggerDom;
  this.captureTrigger = captureTrigger;

  this._listeners = [];
  this._components = [];
  this._pendingUpdates = [];

  function componentCleanup() {
    var components = dom._components
      , map = getMarkers()
      , i, component
    for (i = components.length; i--;) {
      component = components[i];
      if (component && !getMarker(map, component.scope)) {
        component.emit('destroy');
      }
    }
  }
  // TODO This 'cleanup' event is never emitted; deal with later
  // This cleanup listeners is placed at the beginning so that component
  // scopes are cleared before any ref cleanups are checked
  model.listeners('cleanup').unshift(componentCleanup);
}

Dom.prototype = {
  clear: domClear
, bind: domBind
, item: domItem
, marker: domMarker
, update: domUpdate
, addListener: domAddListener
, removeListener: domRemoveListener
, addComponent: addComponent
, _setDirty: setDirty

, getMethods: {
    attr: getAttr
  , prop: getProp
  , propOt: getPropOt
  , stringInsert: getPropOt
  , stringRemove: getPropOt
  , html: getHtml
    // These methods return NaN, because it never equals anything else. Thus,
    // when compared against the new value, the new value will always be set
  , insert: getNaN
  , remove: getNaN
  , move: getNaN
  }

, setMethods: {
    attr: setAttr
  , prop: setProp
  , propOt: setPropOt
  , stringInsert: setStringInsert
  , stringRemove: setStringRemove
  , html: setHtml
  , insert: setInsert
  , remove: setRemove
  , move: setMove
  }

, fns: {
    $forChildren: forChildren
  , $forName: forName
  }
}

function domClear() {
  this._events.clear();
  this._captureEvents.clear();
  var components = this._components
    , listeners = this._listeners
    , i, component
  for (i = listeners.length; i--;) {
    removeListener.apply(null, listeners[i]);
  }
  this._listeners = [];
  for (i = components.length; i--;) {
    component = components[i];
    component && component.emit('destroy');
  }
  this._components = [];
  markers = {};
}

function domListenerHash() {
  var out = {}
    , key
  for (key in this) {
    if (key === 'view' || key === 'ctx' || key === 'pathId') continue;
    out[key] = this[key];
  }
  return out;
}

function domBind(eventName, id, listener) {
  listener.toJSON = domListenerHash;
  if (listener.capture) {
    listener.id = id;
    this._captureEvents.bind(eventName, listener);
  } else {
    this._events.bind("" + eventName + ":" + id, listener, eventName);
  }
}

function domItem(id) {
  return document.getElementById(id) || globalElements[id] || getRange(id);
}

// HACK: Crappy interface. Should refactor marker getting to be a prototype
// method and make dirty a property of dom instance
function setDirty(value) {
  markersDirty = value;
}

function domUpdate(el, method, ignore, value, property, index, arg) {
  // Wrapped in a try / catch so that errors thrown on DOM updates don't
  // stop subsequent code from running
  try {
    // Don't do anything if the element is already up to date
    if (value === this.getMethods[method](el, property)) return;
    this.setMethods[method](el, ignore, value, property, index, arg);
    markersDirty = true;
  } catch (err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }
}

function domAddListener(el, name, callback, captures) {
  this._listeners.push([el, name, callback, captures]);
  addListener(el, name, callback, captures);
}
function domRemoveListener(el, name, callback, captures) {
  removeListener(el, name, callback, captures);
}

function addComponent(ctx, component) {
  var components = this._components
    , dom = component.dom = Object.create(this);

  components.push(component);
  component.on('destroy', function() {
    var index = components.indexOf(component);
    if (index === -1) return;
    // The components array gets replaced on a dom.clear, so we allow
    // it to get sparse as individual components are destroyed
    delete components[index];
  });

  dom.addListener = function(el, name, callback, captures) {
    component.on('destroy', function() {
      removeListener(el, name, callback, captures);
    });
    addListener(el, name, callback, captures);
  };

  dom.element = function(name) {
    var id = ctx.$elements[name];
    return document.getElementById(id);
  };

  return dom;
}


function getAttr(el, attr) {
  return el.getAttribute && el.getAttribute(attr);
}
function getProp(el, prop) {
  return el[prop];
}
function getPropOt(el, prop) {
  // IE and Opera replace \n with \r\n
  var value = el[prop];
  return value && value.replace && value.replace(/\r\n/g, '\n');
}
function getHtml(el) {
  return el.innerHTML;
}
function getNaN() {
  return NaN;
}

function setAttr(el, ignore, value, attr) {
  el.setAttribute && el.setAttribute(attr, value);
}
function setProp(el, ignore, value, prop) {
  el[prop] = value;
}
function setPropOt(el, ignore, value, prop) {
  el[prop] = value;
}
function setStringInsert(el, ignore, value, prop, index, text) {
  var previous = getPropOt(el, prop);
  textOt.onStringInsert(el, previous, index, text);
}
function setStringRemove(el, ignore, value, prop, index, howMany) {
  var previous = getPropOt(el, prop);
  textOt.onStringRemove(el, previous, index, howMany);
}

function makeSVGFragment(fragment, svgElement) {
  // TODO: Allow optional namespace declarations
  var pre = '<svg xmlns=http:http://www.w3.org/2000/svg xmlns:xlink=http:http://www.w3.org/1999/xlink>' 
    , post = '</svg>'
    , range = document.createRange()
  range.selectNode(svgElement);
  return range.createContextualFragment(pre + fragment + post);
}
function appendSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , i
  for (i = children.length; i--;) {
    element.appendChild(children[0]);
  }
}
function insertBeforeSVG(element, fragment, svgElement) {
  var frag = makeSVGFragment(fragment, svgElement)
    , children = frag.childNodes[0].childNodes
    , parent = element.parentNode
    , i
  for (i = children.length; i--;) {
    parent.insertBefore(children[0], element);
  }
}
function removeChildren(element) {
  var children = element.childNodes
    , i
  for (i = children.length; i--;) {
    element.removeChild(children[0]);
  }
}

function isSVG(obj) {
  return !!obj.ownerSVGElement || obj.tagName === "svg";
}
function svgRoot(obj) {
  return obj.ownerSVGElement || obj;
}
function isRange(obj) {
  return !!obj.cloneRange;
}

function setHtml(obj, ignore, value, escape) {
  if (escape) value = escapeHtml(value);
  if(isRange(obj)) {
    if(isSVG(obj.startContainer)) {
      // SVG Element
      obj.deleteContents();
      var svgElement = svgRoot(obj.startContainer);
      obj.insertNode(makeSVGFragment(value, svgElement));
      return;
    } else {
      // Range
      obj.deleteContents();
      obj.insertNode(obj.createContextualFragment(value));
      return;
    }
  }
  if (isSVG(obj)) {
    // SVG Element
    var svgElement = svgRoot(obj);
    removeChildren(obj);
    appendSVG(obj, value, svgElement);
    return;
  }
  // HTML Element
  if (ignore && obj.id === ignore) return;
  obj.innerHTML = value;
}
function setInsert(obj, ignore, value, escape, index) {
  if (escape) value = escapeHtml(value);
  if (obj.nodeType) {
    // Element
    if (ref = obj.childNodes[index]) {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        insertBeforeSVG(ref, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.insertBefore(range.createContextualFragment(value), ref);
    } else {
      if (isSVG(obj)) {
        var svgElement = obj.ownerSVGElement || obj;
        appendSVG(obj, value, svgElement);
        return;
      }
      var range = document.createRange();
      range.selectNodeContents(obj);
      obj.appendChild(range.createContextualFragment(value));
    }
  } else {
    // Range
    if (isSVG(obj.startContainer)) {
      var el = obj.startContainer
      , ref = el.childNodes[obj.startOffset + index];
      var svgElement = svgRoot(ref);
      el.insertBefore(makeSVGFragment(value, svgElement), ref)
    } else {
      var el = obj.startContainer
        , ref = el.childNodes[obj.startOffset + index];
      el.insertBefore(obj.createContextualFragment(value), ref);
    }
  }
}
function setRemove(el, ignore, index) {
  if (!el.nodeType) {
    // Range
    index += el.startOffset;
    el = el.startContainer;
  }
  var child = el.childNodes[index];
  if (child) el.removeChild(child);
}
function setMove(el, ignore, from, property, to, howMany) {
  var child, fragment, nextChild, offset, ref, toEl;
  if (!el.nodeType) {
    offset = el.startOffset;
    from += offset;
    to += offset;
    el = el.startContainer;
  }
  child = el.childNodes[from];

  // Don't move if the item at the destination is passed as the ignore
  // option, since this indicates the intended item was already moved
  // Also don't move if the child to move matches the ignore option
  if (!child || ignore && (toEl = el.childNodes[to]) &&
      toEl.id === ignore || child.id === ignore) return;

  ref = el.childNodes[to > from ? to + howMany : to];
  if (howMany > 1) {
    fragment = document.createDocumentFragment();
    while (howMany--) {
      nextChild = child.nextSibling;
      fragment.appendChild(child);
      if (!(child = nextChild)) break;
    }
    el.insertBefore(fragment, ref);
    return;
  }
  el.insertBefore(child, ref);
}

function forChildren(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  // Re-trigger the event on all child elements
  var children = el.childNodes;
  for (var i = 0, len = children.length, child; i < len; i++) {
    child = children[i];
    if (child.nodeType !== 1) continue;  // Node.ELEMENT_NODE
    dom.trigger(e, child, true, true);
    forChildren(e, child, next, dom);
  }
}

function forName(e, el, next, dom) {
  // Prevent infinte emission
  if (!next.firstTrigger) return;

  var name = el.getAttribute('name');
  if (!name) return;

  // Re-trigger the event on all other elements with
  // the same 'name' attribute
  var elements = document.getElementsByName(name)
    , len = elements.length;
  if (!(len > 1)) return;
  for (var i = 0, element; i < len; i++) {
    element = elements[i];
    if (element === el) continue;
    dom.trigger(e, element, false, true);
  }
}

function getMarkers() {
  var map = {};
  // NodeFilter.SHOW_COMMENT == 128
  var commentIterator = document.createTreeWalker(document, 128, null, false);
  var comment;
  while (comment = commentIterator.nextNode()) {
    map[comment.data] = comment;
  }
  return map;
}

function getMarker(map, name) {
  var marker = map[name];
  if (!marker) return;

  // Comment nodes may continue to exist even if they have been removed from
  // the page. Thus, make sure they are still somewhere in the page body
  if (!document.contains(marker)) {
    delete map[name];
    return;
  }
  return marker;
}

function domMarker(name) {
  var marker = getMarker(markers, name);
  if (!marker && markersDirty) {
    markers = getMarkers();
    markersDirty = false;
    marker = getMarker(markers, name);
  }
  return marker;
}

function getRange(name) {
  var start = domMarker(name);
  if (!start) return;
  var end = domMarker('$' + name);
  if (!end) return;

  var range = document.createRange();
  range.setStartAfter(start);
  range.setEndBefore(end);
  return range;
}

if (document.addEventListener) {
  addListener = function(el, name, callback, captures) {
    el.addEventListener(name, callback, captures || false);
  };
  removeListener = function(el, name, callback, captures) {
    el.removeEventListener(name, callback, captures || false);
  };
}

},{"racer":"IocUA/","./EventDispatcher":26,"./viewPath":52,"./textOt":42,"dom-shim":53,"html-util":54}],24:[function(require,module,exports){
var escapeHtml = require('html-util').escapeHtml
  , errors = {};

exports.errorHtml = errorHtml;
exports.autoRefresh = autoRefresh;

function errorHtml(errors) {
  var text = ''
    , type, err;
  for (type in errors) {
    err = errors[type];
    text += '<h3>' + escapeHtml(type) + ' Error</h3><pre>' + escapeHtml(err) + '</pre>';
  }
  if (!text) return;
  return '<div id=$_derbyError style="position:absolute;background:rgba(0,0,0,.7);top:0;left:0;right:0;bottom:0;text-align:center">' +
    '<div style="background:#fff;padding:20px 40px;margin:60px;display:inline-block;text-align:left">' +
    text + '</div></div>';
}

function autoRefresh(view, model) {

  model.channel.on('derby:reload', reloadOnReady);
  // Wait to reload until the server is responsive again after restarting
  function reloadOnReady() {
    xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState !== 4) return;
      if (xhr.status === 200) {
        return window.location.reload(true);
      }
      reloadOnReady();
    };
    xhr.open('GET', window.location.href);
    xhr.send();
  }

  model.channel.on('derby:refreshCss', function(data) {
    var el = document.getElementById('$_css');
    if (el) el.innerHTML = data.css;
    updateError('CSS', data.errText);
  });

  model.channel.on('derby:refreshHtml', function(data) {
    view._makeAll(data.templates, data.instances);
    view._makeComponents(data.libraryData);
    var errText = data.errText;
    try {
      view.app.history.refresh();
    } catch (err) {
      errText || (errText = err.stack);
    }
    updateError('Template', data.errText);
  });
}

function updateError(type, err) {
  if (err) {
    errors[type] = err;
  } else {
    delete errors[type];
  }
  var el = document.getElementById('$_derbyError')
    , html = errorHtml(errors)
    , fragment, range;
  if (html) {
    if (el) {
      el.outerHTML = html;
    } else {
      range = document.createRange();
      range.selectNode(document.body);
      fragment = range.createContextualFragment(html);
      document.body.appendChild(fragment);
    }
  } else {
    if (el) el.parentNode.removeChild(el);
  }
}

},{"html-util":54}],43:[function(require,module,exports){
var url = require('url');

exports.init = function (model) {
  var filename = model.get('filename') || 'github-btn.html'
    , fileurl = model.get('fileurl')
    , domain = model.get('domain') || 'ghbtns.com'
    , giturl = model.get('giturl')
    , height = model.get('height')
    , protocol = model.get('secure') ? 'https' : 'http'
    , repo = model.get('repo')
    , size = model.get('size')
    , type = model.get('type')
    , user = model.get('user');

  if (!giturl && (!user || !repo)) {
    return console.error('ghbtns:button: giturl or user/repo required');
  }

  if (!type) {
    return console.error('ghbtns:button: type required');
  }

  if (!fileurl) {
    model.set('fileurl', protocol + '://' + domain + '/' + filename);
  }

  if (giturl) {
    var gitpath = url.parse(giturl).path.split('/');
    model.set('repo', gitpath[2].slice(0, -4));
    model.set('user', gitpath[1]);
  }

  if (!height) {
    model.set('height', size === 'large' ? '30' : '20');
  }

  model.set('show', true);
};
},{"url":55}],47:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],53:[function(require,module,exports){
var doc = document
  , elementProto = HTMLElement.prototype
  , nodeProto = Node.prototype

// Add support for Node.contains for Firefox < 9
if (!doc.contains) {
  nodeProto.contains = function(node) {
    return !!(this.compareDocumentPosition(node) & 16)
  }
}

// Add support for insertAdjacentHTML for Firefox < 8
// Based on insertAdjacentHTML.js by Eli Grey, http://eligrey.com
if (!doc.body.insertAdjacentHTML) {
  elementProto.insertAdjacentHTML = function(position, html) {
    var position = position.toLowerCase()
      , ref = this
      , parent = ref.parentNode
      , container = doc.createElement(parent.tagName)
      , firstChild, nextSibling, node

    container.innerHTML = html
    if (position === 'beforeend') {
      while (node = container.firstChild) {
        ref.appendChild(node)
      }
    } else if (position === 'beforebegin') {
      while (node = container.firstChild) {
        parent.insertBefore(node, ref)
      }
    } else if (position === 'afterend') {
      nextSibling = ref.nextSibling
      while (node = container.lastChild) {
        nextSibling = parent.insertBefore(node, nextSibling)
      }
    } else if (position === 'afterbegin') {
      firstChild = ref.firstChild
      while (node = container.lastChild) {
        firstChild = ref.insertBefore(node, firstChild)
      }
    }
  }
}

elementProto.matches =
  elementProto.webkitMatchesSelector ||
  elementProto.mozMatchesSelector ||
  elementProto.oMatchesSelector ||
  elementProto.msMatchesSelector

},{}],55:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http:http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":56}],29:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('../util');
var Model = require('./Model');

// This map determines which events get re-emitted as an 'all' event
Model.MUTATOR_EVENTS = {
  change: true
, insert: true
, remove: true
, move: true
, stringInsert: true
, stringRemove: true
, load: true
, unload: true
};

Model.INITS.push(function(model) {
  EventEmitter.call(this);

  // Set max listeners to unlimited
  model.setMaxListeners(0);

  // Used in async methods to emit an error event if a callback is not supplied.
  // This will throw if there is no handler for model.on('error')
  model.root._defaultCallback = defaultCallback;
  function defaultCallback(err) {
    if (typeof err === 'string') err = new Error(err);
    if (err) model.emit('error', err);
  }

  model.root._mutatorEventQueue = null;
  model._pass = new Passed({}, {});
});

util.mergeInto(Model.prototype, EventEmitter.prototype);

// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and
// EventEmitter.prototype.once return `this`. The Model equivalents return
// the listener instead, since it is made internally for method subscriptions
// and may need to be passed to removeListener.

Model.prototype._emit = EventEmitter.prototype.emit;
Model.prototype.emit = function(type) {
  if (Model.MUTATOR_EVENTS[type]) {
    if (this._silent) return this;
    var segments = arguments[1];
    var eventArgs = arguments[2];
    if (this.root._mutatorEventQueue) {
      this.root._mutatorEventQueue.push([type, segments, eventArgs]);
      return this;
    }
    this.root._mutatorEventQueue = [];
    this._emit(type, segments, eventArgs);
    this._emit('all', segments, [type].concat(eventArgs));
    while (this.root._mutatorEventQueue.length) {
      var queued = this.root._mutatorEventQueue.shift();
      type = queued[0];
      segments = queued[1];
      eventArgs = queued[2];
      this._emit(type, segments, eventArgs);
      this._emit('all', segments, [type].concat(eventArgs));
    }
    this.root._mutatorEventQueue = null;
    return this;
  }
  return this._emit.apply(this, arguments);
};

Model.prototype._on = EventEmitter.prototype.on;
Model.prototype.addListener =
Model.prototype.on = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  this._on(type, listener);
  return listener;
};

Model.prototype.once = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  function g() {
    var matches = listener.apply(null, arguments);
    if (matches) this.removeListener(type, g);
  }
  this._on(type, g);
  return g;
};

Model.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;
Model.prototype.removeAllListeners = function(type, subpattern) {
  if (!this._events) return this;

  // If a pattern is specified without an event type, remove all model event
  // listeners under that pattern for all events
  if (!type) {
    for (var key in this._events) {
      this.removeAllListeners(key, subpattern);
    }
    return this;
  }

  var pattern = this.path(subpattern);
  // If no pattern is specified, remove all listeners like normal
  if (!pattern) {
    if (arguments.length === 0) {
      return this._removeAllListeners();
    } else {
      return this._removeAllListeners(type);
    }
  }

  // Remove all listeners for an event under a pattern
  var listeners = this.listeners(type);
  var segments = pattern.split('.');
  // Make sure to iterate in reverse, since the array might be
  // mutated as listeners are removed
  for (var i = listeners.length; i--;) {
    var listener = listeners[i];
    if (patternContained(pattern, segments, listener)) {
      this.removeListener(type, listener);
    }
  }
};

function patternContained(pattern, segments, listener) {
  var listenerSegments = listener.patternSegments;
  if (!listenerSegments) return false;
  if (pattern === listener.pattern || pattern === '**') return true;
  var len = segments.length;
  if (len > listenerSegments.length) return false;
  for (var i = 0; i < len; i++) {
    if (segments[i] !== listenerSegments[i]) return false;
  }
  return true;
}

Model.prototype.pass = function(object, invert) {
  var model = this._child();
  model._pass = (invert) ?
    new Passed(object, this._pass) :
    new Passed(this._pass, object);
  return model;
};

function Passed(previous, value) {
  for (var key in previous) {
    this[key] = previous[key];
  }
  for (var key in value) {
    this[key] = value[key];
  }
}

/**
 * The returned Model will or won't trigger event handlers when the model emits
 * events, depending on `value`
 * @param {Boolean|Null} value defaults to true
 * @return {Model}
 */
Model.prototype.silent = function(value) {
  var model = this._child();
  model._silent = (value == null) ? true : value;
  return model;
};

function eventListener(model, subpattern, cb) {
  if (cb) {
    // For signatures:
    // model.on('change', 'example.subpath', callback)
    // model.at('example').on('change', 'subpath', callback)
    var pattern = model.path(subpattern);
    return modelEventListener(pattern, cb);
  }
  var path = model.path();
  cb = arguments[1];
  // For signature:
  // model.at('example').on('change', callback)
  if (path) return modelEventListener(path, cb);
  // For signature:
  // model.on('normalEvent', callback)
  return cb;
}

function modelEventListener(pattern, cb) {
  var patternSegments = pattern.split('.');
  var testFn = testPatternFn(pattern, patternSegments);

  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;
    cb.apply(null, args);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;

  return modelListener;
}

function testPatternFn(pattern, patternSegments) {
  if (pattern === '**') {
    return function testPattern(segments) {
      return [segments.join('.')];
    };
  }

  var endingRest = stripRestWildcard(patternSegments);

  return function testPattern(segments) {
    // Any pattern with more segments does not match
    var patternLen = patternSegments.length;
    if (patternLen > segments.length) return;

    // A pattern with the same number of segments matches if each
    // of the segments are wildcards or equal. A shorter pattern matches
    // if it ends in a rest wildcard and each of the corresponding
    // segments are wildcards or equal.
    if (patternLen === segments.length || endingRest) {
      var captures = [];
      for (var i = 0; i < patternLen; i++) {
        var patternSegment = patternSegments[i];
        var segment = segments[i];
        if (patternSegment === '*' || patternSegment === '**') {
          captures.push(segment);
          continue;
        }
        if (patternSegment !== segment) return;
      }
      if (endingRest) {
        var remainder = segments.slice(i).join('.');
        captures.push(remainder);
      }
      return captures;
    }
  };
}

function stripRestWildcard(segments) {
  // ['example', '**'] -> ['example']; return true
  var lastIndex = segments.length - 1;
  if (segments[lastIndex] === '**') {
    segments.pop();
    return true;
  }
  // ['example', 'subpath**'] -> ['example', 'subpath']; return true
  var match = /^([^\*]+)\*\*$/.exec(segments[lastIndex]);
  if (!match) return false;
  segments[lastIndex] = match[1];
  return true;
}

},{"events":9,"../util":10,"./Model":28}],30:[function(require,module,exports){
var Model = require('./Model');

exports.mixin = {};

Model.prototype._splitPath = function(subpath) {
  var path = this.path(subpath);
  return (path && path.split('.')) || [];
};

/**
 * Returns the path equivalent to the path of the current scoped model plus
 * (optionally) a suffix subpath
 *
 * @optional @param {String} subpath
 * @return {String} absolute path
 * @api public
 */
Model.prototype.path = function(subpath) {
  if (subpath == null || subpath === '') return (this._at) ? this._at : '';
  if (typeof subpath === 'string' || typeof subpath === 'number') {
    return (this._at) ? this._at + '.' + subpath : '' + subpath;
  }
  if (typeof subpath.path === 'function') return subpath.path();
};

Model.prototype.isPath = function(subpath) {
  return this.path(subpath) != null;
};

Model.prototype.scope = function(path) {
  var model = this._child();
  model._at = path;
  return model;
};

/**
 * Create a model object scoped to a particular path.
 * Example:
 *     var user = model.at('users.1');
 *     user.set('username', 'brian');
 *     user.on('push', 'todos', function (todo) {
 *       // ...
 *     });
 *
 *  @param {String} segment
 *  @return {Model} a scoped model
 *  @api public
 */
Model.prototype.at = function(subpath) {
  var path = this.path(subpath);
  return this.scope(path);
};

/**
 * Returns a model scope that is a number of levels above the current scoped
 * path. Number of levels defaults to 1, so this method called without
 * arguments returns the model scope's parent model scope.
 *
 * @optional @param {Number} levels
 * @return {Model} a scoped model
 */
Model.prototype.parent = function(levels) {
  if (levels == null) levels = 1;
  var segments = this._splitPath();
  var len = Math.max(0, segments.length - levels);
  var path = segments.slice(0, len).join('.');
  return this.scope(path);
};

/**
 * Returns the last property segment of the current model scope path
 *
 * @optional @param {String} path
 * @return {String}
 */
Model.prototype.leaf = function(path) {
  if (!path) path = this.path();
  var i = path.lastIndexOf('.');
  return path.slice(i + 1);
};

},{"./Model":28}],31:[function(require,module,exports){
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var util = require('../util');

function CollectionMap() {}
function ModelData() {}
function DocMap() {}
function CollectionData() {}

Model.INITS.push(function(model) {
  model.root.collections = new CollectionMap;
  model.root.data = new ModelData;
});

Model.prototype.getCollection = function(collectionName) {
  return this.root.collections[collectionName];
};
Model.prototype.getDoc = function(collectionName, id) {
  var collection = this.root.collections[collectionName];
  return collection && collection.docs[id];
};
Model.prototype.get = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._get(segments);
};
Model.prototype._get = function(segments) {
  return util.lookup(segments, this.root.data);
};
Model.prototype.getOrCreateCollection = function(name) {
  var collection = this.root.collections[name];
  if (collection) return collection;
  var Doc = this._getDocConstructor(name);
  collection = new Collection(this.root, name, Doc);
  this.root.collections[name] = collection;
  return collection;
};
Model.prototype._getDocConstructor = function() {
  // Only create local documents. This is overriden in ./connection.js, so that
  // the RemoteDoc behavior can be selectively included
  return LocalDoc;
};

/**
 * Returns an existing document with id in a collection. If the document does
 * not exist, then creates the document with id in a collection and returns the
 * new document.
 * @param {String} collectionName
 * @param {String} id
 * @param {Object} [data] data to create if doc with id does not exist in collection
 */
Model.prototype.getOrCreateDoc = function(collectionName, id, data) {
  var collection = this.getOrCreateCollection(collectionName);
  return collection.docs[id] || collection.add(id, data);
};

/**
 * @param {String} collectionName
 */
Model.prototype.destroy = function(collectionName) {
  // TODO: non-collections
  var collection = this.getCollection(collectionName);
  collection && collection.destroy();
  this.removeAllRefs(collectionName);
  this.stopAll(collectionName);
  this.removeAllFilters(collectionName);
  this.removeAllListeners(null, collectionName);
};

function Collection(model, name, Doc) {
  this.model = model;
  this.name = name;
  this.Doc = Doc;
  this.docs = new DocMap();
  this.data = model.data[name] = new CollectionData();
}

/**
 * Adds a document with `id` and `data` to `this` Collection.
 * @param {String} id
 * @param {Object} data
 * @return {LocalDoc|RemoteDoc} doc
 */
Collection.prototype.add = function(id, data) {
  var doc = new this.Doc(this.model, this.name, id, data);
  this.docs[id] = doc;
  return doc;
};
Collection.prototype.destroy = function() {
  delete this.model.collections[this.name];
  delete this.model.data[this.name];
};

/**
 * Removes the document with `id` from `this` Collection. If there are no more
 * documents in the Collection after the given document is removed, then this
 * also destroys the Collection.
 * @param {String} id
 */
Collection.prototype.remove = function(id) {
  delete this.docs[id];
  delete this.data[id];
  if (noKeys(this.docs)) this.destroy();
};

/**
 * Returns an object that maps doc ids to fully resolved documents.
 * @return {Object}
 */
Collection.prototype.get = function() {
  return this.data;
};

function noKeys(object) {
  for (var key in object) {
    return false;
  }
  return true;
}

},{"./Model":28,"./LocalDoc":57,"../util":10}],32:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.prototype._mutate = function(segments, fn, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var collectionName = segments[0];
  var id = segments[1];
  if (!collectionName || !id) {
    var message = fn.name + ' must be performed under a collection ' +
      'and document id. Invalid path: ' + segments.join('.');
    return cb(new Error(message));
  }
  var doc = this.getOrCreateDoc(collectionName, id);
  var docSegments = segments.slice(2);
  return fn(doc, docSegments, cb);
};

Model.prototype.set = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._set(segments, value, cb);
};
Model.prototype._set = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function set(doc, docSegments, fnCb) {
    var previous = doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, set, cb);
};

Model.prototype.setEach = function() {
  var subpath, object, cb;
  if (arguments.length === 1) {
    object = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    object = arguments[1];
  } else {
    subpath = arguments[0];
    object = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setEach(segments, object, cb);
};
Model.prototype._setEach = function(segments, object, cb) {
  segments = this._dereference(segments);
  var group = util.asyncGroup(cb || this.root._defaultCallback);
  for (var key in object) {
    var value = object[key];
    this._set(segments.concat(key), value, group());
  }
};

Model.prototype.add = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      value = arguments[0];
      cb = arguments[1];
    } else {
      subpath = arguments[0];
      value = arguments[1];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._add(segments, value, cb);
};
Model.prototype._add = function(segments, value, cb) {
  if (typeof value !== 'object') {
    var message = 'add requires an object value. Invalid value: ' + value;
    cb || (cb = this.root._defaultCallback);
    return cb(new Error(message));
  }
  var id = value.id || this.id();
  value.id = id;
  this._set(segments.concat(id), value, cb);
  return id;
};

Model.prototype.setNull = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setNull(segments, value, cb);
};
Model.prototype._setNull = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setNull(doc, docSegments, fnCb) {
    var previous = doc.get(docSegments);
    if (previous != null) {
      fnCb();
      return previous;
    }
    doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, setNull, cb);
};

Model.prototype.del = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._del(segments, cb);
};
Model.prototype._del = function(segments, cb) {
  segments = this._dereference(segments);
  var model = this;
  function del(doc, docSegments, fnCb) {
    var previous = doc.del(docSegments, fnCb);
    // When deleting an entire document, also remove the reference to the
    // document object from its collection
    if (segments.length === 2) {
      var collectionName = segments[0];
      var id = segments[1];
      model.root.collections[collectionName].remove(id);
    }
    model.emit('change', segments, [void 0, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, del, cb);
};

Model.prototype.increment = function() {
  var subpath, byNumber, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else if (typeof arguments[0] === 'number') {
      byNumber = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        byNumber = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      subpath = arguments[0];
      byNumber = arguments[1];
    }
  } else {
    subpath = arguments[0];
    byNumber = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._increment(segments, byNumber, cb);
};
Model.prototype._increment = function(segments, byNumber, cb) {
  segments = this._dereference(segments);
  if (byNumber == null) byNumber = 1;
  var model = this;
  function increment(doc, docSegments, fnCb) {
    var value = doc.increment(docSegments, byNumber, fnCb);
    var previous = value - byNumber;
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, increment, cb);
};

Model.prototype.push = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._push(segments, value, cb);
};
Model.prototype._push = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function push(doc, docSegments, fnCb) {
    var length = doc.push(docSegments, value, fnCb);
    model.emit('insert', segments, [length - 1, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, push, cb);
};

Model.prototype.unshift = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._unshift(segments, value, cb);
};
Model.prototype._unshift = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function unshift(doc, docSegments, fnCb) {
    var length = doc.unshift(docSegments, value, fnCb);
    model.emit('insert', segments, [0, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, unshift, cb);
};

Model.prototype.insert = function() {
  var subpath, index, values, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for insert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    values = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
  } else {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._insert(segments, +index, values, cb);
};
Model.prototype._insert = function(segments, index, values, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function insert(doc, docSegments, fnCb) {
    var inserted = (Array.isArray(values)) ? values : [values];
    var length = doc.insert(docSegments, index, inserted, fnCb);
    model.emit('insert', segments, [index, inserted, model._pass]);
    return length;
  }
  return this._mutate(segments, insert, cb);
};

Model.prototype.pop = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._pop(segments, cb);
};
Model.prototype._pop = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function pop(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.pop(docSegments, fnCb);
    model.emit('remove', segments, [length - 1, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, pop, cb);
};

Model.prototype.shift = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._shift(segments, cb);
};
Model.prototype._shift = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function shift(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.shift(docSegments, fnCb);
    model.emit('remove', segments, [0, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, shift, cb);
};

Model.prototype.remove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    index = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  if (index == null) index = segments.pop();
  return this._remove(segments, +index, howMany, cb);
};
Model.prototype._remove = function(segments, index, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function remove(doc, docSegments, fnCb) {
    var removed = doc.remove(docSegments, index, howMany, fnCb);
    model.emit('remove', segments, [index, removed, model._pass]);
    return removed;
  }
  return this._mutate(segments, remove, cb);
};

Model.prototype.move = function() {
  var subpath, from, to, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for move'));
  } else if (arguments.length === 2) {
    from = arguments[0];
    to = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      from = arguments[0];
      to = arguments[1];
      cb = arguments[2];
    } else if (typeof arguments[0] === 'number') {
      from = arguments[0];
      to = arguments[1];
      howMany = arguments[2];
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
    }
  } else if (arguments.length === 4) {
    if (typeof arguments[3] === 'function') {
      cb = arguments[3];
      if (typeof arguments[0] === 'number') {
        from = arguments[0];
        to = arguments[1];
        howMany = arguments[2];
      } else {
        subpath = arguments[0];
        from = arguments[1];
        to = arguments[2];
      }
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
      howMany = arguments[3];
    }
  } else {
    subpath = arguments[0];
    from = arguments[1];
    to = arguments[2];
    howMany = arguments[3];
    cb = arguments[4];
  }
  var segments = this._splitPath(subpath);
  return this._move(segments, from, to, howMany, cb);
};
Model.prototype._move = function(segments, from, to, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function move(doc, docSegments, fnCb) {
    // Cast to numbers
    from = +from;
    to = +to;
    // Convert negative indices into positive
    if (from < 0 || to < 0) {
      var len = doc.get(docSegments).length;
      if (from < 0) from += len;
      if (to < 0) to += len;
    }
    var moved = doc.move(docSegments, from, to, howMany, fnCb);
    model.emit('move', segments, [from, to, moved.length, model._pass]);
    return moved;
  }
  return this._mutate(segments, move, cb);
};

Model.prototype.stringInsert = function() {
  var subpath, index, text, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringInsert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    text = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      text = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      text = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    text = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringInsert(segments, index, text, cb);
};
Model.prototype._stringInsert = function(segments, index, text, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringInsert(doc, docSegments, fnCb) {
    var previous = doc.stringInsert(docSegments, index, text, fnCb);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringInsert'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringInsert, cb);
};

Model.prototype.stringRemove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringRemove'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    howMany = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      howMany = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringRemove(segments, index, howMany, cb);
};
Model.prototype._stringRemove = function(segments, index, howMany, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringRemove(doc, docSegments, fnCb) {
    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringRemove'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringRemove, cb);
};

},{"../util":10,"./Model":28}],35:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model, options) {
  model.root.fetchOnly = options.fetchOnly;
  model.root.unloadDelay = options.unloadDelay || 1000;

  // Keeps track of the count of fetches (that haven't been undone by an
  // unfetch) per doc. Maps doc id to the fetch count.
  model.root._fetchedDocs = new FetchedDocs;

  // Keeps track of the count of subscribes (that haven't been undone by an
  // unsubscribe) per doc. Maps doc id to the subscribe count.
  model.root._subscribedDocs = new SubscribedDocs;

  // Maps doc path to doc version
  model.root._loadVersions = new LoadVersions;
});

function FetchedDocs() {}
function SubscribedDocs() {}
function LoadVersions() {}

Model.prototype.fetch = function() {
  this._forSubscribable(arguments, 'fetch');
  return this;
};
Model.prototype.unfetch = function() {
  this._forSubscribable(arguments, 'unfetch');
  return this;
};
Model.prototype.subscribe = function() {
  this._forSubscribable(arguments, 'subscribe');
  return this;
};
Model.prototype.unsubscribe = function() {
  this._forSubscribable(arguments, 'unsubscribe');
  return this;
};

/**
 * @private
 * @param {Arguments} argumentsObject can take 1 of two forms
 *   1. [[subscribableObjects...], cb]
 *   2. [subscribableObjects..., cb]
 * @param {String} method can be 'fetch', 'unfetch', 'subscribe', 'unsubscribe'
 */
Model.prototype._forSubscribable = function(argumentsObject, method) {
  if (Array.isArray(argumentsObject[0])) {
    var args = argumentsObject[0];
    var cb = argumentsObject[1] || this.root._defaultCallback;
  } else {
    var args = Array.prototype.slice.call(argumentsObject);
    var last = args[args.length - 1];
    var cb = (typeof last === 'function') ? args.pop() : this.root._defaultCallback;
  }
  // If no queries or paths are passed in, try to use this model's scope
  if (!args.length) args.push(null);
  var group = util.asyncGroup(cb);
  var docMethod = method + 'Doc';

  var finished = group();
  for (var i = 0; i < args.length; i++) {
    var item = args[i];
    if (item instanceof Query) {
      item[method](group());
    } else {
      var segments = this._dereference(this._splitPath(item));
      if (segments.length === 2) {
        // Do the appropriate method for a single document.
        this[docMethod](segments[0], segments[1], group());
      } else if (segments.length === 1) {
        // Make a query to an entire collection.
        var query = this.query(segments[0], {});
        query[method](group());
      } else if (segments.length === 0) {
        cb(new Error('No path specified for ' + method));
      } else {
        cb(new Error('Cannot ' + method + ' to a path within a document: ' +
            segments.join('.')));
      }
    }
  }
  finished();
};

/**
 * @param {String}
 * @param {String} id
 * @param {Function} cb(err)
 * @param {Boolean} alreadyLoaded
 */
Model.prototype.fetchDoc = function(collectionName, id, cb, alreadyLoaded) {
  if (!cb) cb = this.root._defaultCallback;

  // Maintain a count of fetches so that we can unload the document when
  // there are no remaining fetches or subscribes for that document
  var path = collectionName + '.' + id;
  this.emit('fetchDoc', path, this._context, this._pass);
  this.root._fetchedDocs[path] = (this.root._fetchedDocs[path] || 0) + 1;

  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (alreadyLoaded) {
    process.nextTick(fetchDocCallback);
  } else {
    doc.shareDoc.fetch(fetchDocCallback);
  }
  function fetchDocCallback(err) {
    if (err) return cb(err);
    if (doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

/**
 * @param {String} collectionName
 * @param {String} id of the document we want to subscribe to
 * @param {Function} cb(err)
 */
Model.prototype.subscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;

  var path = collectionName + '.' + id;
  this.emit('subscribeDoc', path, this._context, this._pass);
  var count = this.root._subscribedDocs[path] = (this.root._subscribedDocs[path] || 0) + 1;
  // Already requested a subscribe, so just return
  if (count > 1) return cb();

  // Subscribe if currently unsubscribed
  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (this.root.fetchOnly) {
    // Only fetch if the document isn't already loaded
    if (doc.get() === void 0) {
      doc.shareDoc.fetch(subscribeDocCallback);
    } else {
      process.nextTick(subscribeDocCallback);
    }
  } else {
    doc.shareDoc.subscribe(subscribeDocCallback);
  }
  function subscribeDocCallback(err) {
    if (err) return cb(err);
    if (!doc.createdLocally && doc.shareDoc.version !== model.root._loadVersions[path]) {
      model.root._loadVersions[path] = doc.shareDoc.version;
      doc._updateCollectionData();
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

Model.prototype.unfetchDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unfetchDoc', path, this._context, this._pass);
  var fetchedDocs = this.root._fetchedDocs;

  // No effect if the document has no fetch count
  if (!fetchedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnfetchDoc, this.root.unloadDelay);
  } else {
    finishUnfetchDoc();
  }
  function finishUnfetchDoc() {
    var count = --fetchedDocs[path];
    if (count) return cb(null, count);
    delete fetchedDocs[path];
    model._maybeUnloadDoc(collectionName, id, path);
    cb(null, 0);
  }
};

Model.prototype.unsubscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this.root._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unsubscribeDoc', path, this._context, this._pass);
  var subscribedDocs = this.root._subscribedDocs;

  // No effect if the document is not currently subscribed
  if (!subscribedDocs[path]) return cb();

  var model = this;
  if (this.root.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnsubscribeDoc, this.root.unloadDelay);
  } else {
    finishUnsubscribeDoc();
  }
  function finishUnsubscribeDoc() {
    var count = --subscribedDocs[path];
    // If there are more remaining subscriptions, only decrement the count
    // and callback with how many subscriptions are remaining
    if (count) return cb(null, count);

    // If there is only one remaining subscription, actually unsubscribe
    delete subscribedDocs[path];
    if (model.root.fetchOnly) {
      unsubscribeDocCallback();
    } else {
      var shareDoc = model.root.shareConnection.get(collectionName, id);
      if (!shareDoc) {
        return cb(new Error('Share document not found for: ' + path));
      }
      shareDoc.unsubscribe(unsubscribeDocCallback);
    }
  }
  function unsubscribeDocCallback(err) {
    model._maybeUnloadDoc(collectionName, id, path);
    if (err) return cb(err);
    cb(null, 0);
  }
};

/**
 * Removes the document from the local model if the model no longer has any
 * remaining fetches or subscribes on path.
 * Called from Model.prototype.unfetchDoc and Model.prototype.unsubscribeDoc as
 * part of attempted cleanup.
 * @param {String} collectionName
 * @param {String} id
 * @param {String} path
 */
Model.prototype._maybeUnloadDoc = function(collectionName, id, path) {
  var doc = this.getDoc(collectionName, id);
  if (!doc) return;
  // Remove the document from the local model if it no longer has any
  // remaining fetches or subscribes
  if (this.root._fetchedDocs[path] || this.root._subscribedDocs[path]) return;
  var previous = doc.get();
  this.root.collections[collectionName].remove(id);
  if (doc.shareDoc) doc.shareDoc.destroy();
  delete this.root._loadVersions[path];
  this.emit('unload', [collectionName, id], [previous, this._pass]);
};

})(require("__browserify_process"))
},{"../util":10,"./Model":28,"./Query":36,"__browserify_process":8}],37:[function(require,module,exports){
/**
 * Contexts are useful for keeping track of the origin of subscribes.
 */

var Model = require('./Model');
var Query = require('./Query');

Model.INITS.push(function(model) {
  model.root._contexts = new Contexts;
  model.setContext('root');
  [ 'fetchDoc', 'subscribeDoc', 'unfetchDoc', 'unsubscribeDoc'
  , 'fetchQuery', 'subscribeQuery', 'unfetchQuery', 'unsubscribeQuery'
  ].forEach(function(event) {
    model.on(event, function(item, context, pass) {
      context[event](item, pass);
    });
  });
});

Model.prototype.context = function(id) {
  var model = this._child();
  model.setContext(id);
  return model;
};

Model.prototype.setContext = function(id) {
  var context = this.root._contexts[id] || new Context(this, id);
  this._context = this.root._contexts[id] = context;
  return context;
};

Model.prototype.unload = function(id) {
  var context = (id) ? this.root._contexts[id] : this._context;
  context.unload();
};

function Contexts() {}

function FetchedDocs() {}
function SubscribedDocs() {}
function FetchedQueries() {}
function SubscribedQueries() {}

function Context(model, id) {
  this.model = model;
  this.id = id;
  this.fetchedDocs = new FetchedDocs;
  this.subscribedDocs = new SubscribedDocs;
  this.fetchedQueries = new FetchedQueries;
  this.subscribedQueries = new SubscribedQueries;
}

Context.prototype.toJSON = function() {
  return {
    fetchedDocs: this.fetchedDocs
  , subscribedDocs: this.subscribedDocs
  , fetchedQueries: this.fetchedQueries
  , subscribedQueries: this.subscribedQueries
  };
};

Context.prototype.fetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.fetchedDocs, path);
};
Context.prototype.subscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.subscribedDocs, path);
};
Context.prototype.unfetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.fetchedDocs, path);
};
Context.prototype.unsubscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.subscribedDocs, path);
};
Context.prototype.fetchQuery = function(query) {
  mapIncrement(this.fetchedQueries, query.hash);
};
Context.prototype.subscribeQuery = function(query) {
  mapIncrement(this.subscribedQueries, query.hash);
};
Context.prototype.unfetchQuery = function(query) {
  mapDecrement(this.fetchedQueries, query.hash);
};
Context.prototype.unsubscribeQuery = function(query) {
  mapDecrement(this.subscribedQueries, query.hash);
};
function mapIncrement(map, key) {
  map[key] = (map[key] || 0) + 1;
}
function mapDecrement(map, key) {
  map[key] && map[key]--;
  if (!map[key]) delete map[key];
}

Context.prototype.unload = function() {
  var model = this.model;
  for (var hash in this.fetchedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.fetchedQueries[hash];
    while (count--) query.unfetch(null);
  }
  for (var hash in this.subscribedQueries) {
    var query = model.root._queries.map[hash];
    if (!query) continue;
    var count = this.subscribedQueries[hash];
    while (count--) query.unsubscribe(null);
  }
  for (var path in this.fetchedDocs) {
    var segments = path.split('.');
    var count = this.fetchedDocs[path];
    while (count--) model.unfetchDoc(segments[0], segments[1]);
  }
  for (var path in this.subscribedDocs) {
    var segments = path.split('.');
    var count = this.subscribedDocs[path];
    while (count--) model.unsubscribeDoc(segments[0], segments[1]);
  }
  model._context = model.root._contexts[this.id] = new Context(model, this.id);
};

},{"./Model":28,"./Query":36}],38:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

function NamedFns() {}

Model.INITS.push(function(model) {
  model.root._namedFns = new NamedFns();
  model.root._fns = new Fns(model);
  model.on('all', fnListener);
  function fnListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._fns.fromMap;
    for (var path in map) {
      var fn = map[path];
      if (pass.$fn === fn) continue;
      if (util.mayImpactAny(fn.inputsSegments, segments)) {
        // Mutation affecting input path
        fn.onInput(pass);
      } else if (util.mayImpact(fn.fromSegments, segments)) {
        // Mutation affecting output path
        fn.onOutput(pass);
      }
    }
  }
});

Model.prototype.fn = function(name, fns) {
  this.root._namedFns[name] = fns;
};

function parseStartArguments(model, args, hasPath) {
  if (typeof args[0] === 'function') {
    var fns = args[0];
  } else {
    var name = args[0];
  }
  if (hasPath) {
    var path = model.path(args[1]);
    var inputPaths = Array.prototype.slice.call(args, 2);
  } else {
    var inputPaths = Array.prototype.slice.call(args, 1);
  }
  var i = inputPaths.length - 1;
  if (model.isPath(inputPaths[i])) {
    inputPaths[i] = model.path(inputPaths[i]);
  } else {
    var options = inputPaths.pop();
  }
  while (i--) {
    inputPaths[i] = model.path(inputPaths[i]);
  }
  return {
    name: name
  , path: path
  , inputPaths: inputPaths
  , fns: fns
  , options: options
  };
}

Model.prototype.evaluate = function(name) {
  var args = parseStartArguments(this, arguments, false);
  return this.root._fns.get(args.name, args.inputPaths, args.fns, args.options);
};

Model.prototype.start = function(name, subpath) {
  var args = parseStartArguments(this, arguments, true);
  return this.root._fns.start(args.name, args.path, args.inputPaths, args.fns, args.options);
};

Model.prototype.stop = function(subpath) {
  var path = this.path(subpath);
  this.root._fns.stop(path);
};

Model.prototype.stopAll = function(subpath) {
  var segments = this._splitPath(subpath);
  var fns = this.root._fns.fromMap;
  for (var from in fns) {
    if (util.contains(segments, fns[from].fromSegments)) {
      this.stop(from);
    }
  }
};

function FromMap() {}
function Fns(model) {
  this.model = model;
  this.nameMap = model.root._namedFns;
  this.fromMap = new FromMap;
}

Fns.prototype.get = function(name, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, null, inputPaths, fns, options);
  return fn.get();
};

Fns.prototype.start = function(name, path, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name] || defaultFns[name]);
  var fn = new Fn(this.model, name, path, inputPaths, fns, options);
  this.fromMap[path] = fn;
  return fn.onInput();
};

Fns.prototype.stop = function(path) {
  var fn = this.fromMap[path];
  delete this.fromMap[path];
  return fn;
};

Fns.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var fn = this.fromMap[from];
    // Don't try to bundle non-named functions that were started via
    // model.start directly instead of by name
    if (!fn.name) continue;
    out.push([fn.name, fn.from].concat(fn.inputPaths));
  }
  return out;
};

function Fn(model, name, from, inputPaths, fns, options) {
  this.model = model.pass({$fn: this});
  this.name = name;
  this.from = from;
  this.inputPaths = inputPaths;
  if (!fns) {
    var err = new TypeError('Model function not found: ' + name);
    model.emit('error', err);
  }
  this.getFn = fns.get || fns;
  this.setFn = fns.set;
  this.fromSegments = from && from.split('.');
  this.inputsSegments = [];
  for (var i = 0; i < this.inputPaths.length; i++) {
    var segments = this.inputPaths[i].split('.');
    this.inputsSegments.push(segments);
  }
  var copy = (options && options.copy) || 'output';
  this.copyInput = (copy === 'input' || copy === 'both');
  this.copyOutput = (copy === 'output' || copy === 'both');
}

Fn.prototype.apply = function(fn, inputs) {
  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {
    var input = this.model._get(this.inputsSegments[i]);
    inputs.push(this.copyInput ? util.deepCopy(input) : input);
  }
  return fn.apply(this.model, inputs);
};

Fn.prototype.get = function() {
  return this.apply(this.getFn, []);
};

var diffOptions = {equal: util.deepEqual};
var eachDiffOptions = {each: true, equal: util.deepEqual};

Fn.prototype.set = function(value, pass) {
  if (!this.setFn) return;
  var out = this.apply(this.setFn, [value]);
  if (!out) return;
  var inputsSegments = this.inputsSegments;
  var model = this.model.pass(pass, true);
  for (var key in out) {
    if (key === 'each') {
      var each = out[key];
      for (key in each) {
        var value = (this.copyOutput) ? util.deepCopy(each[key]) : each[key];
        model._setDiff(inputsSegments[key], value, eachDiffOptions);
      }
      continue;
    }
    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];
    model._setDiff(inputsSegments[key], value, diffOptions);
  }
};

Fn.prototype.onInput = function(pass) {
  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();
  this.model.pass(pass, true)._setDiff(this.fromSegments, value, diffOptions);
  return value;
};

Fn.prototype.onOutput = function(pass) {
  var value = this.model._get(this.fromSegments);
  return this.set(value, pass);
};

},{"../util":10,"./Model":28,"./defaultFns":58}],39:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var defaultFns = require('./defaultFns');

Model.INITS.push(function(model) {
  model.root._filters = new Filters(model);
  model.on('all', filterListener);
  function filterListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model.root._filters.fromMap;
    for (var path in map) {
      var filter = map[path];
      if (pass.$filter === filter) continue;
      if (util.mayImpact(filter.inputSegments, segments)) {
        filter.update(pass);
      }
    }
  }
});

Model.prototype.filter = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, fn);
};

Model.prototype.sort = function(input, fn) {
  var inputPath = this.path(input);
  return this.root._filters.add(inputPath, null, fn || 'asc');
};

Model.prototype.removeAllFilters = function(subpath) {
  var segments = this._splitPath(subpath);
  var filters = this.root._filters.fromMap;
  for (var from in filters) {
    if (util.contains(segments, filters[from].fromSegments)) {
      filters[from].destroy();
    }
  }
};

function FromMap() {}
function Filters(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

Filters.prototype.add = function(inputPath, filterFn, sortFn) {
  return new Filter(this, inputPath, filterFn, sortFn);
};

Filters.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var filter = this.fromMap[from];
    // Don't try to bundle if functions were passed directly instead of by name
    if (!filter.bundle) continue;
    out.push([filter.inputPath, filter.filterName, filter.sortName, from]);
  }
  return out;
};

function Filter(filters, inputPath, filterFn, sortFn) {
  this.filters = filters;
  this.model = filters.model.pass({$filter: this});
  this.inputPath = inputPath;
  this.inputSegments = inputPath.split('.');
  this.filterName = null;
  this.sortName = null;
  this.bundle = true;
  this.filterFn = null;
  this.sortFn = null;
  if (filterFn) this.filter(filterFn);
  if (sortFn) this.sort(sortFn);
  this.idsSegments = null;
  this.from = null;
  this.fromSegments = null;
}

Filter.prototype.filter = function(fn) {
  if (typeof fn === 'function') {
    this.filterFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.filterName = fn;
    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.filterFn) {
      var err = new TypeError('Filter function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.sort = function(fn) {
  if (!fn) fn = 'asc';
  if (typeof fn === 'function') {
    this.sortFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.sortName = fn;
    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];
    if (!this.sortFn) {
      var err = new TypeError('Sort function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.ids = function() {
  var items = this.model._get(this.inputSegments);
  var ids = [];
  if (!items) return ids;
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          ids.push(i);
        }
      }
    } else {
      for (var i = 0; i < items.length; i++) ids.push(i);
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          ids.push(key);
        }
      }
    } else {
      ids = Object.keys(items);
    }
  }
  var sortFn = this.sortFn;
  if (sortFn) {
    ids.sort(function(a, b) {
      return sortFn(items[a], items[b]);
    });
  }
  return ids;
};

Filter.prototype.get = function() {
  var items = this.model._get(this.inputSegments);
  var results = [];
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          results.push(items[i]);
        }
      }
    } else {
      results = items.slice();
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          results.push(items[key]);
        }
      }
    } else {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          results.push(items[key]);
        }
      }
    }
  }
  if (this.sortFn) results.sort(this.sortFn);
  return results;
};

Filter.prototype.update = function(pass) {
  var ids = this.ids();
  this.model.pass(pass, true)._setDiff(this.idsSegments, ids);
};

Filter.prototype.ref = function(from) {
  from = this.model.path(from);
  this.from = from;
  this.fromSegments = from.split('.');
  this.filters.fromMap[from] = this;
  this.idsSegments = ['$filters', from.replace(/\./g, '|')];
  this.update();
  return this.model.refList(from, this.inputPath, this.idsSegments.join('.'));
};

Filter.prototype.destroy = function() {
  delete this.filters.fromMap[this.from];
  this.model.removeRefList(this.from);
  this.model._del(this.idsSegments);
};

},{"../util":10,"./Model":28,"./defaultFns":58}],40:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refLists = new RefLists(root);
  for (var type in Model.MUTATOR_EVENTS) {
    addListener(root, type);
  }
});

function addListener(model, type) {
  model.on(type, refListListener);
  function refListListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Check for updates on or underneath paths
    var fromMap = model._refLists.fromMap;
    for (var from in fromMap) {
      var refList = fromMap[from];
      if (pass.$refList === refList) continue;
      refList.onMutation(type, segments, eventArgs);
    }
  }
}

/**
 * @param {String} type
 * @param {Array} segments
 * @param {Array} eventArgs
 * @param {RefList} refList
 */
function patchFromEvent(type, segments, eventArgs, refList) {
  var fromLength = refList.fromSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `from` output itself
  if (segmentsLength === fromLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var values = eventArgs[1];
      var ids = setNewToValues(model, refList, values);
      model._insert(refList.idsSegments, index, ids);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      var ids = model._remove(refList.idsSegments, index, howMany);
      // Delete the appropriate items underneath `to` if the `deleteRemoved`
      // option was set true
      if (refList.deleteRemoved) {
        for (var i = 0; i < ids.length; i++) {
          var item = refList.itemById(ids[i]);
          model._del(refList.toSegmentsByItem(item));
        }
      }
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.idsSegments, from, to, howMany);
      return;
    }

    // Change of the entire output
    var values = (type === 'change') ?
      eventArgs[0] : model._get(refList.fromSegments);
    // Set ids to empty list if output is set to null
    if (!values) {
      model._set(refList.idsSegments, []);
      return;
    }
    // If the entire output is set, create a list of ids based on the output,
    // and update the corresponding items
    var ids = setNewToValues(model, refList, values);
    model._set(refList.idsSegments, ids);
    return;
  }

  // If mutation is on a parent of `from`, we might need to re-create the
  // entire refList output
  if (segmentsLength < fromLength) {
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  var index = segments[fromLength];
  var value = model._get(refList.fromSegments.concat(index));
  var toSegments = refList.toSegmentsByItem(value);

  // Mutation underneath a child of the `from` object.
  if (segmentsLength > fromLength + 1) {
    var message = 'Mutation on descendant of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }

  // Otherwise, mutation of a child of the `from` object

  // If changing the item itself, it will also have to be re-set on the
  // original object
  if (type === 'change') {
    model._set(toSegments, value);
    updateIdForValue(model, refList, index, value);
    return;
  }
  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var stringValue = eventArgs[1];
    model._stringInsert(toSegments, stringIndex, stringValue);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    model._stringRemove(toSegments, stringIndex, howMany);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    var message = 'Array mutation on child of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }
}

/**
 * @private
 * @param {Model} model
 * @param {RefList} refList
 * @param {Array} values
 */
function setNewToValues(model, refList, values, fn) {
  var ids = [];
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var id = refList.idByItem(value);
    if (id === void 0 && typeof value === 'object') {
      id = value.id = model.id();
    }
    var toSegments = refList.toSegmentsByItem(value);
    if (id === void 0 || toSegments === void 0) {
      var message = 'Unable to add item to refList: ' + value;
      return model.emit('error', new Error(message));
    }
    if (model._get(toSegments) !== value) {
      model._set(toSegments, value);
    }
    ids.push(id);
  }
  return ids;
}
function updateIdForValue(model, refList, index, value) {
  var id = refList.idByItem(value);
  var outSegments = refList.idsSegments.concat(index);
  model._set(outSegments, id);
}

function patchToEvent(type, segments, eventArgs, refList) {
  var toLength = refList.toSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `to` object itself
  if (segmentsLength === toLength) {
    if (type === 'insert') {
      var insertIndex = eventArgs[0];
      var values = eventArgs[1];
      for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var indices = refList.indicesByItem(value);
        if (!indices) continue;
        for (var j = 0; j < indices.length; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, value);
        }
      }
      return;
    }

    if (type === 'remove') {
      var removeIndex = eventArgs[0];
      var values = eventArgs[1];
      var howMany = values.length;
      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {
        var indices = refList.indicesByItem(values[i]);
        if (!indices) continue;
        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, void 0);
        }
      }
      return;
    }

    if (type === 'move') {
      // Moving items in the `to` object should have no effect on the output
      return;
    }
  }

  // Mutation on or above the `to` object
  if (segmentsLength <= toLength) {
    // If the entire `to` object is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Mutation underneath a child of the `to` object. The item will already
  // be up to date, since it is under an object reference. Just re-emit
  if (segmentsLength > toLength + 1) {
    var value = model._get(segments.slice(0, toLength + 1));
    var indices = refList.indicesByItem(value);
    if (!indices) return;
    var remaining = segments.slice(toLength + 1);
    for (var i = 0; i < indices.length; i++) {
      var index = indices[i];
      var dereferenced = refList.fromSegments.concat(index, remaining);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
    return;
  }

  // Otherwise, mutation of a child of the `to` object

  // If changing the item itself, it will also have to be re-set on the
  // array created by the refList
  if (type === 'change' || type === 'load' || type === 'unload') {
    var value, previous;
    if (type === 'change') {
      value = eventArgs[0];
      previous = eventArgs[1];
    } else if (type === 'load') {
      value = eventArgs[0];
      previous = void 0;
    } else if (type === 'unload') {
      value = void 0;
      previous = eventArgs[0];
    }
    var newIndices = refList.indicesByItem(value);
    var oldIndices = refList.indicesByItem(previous);
    if (!newIndices && !oldIndices) return;
    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {
      // The changed item used to refer to some indices, but no longer does
      for (var i = 0; i < oldIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(oldIndices[i]);
        model._set(outSegments, void 0);
      }
    }
    if (newIndices) {
      for (var i = 0; i < newIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(newIndices[i]);
        model._set(outSegments, value);
      }
    }
    return;
  }

  var value = model._get(segments.slice(0, toLength + 1));
  var indices = refList.indicesByItem(value);
  if (!indices) return;

  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var value = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringInsert(outSegments, stringIndex, value);
    }
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringRemove(outSegments, stringIndex, howMany);
    }
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    // Array mutations will have already been updated via an object
    // reference, so only re-emit
    for (var i = 0; i < indices.length; i++) {
      var dereferenced = refList.fromSegments.concat(indices[i]);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
  }
}
function equivalentArrays(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function patchIdsEvent(type, segments, eventArgs, refList) {
  var idsLength = refList.idsSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // An array mutation of the ids should be mirrored with a like change in
  // the output array
  if (segmentsLength === idsLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var inserted = eventArgs[1];
      var values = [];
      for (var i = 0; i < inserted.length; i++) {
        var value = refList.itemById(inserted[i]);
        values.push(value);
      }
      model._insert(refList.fromSegments, index, values);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      model._remove(refList.fromSegments, index, howMany);
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.fromSegments, from, to, howMany);
      return;
    }
  }

  // Mutation on the `ids` list itself
  if (segmentsLength <= idsLength) {
    // If the entire `ids` array is updated, we need to re-create the
    // entire refList output and apply what is different
    model._setArrayDiff(refList.fromSegments, refList.get());
    return;
  }

  // Otherwise, direct mutation of a child in the `ids` object or mutation
  // underneath an item in the `ids` list. Update the item for the appropriate
  // id if it has changed
  var index = segments[idsLength];
  var id = refList.idByIndex(index);
  var item = refList.itemById(id);
  var itemSegments = refList.fromSegments.concat(index);
  if (model._get(itemSegments) !== item) {
    model._set(itemSegments, item);
  }
}

Model.prototype.refList = function() {
  var from, to, ids, options;
  if (arguments.length === 2) {
    to = arguments[0];
    ids = arguments[1];
  } else if (arguments.length === 3) {
    if (this.isPath(arguments[2])) {
      from = arguments[0];
      to = arguments[1];
      ids = arguments[2];
    } else {
      to = arguments[0];
      ids = arguments[1];
      options = arguments[2];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    ids = arguments[2];
    options = arguments[3];
  }
  var fromPath = this.path(from);
  if (Array.isArray(to)) {
    var toPath = [];
    for (var i = 0; i < to.length; i++) {
      toPath.push(this.path(to[i]));
    }
  } else {
    var toPath = this.path(to);
  }
  var idsPath = this.path(ids);
  var refList = this.root._refLists.add(fromPath, toPath, idsPath, options);
  this.pass({$refList: refList})._setArrayDiff(refList.fromSegments, refList.get());
  return this.scope(fromPath);
};

Model.prototype.removeRefList = function(from) {
  var fromPath = this.path(from);
  var refList = this.root._refLists.remove(fromPath);
  if (refList) this._del(refList.fromSegments);
};

function RefList(model, from, to, ids, options) {
  this.model = model && model.pass({$refList: this});
  this.from = from;
  this.to = to;
  this.ids = ids;
  this.fromSegments = from && from.split('.');
  this.toSegments = to && to.split('.');
  this.idsSegments = ids && ids.split('.');
  this.options = options;
  this.deleteRemoved = options && options.deleteRemoved;
}

// The default implementation assumes that the ids array is a flat list of
// keys on the to object. Ideally, this mapping could be customized via
// inheriting from RefList and overriding these methods without having to
// modify the above event handling code.
// 
// In the default refList implementation, `key` and `id` are equal.
// 
// Terms in the below methods:
//   `item`  - Object on the `to` path, which gets mirrored on the `from` path
//   `key`   - The property under `to` at which an item is located
//   `id`    - String or object in the array at the `ids` path
//   `index` - The index of an id, which corresponds to an index on `from`
RefList.prototype.get = function() {
  var ids = this.model._get(this.idsSegments);
  if (!ids) return [];
  var items = this.model._get(this.toSegments);
  var out = [];
  for (var i = 0; i < ids.length; i++) {
    var key = ids[i];
    out.push(items && items[key]);
  }
  return out;
};
RefList.prototype.dereference = function(segments, i) {
  var remaining = segments.slice(i + 1);
  var key = this.idByIndex(remaining[0]);
  if (key == null) return [];
  remaining[0] = key;
  return this.toSegments.concat(remaining);
};
RefList.prototype.toSegmentsByItem = function(item) {
  var key = this.idByItem(item);
  if (key === void 0) return;
  return this.toSegments.concat(key);
};
RefList.prototype.idByItem = function(item) {
  if (item && item.id) return item.id;
  var items = this.model._get(this.toSegments);
  for (var key in items) {
    if (item === items[key]) return key;
  }
};
RefList.prototype.indicesByItem = function(item) {
  var id = this.idByItem(item);
  var ids = this.model._get(this.idsSegments);
  if (!ids) return;
  var indices;
  var index = -1;
  while (true) {
    index = ids.indexOf(id, index + 1);
    if (index === -1) break;
    if (indices) {
      indices.push(index);
    } else {
      indices = [index];
    }
  }
  return indices;
};
RefList.prototype.itemById = function(id) {
  return this.model._get(this.toSegments.concat(id));
};
RefList.prototype.idByIndex = function(index) {
  return this.model._get(this.idsSegments.concat(index));
};
RefList.prototype.onMutation = function(type, segments, eventArgs) {
  if (util.mayImpact(this.toSegments, segments)) {
    patchToEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.idsSegments, segments)) {
    patchIdsEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.fromSegments, segments)) {
    patchFromEvent(type, segments, eventArgs, this);
  }
};

function FromMap() {}

function RefLists(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

RefLists.prototype.add = function(from, to, ids, options) {
  var refList = new RefList(this.model, from, to, ids, options);
  this.fromMap[from] = refList;
  return refList;
};

RefLists.prototype.remove = function(from) {
  var refList = this.fromMap[from];
  delete this.fromMap[from];
  return refList;
};

RefLists.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var refList = this.fromMap[from];
    out.push([refList.from, refList.to, refList.ids, refList.options]);
  }
  return out;
};

},{"../util":10,"./Model":28}],41:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');

Model.INITS.push(function(model) {
  var root = model.root;
  root._refs = new Refs(root);
  addIndexListeners(root);
  addListener(root, 'change', refChange);
  addListener(root, 'load', refLoad);
  addListener(root, 'unload', refUnload);
  addListener(root, 'insert', refInsert);
  addListener(root, 'remove', refRemove);
  addListener(root, 'move', refMove);
  addListener(root, 'stringInsert', refStringInsert);
  addListener(root, 'stringRemove', refStringRemove);
});

function addIndexListeners(model) {
  model.on('insert', function refInsertIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchInsert(refIndex) {
      return (index <= refIndex) ? refIndex + howMany : refIndex;
    }
    onIndexChange(segments, patchInsert);
  });
  model.on('remove', function refRemoveIndex(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchRemove(refIndex) {
      return (index <= refIndex) ? refIndex - howMany : refIndex;
    }
    onIndexChange(segments, patchRemove);
  });
  model.on('move', function refMoveIndex(segments, eventArgs) {
    var from = eventArgs[0];
    var to = eventArgs[1];
    var howMany = eventArgs[2];
    function patchMove(refIndex) {
      // If the index was moved itself
      if (from <= refIndex && refIndex < from + howMany) {
        return refIndex + to - from;
      }
      // Remove part of a move
      if (from <= refIndex) refIndex -= howMany;
      // Insert part of a move
      if (to <= refIndex) refIndex += howMany;
      return refIndex;
    }
    onIndexChange(segments, patchMove);
  });
  function onIndexChange(segments, patch) {
    var fromMap = model._refs.fromMap;
    for (var from in fromMap) {
      var ref = fromMap[from];
      if (!(ref.updateIndices &&
        util.contains(segments, ref.toSegments) &&
        ref.toSegments.length > segments.length)) continue;
      var index = +ref.toSegments[segments.length];
      var patched = patch(index);
      if (index === patched) continue;
      model._refs.remove(from);
      ref.toSegments[segments.length] = '' + patched;
      ref.to = ref.toSegments.join('.');
      model._refs._add(ref);
    }
  }
}

function refChange(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refLoad(model, dereferenced, eventArgs) {
  var value = eventArgs[0];
  model._set(dereferenced, value);
}
function refUnload(model, dereferenced, eventArgs) {
  model._del(dereferenced);
}
function refInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var values = eventArgs[1];
  model._insert(dereferenced, index, values);
}
function refRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1].length;
  model._remove(dereferenced, index, howMany);
}
function refMove(model, dereferenced, eventArgs) {
  var from = eventArgs[0];
  var to = eventArgs[1];
  var howMany = eventArgs[2];
  model._move(dereferenced, from, to, howMany);
}
function refStringInsert(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var text = eventArgs[1];
  model._stringInsert(dereferenced, index, text);
}
function refStringRemove(model, dereferenced, eventArgs) {
  var index = eventArgs[0];
  var howMany = eventArgs[1];
  model._stringRemove(dereferenced, index, howMany);
}

function addListener(model, type, fn) {
  model.on(type, refListener);
  function refListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Find cases where an event is emitted on a path where a reference
    // is pointing. All original mutations happen on the fully dereferenced
    // location, so this detection only needs to happen in one direction
    var toMap = model._refs.toMap;
    for (var i = 0, len = segments.length; i < len; i++) {
      var subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];
      // If a ref is found pointing to a matching subpath, re-emit on the
      // place where the reference is coming from as if the mutation also
      // occured at that path
      var refs = toMap[subpath];
      if (!refs) continue;
      var remaining = segments.slice(i + 1);
      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
        var ref = refs[refIndex];
        var dereferenced = ref.fromSegments.concat(remaining);
        // The value may already be up to date via object reference. If so,
        // simply re-emit the event. Otherwise, perform the same mutation on
        // the ref's path
        if (pass.$original || model._get(dereferenced) === model._get(segments)) {
          model.emit(type, dereferenced, eventArgs);
        } else {
          var setterModel = ref.model.pass(pass, true);
          setterModel._dereference = noopDereference;
          fn(setterModel, dereferenced, eventArgs);
        }
      }
    }
    // If a ref points to a child of a matching subpath, get the value in
    // case it has changed and set if different
    var parentToMap = model._refs.parentToMap;
    var refs = parentToMap[subpath];
    if (!refs) return;
    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
      var ref = refs[refIndex];
      var value = model._get(ref.toSegments);
      var previous = model._get(ref.fromSegments);
      if (previous !== value) {
        var setterModel = ref.model.pass(pass, true);
        setterModel._dereference = noopDereference;
        setterModel._set(ref.fromSegments, value);
      }
    }
  }
}

Model.prototype.ref = function() {
  var from, to, options;
  if (arguments.length === 1) {
    to = arguments[0];
  } else if (arguments.length === 2) {
    if (this.isPath(arguments[1])) {
      from = arguments[0];
      to = arguments[1];
    } else {
      to = arguments[0];
      options = arguments[1];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    options = arguments[2];
  }
  var fromPath = this.path(from);
  var toPath = this.path(to);
  var fromSegments = fromPath.split('.');
  if (fromSegments.length < 2) {
    var message = 'ref must be performed under a collection ' +
      'and document id. Invalid path: ' + fromPath;
    this.emit('error', new Error(message));
  }
  this.root._refs.remove(fromPath);
  var value = this.get(to);
  this._set(fromSegments, value);
  this.root._refs.add(fromPath, toPath, options);
  return this.scope(fromPath);
};

Model.prototype.removeRef = function(from) {
  var fromPath = this.path(from);
  this.root._refs.remove(fromPath);
  this.del(from);
};

Model.prototype.removeAllRefs = function(subpath) {
  var segments = this._splitPath(subpath);
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  for (var from in refs) {
    if (util.contains(segments, refs[from].fromSegments)) {
      this.removeRef(from);
    }
  }
  for (var from in refLists) {
    if (util.contains(segments, refLists[from].fromSegments)) {
      this.removeRefList(from);
    }
  }
};

Model.prototype.dereference = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._dereference(segments).join('.');
};

Model.prototype._dereference = function(segments, forArrayMutator, ignore) {
  if (segments.length === 0) return segments;
  var refs = this.root._refs.fromMap;
  var refLists = this.root._refLists.fromMap;
  do {
    var subpath = '';
    var doAgain = false;
    for (var i = 0, len = segments.length; i < len; i++) {
      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];

      var ref = refs[subpath];
      if (ref) {
        var remaining = segments.slice(i + 1);
        segments = ref.toSegments.concat(remaining);
        doAgain = true;
        break;
      }

      var refList = refLists[subpath];
      if (refList && refList !== ignore) {
        var belowDescendant = i + 2 < len;
        var belowChild = i + 1 < len;
        if (!(belowDescendant || forArrayMutator && belowChild)) continue;
        segments = refList.dereference(segments, i);
        doAgain = true;
        break;
      }
    }
  } while (doAgain);
  // If a dereference fails, return a path that will result in a null value
  // instead of a path to everything in the model
  if (segments.length === 0) return ['$null'];
  return segments;
};

function noopDereference(segments) {
  return segments;
}

function Ref(model, from, to, options) {
  this.model = model && model.pass({$ref: this});
  this.from = from;
  this.to = to;
  this.fromSegments = from.split('.');
  this.toSegments = to.split('.');
  this.parentTos = [];
  for (var i = 1, len = this.toSegments.length; i < len; i++) {
    var parentTo = this.toSegments.slice(0, i).join('.');
    this.parentTos.push(parentTo);
  }
  this.updateIndices = options && options.updateIndices;
}
function FromMap() {}
function ToMap() {}

function Refs(model) {
  this.model = model;
  this.fromMap = new FromMap;
  this.toMap = new ToMap;
  this.parentToMap = new ToMap;
}

Refs.prototype.add = function(from, to, options) {
  var ref = new Ref(this.model, from, to, options);
  return this._add(ref);
};

Refs.prototype._add = function(ref) {
  this.fromMap[ref.from] = ref;
  listMapAdd(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapAdd(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.remove = function(from) {
  var ref = this.fromMap[from];
  if (!ref) return;
  delete this.fromMap[from];
  listMapRemove(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapRemove(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var ref = this.fromMap[from];
    out.push([ref.from, ref.to]);
  }
  return out;
};

function listMapAdd(map, name, item) {
  map[name] || (map[name] = []);
  map[name].push(item);
}

function listMapRemove(map, name, item) {
  var items = map[name];
  if (!items) return;
  var index = items.indexOf(item);
  if (index === -1) return;
  items.splice(index, 1);
  if (!items.length) delete map[name];
}

},{"../util":10,"./Model":28}],56:[function(require,module,exports){
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    };

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}


/*!
 * querystring
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Library version.
 */

exports.version = '0.3.1';

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Cache non-integer test regexp.
 */

var notint = /[^0-9]/;

/**
 * Parse the given query `str`, returning an object.
 *
 * @param {String} str
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};

  function promote(parent, key) {
    if (parent[key].length == 0) return parent[key] = {};
    var t = {};
    for (var i in parent[key]) t[i] = parent[key][i];
    parent[key] = t;
    return t;
  }

  return String(str)
    .split('&')
    .reduce(function(ret, pair){
      try{ 
        pair = decodeURIComponent(pair.replace(/\+/g, ' '));
      } catch(e) {
        // ignore
      }

      var eql = pair.indexOf('=')
        , brace = lastBraceInKey(pair)
        , key = pair.substr(0, brace || eql)
        , val = pair.substr(brace || eql, pair.length)
        , val = val.substr(val.indexOf('=') + 1, val.length)
        , parent = ret;

      // ?foo
      if ('' == key) key = pair, val = '';

      // nested
      if (~key.indexOf(']')) {
        var parts = key.split('[')
          , len = parts.length
          , last = len - 1;

        function parse(parts, parent, key) {
          var part = parts.shift();

          // end
          if (!part) {
            if (isArray(parent[key])) {
              parent[key].push(val);
            } else if ('object' == typeof parent[key]) {
              parent[key] = val;
            } else if ('undefined' == typeof parent[key]) {
              parent[key] = val;
            } else {
              parent[key] = [parent[key], val];
            }
          // array
          } else {
            obj = parent[key] = parent[key] || [];
            if (']' == part) {
              if (isArray(obj)) {
                if ('' != val) obj.push(val);
              } else if ('object' == typeof obj) {
                obj[objectKeys(obj).length] = val;
              } else {
                obj = parent[key] = [parent[key], val];
              }
            // prop
            } else if (~part.indexOf(']')) {
              part = part.substr(0, part.length - 1);
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            // key
            } else {
              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);
              parse(parts, obj, part);
            }
          }
        }

        parse(parts, parent, 'base');
      // optimize
      } else {
        if (notint.test(key) && isArray(parent.base)) {
          var t = {};
          for(var k in parent.base) t[k] = parent.base[k];
          parent.base = t;
        }
        set(parent.base, key, val);
      }

      return ret;
    }, {base: {}}).base;
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix;
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[]'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;
  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    ret.push(stringify(obj[key], prefix
      ? prefix + '[' + encodeURIComponent(key) + ']'
      : encodeURIComponent(key)));
  }
  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

},{}],58:[function(require,module,exports){
var defaultFns = module.exports = new DefaultFns;

defaultFns.reverse = new FnPair(getReverse, setReverse);
defaultFns.asc = asc;
defaultFns.desc = desc;

function DefaultFns() {}
function FnPair(get, set) {
  this.get = get;
  this.set = set;
}

function getReverse(array) {
  return array && array.slice().reverse();
}
function setReverse(values) {
  return {0: getReverse(values)};
}

function asc(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
function desc(a, b) {
  if (a > b) return -1;
  if (a < b) return 1;
  return 0;
}

},{}],44:[function(require,module,exports){
module.exports = function (app) {
  require('./reactiveFns')(app);
  require('./viewFns')(app);
};
},{"./reactiveFns":59,"./viewFns":60}],19:[function(require,module,exports){
(function(global){var htmlUtil = require('html-util')
var md5 = require('MD5')
var parseHtml = htmlUtil.parse
var trimText = htmlUtil.trimText
var unescapeEntities = htmlUtil.unescapeEntities
var escapeHtml = htmlUtil.escapeHtml
var escapeAttribute = htmlUtil.escapeAttribute
var isVoid = htmlUtil.isVoid
var conditionalComment = htmlUtil.conditionalComment
var markup = require('./markup')
var viewPath = require('./viewPath')
var wrapRemainder = viewPath.wrapRemainder
var ctxPath = viewPath.ctxPath
var extractPlaceholder = viewPath.extractPlaceholder
var dataValue = viewPath.dataValue
var pathFnArgs = viewPath.pathFnArgs
var isBound = viewPath.isBound
var eventBinding = require('./eventBinding')
var splitEvents = eventBinding.splitEvents
var fnListener = eventBinding.fnListener
var derby = require('./derby')

module.exports = View;

function empty() {
  return '';
}

var defaultCtx = {
  $aliases: {}
, $paths: []
, $indices: []
};

var CAMEL_REGEXP = /([a-z])([A-Z])/g;

var defaultGetFns = {
  equal: function getEqual(a, b) {
    return a === b;
  }
, not: function getNot(value) {
    return !value;
  }
, or: function getOr() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (arg) return arg;
    };
    return arg;
  }
, and: function getAnd() {
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      if (!arg) return arg;
    };
    return arg;
  }
, gt: function getGt(a, b) {
    return a > b;
  }
, lt: function getLt(a, b) {
    return a < b;
  }
, gte: function getGte(a, b) {
    return a >= b;
  }
, lte: function getLte(a, b) {
    return a <= b;
  }
, dash: function getDash(value) {
    return value && value
      .replace(/[:_\s]/g, '-')
      .replace(CAMEL_REGEXP, '$1-$2')
      .toLowerCase()
  }
, join: function getJoin(items, property, separator) {
    var list, i;
    if (!items) return;
    if (property) {
      list = [];
      for (i = items.length; i--;) {
        list[i] = items[i][property];
      }
    } else {
      list = items;
    }
    return list.join(separator || ', ');
  }
, log: function getLog() {
    console.log.apply(console, arguments);
  }
, trace: function getTrace() {
    console.trace();
  }
, debugger: function getDebugger() {
    debugger;
  }
, path: function getPath(name) {
    return ctxPath(this.view, this.ctx, name);
  }
, noop: function noop() {}
, lookup: viewPath.lookup
};

var defaultSetFns = {
  equal: function setEqual(value, a, b) {
    return value && [b];
  }
, not: function setNot(value) {
    return [!value];
  }
};

function View(libraries, app, appFilename) {
  this._libraries = libraries || [];
  this.app = app || {};
  this._appFilename = appFilename;
  this._inline = '';
  this.clear();
  this.getFns = derby.util.copyObject(defaultGetFns);
  this.setFns = derby.util.copyObject(defaultSetFns);
  if (this._init) this._init();
  this._idCount = 0;
  this._uncreated = [];
}
View.prototype = {
  defaultViews: {
    doctype: function() {
      return '<!DOCTYPE html>';
    }
  , root: empty
  , charset: function() {
      return '<meta charset=utf-8>';
    }
  , title$s: empty
  , head: empty
  , header: empty
  , body: empty
  , footer: empty
  , scripts: empty
  , tail: empty
  }

, _selfNs: 'app'

  // All automatically created ids start with a dollar sign
  // TODO: change this since it messes up query selectors unless escaped
, _uniqueId: uniqueId

, clear: clear
, _resetForRender: resetForRender
, make: make
, _makeAll: makeAll
, _makeComponents: makeComponents
, _findView: findView
, _find: find
, get: get
, fn: fn
, render: render
, componentsByName: componentsByName
, _componentConstructor: componentConstructor
, _flushUncreated: flushUncreated
, _beforeRender: beforeRender
, _afterRender: afterRender
, _beforeRoute: beforeRoute

, inline: empty

, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
}

View.valueBinding = valueBinding;

function clear() {
  this._views = derby.util.copyObject(this.defaultViews);
  this._renders = {};
  this._resetForRender();
}

function resetForRender(model, componentInstances) {
  componentInstances || (componentInstances = {});
  if (model) this.model = model;
  this._componentInstances = componentInstances;
  var libraries = this._libraries
    , i
  for (i = libraries.length; i--;) {
    libraries[i].view._resetForRender(model, componentInstances);
  }
}

function componentsByName(name) {
  return this._componentInstances[name] || [];
}

function componentConstructor(name) {
  return this._selfLibrary && this._selfLibrary.constructors[name];
}

function uniqueId() {
  return '$' + (this._idCount++).toString(36);
}

function make(name, template, options, templatePath) {
  var view = this
    , isString = options && options.literal
    , noMinify = isString
    , onBind, renderer, render, matchTitle;

  if (templatePath && (render = this._renders[templatePath])) {
    this._views[name] = render;
    return
  }

  name = name.toLowerCase();
  matchTitle = /(?:^|\:)title(\$s)?$/.exec(name);
  if (matchTitle) {
    isString = !!matchTitle[1];
    if (isString) {
      onBind = function(events, name) {
        return bindEvents(events, name, render, ['$_doc', 'prop', 'title']);
      };
    } else {
      this.make(name + '$s', template, options, templatePath);
    }
  }

  render = function(ctx, model, triggerId) {
    if (!renderer) {
      renderer = parse(view, name, template, isString, onBind, noMinify);
    }
    return renderer(ctx, model, triggerId);
  }

  render.nonvoid = options && options.nonvoid;

  this._views[name] = render;
  if (templatePath) this._renders[templatePath] = render;
}

function makeAll(templates, instances) {
  var name, instance, options, templatePath;
  if (!instances) return;
  this.clear();
  for (name in instances) {
    instance = instances[name];
    templatePath = instance[0];
    options = instance[1];
    this.make(name, templates[templatePath], options, templatePath);
  }
}

function makeComponents(components) {
  var librariesMap = this._libraries.map
    , name, component, library;
  for (name in components) {
    component = components[name];
    library = librariesMap[name];
    library && library.view._makeAll(component.templates, component.instances);
  }
}

function findView(name, ns) {
  var items = this._views
    , item, i, segments, testNs;
  name = name.toLowerCase();
  if (ns) {
    ns = ns.toLowerCase();
    item = items[ns + ':' + name];
    if (item) return item;

    segments = ns.split(':');
    for (i = segments.length; i-- > 1;) {
      testNs = segments.slice(0, i).join(':');
      item = items[testNs + ':' + name];
      if (item) return item;
    }
  }
  return items[name];
}

function find(name, ns, optional) {
  var view = this._findView(name, ns);
  if (view) return view;
  if (optional) return empty;
  if (ns) name = ns + ':' + name;
  throw new Error("Can't find template: \n  " + name + '\n\n' +
    'Available templates: \n  ' + Object.keys(this._views).join('\n  ')
  );
}

function get(name, ns, ctx) {
  if (typeof ns === 'object') {
    ctx = ns;
    ns = '';
  }
  ctx = ctx ? extend(ctx, defaultCtx) : derby.util.copyObject(defaultCtx);
  this.app.model = this.model;
  ctx.$fnCtx = [this.app];
  ctx.$pathIds = {};
  return this._find(name, ns)(ctx);
}

function fn(name, value) {
  if (typeof name === 'object') {
    for (var k in name) {
      this.fn(k, name[k]);
    }
    return;
  }
  var get, set;
  if (typeof value === 'object') {
    get = value.get;
    set = value.set;
  } else {
    get = value;
  }
  this.getFns[name] = get;
  if (set) this.setFns[name] = set;
}

function emitRender(view, ns, ctx, name) {
  if (view.isServer) return;
  view.app.emit(name, ctx);
  if (ns) view.app.emit(name + ':' + ns, ctx);
}
function beforeRender(model, ns, ctx) {
  ctx = (ctx && Object.create(ctx)) || {};
  ctx.$ns = ns;
  emitRender(this, ns, ctx, 'pre:render');
  return ctx;
}
function afterRender(ns, ctx) {
  emitRender(this, ns, ctx, 'render');
}
function beforeRoute() {
  this.app.dom.clear();
  // Remove all data, refs, listeners, and reactive functions
  // for the previous page
  var silentModel = this.model.silent();
  silentModel.destroy('_page');
  silentModel.destroy('$components');
  // Unfetch and unsubscribe from all queries and documents
  silentModel.unload();
  var lastRender = this._lastRender;
  if (!lastRender) return;
  emitRender(this, lastRender.ns, lastRender.ctx, 'replace');
}

function render(model, ns, ctx, renderHash) {
  if (typeof ns === 'object') {
    renderHash = ctx;
    ctx = ns;
    ns = '';
  }
  this.model = model;

  if (!ctx.$isServer) ctx = this._beforeRender(model, ns, ctx);
  this._lastRender = {
    ns: ns
  , ctx: ctx
  };

  this._resetForRender();
  model.__pathMap.clear();
  model.__events.clear();
  model.__blockPaths = {};
  this.app.dom.clear();
  model.silent().destroy('$components');

  var title = this.get('title$s', ns, ctx)
    , headHtml = this.get('head', ns, ctx)
    , rootHtml = this.get('root', ns, ctx)
    , bodyHtml = this.get('header', ns, ctx) +
        this.get('body', ns, ctx) +
        this.get('footer', ns, ctx)
    , doc = window.document
    , err

  if (renderHash) {
    // Check hashes in development to help find rendering bugs
    if (renderHash === md5(bodyHtml)) {
      this._flushUncreated();
      return;
    }
    err = new Error('Server and client page renders do not match');
    setTimeout(function() {
      throw err;
    }, 0);
  } else if (ctx.$isServer) {
    // Don't finish rendering client side on the very first load, since
    // the page should already have the same HTML from the server
    this._flushUncreated();
    return;
  }

  var documentElement = doc.documentElement
    , attrs = documentElement.attributes
    , i, attr, fakeRoot, body;

  // Remove all current attributes on the documentElement and replace
  // them with the attributes in the rendered rootHtml
  for (i = attrs.length; i--;) {
    attr = attrs[i];
    documentElement.removeAttribute(attr.name);
  }
  // Using the DOM to get the attributes on an <html> tag would require
  // some sort of iframe hack until DOMParser has better browser support.
  // String parsing the html should be simpler and more efficient
  parseHtml(rootHtml, {
    start: function(tag, tagName, attrs) {
      if (tagName !== 'html') return;
      for (var attr in attrs) {
        documentElement.setAttribute(attr, attrs[attr]);
      }
    }
  });

  fakeRoot = doc.createElement('html');
  fakeRoot.innerHTML = bodyHtml;
  body = fakeRoot.getElementsByTagName('body')[0];
  documentElement.replaceChild(body, doc.body);
  doc.title = title;

  this.app.dom._setDirty(true);
  this._flushUncreated();
  this._afterRender(ns, ctx);
}


function extend(parent, obj) {
  var out = Object.create(parent)
    , key;
  if (typeof obj !== 'object' || Array.isArray(obj)) {
    return out;
  }
  for (key in obj) {
    out[key] = obj[key];
  }
  return out;
}

function modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath) {
  var listener = typeof params === 'function'
    ? params(triggerId, blockPaths, saveBlockPath && pathId)
    : params;
  listener.partial = partial;
  listener.ctx = ctx.$stringCtx || ctx;
  return listener;
}

function bindPathEvent(events, bindName, getName, partial, params, saveBlockPath) {
  events.push(function(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId) {
    var path = ctxPath(view, ctx, bindName)
    if (!path) return;
    var pathId = pathMap.id(path);
    var listener = modelListener(params, triggerId, blockPaths, pathId, partial, ctx, saveBlockPath);
    if (bindName !== getName) {
      listener.getValue = function(model) {
        return dataValue(view, ctx, model, getName);
      };
    }
    modelEvents.bind(pathId, listener);
  });
}
function bindEachPathEvent(events, name, getName, partial, params) {
  var bracketIndex = name.indexOf('[');
  if (~bracketIndex) {
    // Bind to each of the items inside brackets
    var paths = viewPath.squareBracketsArgs(name);
    for (var i = paths.length; i--;) {
      bindEachPathEvent(events, paths[i], getName, partial, params);
    }
    // Bind to anything under the root. This ins't very efficent, but it
    // should cover various cases that would require updating the bindings
    // when the arguments inside of the brackets change, which I don't feel
    // like figuring out at the moment
    var before = name.slice(0, bracketIndex);
    if (before) bindEachPathEvent(events, before + '*', getName, partial, params);
    return;
  }
  var match = /(\.*)(.*)/.exec(name);
  var prefix = match[1] || '';
  var relativeName = match[2] || '';
  var segments = relativeName.split('.');
  // This loop stops before reaching zero
  var saveBlockPath = true;
  for (var i = segments.length; i; i--) {
    var bindName = prefix + segments.slice(0, i).join('.');
    bindPathEvent(events, bindName, getName, partial, params, saveBlockPath);
    saveBlockPath = false;
  }
}
function bindEvents(events, name, partial, params) {
  if (~name.indexOf('(')) {
    var args = pathFnArgs(name);
    for (var i = args.length; i--;) {
      bindEachPathEvent(events, args[i] + '*', name, partial, params);
    }
    return;
  }
  bindEachPathEvent(events, name, name, partial, params);
}

function bindEventsById(events, name, partial, attrs, method, prop, blockType) {
  function params(triggerId, blockPaths, pathId) {
    var id = attrs._id || attrs.id;
    if (blockType && pathId) {
      blockPaths[id] = {id: pathId, type: blockType};
    }
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function bindEventsByIdString(events, name, partial, attrs, method, prop) {
  function params(triggerId) {
    var id = triggerId || attrs._id || attrs.id;
    return [id, method, prop];
  }
  bindEvents(events, name, partial, params);
}

function addId(view, attrs) {
  if (attrs.id == null) {
    attrs.id = function() {
      return attrs._id = view._uniqueId();
    };
  }
}

function pushValue(html, i, value, isAttr) {
  if (typeof value === 'function') {
    i = html.push(value, '') - 1;
  } else {
    html[i] += isAttr ? escapeAttribute(value) : value;
  }
  return i;
}

function reduceStack(stack) {
  var html = ['']
    , i = 0
    , attrs, bool, item, key, value, j, len;

  for (j = 0, len = stack.length; j < len; j++) {
    item = stack[j];
    switch (item[0]) {
      case 'start':
        html[i] += '<' + item[1];
        attrs = item[2];
        // Make sure that the id attribute is rendered first
        if ('id' in attrs) {
          html[i] += ' id=';
          i = pushValue(html, i, attrs.id, true);
        }
        for (key in attrs) {
          if (key === 'id') continue;
          value = attrs[key];
          if (value != null) {
            if (bool = value.bool) {
              i = pushValue(html, i, bool);
              continue;
            }
            html[i] += ' ' + key + '=';
            i = pushValue(html, i, value, true);
          } else {
            html[i] += ' ' + key;
          }
        }
        html[i] += '>';
        break;
      case 'text':
        i = pushValue(html, i, item[1]);
        break;
      case 'end':
        html[i] += '</' + item[1] + '>';
        break;
      case 'marker':
        html[i] += '<!--' + item[1];
        i = pushValue(html, i, item[2].id);
        html[i] += '-->';
    }
  }
  return html;
}

function renderer(view, items, events, onRender) {
  return function(ctx, model, triggerId) {
    if (!model) model = view.model;  // Needed, since model parameter is optional

    if (onRender) ctx = onRender(ctx);

    var html = '';
    for (var i = 0, len = items.length; i < len; i++) {
      item = items[i];
      html += (typeof item === 'function') ? item(ctx, model) || '' : item;
    }
    if (view.isServer) return html;

    var pathMap = model.__pathMap;
    var modelEvents = model.__events;
    var blockPaths = model.__blockPaths;
    var dom = global.DERBY && global.DERBY.app.dom;
    // Note that the events array can grow during rendering
    var i = 0;
    var event;
    while (event = events[i++]) {
      event(ctx, modelEvents, dom, pathMap, view, blockPaths, triggerId);
    }
    return html;
  }
}

function bindComponentEvent(component, name, listener) {
  if (name === 'init' || name === 'create') {
    component.once(name, listener.fn);
  } else {
    // Extra indirection allows listener to overwrite itself after first run
    component.on(name, function() {
      listener.fn.apply(null, arguments);
    });
  }
}
function bindComponentEvents(ctx, component, events) {
  var view = events.$view
    , items = events.$events
    , listenerCtx = Object.create(ctx)
    , i, item, name, listener
  // The fnCtx will include this component, but we want to emit
  // on the parent component or app
  listenerCtx.$fnCtx = listenerCtx.$fnCtx.slice(0, -1);
  for (i = items.length; i--;) {
    item = items[i];
    name = item[0];
    listener = fnListener(view, listenerCtx, item[2]);
    bindComponentEvent(component, name, listener);
  }
}

function createComponent(view, model, Component, scope, ctx, macroCtx) {
  var scoped = model.scope(scope);
  var marker = '<!--' + scope + '-->';
  var prefix = scope + '.';
  var component = new Component(scoped, scope);
  var parentFnCtx = model.__fnCtx || ctx.$fnCtx;
  var silentCtx = Object.create(ctx);
  silentCtx.$silent = true;
  var silentModel = model.silent();
  var i, key, path, value, instanceName, instances;

  ctx.$fnCtx = model.__fnCtx = parentFnCtx.concat(component);

  // HACK: Ensure that scoped model has something set
  scoped.set('$null', null);

  for (key in macroCtx) {
    value = macroCtx[key];
    if (key === 'bind') {
      bindComponentEvents(ctx, component, value);
      continue;
    }
    if (value && value.$matchName) {
      path = ctxPath(view, ctx, value.$matchName);
      if (value.$bound) {
        silentModel.ref(prefix + key, path, {updateIndices: true});
        continue;
      }
      value = dataValue(view, ctx, model, path);
      silentModel.set(prefix + key, value);
      continue;
    }
    // TODO: Figure out how to get value of templatized attributes
    if (typeof value === 'function') continue;
    silentModel.set(prefix + key, value);
  }

  instanceName = scoped.get('name');
  if (instanceName) {
    instances = view._componentInstances[instanceName] ||
      (view._componentInstances[instanceName] = []);
    instances.push(component);
  }

  if (component.init) component.init(scoped);
  component.emit('init', component);

  if (view.isServer || ctx.$silent) return marker;

  var app = global.DERBY && global.DERBY.app
    , dom = app.dom
  component.dom = dom;
  component.history = app.history;

  var uncreated = new UncreatedComponent(component, scoped, dom, scope, ctx);
  view._uncreated.push(uncreated);

  return marker;
}

function UncreatedComponent(component, model, dom, scope, ctx) {
  this.component = component;
  this.model = model;
  this.dom = dom;
  this.scope = scope;
  this.ctx = ctx;
}
UncreatedComponent.prototype.create = function() {
  // TODO: Figure out underlying issue and remove
  // If for some reason, component's scoped model does not have any data,
  // do nothing. Not sure why it would get to this state, but it does.
  if (!this.model.get()) return;

  // Destroy in case component was created and replaced within rendering
  if (!this.dom.marker(this.scope)) {
    this.component.emit('destroy');
    return;
  }

  this.dom.addComponent(this.ctx, this.component);
  if (this.component.create) this.component.create(this.model, this.component.dom);
  this.component.emit('create', this.component);
};

function flushUncreated() {
  var uncreated;
  while (uncreated = this._uncreated.shift()) {
    uncreated.create();
  }
};

function extendCtx(view, ctx, value, name, alias, isEach) {
  var path = ctxPath(view, ctx, name)
    , aliases;
  ctx = extend(ctx, value);
  ctx['this'] = value;
  if (alias) {
    aliases = ctx.$aliases = Object.create(ctx.$aliases);
    aliases[alias] = ctx.$paths.length;
    if (isEach) aliases[alias]++;
  }
  if (path) {
    ctx.$paths = [path].concat(ctx.$paths);
  }
  ctx.$pathIds = Object.create(ctx.$pathIds);
  return ctx;
}

function partialValue(view, ctx, model, name, value, listener) {
  if (listener) return value;
  return name ? dataValue(view, ctx, model, name) : true;
}

function partialFn(view, name, type, alias, render, ns, macroCtx) {
  function partialBlock (ctx, model, triggerId, value, index, listener) {
    // Inherit & render attribute context values
    var renderMacroCtx = {}
      , parentMacroCtx = ctx.$macroCtx
      , mergedMacroCtx = macroCtx
      , key, val, matchName
    if (macroCtx.inherit) {
      mergedMacroCtx = {};
      derby.util.mergeInto(mergedMacroCtx, parentMacroCtx);
      derby.util.mergeInto(mergedMacroCtx, macroCtx);
      delete mergedMacroCtx.inherit;
    }
    for (key in mergedMacroCtx) {
      val = mergedMacroCtx[key];
      if (val && val.$matchName) {
        matchName = ctxPath(view, ctx, val.$matchName);
        if (matchName.charAt(0) === '@') {
          val = dataValue(view, ctx, model, matchName);
        } else {
          val = derby.util.copyObject(val);
          val.$matchName = matchName;
        }
      }
      renderMacroCtx[key] = val;
    }

    // Find the appropriate partial template
    var partialNs, partialName, partialOptional, arr;
    if (name === 'derby:view') {
      partialNs = mergedMacroCtx.ns || view._selfNs;
      partialName = mergedMacroCtx.view;
      partialOptional = mergedMacroCtx.optional;
      if (!partialName) throw new Error('<derby:view> tag without a "view" attribute')
      if (partialNs.$matchName) {
        partialNs = dataValue(view, ctx, model, partialNs.$matchName);
      }
      if (partialName.$matchName) {
        partialName = dataValue(view, ctx, model, partialName.$matchName);
      }
    } else {
      arr = splitPartial(name);
      partialNs = arr[0];
      partialName = arr[1];
    }
    // This can happen when using <derby:view view={{...}}>
    if (typeof partialName === 'function') {
      partialName = partialName(Object.create(ctx), model);
    }
    var partialView = nsView(view, partialNs)
      , render = partialView._find(partialName, ns, partialOptional)
      , Component = partialView._componentConstructor(partialName)
      , renderCtx, scope, out, marker

    // Prepare the context for rendering
    if (Component) {
      scope = '$components.' + view._uniqueId();
      renderCtx = extendCtx(view, ctx, null, scope, 'self');
      renderCtx.$elements = {};
      marker = createComponent(view, model, Component, scope, renderCtx, renderMacroCtx);
    } else {
      renderCtx = Object.create(ctx);
    }
    renderCtx.$macroCtx = renderMacroCtx;

    out = render(renderCtx, model);
    if (Component) {
      if (model.__fnCtx) {
        model.__fnCtx = model.__fnCtx.slice(0, -1);
      }
      out = marker + out;
    }
    return out;
  }

  function withBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function ifBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (!(Array.isArray(value) ? value.length : value)) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function unlessBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    if (Array.isArray(value) ? value.length : value) return;
    var renderCtx = extendCtx(view, ctx, value, name, alias);
    return render(renderCtx, model);
  }

  function eachBlock(ctx, model, triggerId, value, index, listener) {
    value = partialValue(view, ctx, model, name, value, listener);
    var isArray = Array.isArray(value);

    if (listener && !isArray) {
      if (value === void 0) return;
      var listCtx = extendCtx(view, ctx, null, name, alias, true);
      var itemPath = listCtx.$paths[0] + '.' + index;
      var item = partialValue(view, listCtx, model, itemPath, value, listener);
      renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [index].concat(renderCtx.$indices);
      renderCtx.$index = index;
      renderCtx.$paths = [itemPath].concat(renderCtx.$paths);
      return render(renderCtx, model);
    }

    if (!isArray || !value.length) return;

    var listCtx = extendCtx(view, ctx, null, name, alias, true);

    var out = '';
    var indices = listCtx.$indices;
    var paths = listCtx.$paths;
    var basePath = paths[0];
    for (var i = 0, len = value.length; i < len; i++) {
      var item = value[i];
      var renderCtx = extend(listCtx, item);
      renderCtx['this'] = item;
      renderCtx.$indices = [i].concat(indices);
      renderCtx.$index = i;
      renderCtx.$paths = [basePath + '.' + i].concat(paths);
      out += (item === void 0) ?
        '<!--empty-->' :
        render(renderCtx, model);
    }
    return out;
  }

  var block =
      (type === 'partial') ? partialBlock
    : (type === 'with' || type === 'else') ? withBlock
    : (type === 'if' || type === 'else if') ? ifBlock
    : (type === 'unless') ? unlessBlock
    : (type === 'each') ? eachBlock
    : null

  if (!block) throw new Error('Unknown block type: ' + type);
  block.type = type;
  return block;
}

var objectToString = Object.prototype.toString;
var arrayToString = Array.prototype.toString;

function valueBinding(value) {
  return value == null ? '' :
    (value.toString === objectToString || value.toString === arrayToString) ?
    JSON.stringify(value) : value;
}

function valueText(value) {
  return valueBinding(value).toString();
}

function textFn(view, name, escape, force) {
  var filter = escape ? function(value) {
    return escape(valueText(value));
  } : valueText;
  return function(ctx, model) {
    return dataValue(view, ctx, model, name, filter, force);
  }
}

function sectionFn(view, queue) {
  var render = renderer(view, reduceStack(queue.stack), queue.events);
  var block = queue.block;
  return partialFn(view, block.name, block.type, block.alias, render);
}

function blockFn(view, sections) {
  var len = sections.length;
  if (!len) return;
  if (len === 1) {
    return sectionFn(view, sections[0]);

  } else {
    var fns = []
      , i, out;
    for (i = 0; i < len; i++) {
      fns.push(sectionFn(view, sections[i]));
    }
    out = function(ctx, model, triggerId, value, index, listener) {
      var out;
      for (i = 0; i < len; i++) {
        out = fns[i](ctx, model, triggerId, value, index, listener);
        if (out != null) return out;
      }
    }
    return out;
  }
}

function parseMarkup(type, attr, tagName, events, attrs, value) {
  var parser = markup[type][attr]
    , anyOut, anyParser, elOut, elParser, out;
  if (!parser) return;
  if (anyParser = parser['*']) {
    anyOut = anyParser(events, attrs, value);
  }
  if (elParser = parser[tagName]) {
    elOut = elParser(events, attrs, value);
  }
  out = anyOut ? extend(anyOut, elOut) : elOut;
  if (out && out.del) delete attrs[attr];
  return out;
}

function pushText(stack, text) {
  if (text) stack.push(['text', text]);
}

function pushVarFn(view, stack, fn, name, escapeFn) {
  if (fn) {
    pushText(stack, fn);
  } else {
    pushText(stack, textFn(view, name, escapeFn));
  }
}

function isPartial(view, tagName) {
  if (tagName === 'derby:view') return true;
  var split = splitPartial(tagName);
  if (!split) return false;
  var tagNs = split[0];
  return (
    tagNs === 'app' ||
    tagNs === 'lib' ||
    !!libraryForNs(view, tagNs)
  );
}

function isPartialSection(tagName) {
  return tagName.charAt(0) === '@';
}

function partialSectionName(tagName) {
  return isPartialSection(tagName) ? tagName.slice(1) : null;
}

function libraryForNs(view, ns) {
  var library = view._libraries.map[ns];
  if (library) return library;
  if (view.parent) return view.parent.view._libraries.map[ns];
}

function nsView(view, ns) {
  if (ns === view._selfNs) return view;
  if (view.parent && ns === view.parent.view._selfNs) return view.parent.view;
  var library = libraryForNs(view, ns);
  if (!library) throw new Error('No library found with namespace ' + ns);
  var partialView = library.view;
  partialView._uniqueId = function() {
    return view._uniqueId();
  };
  partialView.model = view.model;
  partialView._uncreated = view._uncreated;
  return partialView;
}

function splitPartial(partial) {
  var i = partial.indexOf(':');
  if (i === -1) return;
  var partialNs = partial.slice(0, i);
  var partialName = partial.slice(i + 1);
  return [partialNs, partialName];
}

function findComponent(view, partial, ns) {
  var arr = splitPartial(partial)
    , partialNs = arr[0]
    , partialName = arr[1]
    , partialView = nsView(view, partialNs)
  return partialView._find(partialName, ns);
}

function isVoidComponent(view, partial, ns) {
  if (partial === 'derby:view') return true;
  return !findComponent(view, partial, ns).nonvoid;
}

function pushVar(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , partial = match.partial
    , escapeFn = match.escaped && escapeHtml
    , attr, attrs, boundOut, last, tagName, wrap;

  if (partial) {
    fn = partialFn(view, partial, 'partial', null, null, ns, match.macroCtx);
  }

  else if (match.bound) {
    last = lastItem(stack);
    wrap = match.pre ||
      !last ||
      (last[0] !== 'start') ||
      isVoid(tagName = last[1]) ||
      wrapRemainder(tagName, remainder);

    if (wrap) {
      stack.push(['marker', '', attrs = {}]);
    } else {
      attrs = last[2];
      for (attr in attrs) {
        parseMarkup('boundParent', attr, tagName, events, attrs, match);
      }
      boundOut = parseMarkup('boundParent', '*', tagName, events, attrs, match);
      if (boundOut) {
        bindEventsById(events, name, null, attrs, boundOut.method, boundOut.property);
      }
    }
    addId(view, attrs);

    if (!boundOut) {
      bindEventsById(events, name, fn, attrs, 'html', !fn && escapeFn, match.type);
    }
  }

  pushVarFn(view, stack, fn, name, escapeFn);
  if (wrap) {
    stack.push([
      'marker'
    , '$'
    , { id: function() { return attrs._id } }
    ]);
  }
}

function pushVarString(view, ns, stack, events, remainder, match, fn) {
  var name = match.name
    , escapeFn = !match.escaped && unescapeEntities;
  function bindOnce(ctx) {
    ctx.$onBind(events, name);
    bindOnce = empty;
  }
  if (match.bound) {
    events.push(function(ctx) {
      bindOnce(ctx);
    });
  }
  pushVarFn(view, stack, fn, name, escapeFn);
}

function parseMatchError(text, message) {
  throw new Error(message + '\n\n' + text + '\n');
}

function onBlock(start, end, block, queues, callbacks) {
  var lastQueue, queue;
  if (end) {
    lastQueue = queues.pop();
    queue = lastItem(queues);
    queue.sections.push(lastQueue);
  } else {
    queue = lastItem(queues);
  }

  if (start) {
    queue = {
      stack: []
    , events: []
    , block: block
    , sections: []
    };
    queues.push(queue);
    callbacks.onStart(queue);
  } else {
    if (end) {
      callbacks.onStart(queue);
      callbacks.onEnd(queue.sections);
      queue.sections = [];
    } else {
      callbacks.onContent(block);
    }
  }
}

function parseMatch(text, match, queues, callbacks) {
  var hash = match.hash
    , type = match.type
    , name = match.name
    , block = lastItem(queues).block
    , blockType = block && block.type
    , startBlock, endBlock;

  if (type === 'if' || type === 'unless' || type === 'each' || type === 'with') {
    if (hash === '#') {
      startBlock = true;
    } else if (hash === '/') {
      endBlock = true;
    } else {
      parseMatchError(text, type + ' blocks must begin with a #');
    }

  } else if (type === 'else' || type === 'else if') {
    if (hash) {
      parseMatchError(text, type + ' blocks may not start with ' + hash);
    }
    if (blockType !== 'if' && blockType !== 'else if' &&
        blockType !== 'unless' && blockType !== 'each') {
      parseMatchError(text, type + ' may only follow `if`, `else if`, `unless`, or `each`');
    }
    startBlock = true;
    endBlock = true;

  } else if (hash === '/') {
    endBlock = true;

  } else if (hash === '#') {
    parseMatchError(text, '# must be followed by `if`, `unless`, `each`, or `with`');
  }

  if (endBlock && !block) {
    parseMatchError(text, 'Unmatched template end tag');
  }

  onBlock(startBlock, endBlock, match, queues, callbacks);
}

function parseAttr(view, viewName, events, tagName, attrs, attr) {
  var value = attrs[attr];
  if (typeof value === 'function') return;

  var attrOut = parseMarkup('attr', attr, tagName, events, attrs, value) || {}
    , boundOut, match, name, render, method, property;
  if (attrOut.addId) addId(view, attrs);

  if (match = extractPlaceholder(value)) {
    name = match.name;

    if (match.pre || match.post) {
      // Attributes must be a single string, so create a string partial
      addId(view, attrs);
      render = parse(view, viewName, value, true, function(events, name) {
        bindEventsByIdString(events, name, render, attrs, 'attr', attr);
      });

      attrs[attr] = attr === 'id' ? function(ctx, model) {
        return attrs._id = escapeAttribute(render(ctx, model));
      } : function(ctx, model) {
        return escapeAttribute(render(ctx, model));
      }
      return;
    }

    if (match.bound) {
      boundOut = parseMarkup('bound', attr, tagName, events, attrs, match) || {};
      addId(view, attrs);
      method = boundOut.method || 'attr';
      property = boundOut.property || attr;
      bindEventsById(events, name, null, attrs, method, property);
    }

    if (!attrOut.del) {
      attrs[attr] = attrOut.bool ? {
        bool: function(ctx, model) {
          return (dataValue(view, ctx, model, name)) ? ' ' + attr : '';
        }
      } : textFn(view, name, escapeAttribute, true);
    }
  }
}

function parsePartialAttr(view, viewName, events, attrs, attr) {
  var value = attrs[attr]
    , match;

  if (!value) {
    // A true boolean attribute will have a value of null
    if (value === null) attrs[attr] = true;
    return;
  }

  if (attr === 'bind') {
    attrs[attr] = {$events: splitEvents(value), $view: view};
    return;
  }

  if (match = extractPlaceholder(value)) {
    // This attribute needs to be treated as a section
    if (match.pre || match.post) return true;

    attrs[attr] = {$matchName: match.name, $bound: match.bound};

  } else if (value === 'true') {
    attrs[attr] = true;
  } else if (value === 'false') {
    attrs[attr] = false;
  } else if (value === 'null') {
    attrs[attr] = null;
  } else if (!isNaN(value)) {
    attrs[attr] = +value;
  } else if (/^[{[]/.test(value)) {
    try {
      attrs[attr] = JSON.parse(value)
    } catch (err) {}
  }
}

function lastItem(arr) {
  return arr[arr.length - 1];
}

function parse(view, viewName, template, isString, onBind, noMinify) {
  var queues, stack, events, onRender, push;

  queues = [{
    stack: stack = []
  , events: events = []
  , sections: []
  }];

  function onStart(queue) {
    stack = queue.stack;
    events = queue.events;
  }

  if (isString) {
    push = pushVarString;
    onRender = function(ctx) {
      if (ctx.$stringCtx) return ctx;
      ctx = Object.create(ctx);
      ctx.$onBind = onBind;
      ctx.$stringCtx = ctx;
      return ctx;
    }
  } else {
    push = pushVar;
  }

  var index = viewName.lastIndexOf(':')
    , ns = ~index ? viewName.slice(0, index) : ''

  function parseStart(tag, tagName, attrs) {
    var attr, block, out, parser, isSection, attrBlock
    if ('x-no-minify' in attrs) {
      delete attrs['x-no-minify'];
      noMinify = true;
    }

    if (isPartial(view, tagName)) {
      block = {
        partial: tagName
      , macroCtx: attrs
      };
      onBlock(true, false, block, queues, {onStart: onStart});

      for (attr in attrs) {
        isSection = parsePartialAttr(view, viewName, events, attrs, attr);
        if (!isSection) continue;
        attrBlock = {
          partial: '@' + attr
        , macroCtx: lastItem(queues).block.macroCtx
        };
        onBlock(true, false, attrBlock, queues, {onStart: onStart});
        parseText(attrs[attr]);
        parseEnd(tag, '@' + attr);
      }

      if (isVoidComponent(view, tagName, ns)) {
        onBlock(false, true, null, queues, {
          onStart: onStart
        , onEnd: function(queues) {
            push(view, ns, stack, events, '', block);
          }
        })
      }
      return;
    }

    if (isPartialSection(tagName)) {
      block = {
        partial: tagName
      , macroCtx: lastItem(queues).block.macroCtx
      };
      onBlock(true, false, block, queues, {onStart: onStart});
      return;
    }

    if (parser = markup.element[tagName]) {
      out = parser(events, attrs);
      if (out != null ? out.addId : void 0) {
        addId(view, attrs);
      }
    }

    for (attr in attrs) {
      parseAttr(view, viewName, events, tagName, attrs, attr);
    }
    stack.push(['start', tagName, attrs]);
  }

  function parseText(text, isRawText, remainder) {
    var match = extractPlaceholder(text)
      , post, pre;
    if (!match || isRawText) {
      if (!noMinify) {
        text = isString ? unescapeEntities(trimText(text)) : trimText(text);
      }
      pushText(stack, text);
      return;
    }

    pre = match.pre;
    post = match.post;
    if (isString) pre = unescapeEntities(pre);
    pushText(stack, pre);
    remainder = post || remainder;

    parseMatch(text, match, queues, {
      onStart: onStart
    , onEnd: function(sections) {
        var fn = blockFn(view, sections);
        push(view, ns, stack, events, remainder, sections[0].block, fn);
      }
    , onContent: function(match) {
        push(view, ns, stack, events, remainder, match);
      }
    });

    if (post) return parseText(post);
  }

  function parseEnd(tag, tagName) {
    var sectionName = partialSectionName(tagName)
      , endsPartial = isPartial(view, tagName)
    if (endsPartial && isVoidComponent(view, tagName, ns)) {
      throw new Error('End tag "' + tag + '" is not allowed for void component')
    }
    if (sectionName || endsPartial) {
      onBlock(false, true, null, queues, {
        onStart: onStart
      , onEnd: function(queues) {
          var queue = queues[0]
            , block = queue.block
            , fn = renderer(view, reduceStack(queue.stack), queue.events)
          fn.unescaped = true;
          if (sectionName) {
            block.macroCtx[sectionName] = fn;
            return;
          }
          // Put the remaining content not in a section in the default "content" section,
          // unless "inherit" is specified and there is no content, so that the parent
          // content can be inherited
          if (queue.stack.length || !block.macroCtx.inherit) {
            block.macroCtx.content = fn;
          }
          push(view, ns, stack, events, '', block);
        }
      })
      return;
    }
    stack.push(['end', tagName]);
  }

  if (isString) {
    parseText(template);
  } else {
    parseHtml(template, {
      start: parseStart
    , text: parseText
    , end: parseEnd
    , comment: function(tag) {
        if (conditionalComment(tag)) pushText(stack, tag);
      }
    , other: function(tag) {
        pushText(stack, tag);
      }
    });
  }
  return renderer(view, reduceStack(stack), events, onRender);
}

})(window)
},{"./markup":61,"./viewPath":52,"./eventBinding":62,"./derby":"0klAo3","html-util":54,"MD5":63}],61:[function(require,module,exports){
var eventBinding = require('./eventBinding')
  , splitEvents = eventBinding.splitEvents
  , containsEvent = eventBinding.containsEvent
  , addDomEvent = eventBinding.addDomEvent
  , TEXT_EVENTS = 'keyup,keydown/0,cut/0,paste/0,dragover/0,blur'
  , AUTOCOMPLETE_OFF = {
      checkbox: true
    , radio: true
    }
  , onBindA, onBindForm;

module.exports = {
  bound: {
    'value': {
      'input': function(events, attrs, match) {
        var type = attrs.type
          , eventNames, method;
        if (type === 'radio' || type === 'checkbox') return;
        if (type === 'range' || 'x-blur' in attrs) {
          // Only update after the element loses focus
          delete attrs['x-blur'];
          eventNames = 'change,blur';
        } else {
          // By default, update as the user types
          eventNames = TEXT_EVENTS;
        }
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          method = 'prop';
        } else if (type === 'text' || !type) {
          method = 'propOt';
        } else {
          method = 'prop';
        }
        addDomEvent(events, attrs, eventNames, match, {
          method: method
        , property: 'value'
        });
        return {method: method};
      }
    }

  , 'checked': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'checked'
        });
        return {method: 'prop'};
      }
    }

  , 'selected': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, 'change', match, {
          method: 'prop'
        , property: 'selected'
        });
        return {method: 'prop'};
      }
    }

  , 'disabled': {
      '*': function() {
        return {method: 'prop'};
      }
    }
  }

, boundParent: {
    'contenteditable': {
      '*': function(events, attrs, match) {
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: 'html'
        });
      }
    }

  , '*': {
      'textarea': function(events, attrs, match) {
        if ('x-atomic' in attrs) {
          delete attrs['x-atomic'];
          var method = 'prop';
        } else {
          var method = 'propOt';
        }
        addDomEvent(events, attrs, TEXT_EVENTS, match, {
          method: method
        , property: 'value'
        });
        return {method: method, property: 'value'};
      }
    }
  }

, element: {
    'select': function(events, attrs) {
      // Distribute change event to child nodes of select elements
      addDomEvent(events, attrs, 'change:$forChildren');
      return {addId: true};
    }

  , 'input': function(events, attrs) {
      if (AUTOCOMPLETE_OFF[attrs.type] && !('autocomplete' in attrs)) {
        attrs.autocomplete = 'off';
      }
      if (attrs.type === 'radio') {
        // Distribute change events to other elements with the same name
        addDomEvent(events, attrs, 'change:$forName');
      }
    }
  }

, attr: {
    'x-bind': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames);
        return {addId: true, del: true};
      }

    , 'a': onBindA = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, ['click', 'focus']) && !('href' in attrs)) {
          attrs.href = '#';
          if (!('onclick' in attrs)) {
            attrs.onclick = 'return false';
          }
        }
      }

    , 'form': onBindForm = function(events, attrs, eventNames) {
        if (containsEvent(eventNames, 'submit')) {
          if (!('onsubmit' in attrs)) {
            attrs.onsubmit = 'return false';
          }
        }
      }
    }

  , 'x-capture': {
      '*': function(events, attrs, eventNames) {
        addDomEvent(events, attrs, eventNames, null, {capture: true});
        return {addId: true, del: true};
      }
    , 'a': onBindA
    , 'form': onBindForm
    }

  , 'x-as': {
      '*': function(events, attrs, name) {
        events.push(function(ctx) {
          ctx.$elements[name] = attrs._id || attrs.id;
        });
        return {addId: true, del: true}
      }
  }

  , 'checked': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'selected': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'disabled': {
      '*': function() {
        return {bool: true};
      }
    }

  , 'autofocus': {
      '*': function() {
        return {bool: true};
      }
    }
  }

, TEXT_EVENTS: TEXT_EVENTS
, AUTOCOMPLETE_OFF: AUTOCOMPLETE_OFF
};

},{"./eventBinding":62}],62:[function(require,module,exports){
var util = require('racer').util
  , viewPath = require('./viewPath')
  , extractPlaceholder = viewPath.extractPlaceholder
  , dataValue = viewPath.dataValue
  , ctxPath = viewPath.ctxPath
  , pathFnArgs = viewPath.pathFnArgs
  , setBoundFn = viewPath.setBoundFn
  , arraySlice = [].slice

exports.splitEvents = splitEvents;
exports.fnListener = fnListener;
exports.containsEvent = containsEvent;
exports.addDomEvent = util.isServer ? empty : addDomEvent;

function splitEvents(eventNames) {
  var pairs = eventNames.split(',')
    , eventList = []
    , i, j, pair, segments, name, eventName, delay, fns, fn;
  for (i = pairs.length; i--;) {
    pair = pairs[i];
    segments = pair.split(':');
    name = segments[0].split('/');
    eventName = name[0].trim();
    delay = name[1];
    fns = (segments[1] || '').trim().split(/\s+/);
    for (j = fns.length; j--;) {
      fn = fns[j];
      fns[j] = extractPlaceholder(fn) || fn;
    }
    eventList.push([eventName, delay, fns]);
  }
  return eventList;
}

function containsEvent(eventNames, expected) {
  if (!Array.isArray(expected)) expected = [expected];
  var eventList = splitEvents(eventNames)
    , i, j, eventName
  for (i = eventList.length; i--;) {
    eventName = eventList[i][0];
    for (j = expected.length; j--;) {
      if (eventName === expected[j]) return true;
    }
  }
  return false;
}

function addDomEvent(events, attrs, eventNames, match, options) {
  var eventList = splitEvents(eventNames)
    , args, name;

  if (match) {
    name = match.name;

    if (~name.indexOf('(')) {
      args = pathFnArgs(name);
      if (!args.length) return;

      events.push(function(ctx, modelEvents, dom, pathMap, view) {
        var id = attrs._id || attrs.id
          , paths = []
          , arg, path, pathId, event, eventName, eventOptions, i, j;
        options.setValue = function(model, value) {
          return setBoundFn(view, ctx, model, name, value);
        }
        for (i = args.length; i--;) {
          arg = args[i];
          path = ctxPath(view, ctx, arg);
          paths.push(path);
          pathId = pathMap.id(path);
          for (j = eventList.length; j--;) {
            event = eventList[j];
            eventName = event[0];
            eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
            dom.bind(eventName, id, eventOptions);
          }
        }
      });
      return;
    }

    events.push(function(ctx, modelEvents, dom, pathMap, view) {
      var id = attrs._id || attrs.id
        , pathId = pathMap.id(ctxPath(view, ctx, name))
        , event, eventName, eventOptions, i;
      for (i = eventList.length; i--;) {
        event = eventList[i];
        eventName = event[0];
        eventOptions = util.mergeInto({view: view, ctx: ctx, pathId: pathId, delay: event[1]}, options);
        dom.bind(eventName, id, eventOptions);
      }
    });
    return;
  }

  events.push(function(ctx, modelEvents, dom, pathMap, view) {
    var id = attrs._id || attrs.id
      , pathId = pathMap.id(ctxPath(view, ctx, '.'))
      , event, eventName, eventOptions, i;
    for (i = eventList.length; i--;) {
      event = eventList[i];
      eventName = event[0];
      eventOptions = fnListener(view, ctx, event[2], dom);
      eventOptions.delay = event[1];
      util.mergeInto(eventOptions, options);
      util.mergeInto(eventOptions, {view: view, ctx: ctx, pathId: pathId});
      dom.bind(eventName, id, eventOptions);
    }
  });
}

function eachFnListener(view, ctx, fnObj, dom) {
  var fnName, fn, fnCtxs, i, fnCtx;

  fnName = typeof fnObj === 'object'
    ? dataValue(view, ctx, view.model, fnObj.name)
    : fnName = fnObj;

  // If a placeholder for an event name does not have a value, do nothing
  if (!fnName) return empty;

  // See if it is a built-in function
  fn = dom && dom.fns[fnName];

  // Lookup the function name on the component script or app

  // TODO: This simply looks in the local scope for the function
  // and then goes up the scope if a function name is not found.
  // Better would be to actually figure out the scope of where the
  // function name is specfied, since there could easily be namespace
  // conflicts between functions in a component and functions in an
  // app using that component. How to implement this correctly is not
  // obvious at the moment.
  if (!fn) {
    fnCtxs = ctx.$fnCtx;
    for (i = fnCtxs.length; i--;) {
      fnCtx = fnCtxs[i];
      fn = fnCtx[fnName] || viewPath.lookup(fnName, fnCtx);
      if (fn) break;
    }
  }
  if (!fn) throw new Error('Bound function not found: ' + fnName);

  // Bind the listener to the app or component object on which it
  // was defined so that the `this` context will be the instance
  return fn.bind(fnCtx);
}

function fnListener(view, ctx, fnNames, dom) {
  var listener = {
    fn: function() {
      var len = fnNames.length
        , args = arraySlice.call(arguments)
        , i, fn, boundFns

      if (len === 0) {
        // Don't do anything if no handler functions were specified
        return listener.fn = empty;

      } else if (len === 1) {
        fn = eachFnListener(view, ctx, fnNames[0], dom);

      } else {
        boundFns = [];
        for (i = len; i--;) {
          boundFns.push(eachFnListener(view, ctx, fnNames[i], dom));
        }
        fn = function() {
          var args = arraySlice.call(arguments)
          for (var i = boundFns.length; i--;) {
            boundFns[i].apply(null, args);
          }
        }
      }

      listener.fn = fn;
      fn.apply(null, args);
    }
  };
  return listener;
}

function empty() {}

},{"racer":"IocUA/","./viewPath":52}],51:[function(require,module,exports){
var router = module.exports = require('./router')

module.exports = {
  transition: transition
}

/**
 * @param {Function} add (e.g., app.get, app.post, etc.)
 * @param {Array} transitionCalls is an array of objects that look 
 *   like {from, to, forward, back}
 * @param {String} from
 * @param {String} to
 * @param {Function} forward
 * @param {Function} back
 */
function transition(add, calls, from, to, forward, back) {
  if (from === to) return
  for (var i = 0, len = calls.length; i < len; i++) {
    var call = calls[i]
    if (call.from === to) {
      if (hasTransition(calls, from, call.to)) continue
      var composedForward = composeCallbacks(forward, call.forward, to)
      if (back && call.back) {
        var composedBack = composeCallbacks(call.back, back, to)
      }
      add({
        from: from
      , to: call.to
      , forward: composedForward
      , back: composedBack
      })
    } else if (call.to === from) {
      if (hasTransition(calls, call.from, to)) continue
      var composedForward = composeCallbacks(call.forward, forward, from)
      if (back && call.back) {
        var composedBack = composeCallbacks(back, call.back, from)
      }
      add({
        from: call.from
      , to: to
      , forward: composedForward
      , back: composedBack
      })
    }
  }
}

function hasTransition(calls, from, to) {
  for (var i = calls.length; i--;) {
    var call = calls[i];
    if (call.from === from && call.to === to) return true
  }
  return false
}

// TODO: Async support
function composeCallbacks(first, second, intermediatePath) {
  function composed(self, model, params, next, done) {
    var intermediateUrl = router.mapRoute(intermediatePath, params)
    var url = params.url
    var skipped = false
    function wrapNext(err) {
      skipped = true
      next(err)
    }
    params.url = intermediateUrl
    if (first.length === 4) {
      first.call(self, model, params, wrapNext, doneFirst)
    } else {
      first.call(self, model, params, wrapNext)
      doneFirst()
    }
    function doneFirst() {
      if (skipped) return
      params.previous = intermediateUrl
      params.url = url
      if (second.length === 4) {
        second.call(self, model, params, next, done)
      } else {
        second.call(self, model, params, next)
        done && done()
      }
    }
  }
  // These need to be defined individually, since their
  // argument length will be checked
  function asyncComposedCallback(model, params, next, done) {
    composed(this, model, params, next, done);
  }
  function composedCallback(model, params, next) {
    composed(this, model, params, next);
  }
  return (first.length === 4 || second.length === 4) ?
    asyncComposedCallback : composedCallback;
}

},{"./router":50}],52:[function(require,module,exports){
var trimLeading = require('html-util').trimLeading;

exports.wrapRemainder = wrapRemainder;
exports.extractPlaceholder = extractPlaceholder;
exports.pathFnArgs = pathFnArgs;
exports.squareBracketsArgs = squareBracketsArgs;
exports.ctxPath = ctxPath;
exports.getValue = getValue;
exports.dataValue = dataValue;
exports.setBoundFn = setBoundFn;
exports.lookup = lookup;
exports.replaceSquareBrackets = replaceSquareBrackets;

function wrapRemainder(tagName, remainder) {
  if (!remainder) return false;
  return !(new RegExp('^<\/' + tagName, 'i')).test(remainder);
}

var openPlaceholder = /^([\s\S]*?)(\{{1,3})\s*([\s\S]*)/
  , aliasContent = /^([\s\S]*)\s+as\s+:(\S+)\s*$/
  , blockContent = /^([\#\/]?)(else\sif|if|else|unless|each|with|unescaped)?\s*([\s\S]*?)\s*$/
  , closeMap = { 1: '}', 2: '}}' }
function extractPlaceholder(text) {
  var match = openPlaceholder.exec(text);
  if (!match) return;
  var pre = match[1]
    , open = match[2]
    , remainder = match[3]
    , openLen = open.length
    , bound = openLen === 1
    , end = matchBraces(remainder, openLen, 0, '{', '}')
    , endInner = end - openLen
    , inner = remainder.slice(0, endInner)
    , post = remainder.slice(end)
    , alias, hash, type, name, escaped;

  if (/["{[]/.test(inner)) {
    // Make sure that we didn't accidentally match a JSON literal
    try {
      JSON.parse(open + inner + closeMap[openLen]);
      return;
    } catch (e) {}
  }

  match = aliasContent.exec(inner);
  if (match) {
    inner = match[1];
    alias = match[2];
  }

  match = blockContent.exec(inner)
  if (!match) return;
  hash = match[1];
  type = match[2];
  name = match[3];

  escaped = true;
  if (type === 'unescaped') {
    escaped = false;
    type = '';
  }
  if (bound) name = name.replace(/\bthis\b/, '.');
  return {
    pre: pre
  , post: post
  , bound: bound
  , alias: alias
  , hash: hash
  , type: type
  , name: name
  , escaped: escaped
  , source: text
  };
}

function matchBraces(text, num, i, openChar, closeChar) {
  var close, hasClose, hasOpen, open;
  i++;
  while (num) {
    close = text.indexOf(closeChar, i);
    open = text.indexOf(openChar, i);
    hasClose = ~close;
    hasOpen = ~open;
    if (hasClose && (!hasOpen || (close < open))) {
      i = close + 1;
      num--;
      continue;
    } else if (hasOpen) {
      i = open + 1;
      num++;
      continue;
    } else {
      return -1;
    }
  }
  return i;
}

var fnCall = /^([^(]+)\s*\(\s*([\s\S]*?)\s*\)\s*$/
  , argSeparator = /\s*([,(])\s*/g
  , notSeparator = /[^,\s]/g
  , notPathArg = /(?:^['"\d\-[{])|(?:^null$)|(?:^true$)|(?:^false$)/;

function fnArgs(inner) {
  var args = []
    , lastIndex = 0
    , match, end, last;
  while (match = argSeparator.exec(inner)) {
    if (match[1] === '(') {
      end = matchBraces(inner, 1, argSeparator.lastIndex, '(', ')');
      args.push(inner.slice(lastIndex, end));
      notSeparator.lastIndex = end;
      lastIndex = argSeparator.lastIndex =
        notSeparator.test(inner) ? notSeparator.lastIndex - 1 : end;
      continue;
    }
    args.push(inner.slice(lastIndex, match.index));
    lastIndex = argSeparator.lastIndex;
  }
  last = inner.slice(lastIndex);
  if (last) args.push(last);
  return args;
}

function fnCallError(name) {
  throw new Error('malformed view function call: ' + name);
}

function fnArgValue(view, ctx, model, name, arg) {
  var literal = literalValue(arg);
  if (literal !== void 0) return literal;

  var pathMap = model.__pathMap;
  if (!pathMap) return dataValue(view, ctx, model, arg);

  var argIds = ctx.hasOwnProperty('$fnArgIds') ?
    ctx.$fnArgIds : (ctx.$fnArgIds = {});
  var pathId = argIds[arg];
  var path;
  if (pathId) {
    path = pathMap.paths[pathId];
  } else {
    path = ctxPath(view, ctx, arg);
    argIds[arg] = pathMap.id(path);
  }
  return dataValue(view, ctx, model, path);
}

function fnValue(view, ctx, model, name) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , fn, fnName, i;
  for (i = args.length; i--;) {
    args[i] = fnArgValue(view, ctx, model, name, args[i]);
  }
  if (!(fn = view.getFns[fnName])) {
    throw new Error('view function "' + fnName + '" not found for call: ' + name);
  }
  return fn.apply({view: view, ctx: ctx, model: model}, args);
}

function pathFnArgs(name, paths) {
  var match = fnCall.exec(name) || fnCallError(name)
    , args = fnArgs(match[2])
    , i, arg;
  if (paths == null) paths = [];
  for (i = args.length; i--;) {
    arg = args[i];
    if (notPathArg.test(arg)) continue;
    if (~arg.indexOf('(')) {
      pathFnArgs(arg, paths);
      continue;
    }
    paths.push(arg);
  }
  return paths;
}

function relativePath(view, ctx, i, remainder) {
  var name = ctx.$paths[i - 1] + remainder;

  // pathMap is only created in the browser
  var pathMap = view.model.__pathMap;
  if (!pathMap) return name;
  var pathId = ctx.$pathIds[name] || (ctx.$pathIds[name] = pathMap.id(name));
  return pathMap.paths[pathId];
}

function macroName(view, ctx, name) {
  if (name.charAt(0) !== '@') return;

  var segments = name.slice(1).split('.');
  var base = segments.shift().toLowerCase();
  var value = lookup(base, ctx.$macroCtx);
  var matchName = value && value.$matchName;
  var remainder = segments.join('.');

  if (matchName) {
    if (!remainder) return value;
    return {$matchName: matchName + '.' + remainder};
  }
  return (remainder) ? base + '.' + remainder : base;
}

function ctxPath(view, ctx, name) {
  var isWildcard = name.charAt(name.length - 1) === '*';
  if (isWildcard) name = name.slice(0, -1);

  var macroPath = macroName(view, ctx, name);
  if (macroPath && macroPath.$matchName) name = macroPath.$matchName;

  var firstChar = name.charAt(0)
    , i, aliasName, remainder

  // Resolve path aliases
  if (firstChar === ':') {
    if (~(i = name.search(/[.[]/))) {
      aliasName = name.slice(1, i);
      remainder = name.slice(i);
    } else {
      aliasName = name.slice(1);
      remainder = '';
    }
    aliasName = aliasName;
    i = ctx.$paths.length - ctx.$aliases[aliasName];
    if (i !== i) throw new Error('Cannot find alias: ' + name);

    name = relativePath(view, ctx, i, remainder);

  // Resolve relative paths
  } else if (firstChar === '.') {
    i = 0;
    while (name.charAt(i) === '.') {
      i++;
    }
    remainder = i === name.length ? '' : name.slice(i - 1);

    name = relativePath(view, ctx, i, remainder);
  }

  name = replaceSquareBrackets(view, ctx, name);
  if (isWildcard) name += '*';
  return name;
}

function replaceSquareBrackets(view, ctx, name) {
  if (!name) return '';
  var i = name.indexOf('[');
  if (i === -1) return name;

  var end = matchBraces(name, 1, i, '[', ']');
  // This shouldn't normally happen, but just in case return
  if (end === -1) return;
  var before = name.slice(0, i);
  var inside = name.slice(i + 1, end - 1);
  var after = name.slice(end);

  name = replaceSquareBrackets(view, ctx, inside);
  var value = getValue(view, ctx, view.model, name);
  name = (value == null) ? '$null' : value;
  var out = (before) ? before + '.' + name : name;

  while (after) {
    i = after.indexOf('[');
    if (i === -1) return out + after;

    name = after;
    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return;
    before = name.slice(0, i);
    inside = name.slice(i + 1, end - 1);
    after = name.slice(end);

    if (before) out += before;

    name = replaceSquareBrackets(view, ctx, inside);
    value = getValue(view, ctx, view.model, name);
    value = (value == null) ? '$null' : value;
    out += '.' + value;
  }
  return out;
}

function squareBracketsArgs(name, paths) {
  paths || (paths = []);

  while (name) {
    i = name.indexOf('[');
    if (i === -1) return paths;

    end = matchBraces(name, 1, i, '[', ']');
    if (end === -1) return paths;
    inside = name.slice(i + 1, end - 1);
    name = name.slice(end);

    if (inside.indexOf('[') === -1) {
      paths.push(inside);
    } else {
      squareBracketsArgs(inside, paths);
    }
  }
  return paths;
}

function escapeValue(value, escape) {
  return escape ? escape(value) : value;
}

function literalValue(value) {
  if (value === 'null') return null;
  if (value === 'true') return true;
  if (value === 'false') return false;
  var firstChar = value.charAt(0)
    , match;
  if (firstChar === "'") {
    match = /^'(.*)'$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (firstChar === '"') {
    match = /^"(.*)"$/.exec(value) || fnCallError(value);
    return match[1];
  }
  if (/^[\d\-]/.test(firstChar) && !isNaN(value)) {
    return +value;
  }
  if (firstChar === '[' || firstChar === '{') {
    try {
      return JSON.parse(value);
    } catch (e) {}
  }
  return undefined;
}

function getValue(view, ctx, model, name, escape, forceEscape) {
  var literal = literalValue(name)
  if (literal === undefined) {
    return dataValue(view, ctx, model, name, escape, forceEscape);
  }
  return literal;
}

function dataValue(view, ctx, model, name, escape, forceEscape) {
  var macroPath, path, value;
  if (!name) return;
  if (~name.indexOf('(')) {
    value = fnValue(view, ctx, model, name);
    return escapeValue(value, escape);
  }
  path = ctxPath(view, ctx, name);
  macroPath = macroName(view, ctx, path);
  if (macroPath) {
    if (macroPath.$matchName) {
      path = macroPath.$matchName;
    } else {
      value = lookup(macroPath, ctx.$macroCtx);
      if (typeof value === 'function') {
        if (value.unescaped && !forceEscape) return value(ctx, model);
        value = value(ctx, model);
      }
      return escapeValue(value, escape);
    }
  }
  value = lookup(path, ctx);
  if (value === void 0) value = model.get(path)
  return escapeValue(value, escape);
}

function setBoundFn(view, ctx, model, name, value) {
  var match = fnCall.exec(name) || fnCallError(name)
    , fnName = match[1]
    , args = fnArgs(match[2])
    , get = view.getFns[fnName]
    , set = view.setFns[fnName]
    , numInputs = set && set.length - 1
    , arg, i, inputs, out, key, path, len;

  if (!(get && set)) {
    throw new Error('view function "' + fnName + '" setter not found for binding to: ' + name);
  }

  if (numInputs) {
    inputs = [value];
    i = 0;
    while (i < numInputs) {
      inputs.push(fnArgValue(view, ctx, model, name, args[i++]));
    }
    out = set.apply(null, inputs);
  } else {
    out = set(value);
  }
  if (!out) return;

  for (key in out) {
    value = out[key];
    arg = args[key];
    if (~arg.indexOf('(')) {
      setBoundFn(view, ctx, model, arg, value);
      continue;
    }
    if (value === void 0 || notPathArg.test(arg)) continue;
    path = ctxPath(view, ctx, arg);
    if (model.get(path) === value) continue;
    model.set(path, value);
  }
}

function lookup(path, obj) {
  if (!path || !obj) return;
  if (path.indexOf('.') === -1) return obj[path];

  var parts = path.split('.');
  for (var i = 0, l = parts.length; i < l; i++) {
    if (!obj) return obj;

    var prop = parts[i];
    obj = obj[prop];
  }
  return obj;
}

},{"html-util":54}],54:[function(require,module,exports){
var entityCode = require('./entityCode')
  , parse = require('./parse')

module.exports = {
  parse: parse
, escapeHtml: escapeHtml
, escapeAttribute: escapeAttribute
, unescapeEntities: unescapeEntities
, isVoid: isVoid
, conditionalComment: conditionalComment
, trimLeading: trimLeading
, trimText: trimText
, trimTag: trimTag
, minify: minify
}

function escapeHtml(value) {
  if (value == null) return ''

  return value
    .toString()
    .replace(/&(?!\s)|</g, function(match) {
      return match === '&' ? '&amp;' : '&lt;'
    })
}

function escapeAttribute(value) {
  if (value == null || value === '') return '""'

  value = value
    .toString()
    .replace(/&(?!\s)|"/g, function(match) {
      return match === '&' ? '&amp;' : '&quot;'
    })
  return /[ =<>']/.test(value) ? '"' + value + '"' : value
}

// Based on:
// http://code.google.com/p/jslibs/wiki/JavascriptTips#Escape_and_unescape_HTML_entities
function unescapeEntities(html) {
  return html.replace(/&([^;]+);/g, function(match, entity) {
    var charCode = entity.charAt(0) === '#'
          ? entity.charAt(1) === 'x'
            ? entity.slice(2, 17)
            : entity.slice(1)
          : entityCode[entity]
    return String.fromCharCode(charCode)
  })
}

var voidElement = {
  area: 1
, base: 1
, br: 1
, col: 1
, command: 1
, embed: 1
, hr: 1
, img: 1
, input: 1
, keygen: 1
, link: 1
, meta: 1
, param: 1
, source: 1
, track: 1
, wbr: 1
}
function isVoid(name) {
  return name in voidElement
}

// Assume any HTML comment that starts with `<!--[` or ends with `]-->`
// is a conditional comment. This can also be used to keep comments in
// minified HTML, such as `<!--[ Copyright John Doe, MIT Licensed ]-->`
function conditionalComment(tag) {
  return /(?:^<!--\[)|(?:\]-->$)/.test(tag)
}

// Remove leading whitespace and newlines from a string. Whitespace at the end
// of a line will be maintained
function trimLeading(text) {
  return text ? text.replace(/\r?\n\s*/g, '') : ''
}

// Remove leading & trailing whitespace and newlines from a string
function trimText(text) {
  return text ? text.replace(/\s*\r?\n\s*/g, '') : ''
}

// Within a tag, remove leading & trailing whitespace. Keep a linebreak, since
// this could be the separator between attributes
function trimTag(tag) {
  return tag.replace(/(?:\s*\r?\n\s*)+/g, '\n')
}

// Remove linebreaks, leading & trailing space, and comments. Maintain a
// linebreak between HTML tag attributes and maintain conditional comments.
function minify(html) {
  var minified = ''
    , minifyContent = true

  parse(html, {
    start: function(tag, tagName, attrs) {
      minifyContent = !('x-no-minify' in attrs)
      minified += trimTag(tag)
    }
  , end: function(tag) {
      minified += trimTag(tag)
    }
  , text: function(text) {
      minified += minifyContent ? trimText(text) : text
    }
  , comment: function(tag) {
      if (conditionalComment(tag)) minified += tag
    }
  , other: function(tag) {
      minified += tag
    }
  })
  return minified
}

},{"./entityCode":64,"./parse":65}],59:[function(require,module,exports){
module.exports = function (app) {
  app.on('model', function (model) {
    model.fn('locales', function (translations) {
      return Object.keys(translations);
    });
  });

  app.get('*', function (page, model, params, next) {
    model.start('locales', '$lang.locales', '$lang.translations');
    next();
  });
};
},{}],60:[function(require,module,exports){
module.exports = function (app) {
  app.view.fn('__', function () {
    var args = Array.prototype.slice.call(arguments, 0)
      , language = this.model.get('$lang.defaultLocale') || 'en'
      , translationInput = {}
      , translationPath = '';

    switch (args.length) {
      case 0:
        return '';
      case 1:
        translationPath = args[0];
        break;
      case 2:
        if (typeof args[1] === 'object') {
          translationPath = args[0];
          translationInput = args[1];
        } else {
          language = args[0];
          translationPath = args[1];
        }
        break;
      case 3:
        if (typeof args[2] === 'object') {
          language = args[0];
          translationInput = args[2];
          translationPath = args[1];
        } else {
          translationInput[args[1]] = args[2];
          translationPath = args[0];
        }
        break;
      default:
        if (args.length % 2) {
          translationPath = args[0];
          var i = 1;
        } else {
          language = args[0];
          translationPath = args[1];
          var i = 2;
        }
        for (i; i < args.length - 1; i+=2) {
          translationInput[args[i]] = args[i + 1];
        }
        break;
    }

    var viewPath = '__' + language + '_' + translationPath.replace(/\./g, '_');
    var viewFn = app.view.getFns[viewPath];
    if (viewFn) return viewFn(translationInput);
    var translation = this.model.at('$lang.translations').at(language).get(translationPath);
    viewFn = Function('MessageFormat', 'return ' + translation)({locale: {en: function(){} }});
    app.view.fn(viewPath, viewFn);
    return viewFn(translationInput);
  });
};
},{}],48:[function(require,module,exports){

/**
 * Module dependencies.
 */

var utils = require('../utils');

/**
 * Expose `Route`.
 */

module.exports = Route;

/**
 * Initialize `Route` with the given HTTP `method`, `path`,
 * and an array of `callbacks` and `options`.
 *
 * Options:
 *
 *   - `sensitive`    enable case-sensitive routes
 *   - `strict`       enable strict matching for trailing slashes
 *
 * @param {String} method
 * @param {String} path
 * @param {Array} callbacks
 * @param {Object} options.
 * @api private
 */

function Route(method, path, callbacks, options) {
  options = options || {};
  this.path = path;
  this.method = method;
  this.callbacks = callbacks;
  this.regexp = utils.pathRegexp(path
    , this.keys = []
    , options.sensitive
    , options.strict);
}

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Route.prototype.match = function(path){
  var keys = this.keys
    , params = this.params = []
    , m = this.regexp.exec(path);

  if (!m) return false;

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = keys[i - 1];

    var val = 'string' == typeof m[i]
      ? decodeURIComponent(m[i])
      : m[i];

    if (key) {
      params[key.name] = val;
    } else {
      params.push(val);
    }
  }

  return true;
};

},{"../utils":66}],64:[function(require,module,exports){
module.exports = {
  quot: 0x0022
, amp: 0x0026
, apos: 0x0027
, lpar: 0x0028
, rpar: 0x0029
, lt: 0x003C
, gt: 0x003E
, nbsp: 0x00A0
, iexcl: 0x00A1
, cent: 0x00A2
, pound: 0x00A3
, curren: 0x00A4
, yen: 0x00A5
, brvbar: 0x00A6
, sect: 0x00A7
, uml: 0x00A8
, copy: 0x00A9
, ordf: 0x00AA
, laquo: 0x00AB
, not: 0x00AC
, shy: 0x00AD
, reg: 0x00AE
, macr: 0x00AF
, deg: 0x00B0
, plusmn: 0x00B1
, sup2: 0x00B2
, sup3: 0x00B3
, acute: 0x00B4
, micro: 0x00B5
, para: 0x00B6
, middot: 0x00B7
, cedil: 0x00B8
, sup1: 0x00B9
, ordm: 0x00BA
, raquo: 0x00BB
, frac14: 0x00BC
, frac12: 0x00BD
, frac34: 0x00BE
, iquest: 0x00BF
, Agrave: 0x00C0
, Aacute: 0x00C1
, Acirc: 0x00C2
, Atilde: 0x00C3
, Auml: 0x00C4
, Aring: 0x00C5
, AElig: 0x00C6
, Ccedil: 0x00C7
, Egrave: 0x00C8
, Eacute: 0x00C9
, Ecirc: 0x00CA
, Euml: 0x00CB
, Igrave: 0x00CC
, Iacute: 0x00CD
, Icirc: 0x00CE
, Iuml: 0x00CF
, ETH: 0x00D0
, Ntilde: 0x00D1
, Ograve: 0x00D2
, Oacute: 0x00D3
, Ocirc: 0x00D4
, Otilde: 0x00D5
, Ouml: 0x00D6
, times: 0x00D7
, Oslash: 0x00D8
, Ugrave: 0x00D9
, Uacute: 0x00DA
, Ucirc: 0x00DB
, Uuml: 0x00DC
, Yacute: 0x00DD
, THORN: 0x00DE
, szlig: 0x00DF
, agrave: 0x00E0
, aacute: 0x00E1
, acirc: 0x00E2
, atilde: 0x00E3
, auml: 0x00E4
, aring: 0x00E5
, aelig: 0x00E6
, ccedil: 0x00E7
, egrave: 0x00E8
, eacute: 0x00E9
, ecirc: 0x00EA
, euml: 0x00EB
, igrave: 0x00EC
, iacute: 0x00ED
, icirc: 0x00EE
, iuml: 0x00EF
, eth: 0x00F0
, ntilde: 0x00F1
, ograve: 0x00F2
, oacute: 0x00F3
, ocirc: 0x00F4
, otilde: 0x00F5
, ouml: 0x00F6
, divide: 0x00F7
, oslash: 0x00F8
, ugrave: 0x00F9
, uacute: 0x00FA
, ucirc: 0x00FB
, uuml: 0x00FC
, yacute: 0x00FD
, thorn: 0x00FE
, yuml: 0x00FF
, OElig: 0x0152
, oelig: 0x0153
, Scaron: 0x0160
, scaron: 0x0161
, Yuml: 0x0178
, fnof: 0x0192
, circ: 0x02C6
, tilde: 0x02DC
, Alpha: 0x0391
, Beta: 0x0392
, Gamma: 0x0393
, Delta: 0x0394
, Epsilon: 0x0395
, Zeta: 0x0396
, Eta: 0x0397
, Theta: 0x0398
, Iota: 0x0399
, Kappa: 0x039A
, Lambda: 0x039B
, Mu: 0x039C
, Nu: 0x039D
, Xi: 0x039E
, Omicron: 0x039F
, Pi: 0x03A0
, Rho: 0x03A1
, Sigma: 0x03A3
, Tau: 0x03A4
, Upsilon: 0x03A5
, Phi: 0x03A6
, Chi: 0x03A7
, Psi: 0x03A8
, Omega: 0x03A9
, alpha: 0x03B1
, beta: 0x03B2
, gamma: 0x03B3
, delta: 0x03B4
, epsilon: 0x03B5
, zeta: 0x03B6
, eta: 0x03B7
, theta: 0x03B8
, iota: 0x03B9
, kappa: 0x03BA
, lambda: 0x03BB
, mu: 0x03BC
, nu: 0x03BD
, xi: 0x03BE
, omicron: 0x03BF
, pi: 0x03C0
, rho: 0x03C1
, sigmaf: 0x03C2
, sigma: 0x03C3
, tau: 0x03C4
, upsilon: 0x03C5
, phi: 0x03C6
, chi: 0x03C7
, psi: 0x03C8
, omega: 0x03C9
, thetasym: 0x03D1
, upsih: 0x03D2
, piv: 0x03D6
, ensp: 0x2002
, emsp: 0x2003
, thinsp: 0x2009
, zwnj: 0x200C
, zwj: 0x200D
, lrm: 0x200E
, rlm: 0x200F
, ndash: 0x2013
, mdash: 0x2014
, lsquo: 0x2018
, rsquo: 0x2019
, sbquo: 0x201A
, ldquo: 0x201C
, rdquo: 0x201D
, bdquo: 0x201E
, dagger: 0x2020
, Dagger: 0x2021
, bull: 0x2022
, hellip: 0x2026
, permil: 0x2030
, prime: 0x2032
, Prime: 0x2033
, lsaquo: 0x2039
, rsaquo: 0x203A
, oline: 0x203E
, frasl: 0x2044
, euro: 0x20AC
, image: 0x2111
, weierp: 0x2118
, real: 0x211C
, trade: 0x2122
, alefsym: 0x2135
, larr: 0x2190
, uarr: 0x2191
, rarr: 0x2192
, darr: 0x2193
, harr: 0x2194
, crarr: 0x21B5
, lArr: 0x21D0
, uArr: 0x21D1
, rArr: 0x21D2
, dArr: 0x21D3
, hArr: 0x21D4
, forall: 0x2200
, part: 0x2202
, exist: 0x2203
, empty: 0x2205
, nabla: 0x2207
, isin: 0x2208
, notin: 0x2209
, ni: 0x220B
, prod: 0x220F
, sum: 0x2211
, minus: 0x2212
, lowast: 0x2217
, radic: 0x221A
, prop: 0x221D
, infin: 0x221E
, ang: 0x2220
, and: 0x2227
, or: 0x2228
, cap: 0x2229
, cup: 0x222A
, int: 0x222B
, there4: 0x2234
, sim: 0x223C
, cong: 0x2245
, asymp: 0x2248
, ne: 0x2260
, equiv: 0x2261
, le: 0x2264
, ge: 0x2265
, sub: 0x2282
, sup: 0x2283
, nsub: 0x2284
, sube: 0x2286
, supe: 0x2287
, oplus: 0x2295
, otimes: 0x2297
, perp: 0x22A5
, sdot: 0x22C5
, lceil: 0x2308
, rceil: 0x2309
, lfloor: 0x230A
, rfloor: 0x230B
, lang: 0x2329
, rang: 0x232A
, loz: 0x25CA
, spades: 0x2660
, clubs: 0x2663
, hearts: 0x2665
, diams: 0x2666
}

},{}],65:[function(require,module,exports){
var startTag = /^<([^\s=\/!>]+)((?:\s+[^\s=\/>]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+)?)?)*)\s*(\/?)\s*>/
  , endTag = /^<\/([^\s=\/!>]+)[^>]*>/
  , comment = /^<!--([\s\S]*?)-->/
  , commentInside = /<!--[\s\S]*?-->/
  , other = /^<([\s\S]*?)>/
  , attr = /([^\s=]+)(?:\s*(=)\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+))?)?/g
  , rawTagsDefault = /^(style|script)$/i

function empty() {}

function matchEndDefault(tagName) {
  return new RegExp('</' + tagName, 'i')
}

function onStartTag(html, match, handler) {
  var attrs = {}
    , tag = match[0]
    , tagName = match[1]
    , remainder = match[2]
  html = html.slice(tag.length)

  remainder.replace(attr, function(match, name, equals, attr0, attr1, attr2) {
    attrs[name.toLowerCase()] = attr0 || attr1 || attr2 || (equals ? '' : null)
  })
  handler(tag, tagName.toLowerCase(), attrs, html)

  return html
}

function onTag(html, match, handler) {
  var tag = match[0]
    , data = match[1]
  html = html.slice(tag.length)

  handler(tag, data, html)

  return html
}

function onText(html, index, isRawText, handler) {
  var text
  if (~index) {
    text = html.slice(0, index)
    html = html.slice(index)
  } else {
    text = html
    html = ''
  }

  if (text) handler(text, isRawText, html)

  return html
}

function rawEnd(html, ending, offset) {
  offset || (offset = 0)
  var index = html.search(ending)
    , commentMatch = html.match(commentInside)
    , commentEnd
  // Make sure that the ending condition isn't inside of an HTML comment
  if (commentMatch && commentMatch.index < index) {
    commentEnd = commentMatch.index + commentMatch[0].length
    offset += commentEnd
    html = html.slice(commentEnd)
    return rawEnd(html, ending, offset)
  }
  return index + offset
}

module.exports = function(html, options) {
  if (options == null) options = {}

  if (!html) return

  var startHandler = options.start || empty
    , endHandler = options.end || empty
    , textHandler = options.text || empty
    , commentHandler = options.comment || empty
    , otherHandler = options.other || empty
    , matchEnd = options.matchEnd || matchEndDefault
    , errorHandler = options.error
    , rawTags = options.rawTags || rawTagsDefault
    , index, last, match, tagName, err

  while (html) {
    if (html === last) {
      err = new Error('HTML parse error: ' + html)
      if (errorHandler) {
        errorHandler(err)
      } else {
        throw err
      }
    }
    last = html

    if (html[0] === '<') {
      if (match = html.match(startTag)) {
        html = onStartTag(html, match, startHandler)

        tagName = match[1]
        if (rawTags.test(tagName)) {
          index = rawEnd(html, matchEnd(tagName))
          html = onText(html, index, true, textHandler)
        }
        continue
      }

      if (match = html.match(endTag)) {
        match[1] = match[1].toLowerCase()  // tagName
        html = onTag(html, match, endHandler)
        continue
      }

      if (match = html.match(comment)) {
        html = onTag(html, match, commentHandler)
        continue
      }

      if (match = html.match(other)) {
        html = onTag(html, match, otherHandler)
        continue
      }
    }

    index = html.indexOf('<')
    html = onText(html, index, false, textHandler)
  }
}

},{}],67:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('./util');

module.exports = Channel;

function Channel(socket) {
  EventEmitter.call(this);

  this.socket = socket;
  this.messages = new Messages;

  var channel = this;
  var onmessage = socket.onmessage;
  socket.onmessage = function(data) {
    if (data && data.racer) return channel._onMessage(data);
    onmessage && onmessage.call(socket, data);
  };
}

util.mergeInto(Channel.prototype, EventEmitter.prototype);

Channel.prototype.send = function(name, data, cb) {
  var message = this.messages.add(name, data, cb);
  // Proactively call the toJSON function, since the Google Closure JSON
  // serializer doesn't check for it
  this.socket.send(message.toJSON());
};

Channel.prototype._reply = function(id, name, data) {
  var message = new Message(id, true, name, data);
  this.socket.send(message.toJSON());
};

Channel.prototype._onMessage = function(data) {
  if (data.ack) {
    var message = this.messages.remove(data.id);
    if (message && message.cb) message.cb.apply(data.data);
    return;
  }
  var name = data.racer;
  if (data.cb) {
    var channel = this;
    var hasListeners = this.emit(name, data.data, function() {
      var args = Array.prototype.slice.call(arguments);
      channel._reply(data.id, name, args);
    });
    if (!hasListeners) this._reply(data.id, name);
  } else {
    this.emit(name, data.data);
    this._reply(data.id, name);
  }
};

function MessagesMap() {}

function Messages() {
  this.map = new MessagesMap();
  this.idCount = 0;
}
Messages.prototype.id = function() {
  return (++this.idCount).toString(36);
};
Messages.prototype.add = function(name, data, cb) {
  var message = new Message(this.id(), false, name, data, cb);
  this.map[message.id] = message;
  return message;
};
Messages.prototype.remove = function(id) {
  var message = this.map[id];
  delete this.map[id];
  return message;
};

function Message(id, ack, name, data, cb) {
  this.id = id;
  this.ack = ack;
  this.name = name;
  this.data = data;
  this.cb = cb;
}
Message.prototype.toJSON = function() {
  return {
    racer: this.name
  , id: this.id
  , data: this.data
  , ack: +this.ack
  , cb: (this.cb) ? 1 : 0
  };
};

},{"events":9,"./util":10}],57:[function(require,module,exports){
var Doc = require('./Doc');
var util = require('../util');

module.exports = LocalDoc;

function LocalDoc(model, collectionName, id, snapshot) {
  Doc.call(this, model, collectionName, id);
  this.snapshot = snapshot;
  this._updateCollectionData();
}

LocalDoc.prototype = new Doc;

LocalDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.snapshot;
};

LocalDoc.prototype.set = function(segments, value, cb) {
  function set(node, key) {
    var previous = node[key];
    node[key] = value;
    return previous;
  }
  return this._apply(segments, set, cb);
};

LocalDoc.prototype.del = function(segments, cb) {
  // Don't do anything if the value is already undefined, since
  // apply creates objects as it traverses, and the del method
  // should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  function del(node, key) {
    delete node[key];
    return previous;
  }
  return this._apply(segments, del, cb);
};

LocalDoc.prototype.increment = function(segments, byNumber, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'number' || value == null) return;
    return new TypeError(self._errorMessage(
      'increment on non-number', segments, value
    ));
  }
  function increment(node, key) {
    var value = (node[key] || 0) + byNumber;
    node[key] = value;
    return value;
  }
  return this._validatedApply(segments, validate, increment, cb);
};

LocalDoc.prototype.push = function(segments, value, cb) {
  function push(arr) {
    return arr.push(value);
  }
  return this._arrayApply(segments, push, cb);
};

LocalDoc.prototype.unshift = function(segments, value, cb) {
  function unshift(arr) {
    return arr.unshift(value);
  }
  return this._arrayApply(segments, unshift, cb);
};

LocalDoc.prototype.insert = function(segments, index, values, cb) {
  function insert(arr) {
    arr.splice.apply(arr, [index, 0].concat(values));
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

LocalDoc.prototype.pop = function(segments, cb) {
  function pop(arr) {
    return arr.pop();
  }
  return this._arrayApply(segments, pop, cb);
};

LocalDoc.prototype.shift = function(segments, cb) {
  function shift(arr) {
    return arr.shift();
  }
  return this._arrayApply(segments, shift, cb);
};

LocalDoc.prototype.remove = function(segments, index, howMany, cb) {
  function remove(arr) {
    return arr.splice(index, howMany);
  }
  return this._arrayApply(segments, remove, cb);
};

LocalDoc.prototype.move = function(segments, from, to, howMany, cb) {
  function move(arr) {
    // Remove from old location
    var values = arr.splice(from, howMany);
    // Insert in new location
    arr.splice.apply(arr, [to, 0].concat(values));
    return values;
  }
  return this._arrayApply(segments, move, cb);
};

LocalDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringInsert on non-string', segments, value
    ));
  }
  function stringInsert(node, key) {
    var previous = node[key];
    if (previous == null) {
      node[key] = value;
      return previous;
    }
    node[key] = previous.slice(0, index) + value + previous.slice(index);
    return previous;
  }
  return this._validatedApply(segments, validate, stringInsert, cb);
};

LocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringRemove on non-string', segments, value
    ));
  }
  function stringRemove(node, key) {
    var previous = node[key];
    if (previous == null) return previous;
    if (index < 0) index += previous.length;
    node[key] = previous.slice(0, index) + previous.slice(index + howMany);
    return previous;
  }
  return this._validatedApply(segments, validate, stringRemove, cb);
};

LocalDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.snapshot);
};

/**
 * @param {Array} segments is the array representing a path
 * @param {Function} fn(node, key) applies a mutation on node[key]
 * @return {Object} returns the return value of fn(node, key)
 */
LocalDoc.prototype._createImplied = function(segments, fn) {
  var node = this;
  var key = 'snapshot';
  var i = 0;
  var nextKey = segments[i++];
  while (nextKey != null) {
    // Get or create implied object or array
    node = node[key] || (node[key] = /^\d+$/.test(nextKey) ? [] : {});
    key = nextKey;
    nextKey = segments[i++];
  }
  return fn(node, key);
};

LocalDoc.prototype._apply = function(segments, fn, cb) {
  var out = this._createImplied(segments, fn);
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {
  var out = this._createImplied(segments, function(node, key) {
    var err = validate(node[key]);
    if (err) return cb(err);
    return fn(node, key);
  });
  this._updateCollectionData();
  cb();
  return out;
};

LocalDoc.prototype._arrayApply = function(segments, fn, cb) {
  // Lookup a pointer to the property or nested property &
  // return the current value or create a new array
  var arr = this._createImplied(segments, nodeCreateArray);

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr);
  this._updateCollectionData();
  cb();
  return out;
};

function nodeCreateArray(node, key) {
  return node[key] || (node[key] = []);
}

},{"./Doc":68,"../util":10}],69:[function(require,module,exports){
/**
 * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator
 * interface.
 *
 * 1. It maps Racer's mutator methods to outgoing ShareJS operations.
 * 2. It maps incoming ShareJS operations to Racer events.
 */

var Doc = require('./Doc');
var util = require('../util');

module.exports = RemoteDoc;

function RemoteDoc(model, collectionName, id, data) {
  Doc.call(this, model, collectionName, id);
  var shareDoc = this.shareDoc = model._getOrCreateShareDoc(collectionName, id, data);
  this.createdLocally = false;
  this.model = model = model.pass({$remote: true});
  this._passStringInsert = model.pass({$original: 'stringInsert'})._pass;
  this._passStringRemove = model.pass({$original: 'stringRemove'})._pass;
  this._updateCollectionData();

  var doc = this;
  shareDoc.on('op', function(op, isLocal) {
    // Don't emit on local operations, since they are emitted in the mutator
    if (isLocal) return;
    doc._updateCollectionData();
    doc._onOp(op);
  });
  shareDoc.on('del', function(isLocal, previous) {
    // Calling the shareDoc.del method does not emit an operation event,
    // so we create the appropriate event here.
    if (isLocal) return;
    doc._updateCollectionData();
    model.emit('change', [collectionName, id], [void 0, previous, model._pass]);
  });
  shareDoc.on('create', function(isLocal) {
    // Local creates should not emit an event, since they only happen
    // implicitly as a result of another mutation, and that operation will
    // emit the appropriate event. Remote creates can set the snapshot data
    // without emitting an operation event, so an event needs to be emitted
    // for them.
    if (isLocal) {
      // Track when a document was created by this client, so that we don't
      // emit a load event when subsequently subscribed
      doc.createdLocally = true;
      return;
    }
    doc._updateCollectionData();
    var value = shareDoc.snapshot;
    model.emit('change', [collectionName, id], [value, void 0, model._pass]);
  });
}

RemoteDoc.prototype = new Doc;

RemoteDoc.prototype._updateCollectionData = function() {
  this.collectionData[this.id] = this.shareDoc.snapshot;
};

RemoteDoc.prototype.set = function(segments, value, cb) {
  if (segments.length === 0 && !this.shareDoc.type) {
    this.shareDoc.create('json0', value, cb);
    this._updateCollectionData();
    return;
  }
  var previous = this._createImplied(segments);
  var lastSegment = segments[segments.length - 1];
  if (previous instanceof ImpliedOp) {
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  var op = (isArrayIndex(lastSegment)) ?
    (previous == null) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :
    (previous == null) ?
      [new ObjectInsertOp(segments, value)] :
      [new ObjectReplaceOp(segments, previous, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.del = function(segments, cb) {
  if (segments.length === 0) {
    var previous = this.get();
    this.shareDoc.del(cb);
    this._updateCollectionData();
    return previous;
  }
  // Don't do anything if the value is already undefined, since
  // the del method should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  var op = [new ObjectDeleteOp(segments, previous)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.increment = function(segments, byNumber, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = byNumber;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :
      [new ObjectInsertOp(segments, byNumber)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return byNumber;
  }
  var op = [new IncrementOp(segments, byNumber)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous + byNumber;
};

RemoteDoc.prototype.push = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function push(arr, fnCb) {
    var op = [new ListInsertOp(segments, arr.length, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, push, cb);
};

RemoteDoc.prototype.unshift = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function unshift(arr, fnCb) {
    var op = [new ListInsertOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, unshift, cb);
};

RemoteDoc.prototype.insert = function(segments, index, values, cb) {
  var shareDoc = this.shareDoc;
  function insert(arr, fnCb) {
    var op = createInsertOp(segments, index, values);
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

function createInsertOp(segments, index, values) {
  if (!Array.isArray(values)) {
    return [new ListInsertOp(segments, index, values)];
  }
  var op = [];
  for (var i = 0, len = values.length; i < len; i++) {
    op.push(new ListInsertOp(segments, index++, values[i]));
  }
  return op;
}

RemoteDoc.prototype.pop = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function pop(arr, fnCb) {
    var index = arr.length - 1;
    var value = arr[index];
    var op = [new ListRemoveOp(segments, index, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, pop, cb);
};

RemoteDoc.prototype.shift = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function shift(arr, fnCb) {
    var value = arr[0];
    var op = [new ListRemoveOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, shift, cb);
};

RemoteDoc.prototype.remove = function(segments, index, howMany, cb) {
  var shareDoc = this.shareDoc;
  function remove(arr, fnCb) {
    var values = arr.slice(index, index + howMany);
    var op = [];
    for (var i = 0, len = values.length; i < len; i++) {
      op.push(new ListRemoveOp(segments, index, values[i]));
    }
    shareDoc.submitOp(op, fnCb);
    return values;
  }
  return this._arrayApply(segments, remove, cb);
};

RemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {
  var shareDoc = this.shareDoc;
  function move(arr, fnCb) {
    // Get the return value
    var values = arr.slice(from, from + howMany);

    // Build an op that moves each item individually
    var op = [];
    for (var i = 0; i < howMany; i++) {
      op.push(new ListMoveOp(segments, (from < to) ? from : from + howMany - 1, (from < to) ? to + howMany - 1 : to));
    }
    shareDoc.submitOp(op, fnCb);

    return values;
  }
  return this._arrayApply(segments, move, cb);
};

RemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) {
    var lastSegment = segments[segments.length - 1];
    previous.value[lastSegment] = value;
    this.shareDoc.submitOp(previous.op, cb);
    this._updateCollectionData();
    return;
  }
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ObjectInsertOp(segments, value)];
    this.shareDoc.submitOp(op, cb);
    this._updateCollectionData();
    return previous;
  }
  var op = [new StringInsertOp(segments, index, value)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var previous = this._createImplied(segments);
  if (previous instanceof ImpliedOp) return;
  if (previous == null) return previous;
  var removed = previous.slice(index, index + howMany);
  var op = [new StringRemoveOp(segments, index, removed)];
  this.shareDoc.submitOp(op, cb);
  this._updateCollectionData();
  return previous;
};

RemoteDoc.prototype.get = function(segments) {
  return util.lookup(segments, this.shareDoc.snapshot);
};

RemoteDoc.prototype._createImplied = function(segments) {
  if (!this.shareDoc.type) {
    this.shareDoc.create('json0');
  }
  var parent = this.shareDoc;
  var key = 'snapshot';
  var node = parent[key];
  var i = 0;
  var nextKey = segments[i++];
  var op, value;
  while (nextKey != null) {
    if (!node) {
      if (op) {
        value = value[key] = isArrayIndex(nextKey) ? [] : {};
      } else {
        value = isArrayIndex(nextKey) ? [] : {};
        op = (Array.isArray(parent)) ?
          new ListInsertOp(segments.slice(0, i - 2), key, value) :
          new ObjectInsertOp(segments.slice(0, i - 1), value);
      }
      node = value;
    }
    parent = node;
    key = nextKey;
    node = parent[key];
    nextKey = segments[i++];
  }
  if (op) return new ImpliedOp(op, value);
  return node;
};

function ImpliedOp(op, value) {
  this.op = op;
  this.value = value;
}

RemoteDoc.prototype._arrayApply = function(segments, fn, cb) {
  var arr = this._createImplied(segments);
  if (arr instanceof ImpliedOp) {
    this.shareDoc.submitOp(arr.op);
    arr = this.get(segments);
  } else if (arr == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :
      [new ObjectInsertOp(segments, [])];
    this.shareDoc.submitOp(op);
    arr = this.get(segments);
  }

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr, cb);
  this._updateCollectionData();
  return out;
};

RemoteDoc.prototype._onOp = function(op) {
  var item = op[0];
  var segments = [this.collectionName, this.id].concat(item.p);
  var model = this.model;

  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp
  if (defined(item.oi) || defined(item.od)) {
    var value = item.oi;
    var previous = item.od;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListReplaceOp
  } else if (defined(item.li) && defined(item.ld)) {
    var value = item.li;
    var previous = item.ld;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListInsertOp
  } else if (defined(item.li)) {
    var index = segments[segments.length - 1];
    var values = [item.li];
    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);

  // ListRemoveOp
  } else if (defined(item.ld)) {
    var index = segments[segments.length - 1];
    var removed = [item.ld];
    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);

  // ListMoveOp
  } else if (defined(item.lm)) {
    var from = segments[segments.length - 1];
    var to = item.lm - 1;
    var howMany = 1;
    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);

  // StringInsertOp
  } else if (defined(item.si)) {
    var index = segments[segments.length - 1];
    var text = item.si;
    segments = segments.slice(0, -1);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + value.slice(index + text.length);
    model.emit('change', segments, [value, previous, this._passStringInsert]);

  // StringRemoveOp
  } else if (defined(item.sd)) {
    var index = segments[segments.length - 1];
    var text = item.sd;
    var howMany = text.length;
    segments = segments.slice(0, -1);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + text + value.slice(index);
    model.emit('change', segments, [value, previous, this._passStringRemove]);

  // IncrementOp
  } else if (defined(item.na)) {
    var value = this.get(item.p);
    var previous = value - item.na;
    model.emit('change', segments, [value, previous, model._pass]);
  }
};

function ObjectReplaceOp(segments, before, after) {
  this.p = castSegments(segments);
  this.od = before;
  this.oi = (after === void 0) ? null : after;
}
function ObjectInsertOp(segments, value) {
  this.p = castSegments(segments);
  this.oi = (value === void 0) ? null : value;
}
function ObjectDeleteOp(segments, value) {
  this.p = castSegments(segments);
  this.od = (value === void 0) ? null : value;
}
function ListReplaceOp(segments, index, before, after) {
  this.p = castSegments(segments.concat(index));
  this.ld = before;
  this.li = (after === void 0) ? null : after;
}
function ListInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.li = (value === void 0) ? null : value;
}
function ListRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.ld = (value === void 0) ? null : value;
}
function ListMoveOp(segments, from, to) {
  this.p = castSegments(segments.concat(from));
  this.lm = to;
}
function StringInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.si = value;
}
function StringRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.sd = value;
}
function IncrementOp(segments, byNumber) {
  this.p = castSegments(segments);
  this.na = byNumber;
}

function defined(value) {
  return value !== void 0;
}

function castSegments(segments) {
  // Cast number path segments from strings to numbers
  for (var i = segments.length; i--;) {
    var segment = segments[i];
    if (typeof segment === 'string' && isArrayIndex(segment)) {
      segments[i] = +segment;
    }
  }
  return segments;
}

function isArrayIndex(segment) {
  return (/^[0-9]+$/).test(segment);
}

},{"./Doc":68,"../util":10}],70:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],71:[function(require,module,exports){
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInNewContext = function (context) {
    if (!context) context = {};
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
     
    if (!win.eval && win.execScript) {
        // win.eval() magically appears when this is called in IE:
        win.execScript('null');
    }
    
    var res = win.eval(this.code);
    
    forEach(Object_keys(win), function (key) {
        context[key] = win[key];
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInContext = function (context) {
    // seems to be just runInNewContext on magical context objects which are
    // otherwise indistinguishable from objects except plain old objects
    // for the parameter segfaults node
    return this.runInNewContext(context);
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    // not really sure what this one does
    // seems to just make a shallow copy
    var copy = {};
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],66:[function(require,module,exports){
(function(){
/**
 * Module dependencies.
 */

/**
 * toString ref.
 */

var toString = {}.toString;

/**
 * Return ETag for `body`.
 *
 * @param {String|Buffer} body
 * @return {String}
 * @api private
 */

exports.etag = function(body){
  return '"' + crc32.signed(body) + '"';
};

/**
 * Make `locals()` bound to the given `obj`.
 *
 * This is used for `app.locals` and `res.locals`.
 *
 * @param {Object} obj
 * @return {Function}
 * @api private
 */

exports.locals = function(obj){
  function locals(obj){
    for (var key in obj) locals[key] = obj[key];
    return obj;
  };

  return locals;
};

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function(path){
  if ('/' == path[0]) return true;
  if (':' == path[1] && '\\' == path[2]) return true;
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = function(arr, ret){
  var ret = ret || []
    , len = arr.length;
  for (var i = 0; i < len; ++i) {
    if (Array.isArray(arr[i])) {
      exports.flatten(arr[i], ret);
    } else {
      ret.push(arr[i]);
    }
  }
  return ret;
};

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function(type){
  return ~type.indexOf('/')
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function(types){
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Return the acceptable type in `types`, if any.
 *
 * @param {Array} types
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.acceptsArray = function(types, str){
  // accept anything when Accept is not present
  if (!str) return types[0];

  // parse
  var accepted = exports.parseAccept(str)
    , normalized = exports.normalizeTypes(types)
    , len = accepted.length;

  for (var i = 0; i < len; ++i) {
    for (var j = 0, jlen = types.length; j < jlen; ++j) {
      if (exports.accept(normalized[j], accepted[i])) {
        return types[j];
      }
    }
  }
};

/**
 * Check if `type(s)` are acceptable based on
 * the given `str`.
 *
 * @param {String|Array} type(s)
 * @param {String} str
 * @return {Boolean|String}
 * @api private
 */

exports.accepts = function(type, str){
  if ('string' == typeof type) type = type.split(/ *, */);
  return exports.acceptsArray(type, str);
};

/**
 * Check if `type` array is acceptable for `other`.
 *
 * @param {Object} type
 * @param {Object} other
 * @return {Boolean}
 * @api private
 */

exports.accept = function(type, other){
  var t = type.value.split('/');
  return (t[0] == other.type || '*' == other.type)
    && (t[1] == other.subtype || '*' == other.subtype)
    && paramsEqual(type.params, other.params);
};

/**
 * Check if accept params are equal.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Boolean}
 * @api private
 */

function paramsEqual(a, b){
  return !Object.keys(a).some(function(k) {
    return a[k] != b[k];
  });
}

/**
 * Parse accept `str`, returning
 * an array objects containing
 * `.type` and `.subtype` along
 * with the values provided by
 * `parseQuality()`.
 *
 * @param {Type} name
 * @return {Type}
 * @api private
 */

exports.parseAccept = function(str){
  return exports
    .parseParams(str)
    .map(function(obj){
      var parts = obj.value.split('/');
      obj.type = parts[0];
      obj.subtype = parts[1];
      return obj;
    });
};

/**
 * Parse quality `str`, returning an
 * array of objects with `.value`,
 * `.quality` and optional `.params`
 *
 * @param {String} str
 * @return {Array}
 * @api private
 */

exports.parseParams = function(str){
  return str
    .split(/ *, */)
    .map(acceptParams)
    .filter(function(obj){
      return obj.quality;
    })
    .sort(function(a, b){
      if (a.quality === b.quality) {
        return a.originalIndex - b.originalIndex;
      } else {
        return b.quality - a.quality;
      }
    });
};

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' == pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Escape special characters in the given string of html.
 *
 * @param  {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html) {
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
};

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Boolean} sensitive
 * @param  {Boolean} strict
 * @return {RegExp}
 * @api private
 */

exports.pathRegexp = function(path, keys, sensitive, strict) {
  if (toString.call(path) == '[object RegExp]') return path;
  if (Array.isArray(path)) path = '(' + path.join('|') + ')';
  path = path
    .concat(strict ? '' : '/?')
    .replace(/\/\(/g, '(?:/')
    .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, optional, star){
      keys.push({ name: key, optional: !! optional });
      slash = slash || '';
      return ''
        + (optional ? '' : slash)
        + '(?:'
        + (optional ? slash : '')
        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'
        + (optional || '')
        + (star ? '(/*)?' : '');
    })
    .replace(/([\/.])/g, '\\$1')
    .replace(/\*/g, '(.*)');
  return new RegExp('^' + path + '$', sensitive ? '' : 'i');
}

})()
},{}],34:[function(require,module,exports){
var share = require('share/lib/client');
var Channel = require('../Channel');
var Model = require('./Model');
var LocalDoc = require('./LocalDoc');
var RemoteDoc = require('./RemoteDoc');

Model.prototype._createConnection = function(bundle) {
  // Model::_createSocket should be defined by the socket plugin
  this.root.socket = this._createSocket(bundle);

  // The Share connection will bind to the socket by defining the onopen,
  // onmessage, etc. methods
  var shareConnection = this.root.shareConnection = new share.Connection(this.root.socket);
  var segments = ['$connection', 'state'];
  var states = ['connecting', 'connected', 'disconnected', 'stopped'];
  var model = this;
  states.forEach(function(state) {
    shareConnection.on(state, function() {
      model._set(segments, state);
    });
  });
  this._set(segments, 'connected');

  // Wrap the socket methods on top of Share's methods
  this._createChannel();
};

Model.prototype.connect = function() {
  this.root.socket.open();
};
Model.prototype.disconnect = function() {
  this.root.socket.close();
};
Model.prototype.reconnect = function() {
  this.disconnect();
  this.connect();
};

Model.prototype._createChannel = function() {
  this.root.channel = new Channel(this.root.socket);
};

Model.prototype._getOrCreateShareDoc = function(collectionName, id, data) {
  var shareDoc = this.root.shareConnection.get(collectionName, id, data);
  shareDoc.incremental = true;
  return shareDoc;
};

Model.prototype._getDocConstructor = function(name) {
  // Whether the collection is local or remote is determined by its name.
  // Collections starting with an underscore ('_') are for user-defined local
  // collections, those starting with a dollar sign ('$'') are for
  // framework-defined local collections, and all others are remote.
  var firstCharcter = name.charAt(0);
  var isLocal = (firstCharcter === '_' || firstCharcter === '$');
  return (isLocal) ? LocalDoc : RemoteDoc;
};

},{"../Channel":67,"./Model":28,"./LocalDoc":57,"./RemoteDoc":69,"share/lib/client":72}],28:[function(require,module,exports){
var uuid = require('node-uuid');

Model.INITS = [];

module.exports = Model;

function Model(options) {
  this.root = this;

  var inits = Model.INITS;
  options || (options = {});
  for (var i = 0; i < inits.length; i++) {
    inits[i](this, options);
  }
}

Model.prototype.id = function() {
  return uuid.v4();
};

Model.prototype._child = function() {
  return new ChildModel(this);
};

function ChildModel(model) {
  // Shared properties should be accessed via the root. This makes inheritance
  // cheap and easily extensible
  this.root = model.root;

  // EventEmitter methods access these properties directly, so they must be
  // inherited manually instead of via the root
  this._events = model._events;
  this._maxListeners = model._maxListeners;

  // Properties specific to a child instance
  this._context = model._context;
  this._at = model._at;
  this._pass = model._pass;
  this._silent = model._silent;
}
ChildModel.prototype = new Model;

},{"node-uuid":73}],68:[function(require,module,exports){
module.exports = Doc;

function Doc(model, collectionName, id) {
  this.collectionName = collectionName;
  this.id = id;
  this.collectionData = model && model.data[collectionName];
}

Doc.prototype.path = function(segments) {
  return this.collectionName + '.' + this.id + '.' + segments.join('.');
};

Doc.prototype._errorMessage = function(description, segments, value) {
  return description + ' at ' + this.path(segments) + ': ' +
    JSON.stringify(value, null, 2);
};

},{}],33:[function(require,module,exports){
var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');

Model.prototype.setDiff = function() {
  var subpath, value, options, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    value = arguments[1];
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
    } else {
      options = arguments[2];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    options = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._setDiff(segments, value, options, cb);
};
Model.prototype._setDiff = function(segments, value, options, cb) {
  segments = this._dereference(segments);
  var equalFn = (options && options.equal) || util.equal;
  var isEach = options && options.each;
  var model = this;
  function setDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (equalFn(before, value)) return fnCb();
    var group = util.asyncGroup(fnCb);
    doDiff(model, doc, segments, before, value, equalFn, group, isEach);
  }
  return this._mutate(segments, setDiff, cb);
};
Model.prototype._setArrayDiff = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setArrayDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (before === value) return fnCb();
    if (!Array.isArray(before) || !Array.isArray(value)) {
      applySet(model, doc, segments, value, fnCb);
      return;
    }
    var diff = arrayDiff(before, value);
    if (!diff.length) return fnCb();
    var group = util.asyncGroup(fnCb);
    applyArrayDiff(model, doc, segments, diff, group);
  }
  return this._mutate(segments, setArrayDiff, cb);
};

/**
 * @param {Object} doc
 * @param {String} doc.collectionName
 * @param {String} doc.id
 * @param {Object} doc.snapshot
 * @param {Array} segments
 * @param {Object} before
 * @param {Object} after
 * @param {Function} group
 * @param {Boolean} isEach
 */
function doDiff(model, doc, segments, before, after, equalFn, group, isEach) {
  if (typeof before !== 'object' || !before ||
      typeof after !== 'object' || !after) {
    // Set the entire value if not diffable
    applySet(model, doc, segments, after, group());
    return;
  }
  if (Array.isArray(before) && Array.isArray(after)) {
    var diff = arrayDiff(before, after, equalFn);
    if (!diff.length) return group()();
    // If the only change is a single item replacement, diff the item instead
    if (
      diff.length === 2 &&
      diff[0].index === diff[1].index &&
      diff[0] instanceof arrayDiff.RemoveDiff &&
      diff[0].howMany === 1 &&
      diff[1] instanceof arrayDiff.InsertDiff &&
      diff[1].values.length === 1
    ) {
      var index = diff[0].index;
      var itemSegments = segments.concat(index);
      doDiff(model, doc, itemSegments, before[index], after[index], equalFn, group);
      return;
    }
    applyArrayDiff(model, doc, segments, diff, group);
    return;
  }
  if (!isEach) {
    // Delete keys that were in before but not after
    for (var key in before) {
      if (key in after) continue;
      var itemSegments = segments.concat(key);
      var docSegments = itemSegments.slice(2);
      var previous = doc.del(docSegments, group());
      model.emit('change', itemSegments, [void 0, previous, model._pass]);
    }
  }
  // Diff each property in after
  for (var key in after) {
    if (equalFn(before[key], after[key])) continue;
    var itemSegments = segments.concat(key);
    doDiff(model, doc, itemSegments, before[key], after[key], equalFn, group);
  }
}

function applySet(model, doc, segments, after, cb) {
  var docSegments = segments.slice(2);
  var previous = doc.set(docSegments, after, cb);
  model.emit('change', segments, [after, previous, model._pass]);
}

function applyArrayDiff(model, doc, segments, diff, group) {
  var docSegments = segments.slice(2);
  for (var i = 0, len = diff.length; i < len; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Insert
      doc.insert(docSegments, item.index, item.values, group());
      model.emit('insert', segments, [item.index, item.values, model._pass]);
    } else if (item instanceof arrayDiff.RemoveDiff) {
      // Remove
      var removed = doc.remove(docSegments, item.index, item.howMany, group());
      model.emit('remove', segments, [item.index, removed, model._pass]);
    } else if (item instanceof arrayDiff.MoveDiff) {
      // Move
      var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());
      model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);
    }
  }
}

},{"../util":10,"./Model":28,"arraydiff":74}],36:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./Model');
var arrayDiff = require('arraydiff');
var deepEquals = require('deep-is');

module.exports = Query;

Model.INITS.push(function(model) {
  model.root._queries = new Queries;
  if (model.root.fetchOnly) return;
  model.on('all', function(segments) {
    // Updated async, since this is likely the result of an operation that
    // includes creating the doc, and we would like that to happen before
    // sending the subscribe message
    process.nextTick(function() {
      var map = model.root._queries.map;
      for (var hash in map) {
        var query = map[hash];
        if (query.isPathQuery && query.shareQuery && util.mayImpact(query.expression, segments)) {
          var ids = pathIds(model, query.expression);
          var previousIds = model._get(query.idSegments);
          query._onChange(ids, previousIds);
        }
      }
    });
  });
});

/**
 * @param {String} collectionName
 * @param {Object} expression
 * @param {String} source
 * @return {Query}
 */
Model.prototype.query = function(collectionName, expression, source) {
  if (typeof expression.path === 'function' || typeof expression !== 'object') {
    expression = this._splitPath(expression);
  }
  var query = this.root._queries.get(collectionName, expression, source);
  if (query) return query;
  query = new Query(this, collectionName, expression, source);
  this.root._queries.add(query);
  return query;
};

/**
 * Called during initialization of the bundle on page load.
 * @param {Array} items
 * @param {Array} items[*]
 * @param {String} items[*][0] collectionName
 * @param {Object} items[*][1] expression
 * @param {String} items[*][2] source
 * @param {Number} items[*][3] subscribeCount
 * @param {Number} items[*][4] fetchCount
 * @param {Array}  items[*][5] fetchIds
 */
Model.prototype._initQueries = function(items) {
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var query = new Query(this, item[0], item[1], item[2], item[3], item[4], item[5]);
    var count = query.fetchCount;
    while (count--) this.emit('fetchQuery', query, this._context);
    var count = query.subscribeCount;
    query.subscribeCount = 0;
    while (count--) query.subscribe();
  }
};

function QueriesMap() {}

function Queries() {
  this.map = new QueriesMap;
}
Queries.prototype.add = function(query) {
  this.map[query.hash] = query;
};
Queries.prototype.remove = function(query) {
  delete this.map[query.hash];
};
Queries.prototype.get = function(collectionName, expression, source) {
  var hash = queryHash(collectionName, expression, source);
  return this.map[hash];
};
Queries.prototype.toJSON = function() {
  var out = [];
  for (var hash in this.map) {
    var query = this.map[hash];
    if (query.subscribeCount || query.fetchCount) {
      out.push(query.serialize());
    }
  }
  return out;
};

/**
 * @private
 * @constructor
 * @param {Model} model
 * @param {Object} collectionName
 * @param {Object} expression
 * @param {String} source (e.g., 'solr')
 * @param {Number} subscribeCount
 * @param {Number} fetchCount
 * @param {Array<Array<String>>} fetchIds
 */
function Query(model, collectionName, expression, source, subscribeCount, fetchCount, fetchIds) {
  this.model = model.pass({$query: this});
  this.collectionName = collectionName;
  this.expression = expression;
  this.source = source;
  this.hash = queryHash(collectionName, expression, source);
  this.segments = ['$queries', this.hash];
  this.idSegments = ['$queries', this.hash, 'ids'];
  this.extraSegments = ['$queries', this.hash, 'extra'];
  this.isPathQuery = Array.isArray(expression);

  this._pendingSubscribeCallbacks = [];

  // These are used to help cleanup appropriately when calling unsubscribe and
  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe
  // are called the same number of times that fetch and subscribe were called.
  this.subscribeCount = subscribeCount || 0;
  this.fetchCount = fetchCount || 0;
  // The list of ids at the time of each fetch is pushed onto fetchIds, so
  // that unfetchDoc can be called the same number of times as fetchDoc
  this.fetchIds = fetchIds || [];

  this.created = false;
  this.shareQuery = null;
}

Query.prototype.create = function() {
  this.created = true;
  this.model.root._queries.add(this);
};

Query.prototype.destroy = function() {
  this.created = false;
  if (this.shareQuery) {
    this.shareQuery.destroy();
    this.shareQuery = null;
  }
  this.model.root._queries.remove(this);
  this.model._del(this.segments);
};

Query.prototype.sourceQuery = function() {
  if (this.isPathQuery) {
    var ids = pathIds(this.model, this.expression);
    return {_id: {$in: ids}};
  }
  return this.expression;
};

/**
 * @param {Function} [cb] cb(err)
 */
Query.prototype.fetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('fetchQuery', this, this.model._context);

  this.fetchCount++;

  if (!this.created) this.create();
  var query = this;

  var model = this.model;
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'fetch', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, fetchQueryCallback
  );
  function fetchQueryCallback(err, results, extra) {
    if (err) return cb(err);
    var ids = resultsIds(results);

    // Keep track of the ids at fetch time for use in unfetch
    query.fetchIds.push(ids.slice());
    // Update the results ids and extra
    model._setDiff(query.idSegments, ids);
    if (extra !== void 0) {
      model._setDiff(query.extraSegments, extra, {equal: deepEquals});
    }

    if (!ids.length) return cb();

    // Call fetchDoc for each document returned so that the proper load events
    // and internal counts are maintained. However, specify that we already
    // loaded the documents as part of the query, since we don't want to
    // actually fetch the documents again
    var alreadyLoaded = true;
    var group = util.asyncGroup(cb);
    for (var i = 0; i < ids.length; i++) {
      model.fetchDoc(query.collectionName, ids[i], group(), alreadyLoaded);
    }
  }
  return this;
};

/**
 * Sets up a subscription to `this` query.
 * @param {Function} cb(err)
 */
Query.prototype.subscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('subscribeQuery', this, this.model._context);

  var query = this;

  if (this.subscribeCount++) {
    process.nextTick(function () {
      var data = query.model._get(query.segments);
      if (data) cb();
      else query._pendingSubscribeCallbacks.push(cb);
    });
    return this;
  }

  if (!this.created) this.create();

  // When doing server-side rendering, we actually do a fetch the first time
  // that subscribe is called, but keep track of the state as if subscribe
  // were called for proper initialization in the client
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'sub', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  if (!this.model.root.fetchOnly) {
    this._shareSubscribe(options, cb);
    return this;
  }

  var model = this.model;
  options.docMode = 'fetch';
  model.root.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {
      if (err) return cb(err);
      var ids = resultsIds(results);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      query._onChange(ids, null, cb);
      while (cb = query._pendingSubscribeCallbacks.shift()) {
        query._onChange(ids, null, cb);
      }
    }
  );
  return this;
};

/**
 * @private
 * @param {Object} options
 * @param {String} [options.source]
 * @param {Boolean} [options.poll]
 * @param {Boolean} [options.docMode = fetch or subscribe]
 * @param {Function} cb(err, results)
 */
Query.prototype._shareSubscribe = function(options, cb) {
  var query = this;
  var model = this.model;
  this.shareQuery = this.model.root.shareConnection.createSubscribeQuery(
    this.collectionName, this.sourceQuery(), options, function (err, results, extra) {
      if (err) return cb(err);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      // Results are not set in the callback, because the shareQuery should
      // emit a 'change' event before calling back
      cb();
    }
  );
  var query = this;
  this.shareQuery.on('insert', function(shareDocs, index) {
    query._onInsert(shareDocs, index);
  });
  this.shareQuery.on('remove', function(shareDocs, index) {
    query._onRemove(shareDocs, index);
  });
  this.shareQuery.on('move', function(shareDocs, from, to) {
    query._onMove(shareDocs, from, to);
  });
  this.shareQuery.on('change', function(results, previous) {
    // Get the new and previous list of ids when the entire results set changes
    var ids = resultsIds(results);
    var previousIds = previous && resultsIds(previous);
    query._onChange(ids, previousIds);
  });
  this.shareQuery.on('extra', function (extra) {
    model._setDiff(query.extraSegments, extra, {equal: deepEquals});
  });
};

/**
 * @public
 * @param {Function} cb(err, newFetchCount)
 */
Query.prototype.unfetch = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unfetchQuery', this, this.model._context);

  // No effect if the query is not currently fetched
  if (!this.fetchCount) {
    cb();
    return this;
  }

  var ids = this.fetchIds.shift() || [];
  for (var i = 0; i < ids.length; i++) {
    this.model.unfetchDoc(this.collectionName, ids[i]);
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnfetchQuery, this.model.root.unloadDelay);
  } else {
    finishUnfetchQuery();
  }
  function finishUnfetchQuery() {
    var count = --query.fetchCount;
    if (count) return cb(null, count);
    // Cleanup when no fetches or subscribes remain
    if (!query.subscribeCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype.unsubscribe = function(cb) {
  if (!cb) cb = this.model.root._defaultCallback;
  this.model.emit('unsubscribeQuery', this, this.model._context);

  // No effect if the query is not currently subscribed
  if (!this.subscribeCount) {
    cb();
    return this;
  }

  var query = this;
  if (this.model.root.unloadDelay) {
    setTimeout(finishUnsubscribeQuery, this.model.root.unloadDelay);
  } else {
    finishUnsubscribeQuery();
  }
  function finishUnsubscribeQuery() {
    var count = --query.subscribeCount;
    if (count) return cb(null, count);

    if (query.shareQuery) {
      var ids = resultsIds(query.shareQuery.results);
      query.shareQuery.destroy();
      query.shareQuery = null;
    }

    if (!query.model.root.fetchOnly && ids && ids.length) {
      // Unsubscribe all documents that this query currently has in results
      var group = util.asyncGroup(unsubscribeQueryCallback);
      for (var i = 0; i < ids.length; i++) {
        query.model.unsubscribeDoc(query.collectionName, ids[i], group());
      }
    }
    unsubscribeQueryCallback();
  }
  function unsubscribeQueryCallback(err) {
    if (err) return cb(err);
    // Cleanup when no fetches or subscribes remain
    if (!query.fetchCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype._onInsert = function(shareDocs, index) {
  var ids = [];
  for (var i = 0; i < shareDocs.length; i++) {
    var id = shareDocs[i].name;
    ids.push(id);
    this.model.subscribeDoc(this.collectionName, id);
  }
  this.model._insert(this.idSegments, index, ids);
};
Query.prototype._onRemove = function(shareDocs, index) {
  this.model._remove(this.idSegments, index, shareDocs.length);
  for (var i = 0; i < shareDocs.length; i++) {
    this.model.unsubscribeDoc(this.collectionName, shareDocs[i].name);
  }
};
Query.prototype._onMove = function(shareDocs, from, to) {
  this.model._move(this.idSegments, from, to, shareDocs.length);
};

Query.prototype._onChange = function(ids, previousIds, cb) {
  // Diff the new and previous list of ids, subscribing to documents for
  // inserted ids and unsubscribing from documents for removed ids
  var diff = (previousIds) ?
    arrayDiff(previousIds, ids) :
    [new arrayDiff.InsertDiff(0, ids)];
  var previousCopy = previousIds && previousIds.slice();

  // The results are updated via a different diff, since they might already
  // have a value from a fetch or previous shareQuery instance
  this.model._setDiff(this.idSegments, ids);

  if (cb) {
    var group = util.asyncGroup(cb);
    var finished = group();
  }
  for (var i = 0; i < diff.length; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Subscribe to the document for each inserted id
      var values = item.values;
      for (var j = 0; j < values.length; j++) {
        this.model.subscribeDoc(this.collectionName, values[j], cb && group());
      }
    } else if (item instanceof arrayDiff.RemoveDiff) {
      var values = previousCopy.splice(item.index, item.howMany);
      // Unsubscribe from the document for each removed id
      for (var j = 0; j < values.length; j++) {
        this.model.unsubscribeDoc(this.collectionName, values[j], cb && group());
      }
    }
    // Moving doesn't change document subscriptions, so that is ignored.
  }
  // Make sure that the callback gets called if the diff is empty or it
  // contains no inserts or removes
  finished && finished();
};

Query.prototype.get = function() {
  var results = [];
  var data = this.model._get(this.segments);
  if (!data) {
    console.warn('You must fetch or subscribe to a query before getting its results.');
    return results;
  }
  var ids = data.ids;
  if (!ids) return results;

  var collection = this.model.getCollection(this.collectionName);
  for (var i = 0, l = ids.length; i < l; i++) {
    var id = ids[i];
    var doc = collection && collection.docs[id];
    results.push(doc && doc.get());
  }
  return (data.extra === void 0) ?
    results :
    {results: results, extra: data.extra};
};

/**
 * Lazily creates or gets a ref to our resultset's results.
 */
Query.prototype.ref = function(from) {
  var idsPath = this.idSegments.join('.');
  return this.model.refList(from, this.collectionName, idsPath);
};

/**
 * Lazily creates or gets a ref to our resultset's extra data.
 */
Query.prototype.extraRef = function(from, relPath) {
  var extraPath = this.extraSegments.join('.') + (relPath ? '.' + relPath : '');
  return this.model.ref(from, extraPath);
};

Query.prototype.serialize = function() {
  return [
    this.collectionName
  , this.expression
  , this.source
  , this.subscribeCount
  , this.fetchCount
  , this.fetchIds
  ];
};

function queryHash(collectionName, expression, source) {
  var args = [collectionName, expression, source];
  return JSON.stringify(args).replace(/\./g, '|');
}

function resultsIds(results) {
  var ids = [];
  for (var i = 0; i < results.length; i++) {
    var shareDoc = results[i];
    ids.push(shareDoc.name);
  }
  return ids;
}

function pathIds(model, segments) {
  var value = model._get(segments);
  return (typeof value === 'string') ? [value] :
    (Array.isArray(value)) ? value.slice() : [];
}

function collectionShareDocs(model, collectionName) {
  var collection = model.getCollection(collectionName);
  if (!collection) return;

  var results = [];
  for (var name in collection.docs) {
    results.push(collection.docs[name].shareDoc);
  }

  return results;
}


})(require("__browserify_process"))
},{"../util":10,"./Model":28,"arraydiff":74,"deep-is":47,"__browserify_process":8}],49:[function(require,module,exports){
var qs = require('qs')
var parseUrl = require('url').parse
var resolveUrl = require('url').resolve
var renderRoute = require('./router').render
var currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

// Replace the initial state with the current URL immediately,
// so that it will be rendered if the state is later popped
if (window.history.replaceState) {
  window.history.replaceState({
    $render: true,
    $method: 'get'
  }, null, window.location.href)
}

module.exports = History

function History(createPage, routes) {
  this._createPage = createPage
  this._routes = routes

  if (window.history.pushState) {
    addListeners(this)
    return
  }
  this.push = function(url) {
    window.location.assign(url)
  }
  this.replace = function(url) {
    window.location.replace(url)
  }
  this.refresh = function() {
    window.location.reload()
  }
}

History.prototype.push = function(url, render, state, e) {
  this._update('pushState', url, render, state, e)
}

History.prototype.replace = function(url, render, state, e) {
  this._update('replaceState', url, render, state, e)
}

// Rerender the current url locally
History.prototype.refresh = function() {
  var path = routePath(window.location.href)
  renderRoute(this.page(), {url: path, previous: path, method: 'get'})
}

History.prototype.back = function() {
  window.history.back()
}

History.prototype.forward = function() {
  window.history.forward()
}

History.prototype.go = function(i) {
  window.history.go(i)
}

History.prototype._update = function(historyMethod, relativeUrl, render, state, e) {
  var url = resolveUrl(window.location.href, relativeUrl)
  var path = routePath(url)

  // TODO: history.push should set the window.location with external urls
  if (!path) return
  if (render == null) render = true
  if (state == null) state = {}

  // Update the URL
  var options = renderOptions(e, path)
  state.$render = true
  state.$method = options.method
  window.history[historyMethod](state, null, options.url)
  currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  if (render) renderRoute(this.page(), options, e)
}

History.prototype.page = function() {
  if (this._page) return this._page

  var page = this._page = this._createPage()
  var history = this

  function redirect(url) {
    if (url === 'back') return history.back()
    // TODO: Add support for `basepath` option like Express
    if (url === 'home') url = '\\'
    history.replace(url, true)
  }

  page.redirect = redirect
  page._routes = this._routes
  return page
}

// Get the pathname if it is on the same protocol and domain
function routePath(url) {
  var match = parseUrl(url)
  return match &&
    match.protocol === window.location.protocol &&
    match.host === window.location.host &&
    match.pathname + (match.search || '')
}

function renderOptions(e, path) {
  // If this is a form submission, extract the form data and
  // append it to the url for a get or params.body for a post
  if (e && e.type === 'submit') {
    var form = e.target
    var elements = form.elements
    var query = []
    for (var i = 0, len = elements.length, el; i < len; i++) {
      el = elements[i]
      var name = el.name
      if (!name) continue
      var value = el.value
      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))
      if (name === '_method') {
        var override = value.toLowerCase()
        if (override === 'delete') override = 'del'
      }
    }
    query = query.join('&')
    if (form.method.toLowerCase() === 'post') {
      var method = override || 'post'
      var body = qs.parse(query)
    } else {
      method = 'get'
      path += '?' + query
    }
  } else {
    method = 'get'
  }
  return {
    method: method
  , url: path
  , previous: (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search
  , body: body
  , form: form
  , link: e && e._tracksLink
  }
}

function addListeners(history) {

  // Detect clicks on links
  function onClick(e) {
    var el = e.target

    // Ignore command click, control click, and non-left click
    if (e.metaKey || e.which !== 1) return

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Also look up for parent links (<a><img></a>)
    while (el) {
      var url = el.href
      if (url) {

        // Ignore if created by Tracks
        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return

        // Ignore links meant to open in a different window or frame
        if (el.target && el.target !== '_self') return

        // Ignore hash links to the same page
        var hashIndex = url.indexOf('#')
        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {
          return
        }

        e._tracksLink = el
        history.push(url, true, null, e)
        return
      }

      el = el.parentNode
    }
  }

  function onSubmit(e) {
    var target = e.target

    // Ignore if already prevented
    if (e.defaultPrevented || e.returnValue === false) return

    // Only handle if emitted on a form element that isn't multipart
    if (target.tagName.toLowerCase() !== 'form') return
    if (target.enctype === 'multipart/form-data') return

    // Ignore if created by Tracks
    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return

    // Use the url from the form action, defaulting to the current url
    var url = target.action || window.location.href
    history.push(url, true, null, e)
  }

  function onPopState(e) {
    var previous = currentPath
    var state = e.state
    currentPath = (window.location.pathname.slice(window.location.pathname.indexOf('index.html') + 10) + '/') + window.location.search

    var options = {
      previous: previous
    , url: currentPath
    }

    if (state) {
      if (!state.$render) return
      options.method = state.$method
      // Note that the post body is only sent on the initial reqest
      // and it is empty if the state is later popped
      return renderRoute(history.page(), options)
    }

    // The state object will be null for states created by jump links.
    // window.location.hash cannot be used, because it returns nothing
    // if the url ends in just a hash character
    var url = window.location.href
      , hashIndex = url.indexOf('#')
      , el, id
    if (~hashIndex && currentPath !== previous) {
      options.method = 'get'
      renderRoute(history.page(), options)
      id = url.slice(hashIndex + 1)
      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {
        el.scrollIntoView()
      }
    }
  }

  document.addEventListener('click', onClick, false)
  document.addEventListener('submit', onSubmit, false)
  window.addEventListener('popstate', onPopState, false)
}

},{"url":55,"./router":50,"qs":75}],50:[function(require,module,exports){
var qs = require('qs')
var nodeUrl = require('url');

module.exports = {
  render: render
, isTransitional: isTransitional
, mapRoute: mapRoute
}

function isTransitional(pattern) {
  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')
}

function mapRoute(from, params) {
  var i = params.url.indexOf('?')
  var queryString = (~i) ? params.url.slice(i) : ''
  // If the route looks like /:a/:b?/:c/:d?
  // and :b and :d are missing, return /a/c
  // Thus, skip the / if the value is missing
  var i = 0
  var path = from.replace(/\/(?:(?:\:([^?\/:*]+))|\*)(\?)?/g, onMatch)
  function onMatch(match, key, optional) {
    var value = key ? params[key] : params[i++]
    return (optional && value === void 0) ? '' : '/' + value
  }
  return path + queryString
}

function render(page, options, e) {
  var req = new RenderReq(page, options, e)
  req.routeTransitional(0, function() {
    req.routeQueue(0, function() {
      req.routeAndTransition(0, function() {
        // Cancel rendering by this app if no routes match
        req.cancel()
      })
    })
  })
}

function RenderReq(page, options, e) {
  this.page = page
  this.options = options
  this.e = e
  this.setUrl(options.url.replace(/#.*/, ''))
  var queryString = nodeUrl.parse(this.url).query;
  this.query = queryString ? qs.parse(queryString) : {}
  this.method = options.method
  this.body = options.body || {}
  this.previous = options.previous
  var routes = page._routes
  this.transitional = routes.transitional[this.method]
  this.queue = routes.queue[this.method]
  this.onRoute = routes.onRoute
}

RenderReq.prototype.cancel = function() {
  var options = this.options
  // Don't do anything if this is the result of an event, since the
  // appropriate action will happen by default
  if (this.e || options.noNavigate) return
  // Otherwise, manually perform appropriate action
  if (options.form) {
    options.form.setAttribute('data-router-ignore', '')
    options.form.submit()
  } else if (options.link) {
    options.link.setAttribute('data-router-ignore', '')
    options.link.click()
  } else {
    window.location.assign(options.url)
  }
}

RenderReq.prototype.setUrl = function(url) {
  this.url = url
  this.path = this.url.replace(/\?.*/, '')
}

RenderReq.prototype.routeTransitional = function(i, next) {
  i || (i = 0)
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path) || !item.from.match(this.previous)) continue
    var req = this
    var otherParams = this.routeParams(item.from)
    var params = this.routeParams(item.to, otherParams)
    // Even though we don't need to do anything after a done, pass a
    // no op function, so that routes can expect it to be defined
    function done() {}
    this.onMatch(item.to, params, function(err) {
      if (err) return req.cancel()
      req.routeTransitional(i, next)
    }, done)
    return
  }
  next()
}

RenderReq.prototype.routeQueue = function(i, next) {
  i || (i = 0)
  var route
  while (route = this.queue[i++]) {
    if (!route.match(this.path)) continue
    var req = this
    var params = this.routeParams(route)
    this.onMatch(route, params, function(err) {
      if (err) return req.cancel()
      req.routeQueue(i, next)
    })
    return
  }
  next()
}

RenderReq.prototype.routeAndTransition = function(i, next) {
  i || (i = 0)
  var render = this.page.render
  var item
  while (item = this.transitional[i++]) {
    if (!item.to.match(this.path)) continue
    var url = this.url
    var params = this.routeParams(item.to)
    this.setUrl(mapRoute(item.from.path, params))
    var req = this
    var skipped = false
    function continueNext() {
      skipped = true
      req.setUrl(url)
      req.page.render = render
      req.routeAndTransition(i, next)
    }
    this.page.render = function() {
      var renderArguments = arguments
      function done() {
        if (skipped) return
        req.page.render = render
        render.apply(req.page, renderArguments)
      }
      req.setUrl(url)
      var isAsync = req.onMatch(item.to, params, continueNext, done)
      if (isAsync) return
      done()
    }
    this.routeQueue(0, continueNext)
    return
  }
  next()
}

RenderReq.prototype.onMatch = function(route, params, next, done) {
  // Stop the default browser action, such as clicking a link or submitting a form
  if (this.e) {
    this.e.preventDefault()
    this.e = null
  }
  this.page.params = params
  return this.onRoute(
    route.callbacks
  , this.page
  , this.page.params
  , next
  , route.isTransitional
  , done
  )
}

RenderReq.prototype.routeParams = function(route, otherParams) {
  var routeParams = route.params
  var params = routeParams.slice()
  if (otherParams) {
    for (var key in otherParams) {
      params[key] = otherParams[key]
    }
  }
  for (var key in routeParams) {
    params[key] = routeParams[key]
  }
  params.previous = this.previous
  params.url = this.url
  params.body = this.body
  params.query = this.query
  params.method = this.method
  return params
}

},{"url":55,"qs":75}],76:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],73:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

})(require("__browserify_buffer").Buffer)
},{"crypto":77,"__browserify_buffer":76}],74:[function(require,module,exports){
module.exports = arrayDiff;

// Based on some rough benchmarking, this algorithm is about O(2n) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

arrayDiff.InsertDiff = InsertDiff;
arrayDiff.RemoveDiff = RemoveDiff;
arrayDiff.MoveDiff = MoveDiff;

function InsertDiff(index, values) {
  this.index = index;
  this.values = values;
}
InsertDiff.prototype.type = 'insert';
InsertDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , values: this.values
  };
};

function RemoveDiff(index, howMany) {
  this.index = index;
  this.howMany = howMany;
}
RemoveDiff.prototype.type = 'remove';
RemoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , howMany: this.howMany
  };
};

function MoveDiff(from, to, howMany) {
  this.from = from;
  this.to = to;
  this.howMany = howMany;
}
MoveDiff.prototype.type = 'move';
MoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , from: this.from
  , to: this.to
  , howMany: this.howMany
  };
};

function strictEqual(a, b) {
  return a === b;
}

function arrayDiff(before, after, equalFn) {
  if (!equalFn) equalFn = strictEqual;

  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  // 
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (!equalFn(beforeItem, after[afterIndex])) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var howMany = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        howMany++;
      } while (
        beforeIndex < beforeLength &&
        afterIndex < afterLength &&
        equalFn(before[beforeIndex], after[afterIndex]) &&
        !afterMarked[afterIndex]
      );
      moves.push(new MoveDiff(from, to, howMany));
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var howMany = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      howMany++;
    }
    removes.push(new RemoveDiff(index, howMany));
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var howMany = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      howMany++;
    }
    var values = after.slice(index, index + howMany);
    inserts.push(new InsertDiff(index, values));
  }

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.howMany;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.howMany;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var howMany = insert.values.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= howMany;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.howMany;
      if (earlier.to >= move.from) earlier.to += move.howMany;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.howMany;
      if (later.from >= move.to) later.from += move.howMany;
    }
  }

  return removes.concat(outputMoves, inserts);
}

},{}],45:[function(require,module,exports){
var _ = require('lodash')
  , compiler = require('./compiler')
  , memoryCache = require('memory-cache');

module.exports = function (options) {
  options = _.defaults(options || {}, {
    cache: {expiration: 0},
  });

  function getTranslations(callback) {
    var translations = memoryCache.get('translations');
    if (translations) return callback(null, translations);
    compiler.compile(options, function (err, translations) {
      if (err) return callback(err);
      memoryCache.put('translations', translations, options.cache.expiration);
      callback(null, translations);
    });
  }

  return function (req, res, next) {
    var model = req.getModel();
    getTranslations(function (err, translations) {
      if (err) return next(err);
      model.set('$lang.defaultLocale', 'en');
      model.set('$lang.translations', translations);
      next();
    });
  };
};
},{"./compiler":78,"lodash":79,"memory-cache":80}],63:[function(require,module,exports){
(function(){
  var crypt = require('crypt'),
      utf8 = require('charenc').utf8,
      bin = require('charenc').bin,

  // The core
  md5 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    var digestbytes = crypt.wordsToBytes(md5(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

},{"crypt":81,"charenc":82}],75:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Create a nullary object if possible
 */

function createObject() {
  return Object.create
    ? Object.create(null)
    : {};
}

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = createObject();
  var t = createObject();
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = createObject();
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Restore Object.prototype.
 * see pull-request #58
 */

function restoreProto(obj) {
  if (!Object.create) return obj;
  if (isArray(obj)) return obj;
  if (obj && 'object' != typeof obj) return obj;

  for (var key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      obj[key] = restoreProto(obj[key]);
    }
  }

  obj.__proto__ = Object.prototype;
  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: createObject() }).base;

  return restoreProto(compact(ret));
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],79:[function(require,module,exports){
(function(global){/**
 * @license
 * Lo-Dash 2.3.0 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setImmediate', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria;

    // ensure a stable sort in V8 and other engines
    // http://code.google.com/p/v8/issues/detail?id=90
    if (ac !== bc) {
      if (ac > bc || typeof ac == 'undefined') {
        return 1;
      }
      if (ac < bc || typeof bc == 'undefined') {
        return -1;
      }
    }
    // The JS engine embedded in Adobe applications like InDesign has a buggy
    // `Array#sort` implementation that causes it, under certain circumstances,
    // to return the same value for `a` and `b`.
    // See https://github.com/jashkenas/underscore/pull/1247
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        now = reNative.test(now = Date.now) && now || function() { return +new Date; },
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice;

    /** Used to detect `setImmediate` in Node.js */
    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&
      !reNative.test(setImmediate) && setImmediate;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = reNative.test(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !reNative.test(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          var args = partialArgs.slice();
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = partialArgs.slice();
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        length = a.length;
        size = b.length;

        // compare lengths to determine if a deep comparison is necessary
        result = size == a.length;
        if (!result && !isWhere) {
          return result;
        }
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          var index = length,
              value = b[size];

          if (isWhere) {
            while (index--) {
              if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                break;
              }
            }
          } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
            break;
          }
        }
        return result;
      }
      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
      // which, in this case, is more costly
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          // count the number of properties.
          size++;
          // deep compare each property value.
          return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
        }
      });

      if (result && !isWhere) {
        // ensure both objects have the same number of properties
        forIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            // `size` will be `-1` if `a` has more properties than `b`
            return (result = --size > -1);
          }
        });
      }
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        if (cache) {
          indexOf = cacheIndexOf;
          seen = cache;
        } else {
          isLarge = false;
          seen = callback ? seen : (releaseArray(seen), result);
        }
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        bindData = bindData.slice();

        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          push.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http:http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified object `property` exists and is a direct property,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to check.
     * @param {string} property The property to check for.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, property) {
      return object ? hasOwnProperty.call(object, property) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     *  _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }

      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its elements
     * through a callback, with each callback execution potentially mutating
     * the `accumulator` object. The callback is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    function pluck(collection, property) {
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = collection[index][property];
        }
      }
      return result || map(collection, property);
    }

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 5
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * // using "_.pluck" callback shorthand
     * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
     * // => ['apple', 'banana', 'strawberry']
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      callback = lodash.createCallback(callback, thisArg, 3);
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        object.criteria = callback(value, key, collection);
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} properties The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of composite values.
     * @example
     *
     * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2]
     */
    function intersection(array) {
      var args = arguments,
          argsLength = args.length,
          argsIndex = -1,
          caches = getArray(),
          index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [],
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = args[argsIndex];
        caches[argsIndex] = indexOf === baseIndexOf &&
          (value ? value.length : 0) >= largeArraySize &&
          createCache(argsIndex ? args[argsIndex] : seen);
      }
      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of composite values.
     * @example
     *
     * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2, 3, 101, 10]
     */
    function union(array) {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *  'label': 'docs',
     *  'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return function(object) {
          return object[func];
        };
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function() { console.log('deferred'); });
     * // returns from the function before 'deferred' is logged
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }
    // use `setImmediate` if available in Node.js
    if (setImmediate) {
      defer = function(func) {
        if (!isFunction(func)) {
          throw new TypeError;
        }
        return setImmediate.apply(context, arguments);
      };
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * var log = _.bind(console.log, console);
     * _.delay(log, 1000, 'logged later');
     * // => 'logged later' (Appears after one second.)
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the `lodash` function and
     * chainable wrapper.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object of function properties to add to `lodash`.
     * @param {Object} object The object of function properties to add to `lodash`.
     * @example
     *
     * _.mixin({
     *   'capitalize': function(string) {
     *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     *   }
     * });
     *
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source) {
      var ctor = object,
          isFunc = !source || isFunction(ctor);

      if (!source) {
        ctor = lodashWrapper;
        source = object;
        object = lodash;
      }
      forEach(functions(source), function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (value && typeof value == 'object' && value === result) {
              return this;
            }
            result = new ctor(result);
            result.__chain__ = this.__chain__;
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of `property` on `object`. If `property` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} property The property to get the value of.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, property) {
      if (object) {
        var value = object[property];
        return isFunction(value) ? object[property]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http:http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% $.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { '$': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http:http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value()
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    forOwn(lodash, function(func, methodName) {
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function() {
          var args = [this.__wrapped__],
              chainAll = this.__chain__;

          push.apply(args, arguments);
          var result = func.apply(lodash, args);
          return chainAll
            ? new lodashWrapper(result, chainAll)
            : result;
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.3.0';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module by its `noConflict()` method.
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

})(window)
},{}],80:[function(require,module,exports){
var cache = {}
function now() { return (new Date).getTime(); }
var debug = false;
var hitCount = 0;
var missCount = 0;

exports.put = function(key, value, time, timeoutCallback) {
  if (debug) console.log('caching: '+key+' = '+value+' (@'+time+')');
  var oldRecord = cache[key];
	if (oldRecord) {
		clearTimeout(oldRecord.timeout);
	}

	var expire = time + now();
	var record = {value: value, expire: expire};

	if (!isNaN(expire)) {
		var timeout = setTimeout(function() {
	    exports.del(key);
	    if (typeof timeoutCallback === 'function') {
	    	timeoutCallback(key);
	    }
	  }, time);
		record.timeout = timeout;
	}

	cache[key] = record;
}

exports.del = function(key) {
  delete cache[key];
}

exports.clear = function() {
  cache = {};
}

exports.get = function(key) {
  var data = cache[key];
  if (typeof data != "undefined") {
    if (isNaN(data.expire) || data.expire >= now()) {
	  if (debug) hitCount++;
      return data.value;
    } else {
      // free some space
      if (debug) missCount++;
      exports.del(key);
    }
  }
  return null;
}

exports.size = function() { 
  var size = 0, key;
  for (key in cache) {
    if (cache.hasOwnProperty(key)) 
      if (exports.get(key) !== null)
        size++;
  }
  return size;
}

exports.memsize = function() { 
  var size = 0, key;
  for (key in cache) {
    if (cache.hasOwnProperty(key)) 
      size++;
  }
  return size;
}

exports.debug = function(bool) {
  debug = bool;
}

exports.hits = function() {
	return hitCount;
}

exports.misses = function() {
	return missCount;
}

},{}],72:[function(require,module,exports){

exports.Connection = require('./connection').Connection;
exports.Doc = require('./doc').Doc;

},{"./connection":83,"./doc":84}],81:[function(require,module,exports){
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();

},{}],82:[function(require,module,exports){
var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;

},{}],77:[function(require,module,exports){
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, rng(size));
    } catch (err) { callback(err); }
  } else {
    return rng(size);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
;['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'].forEach(function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./sha":85,"./rng":86,"./md5":87}],78:[function(require,module,exports){
var _ = require('lodash')
  , findit = require('findit')
  , fs = require('fs')
  , loader = require('./loader')
  , MessageFormat = require('messageformat')
  , path = require('path')
  , traverse = require('traverse')
  , vm = require('vm');

exports.compile = function (options, callback) {
  if (!options.load) options.load = loader.filesystem(options);

  function getFormats(callback) {
    var dir = path.resolve(require.resolve('messageformat'), '../locale')
      , find = findit(dir)
      , sandbox = {MessageFormat: {locale: {}}}
      , context = vm.createContext(sandbox);

    find.on('file', function (file) {
      if (path.extname(file) !== '.js') return;
      var code = fs.readFileSync(file, {encoding: 'utf8'});
      vm.runInContext(code, context);
    });

    find.on('end', function () {
      callback(context.MessageFormat);
    });
  }

  getFormats(function (defaultFormats) {
    var find = findit(options.directory);

    options.load(function (err, formats, translations) {
      if (err) return callback(err);
      formats = _.merge(defaultFormats, formats || {});
      callback(null, traverse(translations).map(function (translation) {
        if (this.level < 2) return;
        if (!this.isLeaf) return;
        var locale = this.path[0];
        var messageformat = new MessageFormat(locale, formats.locale[locale]);
        this.update(messageformat.precompile(messageformat.parse(translation)), true);
      }));
    });
  });
};
},{"fs":70,"path":46,"vm":71,"./loader":88,"findit":89,"lodash":79,"traverse":90,"messageformat":91}],85:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],86:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],87:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],89:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var fs = require('fs');
var path = require('path');

module.exports = function walk (dir, opts, emitter, dstat) {
    if (!opts) opts = {};
    var fdir = opts._original || dir;
    opts._original = undefined;
    
    if (!emitter) {
        emitter = new EventEmitter;
        emitter.stop = function () {
            emitter._stopped = true;
            emitter.emit('stop');
        };
        emitter._pending = 0;
        emitter._seen = {};
    }
    emitter._pending ++;
    
    if (dstat) {
        var stopped = false;
        emitter.emit('directory', fdir, dstat, function stop () {
            stopped = true;
        });
        emitter.emit('path', fdir, dstat);
        if (!stopped) fs.readdir(dir, onreaddir);
        else check()
    }
    else fs.lstat(dir, function onstat (err, stat) {
        if (emitter._stopped) return;
        if (err) return finish();
        emitter._seen[stat.ino || dir] = true;
        
        if (stat.isSymbolicLink() && opts.followSymlinks) {
            emitter.emit('link', fdir, stat);
            fs.readlink(dir, function (err, rfile) {
                if (emitter._stopped) return;
                if (err) return finish();
                var file_ = path.resolve(dir, rfile);
                emitter.emit('readlink', fdir, file_);
                fs.lstat(file_, onstat);
            });
        }
        else if (stat.isSymbolicLink()) {
            emitter.emit('link', fdir, stat);
            emitter.emit('path', fdir, stat);
            finish();
        }
        else if (stat.isDirectory()) {
            var stopped = false;
            emitter.emit('directory', fdir, stat, function stop () {
                stopped = true;
            });
            emitter.emit('path', fdir, stat);
            if (!stopped) fs.readdir(dir, onreaddir);
            else check()
        }
        else {
            emitter.emit('file', fdir, stat);
            emitter.emit('path', fdir, stat);
            finish();
        }
    });
    
    return emitter;
    
    function check () {
        if (-- emitter._pending === 0) finish();
    }
    
    function finish () {
        emitter.emit('end');
        emitter._seen = null;
    }
    
    function onreaddir (err, files) {
        if (emitter._stopped) return;
        emitter._pending --;
        if (err) return check();
        
        files.forEach(function (rfile) {
            emitter._pending ++;
            var file = path.join(fdir, rfile);
            
            fs.lstat(file, function (err, stat) {
                if (emitter._stopped) return;
                if (err) check()
                else onstat(file, stat)
            });
        });
    }
    
    function onstat (file, stat, original) {
        if (emitter._seen[stat.ino || file]) return check();
        emitter._seen[stat.ino || file] = true;
        
        if (stat.isDirectory()) {
            if (original) opts._original = original;
            walk(file, opts, emitter, stat);
            check();
        }
        else if (stat.isSymbolicLink() && opts.followSymlinks) {
            emitter.emit('link', file, stat);
            
            fs.readlink(file, function (err, rfile) {
                if (emitter._stopped) return;
                if (err) return check();
                var file_ = path.resolve(path.dirname(file), rfile);
                
                emitter.emit('readlink', file, file_);
                fs.lstat(file_, function (err, stat_) {
                    if (emitter._stopped) return;
                    if (err) return check();
                    
                    emitter._pending ++;
                    onstat(file_, stat_, file);
                    check();
                });
            });
        }
        else if (stat.isSymbolicLink()) {
            emitter.emit('link', file, stat);
            emitter.emit('path', file, stat);
            check();
        }
        else {
            emitter.emit('file', file, stat);
            emitter.emit('path', file, stat);
            check();
        }
    }
};

},{"events":9,"fs":70,"path":46}],90:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],91:[function(require,module,exports){
/**
 * messageformat.js
 *
 * ICU PluralFormat + SelectFormat for JavaScript
 *
 * @author Alex Sexton - @SlexAxton
 * @version 0.1.5
 * @license WTFPL
 * @contributor_license Dojo CLA
*/
(function ( root ) {

  // Create the contructor function
  function MessageFormat ( locale, pluralFunc ) {
    var fallbackLocale;

    if ( locale && pluralFunc ) {
      MessageFormat.locale[ locale ] = pluralFunc;
    }

    // Defaults
    fallbackLocale = locale = locale || "en";
    pluralFunc = pluralFunc || MessageFormat.locale[ fallbackLocale = MessageFormat.Utils.getFallbackLocale( locale ) ];

    if ( ! pluralFunc ) {
      throw new Error( "Plural Function not found for locale: " + locale );
    }

    // Own Properties
    this.pluralFunc = pluralFunc;
    this.locale = locale;
    this.fallbackLocale = fallbackLocale;
  }

  // Set up the locales object. Add in english by default
  MessageFormat.locale = {
    "en" : function ( n ) {
      if ( n === 1 ) {
        return "one";
      }
      return "other";
    }
  };

  // Build out our basic SafeString type
  // more or less stolen from Handlebars by @wycats
  MessageFormat.SafeString = function( string ) {
    this.string = string;
  };

  MessageFormat.SafeString.prototype.toString = function () {
    return this.string.toString();
  };

  MessageFormat.Utils = {
    numSub : function ( string, key, depth ) {
      // make sure that it's not an escaped octothorpe
      return string.replace( /^#|[^\\]#/g, function (m) {
        var prefix = m && m.length === 2 ? m.charAt(0) : '';
        return prefix + '" + (function(){ var x = ' +
        key+';\nif( isNaN(x) ){\nthrow new Error("MessageFormat: `"+lastkey_'+depth+'+"` isnt a number.");\n}\nreturn x;\n})() + "';
      });
    },
    escapeExpression : function (string) {
      var escape = {
            "\n": "\\n",
            "\"": '\\"'
          },
          badChars = /[\n"]/g,
          possible = /[\n"]/,
          escapeChar = function(chr) {
            return escape[chr] || "&amp;";
          };

      // Don't escape SafeStrings, since they're already safe
      if ( string instanceof MessageFormat.SafeString ) {
        return string.toString();
      }
      else if ( string === null || string === false ) {
        return "";
      }

      if ( ! possible.test( string ) ) {
        return string;
      }
      return string.replace( badChars, escapeChar );
    },
    getFallbackLocale: function( locale ) {
      var tagSeparator = locale.indexOf("-") >= 0 ? "-" : "_";

      // Lets just be friends, fallback through the language tags
      while ( ! MessageFormat.locale.hasOwnProperty( locale ) ) {
        locale = locale.substring(0, locale.lastIndexOf( tagSeparator ));
        if (locale.length === 0) {
          return null;
        }
      }

      return locale;
    }
  };

  // This is generated and pulled in for browsers.
  var mparser = (function(){
    /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */

    var result = {
      /*
      * Parses the input with a generated parser. If the parsing is successfull,
      * returns a value explicitly or implicitly specified by the grammar from
      * which the parser was generated (see |PEG.buildParser|). If the parsing is
      * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
      */
      parse: function(input, startRule) {
        var parseFunctions = {
          "_": parse__,
          "char": parse_char,
          "chars": parse_chars,
          "digits": parse_digits,
          "elementFormat": parse_elementFormat,
          "hexDigit": parse_hexDigit,
          "id": parse_id,
          "messageFormatElement": parse_messageFormatElement,
          "messageFormatPattern": parse_messageFormatPattern,
          "messageFormatPatternRight": parse_messageFormatPatternRight,
          "offsetPattern": parse_offsetPattern,
          "pluralFormatPattern": parse_pluralFormatPattern,
          "pluralForms": parse_pluralForms,
          "pluralStyle": parse_pluralStyle,
          "selectFormatPattern": parse_selectFormatPattern,
          "selectStyle": parse_selectStyle,
          "start": parse_start,
          "string": parse_string,
          "stringKey": parse_stringKey,
          "whitespace": parse_whitespace
        };

        if (startRule !== undefined) {
          if (parseFunctions[startRule] === undefined) {
            throw new Error("Invalid rule name: " + quote(startRule) + ".");
          }
        } else {
          startRule = "start";
        }

        var pos = 0;
        var reportMatchFailures = true;
        var rightmostMatchFailuresPos = 0;
        var rightmostMatchFailuresExpected = [];
        var cache = {};

        function padLeft(input, padding, length) {
          var result = input;

          var padLength = length - input.length;
          for (var i = 0; i < padLength; i++) {
            result = padding + result;
          }

          return result;
        }

        function escape(ch) {
          var charCode = ch.charCodeAt(0);

          if (charCode <= 0xFF) {
            var escapeChar = 'x';
            var length = 2;
          } else {
            var escapeChar = 'u';
            var length = 4;
          }

          return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
        }

        function quote(s) {
          /*
          * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
          * string literal except for the closing quote character, backslash,
          * carriage return, line separator, paragraph separator, and line feed.
          * Any character may appear in the form of an escape sequence.
          */
          return '"' + s
          .replace(/\\/g, '\\\\')            // backslash
          .replace(/"/g, '\\"')              // closing quote character
          .replace(/\r/g, '\\r')             // carriage return
          .replace(/\n/g, '\\n')             // line feed
          .replace(/[\x80-\uFFFF]/g, escape) // non-ASCII characters
          + '"';
        }

        function matchFailed(failure) {
          if (pos < rightmostMatchFailuresPos) {
            return;
          }

          if (pos > rightmostMatchFailuresPos) {
            rightmostMatchFailuresPos = pos;
            rightmostMatchFailuresExpected = [];
          }

          rightmostMatchFailuresExpected.push(failure);
        }

        function parse_start() {
          var cacheKey = 'start@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_messageFormatPattern();
          var result2 = result1 !== null
          ? (function(messageFormatPattern) { return { type: "program", program: messageFormatPattern }; })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatPattern() {
          var cacheKey = 'messageFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse_string();
          if (result3 !== null) {
            var result4 = [];
            var result5 = parse_messageFormatPatternRight();
            while (result5 !== null) {
              result4.push(result5);
              var result5 = parse_messageFormatPatternRight();
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(s1, inner) {
            var st = [];
            if ( s1 && s1.val ) {
              st.push( s1 );
            }
            for( var i in inner ){
              if ( inner.hasOwnProperty( i ) ) {
                st.push( inner[ i ] );
              }
            }
            return { type: 'messageFormatPattern', statements: st };
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatPatternRight() {
          var cacheKey = 'messageFormatPatternRight@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          if (input.substr(pos, 1) === "{") {
            var result3 = "{";
              pos += 1;
            } else {
              var result3 = null;
              if (reportMatchFailures) {
                matchFailed("\"{\"");
                }
              }
              if (result3 !== null) {
                var result4 = parse__();
                if (result4 !== null) {
                  var result5 = parse_messageFormatElement();
                  if (result5 !== null) {
                    var result6 = parse__();
                    if (result6 !== null) {
                      if (input.substr(pos, 1) === "}") {
                        var result7 = "}";
                        pos += 1;
                  } else {
                    var result7 = null;
                    if (reportMatchFailures) {
                      matchFailed("\"}\"");
                  }
                }
                if (result7 !== null) {
                  var result8 = parse_string();
                  if (result8 !== null) {
                    var result1 = [result3, result4, result5, result6, result7, result8];
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(mfe, s1) {
            var res = [];
            if ( mfe ) {
              res.push(mfe);
            }
            if ( s1 && s1.val ) {
              res.push( s1 );
            }
            return { type: "messageFormatPatternRight", statements : res };
          })(result1[2], result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_messageFormatElement() {
          var cacheKey = 'messageFormatElement@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse_id();
          if (result3 !== null) {
            var savedPos2 = pos;
            if (input.substr(pos, 1) === ",") {
              var result6 = ",";
              pos += 1;
            } else {
              var result6 = null;
              if (reportMatchFailures) {
                matchFailed("\",\"");
              }
            }
            if (result6 !== null) {
              var result7 = parse_elementFormat();
              if (result7 !== null) {
                var result5 = [result6, result7];
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            } else {
              var result5 = null;
              pos = savedPos2;
            }
            var result4 = result5 !== null ? result5 : '';
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(argIdx, efmt) {
            var res = {
              type: "messageFormatElement",
              argumentIndex: argIdx
            };
            if ( efmt && efmt.length ) {
              res.elementFormat = efmt[1];
            }
            else {
              res.output = true;
            }
            return res;
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_elementFormat() {
          var cacheKey = 'elementFormat@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos2 = pos;
          var savedPos3 = pos;
          var result14 = parse__();
          if (result14 !== null) {
            if (input.substr(pos, 6) === "plural") {
              var result15 = "plural";
              pos += 6;
            } else {
              var result15 = null;
              if (reportMatchFailures) {
                matchFailed("\"plural\"");
              }
            }
            if (result15 !== null) {
              var result16 = parse__();
              if (result16 !== null) {
                if (input.substr(pos, 1) === ",") {
                  var result17 = ",";
                  pos += 1;
                } else {
                  var result17 = null;
                  if (reportMatchFailures) {
                    matchFailed("\",\"");
                  }
                }
                if (result17 !== null) {
                  var result18 = parse__();
                  if (result18 !== null) {
                    var result19 = parse_pluralStyle();
                    if (result19 !== null) {
                      var result20 = parse__();
                      if (result20 !== null) {
                        var result12 = [result14, result15, result16, result17, result18, result19, result20];
                      } else {
                        var result12 = null;
                        pos = savedPos3;
                      }
                    } else {
                      var result12 = null;
                      pos = savedPos3;
                    }
                  } else {
                    var result12 = null;
                    pos = savedPos3;
                  }
                } else {
                  var result12 = null;
                  pos = savedPos3;
                }
              } else {
                var result12 = null;
                pos = savedPos3;
              }
            } else {
              var result12 = null;
              pos = savedPos3;
            }
          } else {
            var result12 = null;
            pos = savedPos3;
          }
          var result13 = result12 !== null
          ? (function(t, s) {
            return {
              type : "elementFormat",
              key  : t,
              val  : s.val
            };
          })(result12[1], result12[5])
          : null;
          if (result13 !== null) {
            var result11 = result13;
          } else {
            var result11 = null;
            pos = savedPos2;
          }
          if (result11 !== null) {
            var result0 = result11;
          } else {
            var savedPos0 = pos;
            var savedPos1 = pos;
            var result4 = parse__();
            if (result4 !== null) {
              if (input.substr(pos, 6) === "select") {
                var result5 = "select";
                pos += 6;
              } else {
                var result5 = null;
                if (reportMatchFailures) {
                  matchFailed("\"select\"");
                }
              }
              if (result5 !== null) {
                var result6 = parse__();
                if (result6 !== null) {
                  if (input.substr(pos, 1) === ",") {
                    var result7 = ",";
                    pos += 1;
                  } else {
                    var result7 = null;
                    if (reportMatchFailures) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result7 !== null) {
                    var result8 = parse__();
                    if (result8 !== null) {
                      var result9 = parse_selectStyle();
                      if (result9 !== null) {
                        var result10 = parse__();
                        if (result10 !== null) {
                          var result2 = [result4, result5, result6, result7, result8, result9, result10];
                        } else {
                          var result2 = null;
                          pos = savedPos1;
                        }
                      } else {
                        var result2 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result2 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result2 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result2 = null;
                  pos = savedPos1;
                }
              } else {
                var result2 = null;
                pos = savedPos1;
              }
            } else {
              var result2 = null;
              pos = savedPos1;
            }
            var result3 = result2 !== null
            ? (function(t, s) {
              return {
                type : "elementFormat",
                key  : t,
                val  : s.val
              };
            })(result2[1], result2[5])
            : null;
            if (result3 !== null) {
              var result1 = result3;
            } else {
              var result1 = null;
              pos = savedPos0;
            }
            if (result1 !== null) {
              var result0 = result1;
            } else {
              var result0 = null;;
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralStyle() {
          var cacheKey = 'pluralStyle@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_pluralFormatPattern();
          var result2 = result1 !== null
          ? (function(pfp) {
            return { type: "pluralStyle", val: pfp };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_selectStyle() {
          var cacheKey = 'selectStyle@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = parse_selectFormatPattern();
          var result2 = result1 !== null
          ? (function(sfp) {
            return { type: "selectStyle", val: sfp };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralFormatPattern() {
          var cacheKey = 'pluralFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result6 = parse_offsetPattern();
          var result3 = result6 !== null ? result6 : '';
          if (result3 !== null) {
            var result4 = [];
            var result5 = parse_pluralForms();
            while (result5 !== null) {
              result4.push(result5);
              var result5 = parse_pluralForms();
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(op, pf) {
            var res = {
              type: "pluralFormatPattern",
              pluralForms: pf
            };
            if ( op ) {
              res.offset = op;
            }
            else {
              res.offset = 0;
            }
            return res;
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_offsetPattern() {
          var cacheKey = 'offsetPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            if (input.substr(pos, 6) === "offset") {
              var result4 = "offset";
              pos += 6;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("\"offset\"");
              }
            }
            if (result4 !== null) {
              var result5 = parse__();
              if (result5 !== null) {
                if (input.substr(pos, 1) === ":") {
                  var result6 = ":";
                  pos += 1;
                } else {
                  var result6 = null;
                  if (reportMatchFailures) {
                    matchFailed("\":\"");
                  }
                }
                if (result6 !== null) {
                  var result7 = parse__();
                  if (result7 !== null) {
                    var result8 = parse_digits();
                    if (result8 !== null) {
                      var result9 = parse__();
                      if (result9 !== null) {
                        var result1 = [result3, result4, result5, result6, result7, result8, result9];
                      } else {
                        var result1 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result1 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(d) {
            return d;
          })(result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_selectFormatPattern() {
          var cacheKey = 'selectFormatPattern@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result1 = [];
          var result3 = parse_pluralForms();
          while (result3 !== null) {
            result1.push(result3);
            var result3 = parse_pluralForms();
          }
          var result2 = result1 !== null
          ? (function(pf) {
            return {
              type: "selectFormatPattern",
              pluralForms: pf
            };
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_pluralForms() {
          var cacheKey = 'pluralForms@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            var result4 = parse_stringKey();
            if (result4 !== null) {
              var result5 = parse__();
              if (result5 !== null) {
                if (input.substr(pos, 1) === "{") {
                  var result6 = "{";
                    pos += 1;
                  } else {
                    var result6 = null;
                    if (reportMatchFailures) {
                      matchFailed("\"{\"");
                      }
                    }
                    if (result6 !== null) {
                      var result7 = parse__();
                      if (result7 !== null) {
                        var result8 = parse_messageFormatPattern();
                        if (result8 !== null) {
                          var result9 = parse__();
                          if (result9 !== null) {
                            if (input.substr(pos, 1) === "}") {
                              var result10 = "}";
                              pos += 1;
                        } else {
                          var result10 = null;
                          if (reportMatchFailures) {
                            matchFailed("\"}\"");
                        }
                      }
                      if (result10 !== null) {
                        var result1 = [result3, result4, result5, result6, result7, result8, result9, result10];
                      } else {
                        var result1 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result1 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result1 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(k, mfp) {
            return {
              type: "pluralForms",
              key: k,
              val: mfp
            };
          })(result1[1], result1[5])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_stringKey() {
          var cacheKey = 'stringKey@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos2 = pos;
          var result7 = parse_id();
          var result8 = result7 !== null
          ? (function(i) {
            return i;
          })(result7)
          : null;
          if (result8 !== null) {
            var result6 = result8;
          } else {
            var result6 = null;
            pos = savedPos2;
          }
          if (result6 !== null) {
            var result0 = result6;
          } else {
            var savedPos0 = pos;
            var savedPos1 = pos;
            if (input.substr(pos, 1) === "=") {
              var result4 = "=";
              pos += 1;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("\"=\"");
              }
            }
            if (result4 !== null) {
              var result5 = parse_digits();
              if (result5 !== null) {
                var result2 = [result4, result5];
              } else {
                var result2 = null;
                pos = savedPos1;
              }
            } else {
              var result2 = null;
              pos = savedPos1;
            }
            var result3 = result2 !== null
            ? (function(d) {
              return d;
            })(result2[1])
            : null;
            if (result3 !== null) {
              var result1 = result3;
            } else {
              var result1 = null;
              pos = savedPos0;
            }
            if (result1 !== null) {
              var result0 = result1;
            } else {
              var result0 = null;;
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_string() {
          var cacheKey = 'string@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            var result4 = [];
            var savedPos2 = pos;
            var result6 = parse__();
            if (result6 !== null) {
              var result7 = parse_chars();
              if (result7 !== null) {
                var result8 = parse__();
                if (result8 !== null) {
                  var result5 = [result6, result7, result8];
                } else {
                  var result5 = null;
                  pos = savedPos2;
                }
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            } else {
              var result5 = null;
              pos = savedPos2;
            }
            while (result5 !== null) {
              result4.push(result5);
              var savedPos2 = pos;
              var result6 = parse__();
              if (result6 !== null) {
                var result7 = parse_chars();
                if (result7 !== null) {
                  var result8 = parse__();
                  if (result8 !== null) {
                    var result5 = [result6, result7, result8];
                  } else {
                    var result5 = null;
                    pos = savedPos2;
                  }
                } else {
                  var result5 = null;
                  pos = savedPos2;
                }
              } else {
                var result5 = null;
                pos = savedPos2;
              }
            }
            if (result4 !== null) {
              var result1 = [result3, result4];
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(ws, s) {
            var tmp = [];
            for( var i = 0; i < s.length; ++i ) {
              for( var j = 0; j < s[ i ].length; ++j ) {
                tmp.push(s[i][j]);
              }
            }
            return {
              type: "string",
              val: ws + tmp.join('')
            };
          })(result1[0], result1[1])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_id() {
          var cacheKey = 'id@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var savedPos1 = pos;
          var result3 = parse__();
          if (result3 !== null) {
            if (input.substr(pos).match(/^[a-zA-Z$_]/) !== null) {
              var result4 = input.charAt(pos);
              pos++;
            } else {
              var result4 = null;
              if (reportMatchFailures) {
                matchFailed("[a-zA-Z$_]");
              }
            }
            if (result4 !== null) {
              var result5 = [];
              if (input.substr(pos).match(/^[^ 	\n\r,.+={}]/) !== null) {
                var result7 = input.charAt(pos);
                pos++;
              } else {
                var result7 = null;
                if (reportMatchFailures) {
                  matchFailed("[^ 	\\n\\r,.+={}]");
                }
              }
              while (result7 !== null) {
                result5.push(result7);
                if (input.substr(pos).match(/^[^ 	\n\r,.+={}]/) !== null) {
                  var result7 = input.charAt(pos);
                  pos++;
                } else {
                  var result7 = null;
                  if (reportMatchFailures) {
                    matchFailed("[^ 	\\n\\r,.+={}]");
                  }
                }
              }
              if (result5 !== null) {
                var result6 = parse__();
                if (result6 !== null) {
                  var result1 = [result3, result4, result5, result6];
                } else {
                  var result1 = null;
                  pos = savedPos1;
                }
              } else {
                var result1 = null;
                pos = savedPos1;
              }
            } else {
              var result1 = null;
              pos = savedPos1;
            }
          } else {
            var result1 = null;
            pos = savedPos1;
          }
          var result2 = result1 !== null
          ? (function(s1, s2) {
            return s1 + (s2 ? s2.join('') : '');
          })(result1[1], result1[2])
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_chars() {
          var cacheKey = 'chars@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          var result3 = parse_char();
          if (result3 !== null) {
            var result1 = [];
            while (result3 !== null) {
              result1.push(result3);
              var result3 = parse_char();
            }
          } else {
            var result1 = null;
          }
          var result2 = result1 !== null
          ? (function(chars) { return chars.join(''); })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_char() {
          var cacheKey = 'char@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos5 = pos;
          if (input.substr(pos).match(/^[^{}\\\0- 	\n\r]/) !== null) {
            var result19 = input.charAt(pos);
            pos++;
          } else {
            var result19 = null;
            if (reportMatchFailures) {
              matchFailed("[^{}\\\\\\0- 	\\n\\r]");
            }
          }
          var result20 = result19 !== null
          ? (function(x) {
            return x;
          })(result19)
          : null;
          if (result20 !== null) {
            var result18 = result20;
          } else {
            var result18 = null;
            pos = savedPos5;
          }
          if (result18 !== null) {
            var result0 = result18;
          } else {
            var savedPos4 = pos;
            if (input.substr(pos, 2) === "\\#") {
              var result16 = "\\#";
              pos += 2;
            } else {
              var result16 = null;
              if (reportMatchFailures) {
                matchFailed("\"\\\\#\"");
              }
            }
            var result17 = result16 !== null
            ? (function() {
              return "\\#";
            })()
            : null;
            if (result17 !== null) {
              var result15 = result17;
            } else {
              var result15 = null;
              pos = savedPos4;
            }
            if (result15 !== null) {
              var result0 = result15;
            } else {
              var savedPos3 = pos;
              if (input.substr(pos, 2) === "\\{") {
                var result13 = "\\{";
                  pos += 2;
                } else {
                  var result13 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\{\"");
                    }
                  }
                  var result14 = result13 !== null
                  ? (function() {
                    return "\u007B";
                  })()
                  : null;
                  if (result14 !== null) {
                    var result12 = result14;
                  } else {
                    var result12 = null;
                    pos = savedPos3;
                  }
                  if (result12 !== null) {
                    var result0 = result12;
                  } else {
                    var savedPos2 = pos;
                    if (input.substr(pos, 2) === "\\}") {
                      var result10 = "\\}";
                      pos += 2;
                } else {
                  var result10 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\}\"");
                }
              }
              var result11 = result10 !== null
              ? (function() {
                return "\u007D";
              })()
              : null;
              if (result11 !== null) {
                var result9 = result11;
              } else {
                var result9 = null;
                pos = savedPos2;
              }
              if (result9 !== null) {
                var result0 = result9;
              } else {
                var savedPos0 = pos;
                var savedPos1 = pos;
                if (input.substr(pos, 2) === "\\u") {
                  var result4 = "\\u";
                  pos += 2;
                } else {
                  var result4 = null;
                  if (reportMatchFailures) {
                    matchFailed("\"\\\\u\"");
                  }
                }
                if (result4 !== null) {
                  var result5 = parse_hexDigit();
                  if (result5 !== null) {
                    var result6 = parse_hexDigit();
                    if (result6 !== null) {
                      var result7 = parse_hexDigit();
                      if (result7 !== null) {
                        var result8 = parse_hexDigit();
                        if (result8 !== null) {
                          var result2 = [result4, result5, result6, result7, result8];
                        } else {
                          var result2 = null;
                          pos = savedPos1;
                        }
                      } else {
                        var result2 = null;
                        pos = savedPos1;
                      }
                    } else {
                      var result2 = null;
                      pos = savedPos1;
                    }
                  } else {
                    var result2 = null;
                    pos = savedPos1;
                  }
                } else {
                  var result2 = null;
                  pos = savedPos1;
                }
                var result3 = result2 !== null
                ? (function(h1, h2, h3, h4) {
                  return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
                })(result2[1], result2[2], result2[3], result2[4])
                : null;
                if (result3 !== null) {
                  var result1 = result3;
                } else {
                  var result1 = null;
                  pos = savedPos0;
                }
                if (result1 !== null) {
                  var result0 = result1;
                } else {
                  var result0 = null;;
                };
              };
              };
            };
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_digits() {
          var cacheKey = 'digits@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          var savedPos0 = pos;
          if (input.substr(pos).match(/^[0-9]/) !== null) {
            var result3 = input.charAt(pos);
            pos++;
          } else {
            var result3 = null;
            if (reportMatchFailures) {
              matchFailed("[0-9]");
            }
          }
          if (result3 !== null) {
            var result1 = [];
            while (result3 !== null) {
              result1.push(result3);
              if (input.substr(pos).match(/^[0-9]/) !== null) {
                var result3 = input.charAt(pos);
                pos++;
              } else {
                var result3 = null;
                if (reportMatchFailures) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            var result1 = null;
          }
          var result2 = result1 !== null
          ? (function(ds) {
            return parseInt((ds.join('')), 10);
          })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_hexDigit() {
          var cacheKey = 'hexDigit@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          if (input.substr(pos).match(/^[0-9a-fA-F]/) !== null) {
            var result0 = input.charAt(pos);
            pos++;
          } else {
            var result0 = null;
            if (reportMatchFailures) {
              matchFailed("[0-9a-fA-F]");
            }
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse__() {
          var cacheKey = '_@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }

          var savedReportMatchFailures = reportMatchFailures;
          reportMatchFailures = false;
          var savedPos0 = pos;
          var result1 = [];
          var result3 = parse_whitespace();
          while (result3 !== null) {
            result1.push(result3);
            var result3 = parse_whitespace();
          }
          var result2 = result1 !== null
          ? (function(w) { return w.join(''); })(result1)
          : null;
          if (result2 !== null) {
            var result0 = result2;
          } else {
            var result0 = null;
            pos = savedPos0;
          }
          reportMatchFailures = savedReportMatchFailures;
          if (reportMatchFailures && result0 === null) {
            matchFailed("whitespace");
          }

          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function parse_whitespace() {
          var cacheKey = 'whitespace@' + pos;
          var cachedResult = cache[cacheKey];
          if (cachedResult) {
            pos = cachedResult.nextPos;
            return cachedResult.result;
          }


          if (input.substr(pos).match(/^[ 	\n\r]/) !== null) {
            var result0 = input.charAt(pos);
            pos++;
          } else {
            var result0 = null;
            if (reportMatchFailures) {
              matchFailed("[ 	\\n\\r]");
            }
          }



          cache[cacheKey] = {
            nextPos: pos,
            result:  result0
          };
          return result0;
        }

        function buildErrorMessage() {
          function buildExpected(failuresExpected) {
            failuresExpected.sort();

            var lastFailure = null;
            var failuresExpectedUnique = [];
            for (var i = 0; i < failuresExpected.length; i++) {
              if (failuresExpected[i] !== lastFailure) {
                failuresExpectedUnique.push(failuresExpected[i]);
                lastFailure = failuresExpected[i];
              }
            }

            switch (failuresExpectedUnique.length) {
              case 0:
                return 'end of input';
              case 1:
                return failuresExpectedUnique[0];
              default:
                return failuresExpectedUnique.slice(0, failuresExpectedUnique.length - 1).join(', ')
              + ' or '
              + failuresExpectedUnique[failuresExpectedUnique.length - 1];
            }
          }

          var expected = buildExpected(rightmostMatchFailuresExpected);
          var actualPos = Math.max(pos, rightmostMatchFailuresPos);
          var actual = actualPos < input.length
          ? quote(input.charAt(actualPos))
          : 'end of input';

          return 'Expected ' + expected + ' but ' + actual + ' found.';
        }

        function computeErrorPosition() {
          /*
          * The first idea was to use |String.split| to break the input up to the
          * error position along newlines and derive the line and column from
          * there. However IE's |split| implementation is so broken that it was
          * enough to prevent it.
          */

          var line = 1;
          var column = 1;
          var seenCR = false;

          for (var i = 0; i <  rightmostMatchFailuresPos; i++) {
            var ch = input.charAt(i);
            if (ch === '\n') {
              if (!seenCR) { line++; }
              column = 1;
              seenCR = false;
            } else if (ch === '\r' | ch === '\u2028' || ch === '\u2029') {
              line++;
              column = 1;
              seenCR = true;
            } else {
              column++;
              seenCR = false;
            }
          }

          return { line: line, column: column };
        }



        var result = parseFunctions[startRule]();

        /*
        * The parser is now in one of the following three states:
        *
        * 1. The parser successfully parsed the whole input.
        *
        *    - |result !== null|
        *    - |pos === input.length|
        *    - |rightmostMatchFailuresExpected| may or may not contain something
        *
        * 2. The parser successfully parsed only a part of the input.
        *
        *    - |result !== null|
        *    - |pos < input.length|
        *    - |rightmostMatchFailuresExpected| may or may not contain something
        *
        * 3. The parser did not successfully parse any part of the input.
        *
        *   - |result === null|
        *   - |pos === 0|
        *   - |rightmostMatchFailuresExpected| contains at least one failure
        *
        * All code following this comment (including called functions) must
        * handle these states.
        */
        if (result === null || pos !== input.length) {
          var errorPosition = computeErrorPosition();
          throw new this.SyntaxError(
            buildErrorMessage(),
            errorPosition.line,
            errorPosition.column
          );
        }

        return result;
      },

      /* Returns the parser source code. */
      toSource: function() { return this._source; }
    };

    /* Thrown when a parser encounters a syntax error. */

    result.SyntaxError = function(message, line, column) {
      this.name = 'SyntaxError';
      this.message = message;
      this.line = line;
      this.column = column;
    };

    result.SyntaxError.prototype = Error.prototype;

    return result;
  })();

  MessageFormat.prototype.parse = function () {
    // Bind to itself so error handling works
    return mparser.parse.apply( mparser, arguments );
  };

  MessageFormat.prototype.precompile = function ( ast ) {
    var self = this,
        needOther = false,
        fp = {
      begin: 'function(d){\nvar r = "";\n',
      end  : "return r;\n}"
    };

    function interpMFP ( ast, data ) {
      // Set some default data
      data = data || {};
      var s = '', i, tmp, lastkeyname;

      switch ( ast.type ) {
        case 'program':
          return interpMFP( ast.program );
        case 'messageFormatPattern':
          for ( i = 0; i < ast.statements.length; ++i ) {
            s += interpMFP( ast.statements[i], data );
          }
          return fp.begin + s + fp.end;
        case 'messageFormatPatternRight':
          for ( i = 0; i < ast.statements.length; ++i ) {
            s += interpMFP( ast.statements[i], data );
          }
          return s;
        case 'messageFormatElement':
          data.pf_count = data.pf_count || 0;
          s += 'if(!d){\nthrow new Error("MessageFormat: No data passed to function.");\n}\n';
          if ( ast.output ) {
            s += 'r += d["' + ast.argumentIndex + '"];\n';
          }
          else {
            lastkeyname = 'lastkey_'+(data.pf_count+1);
            s += 'var '+lastkeyname+' = "'+ast.argumentIndex+'";\n';
            s += 'var k_'+(data.pf_count+1)+'=d['+lastkeyname+'];\n';
            s += interpMFP( ast.elementFormat, data );
          }
          return s;
        case 'elementFormat':
          if ( ast.key === 'select' ) {
            s += interpMFP( ast.val, data );
            s += 'r += (pf_' +
                 data.pf_count +
                 '[ k_' + (data.pf_count+1) + ' ] || pf_'+data.pf_count+'[ "other" ])( d );\n';
          }
          else if ( ast.key === 'plural' ) {
            s += interpMFP( ast.val, data );
            s += 'if ( pf_'+(data.pf_count)+'[ k_'+(data.pf_count+1)+' + "" ] ) {\n';
            s += 'r += pf_'+data.pf_count+'[ k_'+(data.pf_count+1)+' + "" ]( d ); \n';
            s += '}\nelse {\n';
            s += 'r += (pf_' +
                 data.pf_count +
                 '[ MessageFormat.locale["' +
                 self.fallbackLocale +
                 '"]( k_'+(data.pf_count+1)+' - off_'+(data.pf_count)+' ) ] || pf_'+data.pf_count+'[ "other" ] )( d );\n';
            s += '}\n';
          }
          return s;
        /* // Unreachable cases.
        case 'pluralStyle':
        case 'selectStyle':*/
        case 'pluralFormatPattern':
          data.pf_count = data.pf_count || 0;
          s += 'var off_'+data.pf_count+' = '+ast.offset+';\n';
          s += 'var pf_' + data.pf_count + ' = { \n';
          needOther = true;
          // We're going to simultaneously check to make sure we hit the required 'other' option.

          for ( i = 0; i < ast.pluralForms.length; ++i ) {
            if ( ast.pluralForms[ i ].key === 'other' ) {
              needOther = false;
            }
            if ( tmp ) {
              s += ',\n';
            }
            else{
              tmp = 1;
            }
            s += '"' + ast.pluralForms[ i ].key + '" : ' + interpMFP( ast.pluralForms[ i ].val,
          (function(){ var res = JSON.parse(JSON.stringify(data)); res.pf_count++; return res; })() );
          }
          s += '\n};\n';
          if ( needOther ) {
            throw new Error("No 'other' form found in pluralFormatPattern " + data.pf_count);
          }
          return s;
        case 'selectFormatPattern':

          data.pf_count = data.pf_count || 0;
          s += 'var off_'+data.pf_count+' = 0;\n';
          s += 'var pf_' + data.pf_count + ' = { \n';
          needOther = true;

          for ( i = 0; i < ast.pluralForms.length; ++i ) {
            if ( ast.pluralForms[ i ].key === 'other' ) {
              needOther = false;
            }
            if ( tmp ) {
              s += ',\n';
            }
            else{
              tmp = 1;
            }
            s += '"' + ast.pluralForms[ i ].key + '" : ' + interpMFP( ast.pluralForms[ i ].val,
              (function(){
                var res = JSON.parse( JSON.stringify( data ) );
                res.pf_count++;
                return res;
              })()
            );
          }
          s += '\n};\n';
          if ( needOther ) {
            throw new Error("No 'other' form found in selectFormatPattern " + data.pf_count);
          }
          return s;
        /* // Unreachable
        case 'pluralForms':
        */
        case 'string':
          return 'r += "' + MessageFormat.Utils.numSub(
            MessageFormat.Utils.escapeExpression( ast.val ),
            'k_' + data.pf_count + ' - off_' + ( data.pf_count - 1 ),
            data.pf_count
          ) + '";\n';
        default:
          throw new Error( 'Bad AST type: ' + ast.type );
      }
    }
    return interpMFP( ast );
  };

  MessageFormat.prototype.compile = function ( message ) {
    return (new Function( 'MessageFormat',
      'return ' +
        this.precompile(
          this.parse( message )
        )
    ))(MessageFormat);
  };


  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = MessageFormat;
    }
    exports.MessageFormat = MessageFormat;
  }
  else if (typeof define === 'function' && define.amd) {
    define(function() {
      return MessageFormat;
    });
  }
  else {
    root['MessageFormat'] = MessageFormat;
  }

})( this );

},{}],92:[function(require,module,exports){
// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;


},{}],88:[function(require,module,exports){
var findit = require('findit')
  , path = require('path')
  , traverse = require('traverse');

exports.filesystem = function (options) {
  if (!options.directory) options.directory = 'locale';
  options.directory = path.resolve(path.dirname(require.main.filename), options.directory);

  return function (callback) {
    var find = findit(options.directory)
      , formats = {locale: {}}
      , translations = {};

    find.on('file', function (file) {
      var extname = path.extname(file);
      if (extname !== '.js' && extname !== '.json') return;
      var namespace = path.relative(options.directory, file).split(path.sep);
      var key = path.basename(namespace.pop(), extname);
      if (key !== 'index') namespace.push(key);
      if (extname === '.js') return formats.locale[namespace[0]] = require(file);
      if (extname === '.json') traverse(translations).set(namespace, require(file));
    });

    find.on('end', function () {
      callback(null, formats, translations);
    });
  };
};
},{"path":46,"findit":89,"traverse":90}],93:[function(require,module,exports){
var Doc;
if (typeof require !== 'undefined') {
  Doc = require('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.get(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Query);


},{"./doc":84,"./microevent":92}],83:[function(require,module,exports){
// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof require !== 'undefined') {
  types = require('ottypes');
  Doc = require('./doc').Doc;
  Query = require('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;
  // I'll store the most recent 100 messages so when errors occur we can see what happened.
  this.messageBuffer = [];

  var connection = this;

  var handleMessage = function(msg) {
    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      case 'bs':
        // Bulk subscribe response. The responses for each document are contained within.
        var result = msg.s;
        for (var cName in result) {
          for (var docName in result[cName]) {
            var doc = connection.get(cName, docName);
            if (!doc) {
              if (console) console.error('Message for unknown doc. Ignoring.', msg);
              break;
            }

            var msg = result[cName][docName];
            if (typeof msg === 'object') {
              doc._handleSubscribe(msg.error, msg.data);
            } else {
              // The msg will be true if we simply resubscribed.
              doc._handleSubscribe(null, null);
            }
          }
        }
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = connection._lastReceivedCollection = msg.c;
          docName = connection._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = connection._lastReceivedCollection;
          docName = msg.d = connection._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));
    connection.messageBuffer.push({t:(new Date()).toTimeString(), recv:JSON.stringify(msg)});
    while (connection.messageBuffer.length > 100) {
      connection.messageBuffer.shift();
    }

    try {
      handleMessage(msg);
    } catch (e) {
      connection.emit('error', e);
      // We could also restart the connection here, although that might result
      // in infinite reconnection bugs.
    }
  }

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  this.subscribeData = {};
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }


  // Its important that operations are resent in the same order that they were
  // originally sent. If we don't sort, an op with a high sequence number will
  // convince the server not to accept any ops with earlier sequence numbers.
  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }

  // Only send bulk subscribe if not empty. Its weird using a for loop for
  // this, but it works pretty well.
  for (var __unused in this.subscribeData) { 
    this.send({a:'bs', s:this.subscribeData});
    break;
  }

  this.opQueue = null;
  this.subscribeData = null;
  
  // No bulk subscribe for queries yet.
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// This is called by the document class when the document wants to subscribe.
// We could just send a subscribe message, but during reconnect that causes a
// bajillion messages over browserchannel. During reconnect we'll aggregate,
// similar to sendOp.
Connection.prototype.sendSubscribe = function(collection, name, v) {
  if (this.subscribeData) {
    var data = this.subscribeData;
    if (!data[collection]) data[collection] = {};

    data[collection][name] = v || null;
  } else {
    var msg = {a:'sub', c:collection, d:name};
    if (v != null) msg.v = v;
    this.send(msg);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));
  this.messageBuffer.push({t:Date.now(), send:JSON.stringify(msg)});
  while (this.messageBuffer.length > 100) {
    this.messageBuffer.shift();
  }

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.getExisting = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

Connection.prototype.getOrCreate = function(collection, name, data) {
  console.trace('getOrCreate is deprecated. Use get() instead');
  return this.get(collection, name, data);
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.get = function(collection, name, data) {
  var doc = this.getExisting(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.data !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Connection);


},{"./query":93,"./doc":84,"./microevent":92,"ottypes":94}],84:[function(require,module,exports){
var types, MicroEvent;

if (typeof require !== "undefined") {
  types = require('ottypes');
  MicroEvent = require('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  // data.data is what the server will actually send. data.snapshot is the old
  // field name - supported now for backwards compatibility.
  this.snapshot = data.data || data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This function exists so connection can call it directly for bulk subscribes.
// It could just make a temporary object literal, thats pretty slow.
Doc.prototype._handleSubscribe = function(err, data) {
  if (err && err !== 'Already subscribed') {
    if (console) console.error("Could not subscribe: " + err);
    this.emit('error', err);
    // There's probably a reason we couldn't subscribe. Don't retry.
    this._setWantSubscribe(false, null, err)
  } else {
    if (data) this.injestData(data);
    this.subscribed = true;
    this.emit('subscribe');
    this._finishSub(true);
  }

  this._clearAction('subscribe');
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      this._handleSubscribe(msg.error, msg.data);
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          console.warn('Operation was rejected (' + msg.error + '). Trying to rollback change locally.');
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        // This will happen naturally in the following (or similar) cases:
        //
        // Client is not subscribed to document.
        // -> client submits an operation (v=10)
        // -> client subscribes to a query which matches this document. Says we
        //    have v=10 of the doc.
        //
        // <- server acknowledges the operation (v=11). Server acknowledges the
        //    operation because the doc isn't subscribed
        // <- server processes the query, which says the client only has v=10.
        //    Server subscribes at v=10 not v=11, so we get another copy of the
        //    v=10 operation.
        //
        // In this case, we can safely ignore the old (duplicate) operation.
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    // Special send method needed for bulk subscribes on reconnect.
    this.connection.sendSubscribe(this.collection, this.name, this.state === 'ready' ? this.version : null);
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

// Unsubscribe. The data will stay around in local memory, but we'll stop
// receiving updates.
Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a:'op', v:this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  // The call to flush is in a timeout so if submitOp() is called multiple
  // times in a closure all the ops are combined before being sent to the
  // server. It doesn't matter if flush is called a bunch of times.
  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    opData.op = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], opData);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(opData, false);
    this._afterOtApply(opData, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. This can happen when you submit ops in a submitOp callback.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};


},{"./microevent":92,"ottypes":94}],94:[function(require,module,exports){

var register = function(type) {
  exports[type.name] = type;
  if (type.uri) {
    return exports[type.uri] = type;
  }
};

// Import all the built-in types. Requiring directly rather than in register()
// so browserify works.
register(require('./simple'));

register(require('./text'));
register(require('./text-tp2'));

register(require('./json0'));


},{"./simple":95,"./text":96,"./text-tp2":97,"./json0":98}],95:[function(require,module,exports){
// This is a really simple OT type. Its not compiled with the web client, but it could be.
//
// Its mostly included for demonstration purposes and its used in the meta unit tests.
//
// This defines a really simple text OT type which only allows inserts. (No deletes).
//
// Ops look like:
//   {position:#, text:"asdf"}
//
// Document snapshots look like:
//   {str:string}

module.exports = {
  // The name of the OT type. The type itself is exposed to ottypes[type.name] and ottypes[type.uri].
  // The name can be used instead of the actual type in all API methods in ShareJS.
  name: 'simple',

  // Canonical name.
  uri: 'http://sharejs.org/types/simple',

  // Create a new document snapshot. Initial data can be passed in.
  create: function(initial) {
    if (initial == null)
      initial = '';

    return {str: initial};
  },

  // Apply the given op to the document snapshot. Returns the new snapshot.
  apply: function(snapshot, op) {
    if (op.position < 0 || op.position > snapshot.str.length)
      throw new Error('Invalid position');

    var str = snapshot.str;
    str = str.slice(0, op.position) + op.text + str.slice(op.position);
    return {str: str};
  },

  // Transform op1 by op2. Returns transformed version of op1.
  // Sym describes the symmetry of the operation. Its either 'left' or 'right'
  // depending on whether the op being transformed comes from the client or the
  // server.
  transform: function(op1, op2, sym) {
    var pos = op1.position;

    if (op2.position < pos || (op2.position === pos && sym === 'left')) {
      pos += op2.text.length;
    }

    return {position: pos, text: op1.text};
  }
};


},{}],96:[function(require,module,exports){
/* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:'str'} : Delete 'str', which appears at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

/** @module text */

exports.name = 'text';
exports.uri = 'http://sharejs.org/types/textv1';

/** Create a new text snapshot.
 *
 * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
 */
exports.create = function(initial) {
  if ((initial != null) && typeof initial !== 'string') {
    throw new Error('Initial data must be a string');
  }
  return initial || '';
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/** Check the operation is valid. Throws if not valid. */
var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
      case 'object':
        // The only valid objects are {d:X} for +ive values of X.
        if (!(typeof c.d === 'number' && c.d > 0)) throw new Error('Object components must be deletes of size > 0');
        break;
      case 'string':
        // Strings are inserts.
        if (!(c.length > 0)) throw new Error('Inserts cannot be empty');
        break;
      case 'number':
        // Numbers must be skips. They have to be +ive numbers.
        if (!(c > 0)) throw new Error('Skip components must be >0');
        if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
        break;
    }
    last = c;
  }

  if (typeof last === 'number') throw new Error('Op has a trailing skip');
};

/** Make a function that appends to the given operation. */
var makeAppend = function(op) {
  return function(component) {
    if (!component || component.d === 0) {
      // The component is a no-op. Ignore!
 
    } else if (op.length === 0) {
      return op.push(component);

    } else if (typeof component === typeof op[op.length - 1]) {
      if (typeof component === 'object') {
        return op[op.length - 1].d += component.d;
      } else {
        return op[op.length - 1] += component;
      }
    } else {
      return op.push(component);
    }
  };
};

/** Makes and returns utility functions take and peek. */
var makeTake = function(op) {
  // The index of the next component to take
  var idx = 0;
  // The offset into the component
  var offset = 0;

  // Take up to length n from the front of op. If n is -1, take the entire next
  // op component. If indivisableField == 'd', delete components won't be separated.
  // If indivisableField == 'i', insert components won't be separated.
  var take = function(n, indivisableField) {
    // We're at the end of the operation. The op has skips, forever. Infinity
    // might make more sense than null here.
    if (idx === op.length)
      return n === -1 ? null : n;

    var part;
    var c = op[idx];
    if (typeof c === 'number') {
      // Skip
      if (n === -1 || c - offset <= n) {
        part = c - offset;
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return n;
      }
    } else if (typeof c === 'string') {
      // Insert
      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
        part = c.slice(offset);
        ++idx;
        offset = 0;
        return part;
      } else {
        part = c.slice(offset, offset + n);
        offset += n;
        return part;
      }
    } else {
      // Delete
      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
        part = {d: c.d - offset};
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return {d: n};
      }
    }
  };

  // Peek at the next op that will be returned.
  var peekType = function() { return op[idx]; };

  return [take, peekType];
};

/** Get the length of a component */
var componentLength = function(c) {
  // Uglify will compress this down into a ternary
  if (typeof c === 'number') {
    return c;
  } else {
    return c.length || c.d;
  }
};

/** Trim any excess skips from the end of an operation.
 *
 * There should only be at most one, because the operation was made with append.
 */
var trim = function(op) {
  if (op.length > 0 && typeof op[op.length - 1] === 'number') {
    op.pop();
  }
  return op;
};

exports.normalize = function(op) {
  var newOp = [];
  var append = makeAppend(newOp);
  for (var i = 0; i < op.length; i++) {
    append(op[i]);
  }
  return trim(newOp);
};

/** Apply an operation to a document snapshot */
exports.apply = function(str, op) {
  if (typeof str !== 'string') {
    throw new Error('Snapshot should be a string');
  }
  checkOp(op);

  // We'll gather the new document here and join at the end.
  var newDoc = [];

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    switch (typeof component) {
      case 'number':
        if (component > str.length) throw new Error('The op is too long for this document');

        newDoc.push(str.slice(0, component));
        // This might be slow for big strings. Consider storing the offset in
        // str instead of rewriting it each time.
        str = str.slice(component);
        break;
      case 'string':
        newDoc.push(component);
        break;
      case 'object':
        str = str.slice(component.d);
        break;
    }
  }

  return newDoc.join('') + str;
};

/** Transform op by otherOp.
 *
 * @param op - The operation to transform
 * @param otherOp - Operation to transform it by
 * @param side - Either 'left' or 'right'
 */
exports.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right') throw new Error("side (" + side + ") must be 'left' or 'right'");

  checkOp(op);
  checkOp(otherOp);

  var newOp = [];
  var append = makeAppend(newOp);

  var _fns = makeTake(op);
  var take = _fns[0],
      peek = _fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];

    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'i');
          append(chunk);
          if (typeof chunk !== 'string') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        if (side === 'left') {
          // The left insert should go first.
          if (typeof peek() === 'string') {
            append(take(-1));
          }
        }

        // Otherwise skip the inserted text.
        append(component.length);
        break;

      case 'object': // Delete
        length = component.d;
        while (length > 0) {
          chunk = take(length, 'i');
          switch (typeof chunk) {
            case 'number':
              length -= chunk;
              break;
            case 'string':
              append(chunk);
              break;
            case 'object':
              // The delete is unnecessary now - the text has already been deleted.
              length -= chunk.d;
          }
        }
        break;
    }
  }
  
  // Append any extra data in op1.
  while ((component = take(-1)))
    append(component);
  
  return trim(newOp);
};

/** Compose op1 and op2 together and return the result */
exports.compose = function(op1, op2) {
  checkOp(op1);
  checkOp(op2);

  var result = [];
  var append = makeAppend(result);
  var take = makeTake(op1)[0];

  for (var i = 0; i < op2.length; i++) {
    var component = op2[i];
    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'd');
          append(chunk);
          if (typeof chunk !== 'object') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        append(component);
        break;

      case 'object': // Delete
        length = component.d;

        while (length > 0) {
          chunk = take(length, 'd');

          switch (typeof chunk) {
            case 'number':
              append({d: chunk});
              length -= chunk;
              break;
            case 'string':
              length -= chunk.length;
              break;
            case 'object':
              append(chunk);
          }
        }
        break;
    }
  }

  while ((component = take(-1)))
    append(component);

  return trim(result);
};

var transformPosition = function(cursor, op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (cursor <= pos) break;

    // I could actually use the op_iter stuff above - but I think its simpler
    // like this.
    switch (typeof c) {
      case 'number':
        if (cursor <= pos + c)
          return cursor;
        pos += c;
        break;

      case 'string':
        pos += c.length;
        cursor += c.length;
        break;

      case 'object':
        cursor -= Math.min(c.d, cursor - pos);
        break;
    }
  }
  return cursor;
};

exports.transformCursor = function(cursor, op, isOwnOp) {
  var pos = 0;
  if (isOwnOp) {
    // Just track the position. We'll teleport the cursor to the end anyway.
    // This works because text ops don't have any trailing skips at the end - so the last
    // component is the last thing.
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      switch (typeof c) {
        case 'number':
          pos += c;
          break;
        case 'string':
          pos += c.length;
          break;
        // Just eat deletes.
      }
    }
    return [pos, pos];
  } else {
    return [transformPosition(cursor[0], op), transformPosition(cursor[1], op)];
  }
};

},{}],97:[function(require,module,exports){
(function(){// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as: {s:'some string', t:[5, -2, 6]}
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

//var append, appendDoc, componentLength, makeTake, takeDoc, transformer;

var type = module.exports = {
  name: 'text-tp2',
  tp2: true,
  uri: 'http://sharejs.org/types/text-tp2v1',
  create: function(initial) {
    if (initial == null) {
      initial = '';
    } else {
      if (typeof initial != 'string') throw new Error('Initial data must be a string');
    }

    return {
      charLength: initial.length,
      totalLength: initial.length,
      data: initial.length ? [initial] : []
    };
  },

  serialize: function(doc) {
    if (!doc.data) {
      throw new Error('invalid doc snapshot');
    }
    return doc.data;
  },

  deserialize: function(data) {
    var doc = type.create();
    doc.data = data;

    for (var i = 0; i < data.length; i++) {
      var component = data[i];

      if (typeof component === 'string') {
        doc.charLength += component.length;
        doc.totalLength += component.length;
      } else {
        doc.totalLength += component;
      }
    }

    return doc;
  }
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (typeof c == 'object') {
      // The component is an insert or a delete.
      if (c.i !== undefined) { // Insert.
        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
          throw new Error('Inserts must insert a string or a +ive number');

      } else if (c.d !== undefined) { // Delete
        if (!(typeof c.d === 'number' && c.d > 0))
          throw new Error('Deletes must be a +ive number');

      } else throw new Error('Operation component must define .i or .d');

    } else {
      // The component must be a skip.
      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

      if (c <= 0) throw new Error('Skip components must be a positive number');
      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
    }

    last = c;
  }
};

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
  if (position.index >= doc.data.length)
    throw new Error('Operation goes past the end of the document');

  var part = doc.data[position.index];

  // This can be written as an ugly-arsed giant ternary statement, but its much
  // more readable like this. Uglify will convert it into said ternary anyway.
  var result;
  if (typeof part == 'string') {
    if (maxlength != null) {
      result = part.slice(position.offset, position.offset + maxlength);
    } else {
      result = part.slice(position.offset);
    }
  } else {
    if (maxlength == null || tombsIndivisible) {
      result = part - position.offset;
    } else {
      result = Math.min(maxlength, part - position.offset);
    }
  }

  var resultLen = result.length || result;

  if ((part.length || part) - position.offset > resultLen) {
    position.offset += resultLen;
  } else {
    position.index++;
    position.offset = 0;
  }

  return result;
};

// Append a part to the end of a document
var appendDoc = type._appendDoc = function(doc, p) {
  if (p === 0 || p === '') return;

  if (typeof p === 'string') {
    doc.charLength += p.length;
    doc.totalLength += p.length;
  } else {
    doc.totalLength += p;
  }

  var data = doc.data;
  if (data.length === 0) {
    data.push(p);
  } else if (typeof data[data.length - 1] === typeof p) {
    data[data.length - 1] += p;
  } else {
    data.push(p);
  }
};

// Apply the op to the document. The document is not modified in the process.
type.apply = function(doc, op) {
  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
    throw new Error('Snapshot is invalid');
  }
  checkOp(op);

  var newDoc = type.create();
  var position = {index: 0, offset: 0};

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    var remainder, part;

    if (typeof component == 'number') { // Skip
      remainder = component;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        appendDoc(newDoc, part);
        remainder -= part.length || part;
      }

    } else if (component.i !== undefined) { // Insert
      appendDoc(newDoc, component.i);

    } else if (component.d !== undefined) { // Delete
      remainder = component.d;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        remainder -= part.length || part;
      }
      appendDoc(newDoc, component.d);
    }
  }
  return newDoc;
};

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
var append = type._append = function(op, component) {
  var last;

  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
    // Drop the new component.
  } else if (op.length === 0) {
    op.push(component);
  } else {
    last = op[op.length - 1];
    if (typeof component == 'number' && typeof last == 'number') {
      op[op.length - 1] += component;
    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
      last.i += component.i;
    } else if (component.d != null && (last.d != null)) {
      last.d += component.d;
    } else {
      op.push(component);
    }
  }
};

// Makes 2 functions for taking components from the start of an op, and for
// peeking at the next op that could be taken.
var makeTake = function(op) {
  // The index of the next component to take
  var index = 0;
  // The offset into the component
  var offset = 0;

  var take = function(maxlength, insertsIndivisible) {
    if (index === op.length) return null;
    var e = op[index];
    var current;
    var result;

    // if the current element is a skip, an insert of a number or a delete
    if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
      var c;
      if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
        // Return the rest of the current element.
        c = current - offset;
        ++index;
        offset = 0;
      } else {
        offset += maxlength;
        c = maxlength;
      }

      // Package the component back up.
      if (e.i != null) {
        return {i: c};
      } else if (e.d != null) {
        return {d: c};
      } else {
        return c;
      }
    } else { // Insert of a string.
      if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
        result = {i: e.i.slice(offset)};
        ++index;
        offset = 0;
      } else {
        result = {i: e.i.slice(offset, offset + maxlength)};
        offset += maxlength;
      }
      return result;
    }
  };

  var peekType = function() {return op[index];};
  return [take, peekType];
};

// Find and return the length of an op component
var componentLength = function(component) {
  if (typeof component === 'number') {
    return component;
  } else if (typeof component.i === 'string') {
    return component.i.length;
  } else {
    return component.d || component.i;
  }
};

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
type.normalize = function(op) {
  var newOp = [];
  for (var i = 0; i < op.length; i++) {
    append(newOp, op[i]);
  }
  return newOp;
};

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
var transformer = function(op, otherOp, goForwards, side) {
  checkOp(op);
  checkOp(otherOp);

  var newOp = [];

  var fns = makeTake(op),
      take = fns[0],
      peek = fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];
    var len = componentLength(component);
    var chunk;

    if (component.i != null) { // Insert text or tombs
      if (goForwards) { // Transform - insert skips over deleted parts.
        if (side === 'left') {
          // The left side insert should go first.
          var next;
          while ((next = peek()) && next.i != null) {
            append(newOp, take());
          }
        }
        // In any case, skip the inserted text.
        append(newOp, len);

      } else { // Prune. Remove skips for inserts.
        while (len > 0) {
          chunk = take(len, true);

          // The chunk will be null if we run out of components in the other op.
          if (chunk === null) throw new Error('The transformed op is invalid');
          if (chunk.d != null)
            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

          if (typeof chunk == 'number')
            len -= chunk;
          else
            append(newOp, chunk);
        }
      }
    } else { // Skips or deletes.
      while (len > 0) {
        chunk = take(len, true);
        if (chunk === null) throw new Error('The op traverses more elements than the document has');

        append(newOp, chunk);
        if (!chunk.i) len -= componentLength(chunk);
      }
    }
  }

  // Append extras from op1.
  var component;
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in the op: " + component);
    }
    append(newOp, component);
  }
  return newOp;
};

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
type.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right')
    throw new Error("side (" + side + ") should be 'left' or 'right'");

  return transformer(op, otherOp, true, side);
};

type.prune = function(op, otherOp) {
  return transformer(op, otherOp, false);
};

type.compose = function(op1, op2) {
  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
  if (op1 == null) return op2;

  checkOp(op1);
  checkOp(op2);

  var result = [];
  var take = makeTake(op1)[0];
  var component;

  for (var i = 0; i < op2.length; i++) {
    component = op2[i];
    var len, chunk;

    if (typeof component === 'number') { // Skip
      // Just copy from op1.
      len = component;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        append(result, chunk);
        len -= componentLength(chunk);
      }

    } else if (component.i !== undefined) { // Insert
      append(result, {i: component.i});

    } else { // Delete
      len = component.d;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        var chunkLength = componentLength(chunk);

        if (chunk.i !== undefined)
          append(result, {i: chunkLength});
        else
          append(result, {d: chunkLength});

        len -= chunkLength;
      }
    }
  }

  // Append extras from op1.
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in op1: " + component);
    }
    append(result, component);
  }
  return result;
};


})()
},{}],98:[function(require,module,exports){
/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};



/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
var text = typeof require !== "undefined" ? require('./text-old') : window.ottypes.text;



/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

if (typeof require !== "undefined") {
  require('./helpers')._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
} else {
  // This is kind of awful - come up with a better way to hook this helper code up.
  exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
}

module.exports = json;

},{"./text-old":99,"./helpers":100}],100:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX, transformX;

  transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    return transformComponent(destRight, right, left, 'right');
  };
  type.transformX = type.transformX = transformX = function(leftOp, rightOp) {
    var k, l, l_, newLeftOp, newRightOp, nextC, r, r_, rightComponent, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

    checkValidOp(leftOp);
    checkValidOp(rightOp);
    newRightOp = [];
    for (_i = 0, _len = rightOp.length; _i < _len; _i++) {
      rightComponent = rightOp[_i];
      newLeftOp = [];
      k = 0;
      while (k < leftOp.length) {
        nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;
        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          _ref = leftOp.slice(k);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            l = _ref[_j];
            append(newLeftOp, l);
          }
          rightComponent = null;
          break;
        } else {
          _ref1 = transformX(leftOp.slice(k), nextC), l_ = _ref1[0], r_ = _ref1[1];
          for (_k = 0, _len2 = l_.length; _k < _len2; _k++) {
            l = l_[_k];
            append(newLeftOp, l);
          }
          for (_l = 0, _len3 = r_.length; _l < _len3; _l++) {
            r = r_[_l];
            append(newRightOp, r);
          }
          rightComponent = null;
          break;
        }
      }
      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };
  return type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right')) {
      throw new Error("type must be 'left' or 'right'");
    }
    if (otherOp.length === 0) {
      return op;
    }
    if (op.length === 1 && otherOp.length === 1) {
      return transformComponent([], op[0], otherOp[0], type);
    }
    if (type === 'left') {
      return transformX(op, otherOp)[0];
    } else {
      return transformX(otherOp, op)[1];
    }
  };
};

},{}],99:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var append, checkValidComponent, checkValidOp, invertComponent, strInject, text, transformComponent, transformPosition;

text = {
  name: 'text-old',
  uri: 'http://sharejs.org/types/textv0',
  create: function() {
    return '';
  }
};

strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

checkValidComponent = function(c) {
  var d_type, i_type;

  if (typeof c.p !== 'number') {
    throw new Error('component missing position field');
  }
  i_type = typeof c.i;
  d_type = typeof c.d;
  if (!((i_type === 'string') ^ (d_type === 'string'))) {
    throw new Error('component needs an i or d field');
  }
  if (!(c.p >= 0)) {
    throw new Error('position cannot be negative');
  }
};

checkValidOp = function(op) {
  var c, _i, _len;

  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    checkValidComponent(c);
  }
  return true;
};

text.apply = function(snapshot, op) {
  var component, deleted, _i, _len;

  checkValidOp(op);
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    component = op[_i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted) {
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
      }
      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

text._append = append = function(newOp, c) {
  var last, _ref, _ref1;

  if (c.i === '' || c.d === '') {
    return;
  }
  if (newOp.length === 0) {
    return newOp.push(c);
  } else {
    last = newOp[newOp.length - 1];
    if ((last.i != null) && (c.i != null) && (last.p <= (_ref = c.p) && _ref <= (last.p + last.i.length))) {
      return newOp[newOp.length - 1] = {
        i: strInject(last.i, c.p - last.p, c.i),
        p: last.p
      };
    } else if ((last.d != null) && (c.d != null) && (c.p <= (_ref1 = last.p) && _ref1 <= (c.p + c.d.length))) {
      return newOp[newOp.length - 1] = {
        d: strInject(c.d, last.p - c.p, last.d),
        p: c.p
      };
    } else {
      return newOp.push(c);
    }
  }
};

text.compose = function(op1, op2) {
  var c, newOp, _i, _len;

  checkValidOp(op1);
  checkValidOp(op2);
  newOp = op1.slice();
  for (_i = 0, _len = op2.length; _i < _len; _i++) {
    c = op2[_i];
    append(newOp, c);
  }
  return newOp;
};

text.compress = function(op) {
  return text.compose([], op);
};

text.normalize = function(op) {
  var c, newOp, _i, _len, _ref;

  newOp = [];
  if ((op.i != null) || (op.p != null)) {
    op = [op];
  }
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    if ((_ref = c.p) == null) {
      c.p = 0;
    }
    append(newOp, c);
  }
  return newOp;
};

transformPosition = function(pos, c, insertAfter) {
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

text.transformCursor = function(position, op, side) {
  var c, insertAfter, _i, _len;

  insertAfter = side === 'right';
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    position = transformPosition(position, c, insertAfter);
  }
  return position;
};

text._tc = transformComponent = function(dest, c, otherC, side) {
  var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidOp([c]);
  checkValidOp([otherC]);
  if (c.i != null) {
    append(dest, {
      i: c.i,
      p: transformPosition(c.p, otherC, side === 'right')
    });
  } else {
    if (otherC.i != null) {
      s = c.d;
      if (c.p < otherC.p) {
        append(dest, {
          d: s.slice(0, otherC.p - c.p),
          p: c.p
        });
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '') {
        append(dest, {
          d: s,
          p: c.p + otherC.i.length
        });
      }
    } else {
      if (c.p >= otherC.p + otherC.d.length) {
        append(dest, {
          d: c.d,
          p: c.p - otherC.d.length
        });
      } else if (c.p + c.d.length <= otherC.p) {
        append(dest, c);
      } else {
        newC = {
          d: '',
          p: c.p
        };
        if (c.p < otherC.p) {
          newC.d = c.d.slice(0, otherC.p - c.p);
        }
        if (c.p + c.d.length > otherC.p + otherC.d.length) {
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
        }
        intersectStart = Math.max(c.p, otherC.p);
        intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect) {
          throw new Error('Delete ops delete different text in the same region of the document');
        }
        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }
  return dest;
};

invertComponent = function(c) {
  if (c.i != null) {
    return {
      d: c.i,
      p: c.p
    };
  } else {
    return {
      i: c.d,
      p: c.p
    };
  }
};

text.invert = function(op) {
  var c, _i, _len, _ref, _results;

  _ref = op.slice().reverse();
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    _results.push(invertComponent(c));
  }
  return _results;
};

if (typeof require === 'undefined') {
  exports._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
} else {
  require('./helpers')._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
}

module.exports = text;

},{"./helpers":100}]},{},[12,6])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9kZXJieS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9saWIvYXBwL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9saWIvYXBwL3JvdXRlcy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9saWIvYXBwL3ZpZXdGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL3JhY2VyLWJyb3dzZXJjaGFubmVsL2xpYi9icm93c2VyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9idWlsdGluL2V2ZW50cy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvcmFjZXItYnJvd3NlcmNoYW5uZWwvbm9kZV9tb2R1bGVzL2Jyb3dzZXJjaGFubmVsL2Rpc3QvYmNzb2NrZXQtdW5jb21wcmVzc2VkLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL1JhY2VyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL2xpYi9hcHAvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vdWkvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vdWkvY29ubmVjdGlvbkFsZXJ0L2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvYXBwLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvZGVyYnkuYnJvd3Nlci5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL2RlcmJ5Lk1vZGVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvdmlld01vZGVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvcGF0aHMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9FdmVudERpc3BhdGNoZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9QYXRoTWFwLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9saWIvdGV4dE90LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS11aS1naXRodWItYnV0dG9ucy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnktbGFuZy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi9wYXRoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL3V0aWwuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9jb21wb25lbnQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvbGliL2Jyb3dzZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9Eb20uanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9yZWZyZXNoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS11aS1naXRodWItYnV0dG9ucy9idXR0b24vaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvZGVlcC1pcy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL2RvbS1zaGltL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi91cmwuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZXZlbnRzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3BhdGhzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2NvbGxlY3Rpb25zLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL211dGF0b3JzLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3N1YnNjcmlwdGlvbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29udGV4dHMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZm4uanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZmlsdGVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3JlZkxpc3QuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvcmVmLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9idWlsdGluL3F1ZXJ5c3RyaW5nLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2RlZmF1bHRGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LWxhbmcvbGliL2FwcC9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbGliL1ZpZXcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9tYXJrdXAuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi9ldmVudEJpbmRpbmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvbGliL2NvbXBvc2UuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYi92aWV3UGF0aC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL2h0bWwtdXRpbC9saWIvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LWxhbmcvbGliL2FwcC9yZWFjdGl2ZUZucy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnktbGFuZy9saWIvYXBwL3ZpZXdGbnMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvdmVuZG9yL2V4cHJlc3Mvcm91dGVyL3JvdXRlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvaHRtbC11dGlsL2xpYi9lbnRpdHlDb2RlLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvaHRtbC11dGlsL2xpYi9wYXJzZS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9DaGFubmVsLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL0xvY2FsRG9jLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL1JlbW90ZURvYy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi9mcy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy90cmFja3MvdmVuZG9yL2V4cHJlc3MvdXRpbHMuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29ubmVjdGlvbi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9Nb2RlbC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9Eb2MuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvc2V0RGlmZi5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9RdWVyeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvSGlzdG9yeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3RyYWNrcy9saWIvcm91dGVyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYXJyYXlkaWZmL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS1sYW5nL2xpYi9zZXJ2ZXIvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9NRDUvbWQ1LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvdHJhY2tzL25vZGVfbW9kdWxlcy9xcy9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnktbGFuZy9ub2RlX21vZHVsZXMvbG9kYXNoL2Rpc3QvbG9kYXNoLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS1sYW5nL25vZGVfbW9kdWxlcy9tZW1vcnktY2FjaGUvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL01ENS9ub2RlX21vZHVsZXMvY3J5cHQvY3J5cHQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9NRDUvbm9kZV9tb2R1bGVzL2NoYXJlbmMvY2hhcmVuYy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS1sYW5nL2xpYi9zZXJ2ZXIvY29tcGlsZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LWxhbmcvbm9kZV9tb2R1bGVzL2ZpbmRpdC9pbmRleC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnktbGFuZy9ub2RlX21vZHVsZXMvdHJhdmVyc2UvaW5kZXguanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LWxhbmcvbm9kZV9tb2R1bGVzL21lc3NhZ2Vmb3JtYXQvbWVzc2FnZWZvcm1hdC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9saWIvY2xpZW50L21pY3JvZXZlbnQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5LWxhbmcvbGliL3NlcnZlci9sb2FkZXIuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9xdWVyeS5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9saWIvY2xpZW50L2Nvbm5lY3Rpb24uanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9kb2MuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL2luZGV4LmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9zaW1wbGUuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3RleHQuanMiLCIvVXNlcnMvcHNpcmVubnkvRHJvcGJveC9Qcml2YXRlL2Rldi9kZXJieS1sYW5nLWRlbW8vbm9kZV9tb2R1bGVzL2RlcmJ5L25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbm9kZV9tb2R1bGVzL290dHlwZXMvbGliL3RleHQtdHAyLmpzIiwiL1VzZXJzL3BzaXJlbm55L0Ryb3Bib3gvUHJpdmF0ZS9kZXYvZGVyYnktbGFuZy1kZW1vL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9qc29uMC5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvaGVscGVycy5qcyIsIi9Vc2Vycy9wc2lyZW5ueS9Ecm9wYm94L1ByaXZhdGUvZGV2L2RlcmJ5LWxhbmctZGVtby9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvdGV4dC1vbGQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25jQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2g4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2M0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNub0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUmFjZXIgPSByZXF1aXJlKCcuL1JhY2VyJyk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBSYWNlcjtcbiIsIihmdW5jdGlvbihfX2Rpcm5hbWUpe3ZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgZGVyYnkgPSBtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUocmFjZXIpO1xuXG52YXIgZGVyYnlQbHVnaW4gPSAocmFjZXIudXRpbC5pc1NlcnZlcikgP1xuICBfX2Rpcm5hbWUgKyAnL2RlcmJ5LnNlcnZlcicgOlxuICByZXF1aXJlKCcuL2RlcmJ5LmJyb3dzZXInKTtcblxuLy8gVE9ETzogUmVtb3ZlIG9yIGltcGxlbWVudFxuZGVyYnkuZ2V0ID0gZnVuY3Rpb24oKSB7fVxuXG5kZXJieVxuICAvLyBTZXJ2ZXItc2lkZSBvciBicm93c2VyLXNpZGUgbWV0aG9kc1xuICAudXNlKGRlcmJ5UGx1Z2luKTtcblxufSkoXCIvbm9kZV9tb2R1bGVzL2RlcmJ5L2xpYlwiKSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAucmVhZHkoZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgbW9kZWwub24oJ2NoYW5nZScsICdfc2Vzc2lvbi5sb2NhbGUnLCBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgICB2YXIgb3JpZ2luID0gbW9kZWwuZ2V0KCckY29uZmlnLm9yaWdpbicpO1xuICAgICAgJC5wb3N0KG9yaWdpbiArICcvbGFuZ3VhZ2UvY2hhbmdlTG9jYWxlJywge2xvY2FsZTogbG9jYWxlfSk7XG4gICAgfSk7XG4gIH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAuZ2V0KCcvJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsKSB7XG4gICAgcGFnZS5yZW5kZXIoJ2hvbWUnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnLzQwMycsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJzQwMycpO1xuICB9KTtcblxuICBhcHAuZ2V0KCcvNDA0JywgZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICBwYWdlLnJlbmRlcignNDA0Jyk7XG4gIH0pO1xuXG4gIGFwcC5nZXQoJy80MDQnLCBmdW5jdGlvbiAocGFnZSkge1xuICAgIHBhZ2UucmVuZGVyKCc0MDQnKTtcbiAgfSk7XG5cbiAgYXBwLmdldCgnLzUwMCcsIGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgcGFnZS5yZW5kZXIoJzUwMCcpO1xuICB9KTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBwKSB7XG4gIGFwcC52aWV3LmZuKCdsaW5rJywgZnVuY3Rpb24gKGhyZWYsIHRleHQpIHtcbiAgICBpZiAoIWhyZWYpIHJldHVybiAnJztcbiAgICByZXR1cm4gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIj4nICsgKHRleHQgfHwgaHJlZikgKyAnPC9hPic7XG4gIH0pO1xufTsiLCJ2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpO1xudmFyIEJDU29ja2V0ID0gcmVxdWlyZSgnYnJvd3NlcmNoYW5uZWwvZGlzdC9iY3NvY2tldC11bmNvbXByZXNzZWQnKS5CQ1NvY2tldDtcblxucmFjZXIuTW9kZWwucHJvdG90eXBlLl9jcmVhdGVTb2NrZXQgPSBmdW5jdGlvbihidW5kbGUpIHtcbiAgdmFyIG9wdGlvbnMgPSBidW5kbGUucmFjZXJCcm93c2VyQ2hhbm5lbDtcbiAgdmFyIGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgJy9jaGFubmVsJztcbiAgaWYgKGJ1bmRsZS5tb3VudCkgYmFzZSA9IGJ1bmRsZS5tb3VudCArIGJhc2U7XG4gIHJldHVybiBuZXcgQkNTb2NrZXQoYmFzZSwgb3B0aW9ucyk7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5zb3VyY2UgPT09IHdpbmRvdyAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7aWYgKCFwcm9jZXNzLkV2ZW50RW1pdHRlcikgcHJvY2Vzcy5FdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEV2ZW50RW1pdHRlciA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gcHJvY2Vzcy5FdmVudEVtaXR0ZXI7XG52YXIgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nXG4gICAgPyBBcnJheS5pc0FycmF5XG4gICAgOiBmdW5jdGlvbiAoeHMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICB9XG47XG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhblxuLy8gMTAgbGlzdGVuZXJzIGFyZSBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoXG4vLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbi8vXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgPSBuO1xufTtcblxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc0FycmF5KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKVxuICAgIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmd1bWVudHNbMV07IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGlmICghaGFuZGxlcikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChpc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIEV2ZW50RW1pdHRlciBpcyBkZWZpbmVkIGluIHNyYy9ub2RlX2V2ZW50cy5jY1xuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0KCkgaXMgYWxzbyBkZWZpbmVkIHRoZXJlLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZExpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PSBcIm5ld0xpc3RlbmVyc1wiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lcnNcIi5cbiAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICAgIHZhciBtO1xuICAgICAgaWYgKHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtID0gdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5vbih0eXBlLCBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcblxuICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNBcnJheShsaXN0KSkge1xuICAgIHZhciBpID0gaW5kZXhPZihsaXN0LCBsaXN0ZW5lcik7XG4gICAgaWYgKGkgPCAwKSByZXR1cm4gdGhpcztcbiAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMClcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdID09PSBsaXN0ZW5lcikge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICh0eXBlICYmIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFtdO1xuICBpZiAoIWlzQXJyYXkodGhpcy5fZXZlbnRzW3R5cGVdKSkge1xuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICB9XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV07XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiKGZ1bmN0aW9uKCl7XG5mdW5jdGlvbiBlKCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIG0oYSkge1xuICByZXR1cm4gZnVuY3Rpb24oYikge1xuICAgIHRoaXNbYV0gPSBiXG4gIH1cbn1cbmZ1bmN0aW9uIGFhKGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW2FdXG4gIH1cbn1cbmZ1bmN0aW9uIGJhKGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhXG4gIH1cbn1cbnZhciBwLCBjYSA9IGNhIHx8IHt9LCBxID0gdGhpcztcbmZ1bmN0aW9uIGRhKGEpIHtcbiAgYSA9IGEuc3BsaXQoXCIuXCIpO1xuICBmb3IodmFyIGIgPSBxLCBjO2MgPSBhLnNoaWZ0KCk7KSB7XG4gICAgaWYobnVsbCAhPSBiW2NdKSB7XG4gICAgICBiID0gYltjXVxuICAgIH1lbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBlYSgpIHtcbn1cbmZ1bmN0aW9uIGZhKGEpIHtcbiAgdmFyIGIgPSB0eXBlb2YgYTtcbiAgaWYoXCJvYmplY3RcIiA9PSBiKSB7XG4gICAgaWYoYSkge1xuICAgICAgaWYoYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJldHVyblwiYXJyYXlcIlxuICAgICAgfVxuICAgICAgaWYoYSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICByZXR1cm4gYlxuICAgICAgfVxuICAgICAgdmFyIGMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7XG4gICAgICBpZihcIltvYmplY3QgV2luZG93XVwiID09IGMpIHtcbiAgICAgICAgcmV0dXJuXCJvYmplY3RcIlxuICAgICAgfVxuICAgICAgaWYoXCJbb2JqZWN0IEFycmF5XVwiID09IGMgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgYS5sZW5ndGggJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5zcGxpY2UgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiAhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSkge1xuICAgICAgICByZXR1cm5cImFycmF5XCJcbiAgICAgIH1cbiAgICAgIGlmKFwiW29iamVjdCBGdW5jdGlvbl1cIiA9PSBjIHx8IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEuY2FsbCAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlICYmICFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFwiY2FsbFwiKSkge1xuICAgICAgICByZXR1cm5cImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm5cIm51bGxcIlxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGlmKFwiZnVuY3Rpb25cIiA9PSBiICYmIFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIGEuY2FsbCkge1xuICAgICAgcmV0dXJuXCJvYmplY3RcIlxuICAgIH1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gcyhhKSB7XG4gIHJldHVyblwiYXJyYXlcIiA9PSBmYShhKVxufVxuZnVuY3Rpb24gZ2EoYSkge1xuICB2YXIgYiA9IGZhKGEpO1xuICByZXR1cm5cImFycmF5XCIgPT0gYiB8fCBcIm9iamVjdFwiID09IGIgJiYgXCJudW1iZXJcIiA9PSB0eXBlb2YgYS5sZW5ndGhcbn1cbmZ1bmN0aW9uIHUoYSkge1xuICByZXR1cm5cInN0cmluZ1wiID09IHR5cGVvZiBhXG59XG5mdW5jdGlvbiBoYShhKSB7XG4gIHJldHVyblwiZnVuY3Rpb25cIiA9PSBmYShhKVxufVxuZnVuY3Rpb24gdihhKSB7XG4gIHJldHVybiBhW2lhXSB8fCAoYVtpYV0gPSArK2phKVxufVxudmFyIGlhID0gXCJjbG9zdXJlX3VpZF9cIiArICgxRTkgKiBNYXRoLnJhbmRvbSgpID4+PiAwKSwgamEgPSAwO1xuZnVuY3Rpb24ga2EoYSwgYiwgYykge1xuICByZXR1cm4gYS5jYWxsLmFwcGx5KGEuYmluZCwgYXJndW1lbnRzKVxufVxuZnVuY3Rpb24gbGEoYSwgYiwgYykge1xuICBpZighYSkge1xuICAgIHRocm93IEVycm9yKCk7XG4gIH1cbiAgaWYoMiA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB2YXIgZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYywgZCk7XG4gICAgICByZXR1cm4gYS5hcHBseShiLCBjKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGEuYXBwbHkoYiwgYXJndW1lbnRzKVxuICB9XG59XG5mdW5jdGlvbiB3KGEsIGIsIGMpIHtcbiAgdyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIC0xICE9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLnRvU3RyaW5nKCkuaW5kZXhPZihcIm5hdGl2ZSBjb2RlXCIpID8ga2EgOiBsYTtcbiAgcmV0dXJuIHcuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxufVxudmFyIHggPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuK25ldyBEYXRlXG59O1xuZnVuY3Rpb24geShhLCBiKSB7XG4gIGZ1bmN0aW9uIGMoKSB7XG4gIH1cbiAgYy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5yYSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBjXG59XG47ZnVuY3Rpb24gbWEoYSwgYikge1xuICBmb3IodmFyIGMgPSAxO2MgPCBhcmd1bWVudHMubGVuZ3RoO2MrKykge1xuICAgIHZhciBkID0gU3RyaW5nKGFyZ3VtZW50c1tjXSkucmVwbGFjZSgvXFwkL2csIFwiJCQkJFwiKTtcbiAgICBhID0gYS5yZXBsYWNlKC9cXCVzLywgZClcbiAgfVxuICByZXR1cm4gYVxufVxuZnVuY3Rpb24gbmEoYSkge1xuICBpZighb2EudGVzdChhKSkge1xuICAgIHJldHVybiBhXG4gIH1cbiAgLTEgIT0gYS5pbmRleE9mKFwiJlwiKSAmJiAoYSA9IGEucmVwbGFjZShwYSwgXCImYW1wO1wiKSk7XG4gIC0xICE9IGEuaW5kZXhPZihcIjxcIikgJiYgKGEgPSBhLnJlcGxhY2UocWEsIFwiJmx0O1wiKSk7XG4gIC0xICE9IGEuaW5kZXhPZihcIj5cIikgJiYgKGEgPSBhLnJlcGxhY2UocmEsIFwiJmd0O1wiKSk7XG4gIC0xICE9IGEuaW5kZXhPZignXCInKSAmJiAoYSA9IGEucmVwbGFjZShzYSwgXCImcXVvdDtcIikpO1xuICByZXR1cm4gYVxufVxudmFyIHBhID0gLyYvZywgcWEgPSAvPC9nLCByYSA9IC8+L2csIHNhID0gL1xcXCIvZywgb2EgPSAvWyY8PlxcXCJdLztcbnZhciB6LCB0YSwgdWEsIHZhO1xuZnVuY3Rpb24gd2EoKSB7XG4gIHJldHVybiBxLm5hdmlnYXRvciA/IHEubmF2aWdhdG9yLnVzZXJBZ2VudCA6IG51bGxcbn1cbnZhID0gdWEgPSB0YSA9IHogPSAhMTtcbnZhciB4YTtcbmlmKHhhID0gd2EoKSkge1xuICB2YXIgeWEgPSBxLm5hdmlnYXRvcjtcbiAgeiA9IDAgPT0geGEuaW5kZXhPZihcIk9wZXJhXCIpO1xuICB0YSA9ICF6ICYmIC0xICE9IHhhLmluZGV4T2YoXCJNU0lFXCIpO1xuICB1YSA9ICF6ICYmIC0xICE9IHhhLmluZGV4T2YoXCJXZWJLaXRcIik7XG4gIHZhID0gIXogJiYgIXVhICYmIFwiR2Vja29cIiA9PSB5YS5wcm9kdWN0XG59XG52YXIgemEgPSB6LCBBID0gdGEsIEFhID0gdmEsIEIgPSB1YSwgQmEgPSBxLm5hdmlnYXRvciwgQ2EgPSAtMSAhPSAoQmEgJiYgQmEucGxhdGZvcm0gfHwgXCJcIikuaW5kZXhPZihcIk1hY1wiKTtcbmZ1bmN0aW9uIERhKCkge1xuICB2YXIgYSA9IHEuZG9jdW1lbnQ7XG4gIHJldHVybiBhID8gYS5kb2N1bWVudE1vZGUgOiB2b2lkIDBcbn1cbnZhciBFYTtcbmE6IHtcbiAgdmFyIEZhID0gXCJcIiwgR2E7XG4gIGlmKHphICYmIHEub3BlcmEpIHtcbiAgICB2YXIgSGEgPSBxLm9wZXJhLnZlcnNpb24sIEZhID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBIYSA/IEhhKCkgOiBIYVxuICB9ZWxzZSB7XG4gICAgaWYoQWEgPyBHYSA9IC9ydlxcOihbXlxcKTtdKykoXFwpfDspLyA6IEEgPyBHYSA9IC9NU0lFXFxzKyhbXlxcKTtdKykoXFwpfDspLyA6IEIgJiYgKEdhID0gL1dlYktpdFxcLyhcXFMrKS8pLCBHYSkge1xuICAgICAgdmFyIElhID0gR2EuZXhlYyh3YSgpKSwgRmEgPSBJYSA/IElhWzFdIDogXCJcIlxuICAgIH1cbiAgfVxuICBpZihBKSB7XG4gICAgdmFyIEphID0gRGEoKTtcbiAgICBpZihKYSA+IHBhcnNlRmxvYXQoRmEpKSB7XG4gICAgICBFYSA9IFN0cmluZyhKYSk7XG4gICAgICBicmVhayBhXG4gICAgfVxuICB9XG4gIEVhID0gRmFcbn1cbnZhciBLYSA9IHt9O1xuZnVuY3Rpb24gQyhhKSB7XG4gIHZhciBiO1xuICBpZighKGIgPSBLYVthXSkpIHtcbiAgICBiID0gMDtcbiAgICBmb3IodmFyIGMgPSBTdHJpbmcoRWEpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpLCBkID0gU3RyaW5nKGEpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpLCBmID0gTWF0aC5tYXgoYy5sZW5ndGgsIGQubGVuZ3RoKSwgZyA9IDA7MCA9PSBiICYmIGcgPCBmO2crKykge1xuICAgICAgdmFyIGggPSBjW2ddIHx8IFwiXCIsIG4gPSBkW2ddIHx8IFwiXCIsIGsgPSBSZWdFeHAoXCIoXFxcXGQqKShcXFxcRCopXCIsIFwiZ1wiKSwgdCA9IFJlZ0V4cChcIihcXFxcZCopKFxcXFxEKilcIiwgXCJnXCIpO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgbCA9IGsuZXhlYyhoKSB8fCBbXCJcIiwgXCJcIiwgXCJcIl0sIHIgPSB0LmV4ZWMobikgfHwgW1wiXCIsIFwiXCIsIFwiXCJdO1xuICAgICAgICBpZigwID09IGxbMF0ubGVuZ3RoICYmIDAgPT0gclswXS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGIgPSAoKDAgPT0gbFsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQobFsxXSwgMTApKSA8ICgwID09IHJbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KHJbMV0sIDEwKSkgPyAtMSA6ICgwID09IGxbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KGxbMV0sIDEwKSkgPiAoMCA9PSByWzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludChyWzFdLCAxMCkpID8gMSA6IDApIHx8ICgoMCA9PSBsWzJdLmxlbmd0aCkgPCAoMCA9PSByWzJdLmxlbmd0aCkgPyAtMSA6ICgwID09IGxbMl0ubGVuZ3RoKSA+ICgwID09IHJbMl0ubGVuZ3RoKSA/IDEgOiAwKSB8fCAobFsyXSA8IHJbMl0gPyAtMSA6IGxbMl0gPiByWzJdID8gMSA6IDApXG4gICAgICB9d2hpbGUoMCA9PSBiKVxuICAgIH1cbiAgICBiID0gS2FbYV0gPSAwIDw9IGJcbiAgfVxuICByZXR1cm4gYlxufVxudmFyIExhID0gcS5kb2N1bWVudCwgTWEgPSBMYSAmJiBBID8gRGEoKSB8fCAoXCJDU1MxQ29tcGF0XCIgPT0gTGEuY29tcGF0TW9kZSA/IHBhcnNlSW50KEVhLCAxMCkgOiA1KSA6IHZvaWQgMDtcbmZ1bmN0aW9uIE5hKGEpIHtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOYSkgOiB0aGlzLnN0YWNrID0gRXJyb3IoKS5zdGFjayB8fCBcIlwiO1xuICBhICYmICh0aGlzLm1lc3NhZ2UgPSBTdHJpbmcoYSkpXG59XG55KE5hLCBFcnJvcik7XG5OYS5wcm90b3R5cGUubmFtZSA9IFwiQ3VzdG9tRXJyb3JcIjtcbmZ1bmN0aW9uIE9hKGEsIGIpIHtcbiAgYi51bnNoaWZ0KGEpO1xuICBOYS5jYWxsKHRoaXMsIG1hLmFwcGx5KG51bGwsIGIpKTtcbiAgYi5zaGlmdCgpO1xuICB0aGlzLkpjID0gYVxufVxueShPYSwgTmEpO1xuT2EucHJvdG90eXBlLm5hbWUgPSBcIkFzc2VydGlvbkVycm9yXCI7XG5mdW5jdGlvbiBQYShhLCBiKSB7XG4gIHRocm93IG5ldyBPYShcIkZhaWx1cmVcIiArIChhID8gXCI6IFwiICsgYSA6IFwiXCIpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbn1cbjt2YXIgUWEgPSBSZWdFeHAoXCJeKD86KFteOi8/Iy5dKyk6KT8oPzovLyg/OihbXi8/I10qKUApPyhbXi8jP10qPykoPzo6KFswLTldKykpPyg/PVsvIz9dfCQpKT8oW14/I10rKT8oPzpcXFxcPyhbXiNdKikpPyg/OiMoLiopKT8kXCIpO1xuZnVuY3Rpb24gUmEoYSkge1xuICB2YXIgYiA9IFNhLCBjO1xuICBmb3IoYyBpbiBiKSB7XG4gICAgYS5jYWxsKHZvaWQgMCwgYltjXSwgYywgYilcbiAgfVxufVxuZnVuY3Rpb24gVGEoYSkge1xuICB2YXIgYiA9IFtdLCBjID0gMCwgZDtcbiAgZm9yKGQgaW4gYSkge1xuICAgIGJbYysrXSA9IGFbZF1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gVWEoYSkge1xuICB2YXIgYiA9IFtdLCBjID0gMCwgZDtcbiAgZm9yKGQgaW4gYSkge1xuICAgIGJbYysrXSA9IGRcbiAgfVxuICByZXR1cm4gYlxufVxudmFyIFZhID0gXCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIik7XG5mdW5jdGlvbiBXYShhLCBiKSB7XG4gIGZvcih2YXIgYywgZCwgZiA9IDE7ZiA8IGFyZ3VtZW50cy5sZW5ndGg7ZisrKSB7XG4gICAgZCA9IGFyZ3VtZW50c1tmXTtcbiAgICBmb3IoYyBpbiBkKSB7XG4gICAgICBhW2NdID0gZFtjXVxuICAgIH1cbiAgICBmb3IodmFyIGcgPSAwO2cgPCBWYS5sZW5ndGg7ZysrKSB7XG4gICAgICBjID0gVmFbZ10sIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLCBjKSAmJiAoYVtjXSA9IGRbY10pXG4gICAgfVxuICB9XG59XG47dmFyIEQgPSBBcnJheS5wcm90b3R5cGUsIFhhID0gRC5pbmRleE9mID8gZnVuY3Rpb24oYSwgYiwgYykge1xuICByZXR1cm4gRC5pbmRleE9mLmNhbGwoYSwgYiwgYylcbn0gOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGMgPSBudWxsID09IGMgPyAwIDogMCA+IGMgPyBNYXRoLm1heCgwLCBhLmxlbmd0aCArIGMpIDogYztcbiAgaWYodShhKSkge1xuICAgIHJldHVybiB1KGIpICYmIDEgPT0gYi5sZW5ndGggPyBhLmluZGV4T2YoYiwgYykgOiAtMVxuICB9XG4gIGZvcig7YyA8IGEubGVuZ3RoO2MrKykge1xuICAgIGlmKGMgaW4gYSAmJiBhW2NdID09PSBiKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgfVxuICByZXR1cm4tMVxufSwgWWEgPSBELmZvckVhY2ggPyBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIEQuZm9yRWFjaC5jYWxsKGEsIGIsIGMpXG59IDogZnVuY3Rpb24oYSwgYiwgYykge1xuICBmb3IodmFyIGQgPSBhLmxlbmd0aCwgZiA9IHUoYSkgPyBhLnNwbGl0KFwiXCIpIDogYSwgZyA9IDA7ZyA8IGQ7ZysrKSB7XG4gICAgZyBpbiBmICYmIGIuY2FsbChjLCBmW2ddLCBnLCBhKVxuICB9XG59O1xuZnVuY3Rpb24gWmEoYSkge1xuICByZXR1cm4gRC5jb25jYXQuYXBwbHkoRCwgYXJndW1lbnRzKVxufVxuZnVuY3Rpb24gJGEoYSkge1xuICB2YXIgYiA9IGEubGVuZ3RoO1xuICBpZigwIDwgYikge1xuICAgIGZvcih2YXIgYyA9IEFycmF5KGIpLCBkID0gMDtkIDwgYjtkKyspIHtcbiAgICAgIGNbZF0gPSBhW2RdXG4gICAgfVxuICAgIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuW11cbn1cbjtmdW5jdGlvbiBhYihhKSB7XG4gIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5OKSB7XG4gICAgcmV0dXJuIGEuTigpXG4gIH1cbiAgaWYodShhKSkge1xuICAgIHJldHVybiBhLnNwbGl0KFwiXCIpXG4gIH1cbiAgaWYoZ2EoYSkpIHtcbiAgICBmb3IodmFyIGIgPSBbXSwgYyA9IGEubGVuZ3RoLCBkID0gMDtkIDwgYztkKyspIHtcbiAgICAgIGIucHVzaChhW2RdKVxuICAgIH1cbiAgICByZXR1cm4gYlxuICB9XG4gIHJldHVybiBUYShhKVxufVxuZnVuY3Rpb24gRShhLCBiLCBjKSB7XG4gIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5mb3JFYWNoKSB7XG4gICAgYS5mb3JFYWNoKGIsIGMpXG4gIH1lbHNlIHtcbiAgICBpZihnYShhKSB8fCB1KGEpKSB7XG4gICAgICBZYShhLCBiLCBjKVxuICAgIH1lbHNlIHtcbiAgICAgIHZhciBkO1xuICAgICAgaWYoXCJmdW5jdGlvblwiID09IHR5cGVvZiBhLmthKSB7XG4gICAgICAgIGQgPSBhLmthKClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBhLk4pIHtcbiAgICAgICAgICBpZihnYShhKSB8fCB1KGEpKSB7XG4gICAgICAgICAgICBkID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGYgPSBhLmxlbmd0aCwgZyA9IDA7ZyA8IGY7ZysrKSB7XG4gICAgICAgICAgICAgIGQucHVzaChnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIGQgPSBVYShhKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGQgPSB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yKHZhciBmID0gYWIoYSksIGcgPSBmLmxlbmd0aCwgaCA9IDA7aCA8IGc7aCsrKSB7XG4gICAgICAgIGIuY2FsbChjLCBmW2hdLCBkICYmIGRbaF0sIGEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG47ZnVuY3Rpb24gYmIoYSwgYikge1xuICB0aGlzLk8gPSB7fTtcbiAgdGhpcy5qID0gW107XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYoMSA8IGMpIHtcbiAgICBpZihjICUgMikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJVbmV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50c1wiKTtcbiAgICB9XG4gICAgZm9yKHZhciBkID0gMDtkIDwgYztkICs9IDIpIHtcbiAgICAgIHRoaXMuc2V0KGFyZ3VtZW50c1tkXSwgYXJndW1lbnRzW2QgKyAxXSlcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZihhKSB7XG4gICAgICBhIGluc3RhbmNlb2YgYmIgPyAoYyA9IGEua2EoKSwgZCA9IGEuTigpKSA6IChjID0gVWEoYSksIGQgPSBUYShhKSk7XG4gICAgICBmb3IodmFyIGYgPSAwO2YgPCBjLmxlbmd0aDtmKyspIHtcbiAgICAgICAgdGhpcy5zZXQoY1tmXSwgZFtmXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnAgPSBiYi5wcm90b3R5cGU7XG5wLmYgPSAwO1xucC5iYyA9IDA7XG5wLk4gPSBmdW5jdGlvbigpIHtcbiAgY2IodGhpcyk7XG4gIGZvcih2YXIgYSA9IFtdLCBiID0gMDtiIDwgdGhpcy5qLmxlbmd0aDtiKyspIHtcbiAgICBhLnB1c2godGhpcy5PW3RoaXMualtiXV0pXG4gIH1cbiAgcmV0dXJuIGFcbn07XG5wLmthID0gZnVuY3Rpb24oKSB7XG4gIGNiKHRoaXMpO1xuICByZXR1cm4gdGhpcy5qLmNvbmNhdCgpXG59O1xucC5pYSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGRiKHRoaXMuTywgYSlcbn07XG5wLnJlbW92ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGRiKHRoaXMuTywgYSkgPyAoZGVsZXRlIHRoaXMuT1thXSwgdGhpcy5mLS0sIHRoaXMuYmMrKywgdGhpcy5qLmxlbmd0aCA+IDIgKiB0aGlzLmYgJiYgY2IodGhpcyksICEwKSA6ICExXG59O1xuZnVuY3Rpb24gY2IoYSkge1xuICBpZihhLmYgIT0gYS5qLmxlbmd0aCkge1xuICAgIGZvcih2YXIgYiA9IDAsIGMgPSAwO2IgPCBhLmoubGVuZ3RoOykge1xuICAgICAgdmFyIGQgPSBhLmpbYl07XG4gICAgICBkYihhLk8sIGQpICYmIChhLmpbYysrXSA9IGQpO1xuICAgICAgYisrXG4gICAgfVxuICAgIGEuai5sZW5ndGggPSBjXG4gIH1cbiAgaWYoYS5mICE9IGEuai5sZW5ndGgpIHtcbiAgICBmb3IodmFyIGYgPSB7fSwgYyA9IGIgPSAwO2IgPCBhLmoubGVuZ3RoOykge1xuICAgICAgZCA9IGEualtiXSwgZGIoZiwgZCkgfHwgKGEualtjKytdID0gZCwgZltkXSA9IDEpLCBiKytcbiAgICB9XG4gICAgYS5qLmxlbmd0aCA9IGNcbiAgfVxufVxucC5nZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBkYih0aGlzLk8sIGEpID8gdGhpcy5PW2FdIDogYlxufTtcbnAuc2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICBkYih0aGlzLk8sIGEpIHx8ICh0aGlzLmYrKywgdGhpcy5qLnB1c2goYSksIHRoaXMuYmMrKyk7XG4gIHRoaXMuT1thXSA9IGJcbn07XG5wLm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBiYih0aGlzKVxufTtcbmZ1bmN0aW9uIGRiKGEsIGIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKVxufVxuO2Z1bmN0aW9uIEYoYSwgYikge1xuICB2YXIgYztcbiAgaWYoYSBpbnN0YW5jZW9mIEYpIHtcbiAgICB0aGlzLkQgPSB2b2lkIDAgIT09IGIgPyBiIDogYS5ELCBlYih0aGlzLCBhLnFhKSwgYyA9IGEuYWIsIEgodGhpcyksIHRoaXMuYWIgPSBjLCBmYih0aGlzLCBhLmphKSwgZ2IodGhpcywgYS5CYSksIGhiKHRoaXMsIGEuSCksIGliKHRoaXMsIGEuUi5uKCkpLCBjID0gYS5NYSwgSCh0aGlzKSwgdGhpcy5NYSA9IGNcbiAgfWVsc2Uge1xuICAgIGlmKGEgJiYgKGMgPSBTdHJpbmcoYSkubWF0Y2goUWEpKSkge1xuICAgICAgdGhpcy5EID0gISFiO1xuICAgICAgZWIodGhpcywgY1sxXSB8fCBcIlwiLCAhMCk7XG4gICAgICB2YXIgZCA9IGNbMl0gfHwgXCJcIjtcbiAgICAgIEgodGhpcyk7XG4gICAgICB0aGlzLmFiID0gZCA/IGRlY29kZVVSSUNvbXBvbmVudChkKSA6IFwiXCI7XG4gICAgICBmYih0aGlzLCBjWzNdIHx8IFwiXCIsICEwKTtcbiAgICAgIGdiKHRoaXMsIGNbNF0pO1xuICAgICAgaGIodGhpcywgY1s1XSB8fCBcIlwiLCAhMCk7XG4gICAgICBpYih0aGlzLCBjWzZdIHx8IFwiXCIsICEwKTtcbiAgICAgIGMgPSBjWzddIHx8IFwiXCI7XG4gICAgICBIKHRoaXMpO1xuICAgICAgdGhpcy5NYSA9IGMgPyBkZWNvZGVVUklDb21wb25lbnQoYykgOiBcIlwiXG4gICAgfWVsc2Uge1xuICAgICAgdGhpcy5EID0gISFiLCB0aGlzLlIgPSBuZXcgamIobnVsbCwgMCwgdGhpcy5EKVxuICAgIH1cbiAgfVxufVxucCA9IEYucHJvdG90eXBlO1xucC5xYSA9IFwiXCI7XG5wLmFiID0gXCJcIjtcbnAuamEgPSBcIlwiO1xucC5CYSA9IG51bGw7XG5wLkggPSBcIlwiO1xucC5NYSA9IFwiXCI7XG5wLm1jID0gITE7XG5wLkQgPSAhMTtcbnAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBbXSwgYiA9IHRoaXMucWE7XG4gIGIgJiYgYS5wdXNoKGtiKGIsIGxiKSwgXCI6XCIpO1xuICBpZihiID0gdGhpcy5qYSkge1xuICAgIGEucHVzaChcIi8vXCIpO1xuICAgIHZhciBjID0gdGhpcy5hYjtcbiAgICBjICYmIGEucHVzaChrYihjLCBsYiksIFwiQFwiKTtcbiAgICBhLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhiKSkpO1xuICAgIGIgPSB0aGlzLkJhO1xuICAgIG51bGwgIT0gYiAmJiBhLnB1c2goXCI6XCIsIFN0cmluZyhiKSlcbiAgfVxuICBpZihiID0gdGhpcy5IKSB7XG4gICAgdGhpcy5qYSAmJiBcIi9cIiAhPSBiLmNoYXJBdCgwKSAmJiBhLnB1c2goXCIvXCIpLCBhLnB1c2goa2IoYiwgXCIvXCIgPT0gYi5jaGFyQXQoMCkgPyBtYiA6IG5iKSlcbiAgfVxuICAoYiA9IHRoaXMuUi50b1N0cmluZygpKSAmJiBhLnB1c2goXCI/XCIsIGIpO1xuICAoYiA9IHRoaXMuTWEpICYmIGEucHVzaChcIiNcIiwga2IoYiwgb2IpKTtcbiAgcmV0dXJuIGEuam9pbihcIlwiKVxufTtcbnAubiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEYodGhpcylcbn07XG5mdW5jdGlvbiBlYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIGEucWEgPSBjID8gYiA/IGRlY29kZVVSSUNvbXBvbmVudChiKSA6IFwiXCIgOiBiO1xuICBhLnFhICYmIChhLnFhID0gYS5xYS5yZXBsYWNlKC86JC8sIFwiXCIpKVxufVxuZnVuY3Rpb24gZmIoYSwgYiwgYykge1xuICBIKGEpO1xuICBhLmphID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYlxufVxuZnVuY3Rpb24gZ2IoYSwgYikge1xuICBIKGEpO1xuICBpZihiKSB7XG4gICAgYiA9IE51bWJlcihiKTtcbiAgICBpZihpc05hTihiKSB8fCAwID4gYikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJCYWQgcG9ydCBudW1iZXIgXCIgKyBiKTtcbiAgICB9XG4gICAgYS5CYSA9IGJcbiAgfWVsc2Uge1xuICAgIGEuQmEgPSBudWxsXG4gIH1cbn1cbmZ1bmN0aW9uIGhiKGEsIGIsIGMpIHtcbiAgSChhKTtcbiAgYS5IID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYlxufVxuZnVuY3Rpb24gaWIoYSwgYiwgYykge1xuICBIKGEpO1xuICBiIGluc3RhbmNlb2YgamIgPyAoYS5SID0gYiwgYS5SLnFiKGEuRCkpIDogKGMgfHwgKGIgPSBrYihiLCBwYikpLCBhLlIgPSBuZXcgamIoYiwgMCwgYS5EKSlcbn1cbmZ1bmN0aW9uIEkoYSwgYiwgYykge1xuICBIKGEpO1xuICBhLlIuc2V0KGIsIGMpXG59XG5mdW5jdGlvbiBxYihhLCBiLCBjKSB7XG4gIEgoYSk7XG4gIHMoYykgfHwgKGMgPSBbU3RyaW5nKGMpXSk7XG4gIHJiKGEuUiwgYiwgYylcbn1cbmZ1bmN0aW9uIEooYSkge1xuICBIKGEpO1xuICBJKGEsIFwienhcIiwgTWF0aC5mbG9vcigyMTQ3NDgzNjQ4ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4ICogTWF0aC5yYW5kb20oKSkgXiB4KCkpLnRvU3RyaW5nKDM2KSk7XG4gIHJldHVybiBhXG59XG5mdW5jdGlvbiBIKGEpIHtcbiAgaWYoYS5tYykge1xuICAgIHRocm93IEVycm9yKFwiVHJpZWQgdG8gbW9kaWZ5IGEgcmVhZC1vbmx5IFVyaVwiKTtcbiAgfVxufVxucC5xYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5EID0gYTtcbiAgdGhpcy5SICYmIHRoaXMuUi5xYihhKTtcbiAgcmV0dXJuIHRoaXNcbn07XG5mdW5jdGlvbiBzYihhLCBiLCBjLCBkKSB7XG4gIHZhciBmID0gbmV3IEYobnVsbCwgdm9pZCAwKTtcbiAgYSAmJiBlYihmLCBhKTtcbiAgYiAmJiBmYihmLCBiKTtcbiAgYyAmJiBnYihmLCBjKTtcbiAgZCAmJiBoYihmLCBkKTtcbiAgcmV0dXJuIGZcbn1cbmZ1bmN0aW9uIGtiKGEsIGIpIHtcbiAgcmV0dXJuIHUoYSkgPyBlbmNvZGVVUkkoYSkucmVwbGFjZShiLCB0YikgOiBudWxsXG59XG5mdW5jdGlvbiB0YihhKSB7XG4gIGEgPSBhLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVyblwiJVwiICsgKGEgPj4gNCAmIDE1KS50b1N0cmluZygxNikgKyAoYSAmIDE1KS50b1N0cmluZygxNilcbn1cbnZhciBsYiA9IC9bI1xcL1xcP0BdL2csIG5iID0gL1tcXCNcXD86XS9nLCBtYiA9IC9bXFwjXFw/XS9nLCBwYiA9IC9bXFwjXFw/QF0vZywgb2IgPSAvIy9nO1xuZnVuY3Rpb24gamIoYSwgYiwgYykge1xuICB0aGlzLkMgPSBhIHx8IG51bGw7XG4gIHRoaXMuRCA9ICEhY1xufVxuZnVuY3Rpb24gSyhhKSB7XG4gIGlmKCFhLmkgJiYgKGEuaSA9IG5ldyBiYiwgYS5mID0gMCwgYS5DKSkge1xuICAgIGZvcih2YXIgYiA9IGEuQy5zcGxpdChcIiZcIiksIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICAgIHZhciBkID0gYltjXS5pbmRleE9mKFwiPVwiKSwgZiA9IG51bGwsIGcgPSBudWxsO1xuICAgICAgMCA8PSBkID8gKGYgPSBiW2NdLnN1YnN0cmluZygwLCBkKSwgZyA9IGJbY10uc3Vic3RyaW5nKGQgKyAxKSkgOiBmID0gYltjXTtcbiAgICAgIGYgPSBkZWNvZGVVUklDb21wb25lbnQoZi5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbiAgICAgIGYgPSBMKGEsIGYpO1xuICAgICAgYS5hZGQoZiwgZyA/IGRlY29kZVVSSUNvbXBvbmVudChnLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpIDogXCJcIilcbiAgICB9XG4gIH1cbn1cbnAgPSBqYi5wcm90b3R5cGU7XG5wLmkgPSBudWxsO1xucC5mID0gbnVsbDtcbnAuYWRkID0gZnVuY3Rpb24oYSwgYikge1xuICBLKHRoaXMpO1xuICB0aGlzLkMgPSBudWxsO1xuICBhID0gTCh0aGlzLCBhKTtcbiAgdmFyIGMgPSB0aGlzLmkuZ2V0KGEpO1xuICBjIHx8IHRoaXMuaS5zZXQoYSwgYyA9IFtdKTtcbiAgYy5wdXNoKGIpO1xuICB0aGlzLmYrKztcbiAgcmV0dXJuIHRoaXNcbn07XG5wLnJlbW92ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgSyh0aGlzKTtcbiAgYSA9IEwodGhpcywgYSk7XG4gIHJldHVybiB0aGlzLmkuaWEoYSkgPyAodGhpcy5DID0gbnVsbCwgdGhpcy5mIC09IHRoaXMuaS5nZXQoYSkubGVuZ3RoLCB0aGlzLmkucmVtb3ZlKGEpKSA6ICExXG59O1xucC5pYSA9IGZ1bmN0aW9uKGEpIHtcbiAgSyh0aGlzKTtcbiAgYSA9IEwodGhpcywgYSk7XG4gIHJldHVybiB0aGlzLmkuaWEoYSlcbn07XG5wLmthID0gZnVuY3Rpb24oKSB7XG4gIEsodGhpcyk7XG4gIGZvcih2YXIgYSA9IHRoaXMuaS5OKCksIGIgPSB0aGlzLmkua2EoKSwgYyA9IFtdLCBkID0gMDtkIDwgYi5sZW5ndGg7ZCsrKSB7XG4gICAgZm9yKHZhciBmID0gYVtkXSwgZyA9IDA7ZyA8IGYubGVuZ3RoO2crKykge1xuICAgICAgYy5wdXNoKGJbZF0pXG4gICAgfVxuICB9XG4gIHJldHVybiBjXG59O1xucC5OID0gZnVuY3Rpb24oYSkge1xuICBLKHRoaXMpO1xuICB2YXIgYiA9IFtdO1xuICBpZihhKSB7XG4gICAgdGhpcy5pYShhKSAmJiAoYiA9IFphKGIsIHRoaXMuaS5nZXQoTCh0aGlzLCBhKSkpKVxuICB9ZWxzZSB7XG4gICAgYSA9IHRoaXMuaS5OKCk7XG4gICAgZm9yKHZhciBjID0gMDtjIDwgYS5sZW5ndGg7YysrKSB7XG4gICAgICBiID0gWmEoYiwgYVtjXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJcbn07XG5wLnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgSyh0aGlzKTtcbiAgdGhpcy5DID0gbnVsbDtcbiAgYSA9IEwodGhpcywgYSk7XG4gIHRoaXMuaWEoYSkgJiYgKHRoaXMuZiAtPSB0aGlzLmkuZ2V0KGEpLmxlbmd0aCk7XG4gIHRoaXMuaS5zZXQoYSwgW2JdKTtcbiAgdGhpcy5mKys7XG4gIHJldHVybiB0aGlzXG59O1xucC5nZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjID0gYSA/IHRoaXMuTihhKSA6IFtdO1xuICByZXR1cm4gMCA8IGMubGVuZ3RoID8gU3RyaW5nKGNbMF0pIDogYlxufTtcbmZ1bmN0aW9uIHJiKGEsIGIsIGMpIHtcbiAgYS5yZW1vdmUoYik7XG4gIDAgPCBjLmxlbmd0aCAmJiAoYS5DID0gbnVsbCwgYS5pLnNldChMKGEsIGIpLCAkYShjKSksIGEuZiArPSBjLmxlbmd0aClcbn1cbnAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5DKSB7XG4gICAgcmV0dXJuIHRoaXMuQ1xuICB9XG4gIGlmKCF0aGlzLmkpIHtcbiAgICByZXR1cm5cIlwiXG4gIH1cbiAgZm9yKHZhciBhID0gW10sIGIgPSB0aGlzLmkua2EoKSwgYyA9IDA7YyA8IGIubGVuZ3RoO2MrKykge1xuICAgIGZvcih2YXIgZCA9IGJbY10sIGYgPSBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGQpKSwgZCA9IHRoaXMuTihkKSwgZyA9IDA7ZyA8IGQubGVuZ3RoO2crKykge1xuICAgICAgdmFyIGggPSBmO1xuICAgICAgXCJcIiAhPT0gZFtnXSAmJiAoaCArPSBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZFtnXSkpKTtcbiAgICAgIGEucHVzaChoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5DID0gYS5qb2luKFwiJlwiKVxufTtcbnAubiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYSA9IG5ldyBqYjtcbiAgYS5DID0gdGhpcy5DO1xuICB0aGlzLmkgJiYgKGEuaSA9IHRoaXMuaS5uKCksIGEuZiA9IHRoaXMuZik7XG4gIHJldHVybiBhXG59O1xuZnVuY3Rpb24gTChhLCBiKSB7XG4gIHZhciBjID0gU3RyaW5nKGIpO1xuICBhLkQgJiYgKGMgPSBjLnRvTG93ZXJDYXNlKCkpO1xuICByZXR1cm4gY1xufVxucC5xYiA9IGZ1bmN0aW9uKGEpIHtcbiAgYSAmJiAhdGhpcy5EICYmIChLKHRoaXMpLCB0aGlzLkMgPSBudWxsLCBFKHRoaXMuaSwgZnVuY3Rpb24oYSwgYykge1xuICAgIHZhciBkID0gYy50b0xvd2VyQ2FzZSgpO1xuICAgIGMgIT0gZCAmJiAodGhpcy5yZW1vdmUoYyksIHJiKHRoaXMsIGQsIGEpKVxuICB9LCB0aGlzKSk7XG4gIHRoaXMuRCA9IGFcbn07XG5mdW5jdGlvbiB1YigpIHtcbn1cbnViLnByb3RvdHlwZS5HYSA9IG51bGw7XG52YXIgdmI7XG5mdW5jdGlvbiB3YigpIHtcbn1cbnkod2IsIHViKTtcbmZ1bmN0aW9uIHhiKGEpIHtcbiAgcmV0dXJuKGEgPSB5YihhKSkgPyBuZXcgQWN0aXZlWE9iamVjdChhKSA6IG5ldyBYTUxIdHRwUmVxdWVzdFxufVxuZnVuY3Rpb24gemIoYSkge1xuICB2YXIgYiA9IHt9O1xuICB5YihhKSAmJiAoYlswXSA9ICEwLCBiWzFdID0gITApO1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24geWIoYSkge1xuICBpZighYS5HYiAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBBY3RpdmVYT2JqZWN0KSB7XG4gICAgZm9yKHZhciBiID0gW1wiTVNYTUwyLlhNTEhUVFAuNi4wXCIsIFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIsIFwiTVNYTUwyLlhNTEhUVFBcIiwgXCJNaWNyb3NvZnQuWE1MSFRUUFwiXSwgYyA9IDA7YyA8IGIubGVuZ3RoO2MrKykge1xuICAgICAgdmFyIGQgPSBiW2NdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KGQpLCBhLkdiID0gZFxuICAgICAgfWNhdGNoKGYpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIEFjdGl2ZVhPYmplY3QuIEFjdGl2ZVggbWlnaHQgYmUgZGlzYWJsZWQsIG9yIE1TWE1MIG1pZ2h0IG5vdCBiZSBpbnN0YWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIGEuR2Jcbn1cbnZiID0gbmV3IHdiO1xuZnVuY3Rpb24gTSgpIHtcbiAgMCAhPSBBYiAmJiAodGhpcy5HYyA9IEVycm9yKCkuc3RhY2ssIEJiW3YodGhpcyldID0gdGhpcylcbn1cbnZhciBBYiA9IDAsIEJiID0ge307XG5NLnByb3RvdHlwZS55YiA9ICExO1xuTS5wcm90b3R5cGUuSWEgPSBmdW5jdGlvbigpIHtcbiAgaWYoIXRoaXMueWIgJiYgKHRoaXMueWIgPSAhMCwgdGhpcy51KCksIDAgIT0gQWIpKSB7XG4gICAgdmFyIGEgPSB2KHRoaXMpO1xuICAgIGRlbGV0ZSBCYlthXVxuICB9XG59O1xuTS5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLk5iKSB7XG4gICAgZm9yKDt0aGlzLk5iLmxlbmd0aDspIHtcbiAgICAgIHRoaXMuTmIuc2hpZnQoKSgpXG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gTihhLCBiKSB7XG4gIHRoaXMudHlwZSA9IGE7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IHRoaXMudGFyZ2V0ID0gYlxufVxucCA9IE4ucHJvdG90eXBlO1xucC51ID0gZSgpO1xucC5JYSA9IGUoKTtcbnAubmEgPSAhMTtcbnAuZGVmYXVsdFByZXZlbnRlZCA9ICExO1xucC5XYSA9ICEwO1xucC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSAhMDtcbiAgdGhpcy5XYSA9ICExXG59O1xudmFyIENiID0gMDtcbmZ1bmN0aW9uIERiKCkge1xufVxucCA9IERiLnByb3RvdHlwZTtcbnAua2V5ID0gMDtcbnAuZWEgPSAhMTtcbnAuSGEgPSAhMTtcbnAuT2EgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBmLCBnKSB7XG4gIGlmKGhhKGEpKSB7XG4gICAgdGhpcy5JYiA9ICEwXG4gIH1lbHNlIHtcbiAgICBpZihhICYmIGEuaGFuZGxlRXZlbnQgJiYgaGEoYS5oYW5kbGVFdmVudCkpIHtcbiAgICAgIHRoaXMuSWIgPSAhMVxuICAgIH1lbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBsaXN0ZW5lciBhcmd1bWVudFwiKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5XID0gYTtcbiAgdGhpcy5VYiA9IGI7XG4gIHRoaXMuc3JjID0gYztcbiAgdGhpcy50eXBlID0gZDtcbiAgdGhpcy5jYXB0dXJlID0gISFmO1xuICB0aGlzLmxiID0gZztcbiAgdGhpcy5IYSA9ICExO1xuICB0aGlzLmtleSA9ICsrQ2I7XG4gIHRoaXMuZWEgPSAhMVxufTtcbnAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLkliID8gdGhpcy5XLmNhbGwodGhpcy5sYiB8fCB0aGlzLnNyYywgYSkgOiB0aGlzLlcuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLlcsIGEpXG59O1xudmFyIEViID0gIUEgfHwgQSAmJiA5IDw9IE1hLCBGYiA9IEEgJiYgIUMoXCI5XCIpO1xuIUIgfHwgQyhcIjUyOFwiKTtcbkFhICYmIEMoXCIxLjliXCIpIHx8IEEgJiYgQyhcIjhcIikgfHwgemEgJiYgQyhcIjkuNVwiKSB8fCBCICYmIEMoXCI1MjhcIik7XG5BYSAmJiAhQyhcIjhcIikgfHwgQSAmJiBDKFwiOVwiKTtcbmZ1bmN0aW9uIEdiKGEpIHtcbiAgR2JbXCIgXCJdKGEpO1xuICByZXR1cm4gYVxufVxuR2JbXCIgXCJdID0gZWE7XG5mdW5jdGlvbiBIYihhLCBiKSB7XG4gIGEgJiYgdGhpcy5PYShhLCBiKVxufVxueShIYiwgTik7XG5wID0gSGIucHJvdG90eXBlO1xucC50YXJnZXQgPSBudWxsO1xucC5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbnAub2Zmc2V0WCA9IDA7XG5wLm9mZnNldFkgPSAwO1xucC5jbGllbnRYID0gMDtcbnAuY2xpZW50WSA9IDA7XG5wLnNjcmVlblggPSAwO1xucC5zY3JlZW5ZID0gMDtcbnAuYnV0dG9uID0gMDtcbnAua2V5Q29kZSA9IDA7XG5wLmNoYXJDb2RlID0gMDtcbnAuY3RybEtleSA9ICExO1xucC5hbHRLZXkgPSAhMTtcbnAuc2hpZnRLZXkgPSAhMTtcbnAubWV0YUtleSA9ICExO1xucC55YyA9ICExO1xucC56YiA9IG51bGw7XG5wLk9hID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYyA9IHRoaXMudHlwZSA9IGEudHlwZTtcbiAgTi5jYWxsKHRoaXMsIGMpO1xuICB0aGlzLnRhcmdldCA9IGEudGFyZ2V0IHx8IGEuc3JjRWxlbWVudDtcbiAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gYjtcbiAgdmFyIGQgPSBhLnJlbGF0ZWRUYXJnZXQ7XG4gIGlmKGQpIHtcbiAgICBpZihBYSkge1xuICAgICAgdmFyIGY7XG4gICAgICBhOiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgR2IoZC5ub2RlTmFtZSk7XG4gICAgICAgICAgZiA9ICEwO1xuICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgfWNhdGNoKGcpIHtcbiAgICAgICAgfVxuICAgICAgICBmID0gITFcbiAgICAgIH1cbiAgICAgIGYgfHwgKGQgPSBudWxsKVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIFwibW91c2VvdmVyXCIgPT0gYyA/IGQgPSBhLmZyb21FbGVtZW50IDogXCJtb3VzZW91dFwiID09IGMgJiYgKGQgPSBhLnRvRWxlbWVudClcbiAgfVxuICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBkO1xuICB0aGlzLm9mZnNldFggPSBCIHx8IHZvaWQgMCAhPT0gYS5vZmZzZXRYID8gYS5vZmZzZXRYIDogYS5sYXllclg7XG4gIHRoaXMub2Zmc2V0WSA9IEIgfHwgdm9pZCAwICE9PSBhLm9mZnNldFkgPyBhLm9mZnNldFkgOiBhLmxheWVyWTtcbiAgdGhpcy5jbGllbnRYID0gdm9pZCAwICE9PSBhLmNsaWVudFggPyBhLmNsaWVudFggOiBhLnBhZ2VYO1xuICB0aGlzLmNsaWVudFkgPSB2b2lkIDAgIT09IGEuY2xpZW50WSA/IGEuY2xpZW50WSA6IGEucGFnZVk7XG4gIHRoaXMuc2NyZWVuWCA9IGEuc2NyZWVuWCB8fCAwO1xuICB0aGlzLnNjcmVlblkgPSBhLnNjcmVlblkgfHwgMDtcbiAgdGhpcy5idXR0b24gPSBhLmJ1dHRvbjtcbiAgdGhpcy5rZXlDb2RlID0gYS5rZXlDb2RlIHx8IDA7XG4gIHRoaXMuY2hhckNvZGUgPSBhLmNoYXJDb2RlIHx8IChcImtleXByZXNzXCIgPT0gYyA/IGEua2V5Q29kZSA6IDApO1xuICB0aGlzLmN0cmxLZXkgPSBhLmN0cmxLZXk7XG4gIHRoaXMuYWx0S2V5ID0gYS5hbHRLZXk7XG4gIHRoaXMuc2hpZnRLZXkgPSBhLnNoaWZ0S2V5O1xuICB0aGlzLm1ldGFLZXkgPSBhLm1ldGFLZXk7XG4gIHRoaXMueWMgPSBDYSA/IGEubWV0YUtleSA6IGEuY3RybEtleTtcbiAgdGhpcy5zdGF0ZSA9IGEuc3RhdGU7XG4gIHRoaXMuemIgPSBhO1xuICBhLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICBkZWxldGUgdGhpcy5uYVxufTtcbnAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgSGIucmEucHJldmVudERlZmF1bHQuY2FsbCh0aGlzKTtcbiAgdmFyIGEgPSB0aGlzLnpiO1xuICBpZihhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgYS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1lbHNlIHtcbiAgICBpZihhLnJldHVyblZhbHVlID0gITEsIEZiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZihhLmN0cmxLZXkgfHwgMTEyIDw9IGEua2V5Q29kZSAmJiAxMjMgPj0gYS5rZXlDb2RlKSB7XG4gICAgICAgICAgYS5rZXlDb2RlID0gLTFcbiAgICAgICAgfVxuICAgICAgfWNhdGNoKGIpIHtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5wLnUgPSBlKCk7XG52YXIgU2EgPSB7fSwgTyA9IHt9LCBQID0ge30sIEliID0ge307XG5mdW5jdGlvbiBKYihhLCBiLCBjLCBkLCBmKSB7XG4gIGlmKHMoYikpIHtcbiAgICBmb3IodmFyIGcgPSAwO2cgPCBiLmxlbmd0aDtnKyspIHtcbiAgICAgIEpiKGEsIGJbZ10sIGMsIGQsIGYpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgYToge1xuICAgIGlmKCFiKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgZXZlbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgZCA9ICEhZDtcbiAgICB2YXIgaCA9IE87XG4gICAgYiBpbiBoIHx8IChoW2JdID0ge2Y6MCwgdDowfSk7XG4gICAgaCA9IGhbYl07XG4gICAgZCBpbiBoIHx8IChoW2RdID0ge2Y6MCwgdDowfSwgaC5mKyspO1xuICAgIHZhciBoID0gaFtkXSwgZyA9IHYoYSksIG47XG4gICAgaC50Kys7XG4gICAgaWYoaFtnXSkge1xuICAgICAgbiA9IGhbZ107XG4gICAgICBmb3IodmFyIGsgPSAwO2sgPCBuLmxlbmd0aDtrKyspIHtcbiAgICAgICAgaWYoaCA9IG5ba10sIGguVyA9PSBjICYmIGgubGIgPT0gZikge1xuICAgICAgICAgIGlmKGguZWEpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIG5ba10uSGEgPSAhMTtcbiAgICAgICAgICBhID0gbltrXTtcbiAgICAgICAgICBicmVhayBhXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICBuID0gaFtnXSA9IFtdLCBoLmYrK1xuICAgIH1cbiAgICBrID0gS2IoKTtcbiAgICBoID0gbmV3IERiO1xuICAgIGguT2EoYywgaywgYSwgYiwgZCwgZik7XG4gICAgaC5IYSA9ICExO1xuICAgIGsuc3JjID0gYTtcbiAgICBrLlcgPSBoO1xuICAgIG4ucHVzaChoKTtcbiAgICBQW2ddIHx8IChQW2ddID0gW10pO1xuICAgIFBbZ10ucHVzaChoKTtcbiAgICBhLmFkZEV2ZW50TGlzdGVuZXIgPyBhICE9IHEgJiYgYS53YiB8fCBhLmFkZEV2ZW50TGlzdGVuZXIoYiwgaywgZCkgOiBhLmF0dGFjaEV2ZW50KGIgaW4gSWIgPyBJYltiXSA6IEliW2JdID0gXCJvblwiICsgYiwgayk7XG4gICAgYSA9IGhcbiAgfVxuICBiID0gYS5rZXk7XG4gIFNhW2JdID0gYTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIEtiKCkge1xuICB2YXIgYSA9IExiLCBiID0gRWIgPyBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGEuY2FsbChiLnNyYywgYi5XLCBjKVxuICB9IDogZnVuY3Rpb24oYykge1xuICAgIGMgPSBhLmNhbGwoYi5zcmMsIGIuVywgYyk7XG4gICAgaWYoIWMpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICB9O1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gTWIoYSwgYiwgYywgZCwgZikge1xuICBpZihzKGIpKSB7XG4gICAgZm9yKHZhciBnID0gMDtnIDwgYi5sZW5ndGg7ZysrKSB7XG4gICAgICBNYihhLCBiW2ddLCBjLCBkLCBmKVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGQgPSAhIWQ7XG4gICAgYToge1xuICAgICAgZyA9IE87XG4gICAgICBpZihiIGluIGcgJiYgKGcgPSBnW2JdLCBkIGluIGcgJiYgKGcgPSBnW2RdLCBhID0gdihhKSwgZ1thXSkpKSB7XG4gICAgICAgIGEgPSBnW2FdO1xuICAgICAgICBicmVhayBhXG4gICAgICB9XG4gICAgICBhID0gbnVsbFxuICAgIH1cbiAgICBpZihhKSB7XG4gICAgICBmb3IoZyA9IDA7ZyA8IGEubGVuZ3RoO2crKykge1xuICAgICAgICBpZihhW2ddLlcgPT0gYyAmJiBhW2ddLmNhcHR1cmUgPT0gZCAmJiBhW2ddLmxiID09IGYpIHtcbiAgICAgICAgICBOYihhW2ddLmtleSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gTmIoYSkge1xuICB2YXIgYiA9IFNhW2FdO1xuICBpZighYiB8fCBiLmVhKSB7XG4gICAgcmV0dXJuITFcbiAgfVxuICB2YXIgYyA9IGIuc3JjLCBkID0gYi50eXBlLCBmID0gYi5VYiwgZyA9IGIuY2FwdHVyZTtcbiAgYy5yZW1vdmVFdmVudExpc3RlbmVyID8gYyAhPSBxICYmIGMud2IgfHwgYy5yZW1vdmVFdmVudExpc3RlbmVyKGQsIGYsIGcpIDogYy5kZXRhY2hFdmVudCAmJiBjLmRldGFjaEV2ZW50KGQgaW4gSWIgPyBJYltkXSA6IEliW2RdID0gXCJvblwiICsgZCwgZik7XG4gIGMgPSB2KGMpO1xuICBpZihQW2NdKSB7XG4gICAgdmFyIGYgPSBQW2NdLCBoID0gWGEoZiwgYik7XG4gICAgMCA8PSBoICYmIEQuc3BsaWNlLmNhbGwoZiwgaCwgMSk7XG4gICAgMCA9PSBmLmxlbmd0aCAmJiBkZWxldGUgUFtjXVxuICB9XG4gIGIuZWEgPSAhMDtcbiAgaWYoYiA9IE9bZF1bZ11bY10pIHtcbiAgICBiLk1iID0gITAsIE9iKGQsIGcsIGMsIGIpXG4gIH1cbiAgZGVsZXRlIFNhW2FdO1xuICByZXR1cm4hMFxufVxuZnVuY3Rpb24gT2IoYSwgYiwgYywgZCkge1xuICBpZighZC5RYSAmJiBkLk1iKSB7XG4gICAgZm9yKHZhciBmID0gMCwgZyA9IDA7ZiA8IGQubGVuZ3RoO2YrKykge1xuICAgICAgZFtmXS5lYSA/IGRbZl0uVWIuc3JjID0gbnVsbCA6IChmICE9IGcgJiYgKGRbZ10gPSBkW2ZdKSwgZysrKVxuICAgIH1cbiAgICBkLmxlbmd0aCA9IGc7XG4gICAgZC5NYiA9ICExO1xuICAgIDAgPT0gZyAmJiAoZGVsZXRlIE9bYV1bYl1bY10sIE9bYV1bYl0uZi0tLCAwID09IE9bYV1bYl0uZiAmJiAoZGVsZXRlIE9bYV1bYl0sIE9bYV0uZi0tKSwgMCA9PSBPW2FdLmYgJiYgZGVsZXRlIE9bYV0pXG4gIH1cbn1cbmZ1bmN0aW9uIFBiKGEpIHtcbiAgdmFyIGIgPSAwO1xuICBpZihudWxsICE9IGEpIHtcbiAgICBpZihhID0gdihhKSwgUFthXSkge1xuICAgICAgYSA9IFBbYV07XG4gICAgICBmb3IodmFyIGMgPSBhLmxlbmd0aCAtIDE7MCA8PSBjO2MtLSkge1xuICAgICAgICBOYihhW2NdLmtleSksIGIrK1xuICAgICAgfVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIFJhKGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIE5iKGMpO1xuICAgICAgYisrXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gUWIoYSwgYiwgYywgZCwgZikge1xuICB2YXIgZyA9IDE7XG4gIGIgPSB2KGIpO1xuICBpZihhW2JdKSB7XG4gICAgdmFyIGggPSAtLWEudCwgbiA9IGFbYl07XG4gICAgbi5RYSA/IG4uUWErKyA6IG4uUWEgPSAxO1xuICAgIHRyeSB7XG4gICAgICBmb3IodmFyIGsgPSBuLmxlbmd0aCwgdCA9IDA7dCA8IGs7dCsrKSB7XG4gICAgICAgIHZhciBsID0gblt0XTtcbiAgICAgICAgbCAmJiAhbC5lYSAmJiAoZyAmPSAhMSAhPT0gUmIobCwgZikpXG4gICAgICB9XG4gICAgfWZpbmFsbHkge1xuICAgICAgYS50ID0gTWF0aC5tYXgoaCwgYS50KSwgbi5RYS0tLCBPYihjLCBkLCBiLCBuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gQm9vbGVhbihnKVxufVxuZnVuY3Rpb24gUmIoYSwgYikge1xuICBhLkhhICYmIE5iKGEua2V5KTtcbiAgcmV0dXJuIGEuaGFuZGxlRXZlbnQoYilcbn1cbmZ1bmN0aW9uIExiKGEsIGIpIHtcbiAgaWYoYS5lYSkge1xuICAgIHJldHVybiEwXG4gIH1cbiAgdmFyIGMgPSBhLnR5cGUsIGQgPSBPO1xuICBpZighKGMgaW4gZCkpIHtcbiAgICByZXR1cm4hMFxuICB9XG4gIHZhciBkID0gZFtjXSwgZiwgZztcbiAgaWYoIUViKSB7XG4gICAgZiA9IGIgfHwgZGEoXCJ3aW5kb3cuZXZlbnRcIik7XG4gICAgdmFyIGggPSAhMCBpbiBkLCBuID0gITEgaW4gZDtcbiAgICBpZihoKSB7XG4gICAgICBpZigwID4gZi5rZXlDb2RlIHx8IHZvaWQgMCAhPSBmLnJldHVyblZhbHVlKSB7XG4gICAgICAgIHJldHVybiEwXG4gICAgICB9XG4gICAgICBhOiB7XG4gICAgICAgIHZhciBrID0gITE7XG4gICAgICAgIGlmKDAgPT0gZi5rZXlDb2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGYua2V5Q29kZSA9IC0xO1xuICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgIH1jYXRjaCh0KSB7XG4gICAgICAgICAgICBrID0gITBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoayB8fCB2b2lkIDAgPT0gZi5yZXR1cm5WYWx1ZSkge1xuICAgICAgICAgIGYucmV0dXJuVmFsdWUgPSAhMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGsgPSBuZXcgSGI7XG4gICAgay5PYShmLCB0aGlzKTtcbiAgICBmID0gITA7XG4gICAgdHJ5IHtcbiAgICAgIGlmKGgpIHtcbiAgICAgICAgZm9yKHZhciBsID0gW10sIHIgPSBrLmN1cnJlbnRUYXJnZXQ7cjtyID0gci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgbC5wdXNoKHIpXG4gICAgICAgIH1cbiAgICAgICAgZyA9IGRbITBdO1xuICAgICAgICBnLnQgPSBnLmY7XG4gICAgICAgIGZvcih2YXIgRyA9IGwubGVuZ3RoIC0gMTshay5uYSAmJiAwIDw9IEcgJiYgZy50O0ctLSkge1xuICAgICAgICAgIGsuY3VycmVudFRhcmdldCA9IGxbR10sIGYgJj0gUWIoZywgbFtHXSwgYywgITAsIGspXG4gICAgICAgIH1cbiAgICAgICAgaWYobikge1xuICAgICAgICAgIGZvcihnID0gZFshMV0sIGcudCA9IGcuZiwgRyA9IDA7IWsubmEgJiYgRyA8IGwubGVuZ3RoICYmIGcudDtHKyspIHtcbiAgICAgICAgICAgIGsuY3VycmVudFRhcmdldCA9IGxbR10sIGYgJj0gUWIoZywgbFtHXSwgYywgITEsIGspXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGYgPSBSYihhLCBrKVxuICAgICAgfVxuICAgIH1maW5hbGx5IHtcbiAgICAgIGwgJiYgKGwubGVuZ3RoID0gMClcbiAgICB9XG4gICAgcmV0dXJuIGZcbiAgfVxuICBjID0gbmV3IEhiKGIsIHRoaXMpO1xuICByZXR1cm4gZiA9IFJiKGEsIGMpXG59XG47ZnVuY3Rpb24gU2IoKSB7XG4gIE0uY2FsbCh0aGlzKVxufVxueShTYiwgTSk7XG5wID0gU2IucHJvdG90eXBlO1xucC53YiA9ICEwO1xucC5wYiA9IG51bGw7XG5wLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIEpiKHRoaXMsIGEsIGIsIGMsIGQpXG59O1xucC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBNYih0aGlzLCBhLCBiLCBjLCBkKVxufTtcbnAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGEpIHtcbiAgdmFyIGIgPSBhLnR5cGUgfHwgYSwgYyA9IE87XG4gIGlmKGIgaW4gYykge1xuICAgIGlmKHUoYSkpIHtcbiAgICAgIGEgPSBuZXcgTihhLCB0aGlzKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBOKSB7XG4gICAgICAgIGEudGFyZ2V0ID0gYS50YXJnZXQgfHwgdGhpc1xuICAgICAgfWVsc2Uge1xuICAgICAgICB2YXIgZCA9IGE7XG4gICAgICAgIGEgPSBuZXcgTihiLCB0aGlzKTtcbiAgICAgICAgV2EoYSwgZClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGQgPSAxLCBmLCBjID0gY1tiXSwgYiA9ICEwIGluIGMsIGc7XG4gICAgaWYoYikge1xuICAgICAgZiA9IFtdO1xuICAgICAgZm9yKGcgPSB0aGlzO2c7ZyA9IGcucGIpIHtcbiAgICAgICAgZi5wdXNoKGcpXG4gICAgICB9XG4gICAgICBnID0gY1shMF07XG4gICAgICBnLnQgPSBnLmY7XG4gICAgICBmb3IodmFyIGggPSBmLmxlbmd0aCAtIDE7IWEubmEgJiYgMCA8PSBoICYmIGcudDtoLS0pIHtcbiAgICAgICAgYS5jdXJyZW50VGFyZ2V0ID0gZltoXSwgZCAmPSBRYihnLCBmW2hdLCBhLnR5cGUsICEwLCBhKSAmJiAhMSAhPSBhLldhXG4gICAgICB9XG4gICAgfVxuICAgIGlmKCExIGluIGMpIHtcbiAgICAgIGlmKGcgPSBjWyExXSwgZy50ID0gZy5mLCBiKSB7XG4gICAgICAgIGZvcihoID0gMDshYS5uYSAmJiBoIDwgZi5sZW5ndGggJiYgZy50O2grKykge1xuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGZbaF0sIGQgJj0gUWIoZywgZltoXSwgYS50eXBlLCAhMSwgYSkgJiYgITEgIT0gYS5XYVxuICAgICAgICB9XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGZvcihmID0gdGhpczshYS5uYSAmJiBmICYmIGcudDtmID0gZi5wYikge1xuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGYsIGQgJj0gUWIoZywgZiwgYS50eXBlLCAhMSwgYSkgJiYgITEgIT0gYS5XYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGEgPSBCb29sZWFuKGQpXG4gIH1lbHNlIHtcbiAgICBhID0gITBcbiAgfVxuICByZXR1cm4gYVxufTtcbnAudSA9IGZ1bmN0aW9uKCkge1xuICBTYi5yYS51LmNhbGwodGhpcyk7XG4gIFBiKHRoaXMpO1xuICB0aGlzLnBiID0gbnVsbFxufTtcbmZ1bmN0aW9uIFRiKGEsIGIpIHtcbiAgTS5jYWxsKHRoaXMpO1xuICB0aGlzLmRhID0gYSB8fCAxO1xuICB0aGlzLkVhID0gYiB8fCBxO1xuICB0aGlzLmViID0gdyh0aGlzLkVjLCB0aGlzKTtcbiAgdGhpcy5vYiA9IHgoKVxufVxueShUYiwgU2IpO1xucCA9IFRiLnByb3RvdHlwZTtcbnAuZW5hYmxlZCA9ICExO1xucC5yID0gbnVsbDtcbnAuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuZGEgPSBhO1xuICB0aGlzLnIgJiYgdGhpcy5lbmFibGVkID8gKHRoaXMuc3RvcCgpLCB0aGlzLnN0YXJ0KCkpIDogdGhpcy5yICYmIHRoaXMuc3RvcCgpXG59O1xucC5FYyA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLmVuYWJsZWQpIHtcbiAgICB2YXIgYSA9IHgoKSAtIHRoaXMub2I7XG4gICAgMCA8IGEgJiYgYSA8IDAuOCAqIHRoaXMuZGEgPyB0aGlzLnIgPSB0aGlzLkVhLnNldFRpbWVvdXQodGhpcy5lYiwgdGhpcy5kYSAtIGEpIDogKHRoaXMuZGlzcGF0Y2hFdmVudChVYiksIHRoaXMuZW5hYmxlZCAmJiAodGhpcy5yID0gdGhpcy5FYS5zZXRUaW1lb3V0KHRoaXMuZWIsIHRoaXMuZGEpLCB0aGlzLm9iID0geCgpKSlcbiAgfVxufTtcbnAuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbmFibGVkID0gITA7XG4gIHRoaXMuciB8fCAodGhpcy5yID0gdGhpcy5FYS5zZXRUaW1lb3V0KHRoaXMuZWIsIHRoaXMuZGEpLCB0aGlzLm9iID0geCgpKVxufTtcbnAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVuYWJsZWQgPSAhMTtcbiAgdGhpcy5yICYmICh0aGlzLkVhLmNsZWFyVGltZW91dCh0aGlzLnIpLCB0aGlzLnIgPSBudWxsKVxufTtcbnAudSA9IGZ1bmN0aW9uKCkge1xuICBUYi5yYS51LmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcCgpO1xuICBkZWxldGUgdGhpcy5FYVxufTtcbnZhciBVYiA9IFwidGlja1wiO1xuZnVuY3Rpb24gVmIoYSkge1xuICBNLmNhbGwodGhpcyk7XG4gIHRoaXMuZSA9IGE7XG4gIHRoaXMuaiA9IFtdXG59XG55KFZiLCBNKTtcbnZhciBXYiA9IFtdO1xuZnVuY3Rpb24gWGIoYSwgYiwgYywgZCkge1xuICBzKGMpIHx8IChXYlswXSA9IGMsIGMgPSBXYik7XG4gIGZvcih2YXIgZiA9IDA7ZiA8IGMubGVuZ3RoO2YrKykge1xuICAgIHZhciBnID0gSmIoYiwgY1tmXSwgZCB8fCBhLCAhMSwgYS5lIHx8IGEpO1xuICAgIGEuai5wdXNoKGcpXG4gIH1cbn1cblZiLnByb3RvdHlwZS51ID0gZnVuY3Rpb24oKSB7XG4gIFZiLnJhLnUuY2FsbCh0aGlzKTtcbiAgWWEodGhpcy5qLCBOYik7XG4gIHRoaXMuai5sZW5ndGggPSAwXG59O1xuVmIucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IEVycm9yKFwiRXZlbnRIYW5kbGVyLmhhbmRsZUV2ZW50IG5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5mdW5jdGlvbiBZYihhLCBiLCBjKSB7XG4gIE0uY2FsbCh0aGlzKTtcbiAgdGhpcy5uYyA9IGE7XG4gIHRoaXMuZGEgPSBiO1xuICB0aGlzLmUgPSBjO1xuICB0aGlzLmhjID0gdyh0aGlzLnRjLCB0aGlzKVxufVxueShZYiwgTSk7XG5wID0gWWIucHJvdG90eXBlO1xucC5YYSA9ICExO1xucC5UYiA9IDA7XG5wLnIgPSBudWxsO1xucC5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuciAmJiAocS5jbGVhclRpbWVvdXQodGhpcy5yKSwgdGhpcy5yID0gbnVsbCwgdGhpcy5YYSA9ICExKVxufTtcbnAudSA9IGZ1bmN0aW9uKCkge1xuICBZYi5yYS51LmNhbGwodGhpcyk7XG4gIHRoaXMuc3RvcCgpXG59O1xucC50YyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnIgPSBudWxsO1xuICB0aGlzLlhhICYmICF0aGlzLlRiICYmICh0aGlzLlhhID0gITEsIFpiKHRoaXMpKVxufTtcbmZ1bmN0aW9uIFpiKGEpIHtcbiAgdmFyIGI7XG4gIGIgPSBhLmhjO1xuICB2YXIgYyA9IGEuZGE7XG4gIGlmKCFoYShiKSkge1xuICAgIGlmKGIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBiLmhhbmRsZUV2ZW50KSB7XG4gICAgICBiID0gdyhiLmhhbmRsZUV2ZW50LCBiKVxuICAgIH1lbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBsaXN0ZW5lciBhcmd1bWVudFwiKTtcbiAgICB9XG4gIH1cbiAgYiA9IDIxNDc0ODM2NDcgPCBjID8gLTEgOiBxLnNldFRpbWVvdXQoYiwgYyB8fCAwKTtcbiAgYS5yID0gYjtcbiAgYS5uYy5jYWxsKGEuZSlcbn1cbjtmdW5jdGlvbiBRKGEsIGIsIGMsIGQsIGYpIHtcbiAgdGhpcy5iID0gYTtcbiAgdGhpcy5hID0gYjtcbiAgdGhpcy5aID0gYztcbiAgdGhpcy5CID0gZDtcbiAgdGhpcy5DYSA9IGYgfHwgMTtcbiAgdGhpcy5EYSA9ICRiO1xuICB0aGlzLmpiID0gbmV3IFZiKHRoaXMpO1xuICB0aGlzLlNhID0gbmV3IFRiO1xuICB0aGlzLlNhLnNldEludGVydmFsKGFjKVxufVxucCA9IFEucHJvdG90eXBlO1xucC52ID0gbnVsbDtcbnAuSiA9ICExO1xucC51YSA9IG51bGw7XG5wLnNiID0gbnVsbDtcbnAucGEgPSBudWxsO1xucC5zYSA9IG51bGw7XG5wLlQgPSBudWxsO1xucC53ID0gbnVsbDtcbnAuWCA9IG51bGw7XG5wLmwgPSBudWxsO1xucC5GYSA9IDA7XG5wLksgPSBudWxsO1xucC50YSA9IG51bGw7XG5wLnAgPSBudWxsO1xucC5oID0gLTE7XG5wLlhiID0gITA7XG5wLmFhID0gITE7XG5wLm9hID0gMDtcbnAuVGEgPSBudWxsO1xudmFyICRiID0gNDVFMywgYWMgPSAyNTA7XG5mdW5jdGlvbiBiYyhhLCBiKSB7XG4gIHN3aXRjaChhKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuXCJOb24tMjAwIHJldHVybiBjb2RlIChcIiArIGIgKyBcIilcIjtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm5cIlhNTEhUVFAgZmFpbHVyZSAobm8gZGF0YSlcIjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm5cIkh0dHBDb25uZWN0aW9uIHRpbWVvdXRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuXCJVbmtub3duIGVycm9yXCJcbiAgfVxufVxudmFyIGNjID0ge30sIGRjID0ge307XG5mdW5jdGlvbiBlYygpIHtcbiAgcmV0dXJuIUEgfHwgQSAmJiAxMCA8PSBNYVxufVxucCA9IFEucHJvdG90eXBlO1xucC5ZID0gbShcInZcIik7XG5wLnNldFRpbWVvdXQgPSBtKFwiRGFcIik7XG5wLiRiID0gbShcIm9hXCIpO1xuZnVuY3Rpb24gZmMoYSwgYiwgYykge1xuICBhLnNhID0gMTtcbiAgYS5UID0gSihiLm4oKSk7XG4gIGEuWCA9IGM7XG4gIGEueGIgPSAhMDtcbiAgZ2MoYSwgbnVsbClcbn1cbmZ1bmN0aW9uIGhjKGEsIGIsIGMsIGQsIGYpIHtcbiAgYS5zYSA9IDE7XG4gIGEuVCA9IEooYi5uKCkpO1xuICBhLlggPSBudWxsO1xuICBhLnhiID0gYztcbiAgZiAmJiAoYS5YYiA9ICExKTtcbiAgZ2MoYSwgZClcbn1cbmZ1bmN0aW9uIGdjKGEsIGIpIHtcbiAgYS5wYSA9IHgoKTtcbiAgaWMoYSk7XG4gIGEudyA9IGEuVC5uKCk7XG4gIHFiKGEudywgXCJ0XCIsIGEuQ2EpO1xuICBhLkZhID0gMDtcbiAgYS5sID0gYS5iLmhiKGEuYi5ZYSgpID8gYiA6IG51bGwpO1xuICAwIDwgYS5vYSAmJiAoYS5UYSA9IG5ldyBZYih3KGEuZGMsIGEsIGEubCksIGEub2EpKTtcbiAgWGIoYS5qYiwgYS5sLCBcInJlYWR5c3RhdGVjaGFuZ2VcIiwgYS5BYyk7XG4gIHZhciBjO1xuICBpZihhLnYpIHtcbiAgICBjID0gYS52O1xuICAgIHZhciBkID0ge30sIGY7XG4gICAgZm9yKGYgaW4gYykge1xuICAgICAgZFtmXSA9IGNbZl1cbiAgICB9XG4gICAgYyA9IGRcbiAgfWVsc2Uge1xuICAgIGMgPSB7fVxuICB9XG4gIGEuWCA/IChhLnRhID0gXCJQT1NUXCIsIGNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBhLmwuc2VuZChhLncsIGEudGEsIGEuWCwgYykpIDogKGEudGEgPSBcIkdFVFwiLCBhLlhiICYmICFCICYmIChjLkNvbm5lY3Rpb24gPSBcImNsb3NlXCIpLCBhLmwuc2VuZChhLncsIGEudGEsIG51bGwsIGMpKTtcbiAgYS5iLkcoamMpO1xuICBpZihkID0gYS5YKSB7XG4gICAgZm9yKGMgPSBcIlwiLCBkID0gZC5zcGxpdChcIiZcIiksIGYgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgIHZhciBnID0gZFtmXS5zcGxpdChcIj1cIik7XG4gICAgICBpZigxIDwgZy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGggPSBnWzBdLCBnID0gZ1sxXSwgbiA9IGguc3BsaXQoXCJfXCIpO1xuICAgICAgICBjID0gMiA8PSBuLmxlbmd0aCAmJiBcInR5cGVcIiA9PSBuWzFdID8gYyArIChoICsgXCI9XCIgKyBnICsgXCImXCIpIDogYyArIChoICsgXCI9cmVkYWN0ZWQmXCIpXG4gICAgICB9XG4gICAgfVxuICB9ZWxzZSB7XG4gICAgYyA9IG51bGxcbiAgfVxuICBhLmEuaW5mbyhcIlhNTEhUVFAgUkVRIChcIiArIGEuQiArIFwiKSBbYXR0ZW1wdCBcIiArIGEuQ2EgKyBcIl06IFwiICsgYS50YSArIFwiXFxuXCIgKyBhLncgKyBcIlxcblwiICsgYylcbn1cbnAuQWMgPSBmdW5jdGlvbihhKSB7XG4gIGEgPSBhLnRhcmdldDtcbiAgdmFyIGIgPSB0aGlzLlRhO1xuICBiICYmIDMgPT0gUihhKSA/ICh0aGlzLmEuZGVidWcoXCJUaHJvdHRsaW5nIHJlYWR5c3RhdGVjaGFuZ2UuXCIpLCBiLnIgfHwgYi5UYiA/IGIuWGEgPSAhMCA6IFpiKGIpKSA6IHRoaXMuZGMoYSlcbn07XG5wLmRjID0gZnVuY3Rpb24oYSkge1xuICB0cnkge1xuICAgIGlmKGEgPT0gdGhpcy5sKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHZhciBiID0gUih0aGlzLmwpLCBjID0gdGhpcy5sLmxhLCBkID0ga2ModGhpcy5sKTtcbiAgICAgICAgaWYoIWVjKCkgfHwgQiAmJiAhQyhcIjQyMCtcIikpIHtcbiAgICAgICAgICBpZig0ID4gYikge1xuICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIGlmKDMgPiBiIHx8IDMgPT0gYiAmJiAhemEgJiYgIWxjKHRoaXMubCkpIHtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hYSB8fCAoNCAhPSBiIHx8IGMgPT0gbWMpIHx8IChjID09IG5jIHx8IDAgPj0gZCA/IHRoaXMuYi5HKG9jKSA6IHRoaXMuYi5HKHBjKSk7XG4gICAgICAgIHFjKHRoaXMpO1xuICAgICAgICB2YXIgZiA9IGtjKHRoaXMubCk7XG4gICAgICAgIHRoaXMuaCA9IGY7XG4gICAgICAgIHZhciBnID0gbGModGhpcy5sKTtcbiAgICAgICAgZyB8fCB0aGlzLmEuZGVidWcoXCJObyByZXNwb25zZSB0ZXh0IGZvciB1cmkgXCIgKyB0aGlzLncgKyBcIiBzdGF0dXMgXCIgKyBmKTtcbiAgICAgICAgdGhpcy5KID0gMjAwID09IGY7XG4gICAgICAgIHRoaXMuYS5pbmZvKFwiWE1MSFRUUCBSRVNQIChcIiArIHRoaXMuQiArIFwiKSBbIGF0dGVtcHQgXCIgKyB0aGlzLkNhICsgXCJdOiBcIiArIHRoaXMudGEgKyBcIlxcblwiICsgdGhpcy53ICsgXCJcXG5cIiArIGIgKyBcIiBcIiArIGYpO1xuICAgICAgICB0aGlzLkogPyAoNCA9PSBiICYmIFModGhpcyksIHRoaXMueGIgPyAocmModGhpcywgYiwgZyksIHphICYmIDMgPT0gYiAmJiAoWGIodGhpcy5qYiwgdGhpcy5TYSwgVWIsIHRoaXMuemMpLCB0aGlzLlNhLnN0YXJ0KCkpKSA6IChzYyh0aGlzLmEsIHRoaXMuQiwgZywgbnVsbCksIHRjKHRoaXMsIGcpKSwgdGhpcy5KICYmICF0aGlzLmFhICYmICg0ID09IGIgPyB0aGlzLmIubWEodGhpcykgOiAodGhpcy5KID0gITEsIGljKHRoaXMpKSkpIDogKDQwMCA9PSBmICYmIDAgPCBnLmluZGV4T2YoXCJVbmtub3duIFNJRFwiKSA/ICh0aGlzLnAgPSAzLCBUKHVjKSwgdGhpcy5hLiQoXCJYTUxIVFRQIFVua25vd24gU0lEIChcIiArIHRoaXMuQiArIFwiKVwiKSkgOiAodGhpcy5wID0gMCwgVCh2YyksIHRoaXMuYS4kKFwiWE1MSFRUUCBCYWQgc3RhdHVzIFwiICsgZiArIFwiIChcIiArIHRoaXMuQiArIFwiKVwiKSksIFModGhpcyksIHdjKHRoaXMpKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIHRoaXMuYS4kKFwiQ2FsbGVkIGJhY2sgd2l0aCBhbiB1bmV4cGVjdGVkIHhtbGh0dHBcIilcbiAgICB9XG4gIH1jYXRjaChoKSB7XG4gICAgdGhpcy5hLmRlYnVnKFwiRmFpbGVkIGNhbGwgdG8gT25YbWxIdHRwUmVhZHlTdGF0ZUNoYW5nZWRfXCIpLCB0aGlzLmwgJiYgbGModGhpcy5sKSA/IHhjKHRoaXMuYSwgaCwgXCJSZXNwb25zZVRleHQ6IFwiICsgbGModGhpcy5sKSkgOiB4Yyh0aGlzLmEsIGgsIFwiTm8gcmVzcG9uc2UgdGV4dFwiKVxuICB9ZmluYWxseSB7XG4gIH1cbn07XG5mdW5jdGlvbiByYyhhLCBiLCBjKSB7XG4gIGZvcih2YXIgZCA9ICEwOyFhLmFhICYmIGEuRmEgPCBjLmxlbmd0aDspIHtcbiAgICB2YXIgZiA9IHljKGEsIGMpO1xuICAgIGlmKGYgPT0gZGMpIHtcbiAgICAgIDQgPT0gYiAmJiAoYS5wID0gNCwgVCh6YyksIGQgPSAhMSk7XG4gICAgICBzYyhhLmEsIGEuQiwgbnVsbCwgXCJbSW5jb21wbGV0ZSBSZXNwb25zZV1cIik7XG4gICAgICBicmVha1xuICAgIH1lbHNlIHtcbiAgICAgIGlmKGYgPT0gY2MpIHtcbiAgICAgICAgYS5wID0gNDtcbiAgICAgICAgVChBYyk7XG4gICAgICAgIHNjKGEuYSwgYS5CLCBjLCBcIltJbnZhbGlkIENodW5rXVwiKTtcbiAgICAgICAgZCA9ICExO1xuICAgICAgICBicmVha1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzYyhhLmEsIGEuQiwgZiwgbnVsbCksIHRjKGEsIGYpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIDQgPT0gYiAmJiAwID09IGMubGVuZ3RoICYmIChhLnAgPSAxLCBUKEJjKSwgZCA9ICExKTtcbiAgYS5KID0gYS5KICYmIGQ7XG4gIGQgfHwgKHNjKGEuYSwgYS5CLCBjLCBcIltJbnZhbGlkIENodW5rZWQgUmVzcG9uc2VdXCIpLCBTKGEpLCB3YyhhKSlcbn1cbnAuemMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBSKHRoaXMubCksIGIgPSBsYyh0aGlzLmwpO1xuICB0aGlzLkZhIDwgYi5sZW5ndGggJiYgKHFjKHRoaXMpLCByYyh0aGlzLCBhLCBiKSwgdGhpcy5KICYmIDQgIT0gYSAmJiBpYyh0aGlzKSlcbn07XG5mdW5jdGlvbiB5YyhhLCBiKSB7XG4gIHZhciBjID0gYS5GYSwgZCA9IGIuaW5kZXhPZihcIlxcblwiLCBjKTtcbiAgaWYoLTEgPT0gZCkge1xuICAgIHJldHVybiBkY1xuICB9XG4gIGMgPSBOdW1iZXIoYi5zdWJzdHJpbmcoYywgZCkpO1xuICBpZihpc05hTihjKSkge1xuICAgIHJldHVybiBjY1xuICB9XG4gIGQgKz0gMTtcbiAgaWYoZCArIGMgPiBiLmxlbmd0aCkge1xuICAgIHJldHVybiBkY1xuICB9XG4gIHZhciBmID0gYi5zdWJzdHIoZCwgYyk7XG4gIGEuRmEgPSBkICsgYztcbiAgcmV0dXJuIGZcbn1cbmZ1bmN0aW9uIENjKGEsIGIpIHtcbiAgYS5wYSA9IHgoKTtcbiAgaWMoYSk7XG4gIHZhciBjID0gYiA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IFwiXCI7XG4gIGEudyA9IGEuVC5uKCk7XG4gIEkoYS53LCBcIkRPTUFJTlwiLCBjKTtcbiAgSShhLncsIFwidFwiLCBhLkNhKTtcbiAgdHJ5IHtcbiAgICBhLksgPSBuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpXG4gIH1jYXRjaChkKSB7XG4gICAgYS5hLkkoXCJBY3RpdmVYIGJsb2NrZWRcIik7XG4gICAgUyhhKTtcbiAgICBhLnAgPSA3O1xuICAgIFQoRGMpO1xuICAgIHdjKGEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBmID0gXCI8aHRtbD48Ym9keT5cIjtcbiAgYiAmJiAoZiArPSAnPHNjcmlwdD5kb2N1bWVudC5kb21haW49XCInICsgYyArICdcIlxceDNjL3NjcmlwdD4nKTtcbiAgZiArPSBcIjwvYm9keT48L2h0bWw+XCI7XG4gIGEuSy5vcGVuKCk7XG4gIGEuSy53cml0ZShmKTtcbiAgYS5LLmNsb3NlKCk7XG4gIGEuSy5wYXJlbnRXaW5kb3cubSA9IHcoYS53YywgYSk7XG4gIGEuSy5wYXJlbnRXaW5kb3cuZCA9IHcoYS5TYiwgYSwgITApO1xuICBhLksucGFyZW50V2luZG93LnJwY0Nsb3NlID0gdyhhLlNiLCBhLCAhMSk7XG4gIGMgPSBhLksuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgYS5LLnBhcmVudFdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICBjLmlubmVySFRNTCA9ICc8aWZyYW1lIHNyYz1cIicgKyBhLncgKyAnXCI+PC9pZnJhbWU+JztcbiAgYS5hLmluZm8oXCJUUklERU5UIFJFUSAoXCIgKyBhLkIgKyBcIikgWyBhdHRlbXB0IFwiICsgYS5DYSArIFwiXTogR0VUXFxuXCIgKyBhLncpO1xuICBhLmIuRyhqYylcbn1cbnAud2MgPSBmdW5jdGlvbihhKSB7XG4gIFUodyh0aGlzLnZjLCB0aGlzLCBhKSwgMClcbn07XG5wLnZjID0gZnVuY3Rpb24oYSkge1xuICBpZighdGhpcy5hYSkge1xuICAgIHZhciBiID0gdGhpcy5hO1xuICAgIGIuaW5mbyhcIlRSSURFTlQgVEVYVCAoXCIgKyB0aGlzLkIgKyBcIik6IFwiICsgRWMoYiwgYSkpO1xuICAgIHFjKHRoaXMpO1xuICAgIHRjKHRoaXMsIGEpO1xuICAgIGljKHRoaXMpXG4gIH1cbn07XG5wLlNiID0gZnVuY3Rpb24oYSkge1xuICBVKHcodGhpcy51YywgdGhpcywgYSksIDApXG59O1xucC51YyA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5hYSB8fCAodGhpcy5hLmluZm8oXCJUUklERU5UIFRFWFQgKFwiICsgdGhpcy5CICsgXCIpOiBcIiArIGEgPyBcInN1Y2Nlc3NcIiA6IFwiZmFpbHVyZVwiKSwgUyh0aGlzKSwgdGhpcy5KID0gYSwgdGhpcy5iLm1hKHRoaXMpLCB0aGlzLmIuRyhGYykpXG59O1xucC5sYyA9IGZ1bmN0aW9uKCkge1xuICBxYyh0aGlzKTtcbiAgdGhpcy5iLm1hKHRoaXMpXG59O1xucC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hYSA9ICEwO1xuICBTKHRoaXMpXG59O1xuZnVuY3Rpb24gaWMoYSkge1xuICBhLnNiID0geCgpICsgYS5EYTtcbiAgR2MoYSwgYS5EYSlcbn1cbmZ1bmN0aW9uIEdjKGEsIGIpIHtcbiAgaWYobnVsbCAhPSBhLnVhKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJXYXRjaERvZyB0aW1lciBub3QgbnVsbFwiKTtcbiAgfVxuICBhLnVhID0gVSh3KGEueGMsIGEpLCBiKVxufVxuZnVuY3Rpb24gcWMoYSkge1xuICBhLnVhICYmIChxLmNsZWFyVGltZW91dChhLnVhKSwgYS51YSA9IG51bGwpXG59XG5wLnhjID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudWEgPSBudWxsO1xuICB2YXIgYSA9IHgoKTtcbiAgMCA8PSBhIC0gdGhpcy5zYiA/ICh0aGlzLkogJiYgdGhpcy5hLkkoXCJSZWNlaXZlZCB3YXRjaGRvZyB0aW1lb3V0IGV2ZW4gdGhvdWdoIHJlcXVlc3QgbG9hZGVkIHN1Y2Nlc3NmdWxseVwiKSwgdGhpcy5hLmluZm8oXCJUSU1FT1VUOiBcIiArIHRoaXMudyksIDIgIT0gdGhpcy5zYSAmJiB0aGlzLmIuRyhvYyksIFModGhpcyksIHRoaXMucCA9IDIsIFQoSGMpLCB3Yyh0aGlzKSkgOiAodGhpcy5hLiQoXCJXYXRjaERvZyB0aW1lciBjYWxsZWQgdG9vIGVhcmx5XCIpLCBHYyh0aGlzLCB0aGlzLnNiIC0gYSkpXG59O1xuZnVuY3Rpb24gd2MoYSkge1xuICBhLmIuSGIoKSB8fCBhLmFhIHx8IGEuYi5tYShhKVxufVxuZnVuY3Rpb24gUyhhKSB7XG4gIHFjKGEpO1xuICB2YXIgYiA9IGEuVGE7XG4gIGIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBiLklhICYmIGIuSWEoKTtcbiAgYS5UYSA9IG51bGw7XG4gIGEuU2Euc3RvcCgpO1xuICBiID0gYS5qYjtcbiAgWWEoYi5qLCBOYik7XG4gIGIuai5sZW5ndGggPSAwO1xuICBhLmwgJiYgKGIgPSBhLmwsIGEubCA9IG51bGwsIGIuYWJvcnQoKSwgYi5JYSgpKTtcbiAgYS5LICYmIChhLksgPSBudWxsKVxufVxucC5FYiA9IGFhKFwicFwiKTtcbmZ1bmN0aW9uIHRjKGEsIGIpIHtcbiAgdHJ5IHtcbiAgICBhLmIuUGIoYSwgYiksIGEuYi5HKEZjKVxuICB9Y2F0Y2goYykge1xuICAgIHhjKGEuYSwgYywgXCJFcnJvciBpbiBodHRwcmVxdWVzdCBjYWxsYmFja1wiKVxuICB9XG59XG47ZnVuY3Rpb24gSWMoYSkge1xuICBhID0gU3RyaW5nKGEpO1xuICBpZigvXlxccyokLy50ZXN0KGEpID8gMCA6IC9eW1xcXSw6e31cXHNcXHUyMDI4XFx1MjAyOV0qJC8udGVzdChhLnJlcGxhY2UoL1xcXFxbXCJcXFxcXFwvYmZucnR1XS9nLCBcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxcclxcdTIwMjhcXHUyMDI5XFx4MDAtXFx4MDhcXHgwYS1cXHgxZl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csIFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpbXFxzXFx1MjAyOFxcdTIwMjldKlxcWykrL2csIFwiXCIpKSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZXZhbChcIihcIiArIGEgKyBcIilcIilcbiAgICB9Y2F0Y2goYikge1xuICAgIH1cbiAgfVxuICB0aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBzdHJpbmc6IFwiICsgYSk7XG59XG5mdW5jdGlvbiBKYyhhKSB7XG4gIHJldHVybiBldmFsKFwiKFwiICsgYSArIFwiKVwiKVxufVxuZnVuY3Rpb24gS2MoYSkge1xuICB2YXIgYiA9IFtdO1xuICBMYyhuZXcgTWModm9pZCAwKSwgYSwgYik7XG4gIHJldHVybiBiLmpvaW4oXCJcIilcbn1cbmZ1bmN0aW9uIE1jKGEpIHtcbiAgdGhpcy5WYSA9IGFcbn1cbmZ1bmN0aW9uIExjKGEsIGIsIGMpIHtcbiAgc3dpdGNoKHR5cGVvZiBiKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgTmMoYiwgYyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjLnB1c2goaXNGaW5pdGUoYikgJiYgIWlzTmFOKGIpID8gYiA6IFwibnVsbFwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBjLnB1c2goYik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICBjLnB1c2goXCJudWxsXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYobnVsbCA9PSBiKSB7XG4gICAgICAgIGMucHVzaChcIm51bGxcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZihzKGIpKSB7XG4gICAgICAgIHZhciBkID0gYi5sZW5ndGg7XG4gICAgICAgIGMucHVzaChcIltcIik7XG4gICAgICAgIGZvcih2YXIgZiA9IFwiXCIsIGcgPSAwO2cgPCBkO2crKykge1xuICAgICAgICAgIGMucHVzaChmKSwgZiA9IGJbZ10sIExjKGEsIGEuVmEgPyBhLlZhLmNhbGwoYiwgU3RyaW5nKGcpLCBmKSA6IGYsIGMpLCBmID0gXCIsXCJcbiAgICAgICAgfVxuICAgICAgICBjLnB1c2goXCJdXCIpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgYy5wdXNoKFwie1wiKTtcbiAgICAgIGQgPSBcIlwiO1xuICAgICAgZm9yKGcgaW4gYikge1xuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgZykgJiYgKGYgPSBiW2ddLCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGYgJiYgKGMucHVzaChkKSwgTmMoZywgYyksIGMucHVzaChcIjpcIiksIExjKGEsIGEuVmEgPyBhLlZhLmNhbGwoYiwgZywgZikgOiBmLCBjKSwgZCA9IFwiLFwiKSlcbiAgICAgIH1cbiAgICAgIGMucHVzaChcIn1cIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyB0eXBlb2YgYik7XG4gIH1cbn1cbnZhciBPYyA9IHsnXCInOidcXFxcXCInLCBcIlxcXFxcIjpcIlxcXFxcXFxcXCIsIFwiL1wiOlwiXFxcXC9cIiwgXCJcXGJcIjpcIlxcXFxiXCIsIFwiXFxmXCI6XCJcXFxcZlwiLCBcIlxcblwiOlwiXFxcXG5cIiwgXCJcXHJcIjpcIlxcXFxyXCIsIFwiXFx0XCI6XCJcXFxcdFwiLCBcIlxceDBCXCI6XCJcXFxcdTAwMGJcIn0sIFBjID0gL1xcdWZmZmYvLnRlc3QoXCJcXHVmZmZmXCIpID8gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx1ZmZmZl0vZyA6IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nO1xuZnVuY3Rpb24gTmMoYSwgYikge1xuICBiLnB1c2goJ1wiJywgYS5yZXBsYWNlKFBjLCBmdW5jdGlvbihhKSB7XG4gICAgaWYoYSBpbiBPYykge1xuICAgICAgcmV0dXJuIE9jW2FdXG4gICAgfVxuICAgIHZhciBiID0gYS5jaGFyQ29kZUF0KDApLCBmID0gXCJcXFxcdVwiO1xuICAgIDE2ID4gYiA/IGYgKz0gXCIwMDBcIiA6IDI1NiA+IGIgPyBmICs9IFwiMDBcIiA6IDQwOTYgPiBiICYmIChmICs9IFwiMFwiKTtcbiAgICByZXR1cm4gT2NbYV0gPSBmICsgYi50b1N0cmluZygxNilcbiAgfSksICdcIicpXG59XG47ZnVuY3Rpb24gUWMoYSkge1xuICByZXR1cm4gUmMoYSB8fCBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciwgW10pXG59XG5mdW5jdGlvbiBSYyhhLCBiKSB7XG4gIHZhciBjID0gW107XG4gIGlmKDAgPD0gWGEoYiwgYSkpIHtcbiAgICBjLnB1c2goXCJbLi4uY2lyY3VsYXIgcmVmZXJlbmNlLi4uXVwiKVxuICB9ZWxzZSB7XG4gICAgaWYoYSAmJiA1MCA+IGIubGVuZ3RoKSB7XG4gICAgICBjLnB1c2goU2MoYSkgKyBcIihcIik7XG4gICAgICBmb3IodmFyIGQgPSBhLmFyZ3VtZW50cywgZiA9IDA7ZiA8IGQubGVuZ3RoO2YrKykge1xuICAgICAgICAwIDwgZiAmJiBjLnB1c2goXCIsIFwiKTtcbiAgICAgICAgdmFyIGc7XG4gICAgICAgIGcgPSBkW2ZdO1xuICAgICAgICBzd2l0Y2godHlwZW9mIGcpIHtcbiAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBnID0gZyA/IFwib2JqZWN0XCIgOiBcIm51bGxcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGcgPSBTdHJpbmcoZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgZyA9IGcgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgZyA9IChnID0gU2MoZykpID8gZyA6IFwiW2ZuXVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGcgPSB0eXBlb2YgZ1xuICAgICAgICB9XG4gICAgICAgIDQwIDwgZy5sZW5ndGggJiYgKGcgPSBnLnN1YnN0cigwLCA0MCkgKyBcIi4uLlwiKTtcbiAgICAgICAgYy5wdXNoKGcpXG4gICAgICB9XG4gICAgICBiLnB1c2goYSk7XG4gICAgICBjLnB1c2goXCIpXFxuXCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYy5wdXNoKFJjKGEuY2FsbGVyLCBiKSlcbiAgICAgIH1jYXRjaChoKSB7XG4gICAgICAgIGMucHVzaChcIltleGNlcHRpb24gdHJ5aW5nIHRvIGdldCBjYWxsZXJdXFxuXCIpXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgYSA/IGMucHVzaChcIlsuLi5sb25nIHN0YWNrLi4uXVwiKSA6IGMucHVzaChcIltlbmRdXCIpXG4gICAgfVxuICB9XG4gIHJldHVybiBjLmpvaW4oXCJcIilcbn1cbmZ1bmN0aW9uIFNjKGEpIHtcbiAgaWYoVGNbYV0pIHtcbiAgICByZXR1cm4gVGNbYV1cbiAgfVxuICBhID0gU3RyaW5nKGEpO1xuICBpZighVGNbYV0pIHtcbiAgICB2YXIgYiA9IC9mdW5jdGlvbiAoW15cXChdKykvLmV4ZWMoYSk7XG4gICAgVGNbYV0gPSBiID8gYlsxXSA6IFwiW0Fub255bW91c11cIlxuICB9XG4gIHJldHVybiBUY1thXVxufVxudmFyIFRjID0ge307XG5mdW5jdGlvbiBVYyhhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMucmVzZXQoYSwgYiwgYywgZCwgZilcbn1cblVjLnByb3RvdHlwZS5DYyA9IDA7XG5VYy5wcm90b3R5cGUuQmIgPSBudWxsO1xuVWMucHJvdG90eXBlLkFiID0gbnVsbDtcbnZhciBWYyA9IDA7XG5VYy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBmKSB7XG4gIHRoaXMuQ2MgPSBcIm51bWJlclwiID09IHR5cGVvZiBmID8gZiA6IFZjKys7XG4gIHRoaXMuUWMgPSBkIHx8IHgoKTtcbiAgdGhpcy56YSA9IGE7XG4gIHRoaXMub2MgPSBiO1xuICB0aGlzLkljID0gYztcbiAgZGVsZXRlIHRoaXMuQmI7XG4gIGRlbGV0ZSB0aGlzLkFiXG59O1xuVWMucHJvdG90eXBlLlliID0gbShcInphXCIpO1xuZnVuY3Rpb24gVihhKSB7XG4gIHRoaXMucGMgPSBhXG59XG5WLnByb3RvdHlwZS5SYSA9IG51bGw7XG5WLnByb3RvdHlwZS56YSA9IG51bGw7XG5WLnByb3RvdHlwZS5mYiA9IG51bGw7XG5WLnByb3RvdHlwZS5GYiA9IG51bGw7XG5mdW5jdGlvbiBXYyhhLCBiKSB7XG4gIHRoaXMubmFtZSA9IGE7XG4gIHRoaXMudmFsdWUgPSBiXG59XG5XYy5wcm90b3R5cGUudG9TdHJpbmcgPSBhYShcIm5hbWVcIik7XG52YXIgWGMgPSBuZXcgV2MoXCJTRVZFUkVcIiwgMUUzKSwgWWMgPSBuZXcgV2MoXCJXQVJOSU5HXCIsIDkwMCksIFpjID0gbmV3IFdjKFwiSU5GT1wiLCA4MDApLCAkYyA9IG5ldyBXYyhcIkNPTkZJR1wiLCA3MDApLCBhZCA9IG5ldyBXYyhcIkZJTkVcIiwgNTAwKTtcbnAgPSBWLnByb3RvdHlwZTtcbnAuZ2V0UGFyZW50ID0gYWEoXCJSYVwiKTtcbnAuWWIgPSBtKFwiemFcIik7XG5mdW5jdGlvbiBiZChhKSB7XG4gIGlmKGEuemEpIHtcbiAgICByZXR1cm4gYS56YVxuICB9XG4gIGlmKGEuUmEpIHtcbiAgICByZXR1cm4gYmQoYS5SYSlcbiAgfVxuICBQYShcIlJvb3QgbG9nZ2VyIGhhcyBubyBsZXZlbCBzZXQuXCIpO1xuICByZXR1cm4gbnVsbFxufVxucC5sb2cgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGlmKGEudmFsdWUgPj0gYmQodGhpcykudmFsdWUpIHtcbiAgICBmb3IoYSA9IHRoaXMua2MoYSwgYiwgYyksIGIgPSBcImxvZzpcIiArIGEub2MsIHEuY29uc29sZSAmJiAocS5jb25zb2xlLnRpbWVTdGFtcCA/IHEuY29uc29sZS50aW1lU3RhbXAoYikgOiBxLmNvbnNvbGUubWFya1RpbWVsaW5lICYmIHEuY29uc29sZS5tYXJrVGltZWxpbmUoYikpLCBxLm1zV3JpdGVQcm9maWxlck1hcmsgJiYgcS5tc1dyaXRlUHJvZmlsZXJNYXJrKGIpLCBiID0gdGhpcztiOykge1xuICAgICAgYyA9IGI7XG4gICAgICB2YXIgZCA9IGE7XG4gICAgICBpZihjLkZiKSB7XG4gICAgICAgIGZvcih2YXIgZiA9IDAsIGcgPSB2b2lkIDA7ZyA9IGMuRmJbZl07ZisrKSB7XG4gICAgICAgICAgZyhkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiID0gYi5nZXRQYXJlbnQoKVxuICAgIH1cbiAgfVxufTtcbnAua2MgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIHZhciBkID0gbmV3IFVjKGEsIFN0cmluZyhiKSwgdGhpcy5wYyk7XG4gIGlmKGMpIHtcbiAgICBkLkJiID0gYztcbiAgICB2YXIgZjtcbiAgICB2YXIgZyA9IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyO1xuICAgIHRyeSB7XG4gICAgICB2YXIgaDtcbiAgICAgIHZhciBuID0gZGEoXCJ3aW5kb3cubG9jYXRpb24uaHJlZlwiKTtcbiAgICAgIGlmKHUoYykpIHtcbiAgICAgICAgaCA9IHttZXNzYWdlOmMsIG5hbWU6XCJVbmtub3duIGVycm9yXCIsIGxpbmVOdW1iZXI6XCJOb3QgYXZhaWxhYmxlXCIsIGZpbGVOYW1lOm4sIHN0YWNrOlwiTm90IGF2YWlsYWJsZVwifVxuICAgICAgfWVsc2Uge1xuICAgICAgICB2YXIgaywgdCwgbCA9ICExO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGsgPSBjLmxpbmVOdW1iZXIgfHwgYy5IYyB8fCBcIk5vdCBhdmFpbGFibGVcIlxuICAgICAgICB9Y2F0Y2gocikge1xuICAgICAgICAgIGsgPSBcIk5vdCBhdmFpbGFibGVcIiwgbCA9ICEwXG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0ID0gYy5maWxlTmFtZSB8fCBjLmZpbGVuYW1lIHx8IGMuc291cmNlVVJMIHx8IHEuJGdvb2dEZWJ1Z0ZuYW1lIHx8IG5cbiAgICAgICAgfWNhdGNoKEcpIHtcbiAgICAgICAgICB0ID0gXCJOb3QgYXZhaWxhYmxlXCIsIGwgPSAhMFxuICAgICAgICB9XG4gICAgICAgIGggPSAhbCAmJiBjLmxpbmVOdW1iZXIgJiYgYy5maWxlTmFtZSAmJiBjLnN0YWNrID8gYyA6IHttZXNzYWdlOmMubWVzc2FnZSwgbmFtZTpjLm5hbWUsIGxpbmVOdW1iZXI6aywgZmlsZU5hbWU6dCwgc3RhY2s6Yy5zdGFjayB8fCBcIk5vdCBhdmFpbGFibGVcIn1cbiAgICAgIH1cbiAgICAgIGYgPSBcIk1lc3NhZ2U6IFwiICsgbmEoaC5tZXNzYWdlKSArICdcXG5Vcmw6IDxhIGhyZWY9XCJ2aWV3LXNvdXJjZTonICsgaC5maWxlTmFtZSArICdcIiB0YXJnZXQ9XCJfbmV3XCI+JyArIGguZmlsZU5hbWUgKyBcIjwvYT5cXG5MaW5lOiBcIiArIGgubGluZU51bWJlciArIFwiXFxuXFxuQnJvd3NlciBzdGFjazpcXG5cIiArIG5hKGguc3RhY2sgKyBcIi0+IFwiKSArIFwiW2VuZF1cXG5cXG5KUyBzdGFjayB0cmF2ZXJzYWw6XFxuXCIgKyBuYShRYyhnKSArIFwiLT4gXCIpXG4gICAgfWNhdGNoKFNkKSB7XG4gICAgICBmID0gXCJFeGNlcHRpb24gdHJ5aW5nIHRvIGV4cG9zZSBleGNlcHRpb24hIFlvdSB3aW4sIHdlIGxvc2UuIFwiICsgU2RcbiAgICB9XG4gICAgZC5BYiA9IGZcbiAgfVxuICByZXR1cm4gZFxufTtcbnAuSSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5sb2coWGMsIGEsIGIpXG59O1xucC4kID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmxvZyhZYywgYSwgYilcbn07XG5wLmluZm8gPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMubG9nKFpjLCBhLCBiKVxufTtcbmZ1bmN0aW9uIFcoYSwgYikge1xuICBhLmxvZyhhZCwgYiwgdm9pZCAwKVxufVxudmFyIGNkID0ge30sIGRkID0gbnVsbDtcbmZ1bmN0aW9uIGVkKGEpIHtcbiAgZGQgfHwgKGRkID0gbmV3IFYoXCJcIiksIGNkW1wiXCJdID0gZGQsIGRkLlliKCRjKSk7XG4gIHZhciBiO1xuICBpZighKGIgPSBjZFthXSkpIHtcbiAgICBiID0gbmV3IFYoYSk7XG4gICAgdmFyIGMgPSBhLmxhc3RJbmRleE9mKFwiLlwiKSwgZCA9IGEuc3Vic3RyKGMgKyAxKSwgYyA9IGVkKGEuc3Vic3RyKDAsIGMpKTtcbiAgICBjLmZiIHx8IChjLmZiID0ge30pO1xuICAgIGMuZmJbZF0gPSBiO1xuICAgIGIuUmEgPSBjO1xuICAgIGNkW2FdID0gYlxuICB9XG4gIHJldHVybiBiXG59XG47ZnVuY3Rpb24gWCgpIHtcbiAgdGhpcy5xID0gZWQoXCJnb29nLm5ldC5Ccm93c2VyQ2hhbm5lbFwiKVxufVxuZnVuY3Rpb24gc2MoYSwgYiwgYywgZCkge1xuICBhLmluZm8oXCJYTUxIVFRQIFRFWFQgKFwiICsgYiArIFwiKTogXCIgKyBFYyhhLCBjKSArIChkID8gXCIgXCIgKyBkIDogXCJcIikpXG59XG5YLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5pbmZvKGEpXG59O1xuZnVuY3Rpb24geGMoYSwgYiwgYykge1xuICBhLkkoKGMgfHwgXCJFeGNlcHRpb25cIikgKyBiKVxufVxuWC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLmluZm8oYSlcbn07XG5YLnByb3RvdHlwZS4kID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLnEuJChhKVxufTtcblgucHJvdG90eXBlLkkgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMucS5JKGEpXG59O1xuZnVuY3Rpb24gRWMoYSwgYikge1xuICBpZighYiB8fCBiID09IGZkKSB7XG4gICAgcmV0dXJuIGJcbiAgfVxuICB0cnkge1xuICAgIHZhciBjID0gSmMoYik7XG4gICAgaWYoYykge1xuICAgICAgZm9yKHZhciBkID0gMDtkIDwgYy5sZW5ndGg7ZCsrKSB7XG4gICAgICAgIGlmKHMoY1tkXSkpIHtcbiAgICAgICAgICB2YXIgZiA9IGNbZF07XG4gICAgICAgICAgaWYoISgyID4gZi5sZW5ndGgpKSB7XG4gICAgICAgICAgICB2YXIgZyA9IGZbMV07XG4gICAgICAgICAgICBpZihzKGcpICYmICEoMSA+IGcubGVuZ3RoKSkge1xuICAgICAgICAgICAgICB2YXIgaCA9IGdbMF07XG4gICAgICAgICAgICAgIGlmKFwibm9vcFwiICE9IGggJiYgXCJzdG9wXCIgIT0gaCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgbiA9IDE7biA8IGcubGVuZ3RoO24rKykge1xuICAgICAgICAgICAgICAgICAgZ1tuXSA9IFwiXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEtjKGMpXG4gIH1jYXRjaChrKSB7XG4gICAgcmV0dXJuIGEuZGVidWcoXCJFeGNlcHRpb24gcGFyc2luZyBleHBlY3RlZCBKUyBhcnJheSAtIHByb2JhYmx5IHdhcyBub3QgSlNcIiksIGJcbiAgfVxufVxuO2Z1bmN0aW9uIGdkKGEsIGIpIHtcbiAgdGhpcy5PYyA9IG5ldyBNYyhhKTtcbiAgdGhpcy5QID0gYiA/IEpjIDogSWNcbn1cbmdkLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuUChhKVxufTtcbnZhciBtYyA9IDcsIG5jID0gODtcbmZ1bmN0aW9uIGhkKGEpIHtcbiAgTS5jYWxsKHRoaXMpO1xuICB0aGlzLmhlYWRlcnMgPSBuZXcgYmI7XG4gIHRoaXMudmEgPSBhIHx8IG51bGxcbn1cbnkoaGQsIFNiKTtcbmhkLnByb3RvdHlwZS5xID0gZWQoXCJnb29nLm5ldC5YaHJJb1wiKTtcbnZhciBpZCA9IC9eaHR0cHM/JC9pO1xucCA9IGhkLnByb3RvdHlwZTtcbnAuUyA9ICExO1xucC5nID0gbnVsbDtcbnAuYmIgPSBudWxsO1xucC5QYSA9IFwiXCI7XG5wLkpiID0gXCJcIjtcbnAubGEgPSAwO1xucC5wID0gXCJcIjtcbnAuaWIgPSAhMTtcbnAuTmEgPSAhMTtcbnAubWIgPSAhMTtcbnAuY2EgPSAhMTtcbnAuJGEgPSAwO1xucC5mYSA9IG51bGw7XG5wLldiID0gXCJcIjtcbnAuY2MgPSAhMTtcbnAuc2VuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAgaWYodGhpcy5nKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJbZ29vZy5uZXQuWGhySW9dIE9iamVjdCBpcyBhY3RpdmUgd2l0aCBhbm90aGVyIHJlcXVlc3Q9XCIgKyB0aGlzLlBhICsgXCI7IG5ld1VyaT1cIiArIGEpO1xuICB9XG4gIGIgPSBiID8gYi50b1VwcGVyQ2FzZSgpIDogXCJHRVRcIjtcbiAgdGhpcy5QYSA9IGE7XG4gIHRoaXMucCA9IFwiXCI7XG4gIHRoaXMubGEgPSAwO1xuICB0aGlzLkpiID0gYjtcbiAgdGhpcy5pYiA9ICExO1xuICB0aGlzLlMgPSAhMDtcbiAgdGhpcy5nID0gdGhpcy52YSA/IHhiKHRoaXMudmEpIDogeGIodmIpO1xuICB0aGlzLmJiID0gdGhpcy52YSA/IHRoaXMudmEuR2EgfHwgKHRoaXMudmEuR2EgPSB6Yih0aGlzLnZhKSkgOiB2Yi5HYSB8fCAodmIuR2EgPSB6Yih2YikpO1xuICB0aGlzLmcub25yZWFkeXN0YXRlY2hhbmdlID0gdyh0aGlzLk9iLCB0aGlzKTtcbiAgdHJ5IHtcbiAgICBXKHRoaXMucSwgWSh0aGlzLCBcIk9wZW5pbmcgWGhyXCIpKSwgdGhpcy5tYiA9ICEwLCB0aGlzLmcub3BlbihiLCBhLCAhMCksIHRoaXMubWIgPSAhMVxuICB9Y2F0Y2goZikge1xuICAgIFcodGhpcy5xLCBZKHRoaXMsIFwiRXJyb3Igb3BlbmluZyBYaHI6IFwiICsgZi5tZXNzYWdlKSk7XG4gICAgamQodGhpcywgZik7XG4gICAgcmV0dXJuXG4gIH1cbiAgYSA9IGMgfHwgXCJcIjtcbiAgdmFyIGcgPSB0aGlzLmhlYWRlcnMubigpO1xuICBkICYmIEUoZCwgZnVuY3Rpb24oYSwgYikge1xuICAgIGcuc2V0KGIsIGEpXG4gIH0pO1xuICBkID0gcS5Gb3JtRGF0YSAmJiBhIGluc3RhbmNlb2YgcS5Gb3JtRGF0YTtcbiAgXCJQT1NUXCIgIT0gYiB8fCAoZy5pYShcIkNvbnRlbnQtVHlwZVwiKSB8fCBkKSB8fCBnLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04XCIpO1xuICBFKGcsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB0aGlzLmcuc2V0UmVxdWVzdEhlYWRlcihiLCBhKVxuICB9LCB0aGlzKTtcbiAgdGhpcy5XYiAmJiAodGhpcy5nLnJlc3BvbnNlVHlwZSA9IHRoaXMuV2IpO1xuICBcIndpdGhDcmVkZW50aWFsc1wiIGluIHRoaXMuZyAmJiAodGhpcy5nLndpdGhDcmVkZW50aWFscyA9IHRoaXMuY2MpO1xuICB0cnkge1xuICAgIHRoaXMuZmEgJiYgKHEuY2xlYXJUaW1lb3V0KHRoaXMuZmEpLCB0aGlzLmZhID0gbnVsbCksIDAgPCB0aGlzLiRhICYmIChXKHRoaXMucSwgWSh0aGlzLCBcIldpbGwgYWJvcnQgYWZ0ZXIgXCIgKyB0aGlzLiRhICsgXCJtcyBpZiBpbmNvbXBsZXRlXCIpKSwgdGhpcy5mYSA9IHEuc2V0VGltZW91dCh3KHRoaXMuRGEsIHRoaXMpLCB0aGlzLiRhKSksIFcodGhpcy5xLCBZKHRoaXMsIFwiU2VuZGluZyByZXF1ZXN0XCIpKSwgdGhpcy5OYSA9ICEwLCB0aGlzLmcuc2VuZChhKSwgdGhpcy5OYSA9ICExXG4gIH1jYXRjaChoKSB7XG4gICAgVyh0aGlzLnEsIFkodGhpcywgXCJTZW5kIGVycm9yOiBcIiArIGgubWVzc2FnZSkpLCBqZCh0aGlzLCBoKVxuICB9XG59O1xucC5EYSA9IGZ1bmN0aW9uKCkge1xuICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjYSAmJiB0aGlzLmcgJiYgKHRoaXMucCA9IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgdGhpcy4kYSArIFwibXMsIGFib3J0aW5nXCIsIHRoaXMubGEgPSBuYywgVyh0aGlzLnEsIFkodGhpcywgdGhpcy5wKSksIHRoaXMuZGlzcGF0Y2hFdmVudChcInRpbWVvdXRcIiksIHRoaXMuYWJvcnQobmMpKVxufTtcbmZ1bmN0aW9uIGpkKGEsIGIpIHtcbiAgYS5TID0gITE7XG4gIGEuZyAmJiAoYS5jYSA9ICEwLCBhLmcuYWJvcnQoKSwgYS5jYSA9ICExKTtcbiAgYS5wID0gYjtcbiAgYS5sYSA9IDU7XG4gIGtkKGEpO1xuICBsZChhKVxufVxuZnVuY3Rpb24ga2QoYSkge1xuICBhLmliIHx8IChhLmliID0gITAsIGEuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLCBhLmRpc3BhdGNoRXZlbnQoXCJlcnJvclwiKSlcbn1cbnAuYWJvcnQgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuZyAmJiB0aGlzLlMgJiYgKFcodGhpcy5xLCBZKHRoaXMsIFwiQWJvcnRpbmdcIikpLCB0aGlzLlMgPSAhMSwgdGhpcy5jYSA9ICEwLCB0aGlzLmcuYWJvcnQoKSwgdGhpcy5jYSA9ICExLCB0aGlzLmxhID0gYSB8fCBtYywgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksIHRoaXMuZGlzcGF0Y2hFdmVudChcImFib3J0XCIpLCBsZCh0aGlzKSlcbn07XG5wLnUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5nICYmICh0aGlzLlMgJiYgKHRoaXMuUyA9ICExLCB0aGlzLmNhID0gITAsIHRoaXMuZy5hYm9ydCgpLCB0aGlzLmNhID0gITEpLCBsZCh0aGlzLCAhMCkpO1xuICBoZC5yYS51LmNhbGwodGhpcylcbn07XG5wLk9iID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubWIgfHwgdGhpcy5OYSB8fCB0aGlzLmNhID8gbWQodGhpcykgOiB0aGlzLnNjKClcbn07XG5wLnNjID0gZnVuY3Rpb24oKSB7XG4gIG1kKHRoaXMpXG59O1xuZnVuY3Rpb24gbWQoYSkge1xuICBpZihhLlMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgY2EpIHtcbiAgICBpZihhLmJiWzFdICYmIDQgPT0gUihhKSAmJiAyID09IGtjKGEpKSB7XG4gICAgICBXKGEucSwgWShhLCBcIkxvY2FsIHJlcXVlc3QgZXJyb3IgZGV0ZWN0ZWQgYW5kIGlnbm9yZWRcIikpXG4gICAgfWVsc2Uge1xuICAgICAgaWYoYS5OYSAmJiA0ID09IFIoYSkpIHtcbiAgICAgICAgcS5zZXRUaW1lb3V0KHcoYS5PYiwgYSksIDApXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKGEuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIiksIDQgPT0gUihhKSkge1xuICAgICAgICAgIFcoYS5xLCBZKGEsIFwiUmVxdWVzdCBjb21wbGV0ZVwiKSk7XG4gICAgICAgICAgYS5TID0gITE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBiID0ga2MoYSksIGMsIGQ7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHN3aXRjaChiKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjAxOlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwMjpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDQ6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA2OlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDMwNDpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjIzOlxuICAgICAgICAgICAgICAgICAgZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZCA9ICExXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCEoYyA9IGQpKSB7XG4gICAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgICBpZihmID0gMCA9PT0gYikge1xuICAgICAgICAgICAgICAgIHZhciBnID0gU3RyaW5nKGEuUGEpLm1hdGNoKFFhKVsxXSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGlmKCFnICYmIHNlbGYubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBoID0gc2VsZi5sb2NhdGlvbi5wcm90b2NvbCwgZyA9IGguc3Vic3RyKDAsIGgubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZiA9ICFpZC50ZXN0KGcgPyBnLnRvTG93ZXJDYXNlKCkgOiBcIlwiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGMgPSBmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjKSB7XG4gICAgICAgICAgICAgIGEuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpLCBhLmRpc3BhdGNoRXZlbnQoXCJzdWNjZXNzXCIpXG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgIGEubGEgPSA2O1xuICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuID0gMiA8IFIoYSkgPyBhLmcuc3RhdHVzVGV4dCA6IFwiXCJcbiAgICAgICAgICAgICAgfWNhdGNoKGspIHtcbiAgICAgICAgICAgICAgICBXKGEucSwgXCJDYW4gbm90IGdldCBzdGF0dXM6IFwiICsgay5tZXNzYWdlKSwgbiA9IFwiXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhLnAgPSBuICsgXCIgW1wiICsga2MoYSkgKyBcIl1cIjtcbiAgICAgICAgICAgICAga2QoYSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZmluYWxseSB7XG4gICAgICAgICAgICBsZChhKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbGQoYSwgYikge1xuICBpZihhLmcpIHtcbiAgICB2YXIgYyA9IGEuZywgZCA9IGEuYmJbMF0gPyBlYSA6IG51bGw7XG4gICAgYS5nID0gbnVsbDtcbiAgICBhLmJiID0gbnVsbDtcbiAgICBhLmZhICYmIChxLmNsZWFyVGltZW91dChhLmZhKSwgYS5mYSA9IG51bGwpO1xuICAgIGIgfHwgYS5kaXNwYXRjaEV2ZW50KFwicmVhZHlcIik7XG4gICAgdHJ5IHtcbiAgICAgIGMub25yZWFkeXN0YXRlY2hhbmdlID0gZFxuICAgIH1jYXRjaChmKSB7XG4gICAgICBhLnEuSShcIlByb2JsZW0gZW5jb3VudGVyZWQgcmVzZXR0aW5nIG9ucmVhZHlzdGF0ZWNoYW5nZTogXCIgKyBmLm1lc3NhZ2UpXG4gICAgfVxuICB9XG59XG5wLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiEhdGhpcy5nXG59O1xuZnVuY3Rpb24gUihhKSB7XG4gIHJldHVybiBhLmcgPyBhLmcucmVhZHlTdGF0ZSA6IDBcbn1cbmZ1bmN0aW9uIGtjKGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gMiA8IFIoYSkgPyBhLmcuc3RhdHVzIDogLTFcbiAgfWNhdGNoKGIpIHtcbiAgICByZXR1cm4gYS5xLiQoXCJDYW4gbm90IGdldCBzdGF0dXM6IFwiICsgYi5tZXNzYWdlKSwgLTFcbiAgfVxufVxuZnVuY3Rpb24gbGMoYSkge1xuICB0cnkge1xuICAgIHJldHVybiBhLmcgPyBhLmcucmVzcG9uc2VUZXh0IDogXCJcIlxuICB9Y2F0Y2goYikge1xuICAgIHJldHVybiBXKGEucSwgXCJDYW4gbm90IGdldCByZXNwb25zZVRleHQ6IFwiICsgYi5tZXNzYWdlKSwgXCJcIlxuICB9XG59XG5wLkViID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB1KHRoaXMucCkgPyB0aGlzLnAgOiBTdHJpbmcodGhpcy5wKVxufTtcbmZ1bmN0aW9uIFkoYSwgYikge1xuICByZXR1cm4gYiArIFwiIFtcIiArIGEuSmIgKyBcIiBcIiArIGEuUGEgKyBcIiBcIiArIGtjKGEpICsgXCJdXCJcbn1cbjtmdW5jdGlvbiBuZCgpIHtcbiAgdGhpcy5WYiA9IHgoKVxufVxubmV3IG5kO1xubmQucHJvdG90eXBlLnNldCA9IG0oXCJWYlwiKTtcbm5kLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldCh4KCkpXG59O1xubmQucHJvdG90eXBlLmdldCA9IGFhKFwiVmJcIik7XG5mdW5jdGlvbiBvZChhLCBiLCBjLCBkLCBmKSB7XG4gIChuZXcgWCkuZGVidWcoXCJUZXN0TG9hZEltYWdlV2l0aFJldHJpZXM6IFwiICsgZik7XG4gIGlmKDAgPT0gZCkge1xuICAgIGMoITEpXG4gIH1lbHNlIHtcbiAgICB2YXIgZyA9IGYgfHwgMDtcbiAgICBkLS07XG4gICAgcGQoYSwgYiwgZnVuY3Rpb24oZikge1xuICAgICAgZiA/IGMoITApIDogcS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvZChhLCBiLCBjLCBkLCBnKVxuICAgICAgfSwgZylcbiAgICB9KVxuICB9XG59XG5mdW5jdGlvbiBwZChhLCBiLCBjKSB7XG4gIGZ1bmN0aW9uIGQoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYuZGVidWcoXCJUZXN0TG9hZEltYWdlOiBcIiArIGIpLCBnLm9ubG9hZCA9IG51bGwsIGcub25lcnJvciA9IG51bGwsIGcub25hYm9ydCA9IG51bGwsIGcub250aW1lb3V0ID0gbnVsbCwgcS5jbGVhclRpbWVvdXQoaCksIGMoYSlcbiAgICAgIH1jYXRjaChkKSB7XG4gICAgICAgIHhjKGYsIGQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBmID0gbmV3IFg7XG4gIGYuZGVidWcoXCJUZXN0TG9hZEltYWdlOiBsb2FkaW5nIFwiICsgYSk7XG4gIHZhciBnID0gbmV3IEltYWdlLCBoID0gbnVsbDtcbiAgZy5vbmxvYWQgPSBkKCEwLCBcImxvYWRlZFwiKTtcbiAgZy5vbmVycm9yID0gZCghMSwgXCJlcnJvclwiKTtcbiAgZy5vbmFib3J0ID0gZCghMSwgXCJhYm9ydFwiKTtcbiAgZy5vbnRpbWVvdXQgPSBkKCExLCBcInRpbWVvdXRcIik7XG4gIGggPSBxLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYoZy5vbnRpbWVvdXQpIHtcbiAgICAgIGcub250aW1lb3V0KClcbiAgICB9XG4gIH0sIGIpO1xuICBnLnNyYyA9IGFcbn1cbjtmdW5jdGlvbiBxZChhLCBiKSB7XG4gIHRoaXMuYiA9IGE7XG4gIHRoaXMuYSA9IGI7XG4gIHRoaXMuUCA9IG5ldyBnZChudWxsLCAhMClcbn1cbnAgPSBxZC5wcm90b3R5cGU7XG5wLnYgPSBudWxsO1xucC5BID0gbnVsbDtcbnAuVWEgPSAhMTtcbnAuYWMgPSBudWxsO1xucC5LYSA9IG51bGw7XG5wLm5iID0gbnVsbDtcbnAuSCA9IG51bGw7XG5wLmMgPSBudWxsO1xucC5oID0gLTE7XG5wLkwgPSBudWxsO1xucC53YSA9IG51bGw7XG5wLlkgPSBtKFwidlwiKTtcbnAuWmIgPSBtKFwiUFwiKTtcbnAuZ2IgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuSCA9IGE7XG4gIGEgPSByZCh0aGlzLmIsIHRoaXMuSCk7XG4gIFQoc2QpO1xuICB0aGlzLmFjID0geCgpO1xuICB2YXIgYiA9IHRoaXMuYi5DYjtcbiAgbnVsbCAhPSBiID8gKHRoaXMuTCA9IHRoaXMuYi5jb3JyZWN0SG9zdFByZWZpeChiWzBdKSwgKHRoaXMud2EgPSBiWzFdKSA/ICh0aGlzLmMgPSAxLCB0ZCh0aGlzKSkgOiAodGhpcy5jID0gMiwgdWQodGhpcykpKSA6IChxYihhLCBcIk1PREVcIiwgXCJpbml0XCIpLCB0aGlzLkEgPSBuZXcgUSh0aGlzLCB0aGlzLmEsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDApLCB0aGlzLkEuWSh0aGlzLnYpLCBoYyh0aGlzLkEsIGEsICExLCBudWxsLCAhMCksIHRoaXMuYyA9IDApXG59O1xuZnVuY3Rpb24gdGQoYSkge1xuICB2YXIgYiA9IHZkKGEuYiwgYS53YSwgXCIvbWFpbC9pbWFnZXMvY2xlYXJkb3QuZ2lmXCIpO1xuICBKKGIpO1xuICBvZChiLnRvU3RyaW5nKCksIDVFMywgdyhhLmljLCBhKSwgMywgMkUzKTtcbiAgYS5HKGpjKVxufVxucC5pYyA9IGZ1bmN0aW9uKGEpIHtcbiAgaWYoYSkge1xuICAgIHRoaXMuYyA9IDIsIHVkKHRoaXMpXG4gIH1lbHNlIHtcbiAgICBUKHdkKTtcbiAgICB2YXIgYiA9IHRoaXMuYjtcbiAgICBiLmEuZGVidWcoXCJUZXN0IENvbm5lY3Rpb24gQmxvY2tlZFwiKTtcbiAgICBiLmggPSBiLlUuaDtcbiAgICBaKGIsIDkpXG4gIH1cbiAgYSAmJiB0aGlzLkcocGMpXG59O1xuZnVuY3Rpb24gdWQoYSkge1xuICBhLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogc3RhcnRpbmcgc3RhZ2UgMlwiKTtcbiAgYS5BID0gbmV3IFEoYSwgYS5hLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwKTtcbiAgYS5BLlkoYS52KTtcbiAgdmFyIGIgPSB4ZChhLmIsIGEuTCwgYS5IKTtcbiAgVCh5ZCk7XG4gIGlmKGVjKCkpIHtcbiAgICBxYihiLCBcIlRZUEVcIiwgXCJ4bWxodHRwXCIpLCBoYyhhLkEsIGIsICExLCBhLkwsICExKVxuICB9ZWxzZSB7XG4gICAgcWIoYiwgXCJUWVBFXCIsIFwiaHRtbFwiKTtcbiAgICB2YXIgYyA9IGEuQTtcbiAgICBhID0gQm9vbGVhbihhLkwpO1xuICAgIGMuc2EgPSAzO1xuICAgIGMuVCA9IEooYi5uKCkpO1xuICAgIENjKGMsIGEpXG4gIH1cbn1cbnAuaGIgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLmIuaGIoYSlcbn07XG5wLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuQSAmJiAodGhpcy5BLmNhbmNlbCgpLCB0aGlzLkEgPSBudWxsKTtcbiAgdGhpcy5oID0gLTFcbn07XG5wLkhiID0gYmEoITEpO1xucC5QYiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5oID0gYS5oO1xuICBpZigwID09IHRoaXMuYykge1xuICAgIGlmKHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiBHb3QgZGF0YSBmb3Igc3RhZ2UgMVwiKSwgYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLlAucGFyc2UoYilcbiAgICAgIH1jYXRjaChkKSB7XG4gICAgICAgIHhjKHRoaXMuYSwgZCk7XG4gICAgICAgIHpkKHRoaXMuYiwgdGhpcyk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5MID0gdGhpcy5iLmNvcnJlY3RIb3N0UHJlZml4KGNbMF0pO1xuICAgICAgdGhpcy53YSA9IGNbMV1cbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogTnVsbCByZXNwb25zZVRleHRcIiksIHpkKHRoaXMuYiwgdGhpcylcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZigyID09IHRoaXMuYykge1xuICAgICAgaWYodGhpcy5VYSkge1xuICAgICAgICBUKEFkKSwgdGhpcy5uYiA9IHgoKVxuICAgICAgfWVsc2Uge1xuICAgICAgICBpZihcIjExMTExXCIgPT0gYikge1xuICAgICAgICAgIGlmKFQoQmQpLCB0aGlzLlVhID0gITAsIHRoaXMuS2EgPSB4KCksIGMgPSB0aGlzLkthIC0gdGhpcy5hYywgZWMoKSB8fCA1MDAgPiBjKSB7XG4gICAgICAgICAgICB0aGlzLmggPSAyMDAsIHRoaXMuQS5jYW5jZWwoKSwgdGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIHN1Y2NlZWRlZDsgdXNpbmcgc3RyZWFtaW5nIGNvbm5lY3Rpb25cIiksIFQoQ2QpLCBEZCh0aGlzLmIsIHRoaXMsICEwKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIFQoRWQpLCB0aGlzLkthID0gdGhpcy5uYiA9IHgoKSwgdGhpcy5VYSA9ICExXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5wLm1hID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaCA9IHRoaXMuQS5oO1xuICBpZighdGhpcy5BLkopIHtcbiAgICB0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogcmVxdWVzdCBmYWlsZWQsIGluIHN0YXRlIFwiICsgdGhpcy5jKSwgMCA9PSB0aGlzLmMgPyBUKEZkKSA6IDIgPT0gdGhpcy5jICYmIFQoR2QpLCB6ZCh0aGlzLmIsIHRoaXMpXG4gIH1lbHNlIHtcbiAgICBpZigwID09IHRoaXMuYykge1xuICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHJlcXVlc3QgY29tcGxldGUgZm9yIGluaXRpYWwgY2hlY2tcIiksIHRoaXMud2EgPyAodGhpcy5jID0gMSwgdGQodGhpcykpIDogKHRoaXMuYyA9IDIsIHVkKHRoaXMpKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKDIgPT0gdGhpcy5jKSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGNvbXBsZXRlIGZvciBzdGFnZSAyXCIpO1xuICAgICAgICB2YXIgYSA9ICExO1xuICAgICAgICAoYSA9IGVjKCkgPyB0aGlzLlVhIDogMjAwID4gdGhpcy5uYiAtIHRoaXMuS2EgPyAhMSA6ICEwKSA/ICh0aGlzLmEuZGVidWcoXCJUZXN0IGNvbm5lY3Rpb24gc3VjY2VlZGVkOyB1c2luZyBzdHJlYW1pbmcgY29ubmVjdGlvblwiKSwgVChDZCksIERkKHRoaXMuYiwgdGhpcywgITApKSA6ICh0aGlzLmEuZGVidWcoXCJUZXN0IGNvbm5lY3Rpb24gZmFpbGVkOyBub3QgdXNpbmcgc3RyZWFtaW5nXCIpLCBUKEhkKSwgRGQodGhpcy5iLCB0aGlzLCAhMSkpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xucC5ZYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iLllhKClcbn07XG5wLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmIuaXNBY3RpdmUoKVxufTtcbnAuRyA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5iLkcoYSlcbn07XG5mdW5jdGlvbiBJZChhLCBiKSB7XG4gIHRoaXMudmIgPSBhIHx8IG51bGw7XG4gIHRoaXMuYyA9IEpkO1xuICB0aGlzLnMgPSBbXTtcbiAgdGhpcy5RID0gW107XG4gIHRoaXMuYSA9IG5ldyBYO1xuICB0aGlzLlAgPSBuZXcgZ2QobnVsbCwgITApO1xuICB0aGlzLkNiID0gYiB8fCBudWxsXG59XG5mdW5jdGlvbiBLZChhLCBiKSB7XG4gIHRoaXMuTGIgPSBhO1xuICB0aGlzLm1hcCA9IGI7XG4gIHRoaXMuRmMgPSBudWxsXG59XG5wID0gSWQucHJvdG90eXBlO1xucC52ID0gbnVsbDtcbnAueGEgPSBudWxsO1xucC5vID0gbnVsbDtcbnAuayA9IG51bGw7XG5wLkggPSBudWxsO1xucC5MYSA9IG51bGw7XG5wLnViID0gbnVsbDtcbnAuTCA9IG51bGw7XG5wLmZjID0gITA7XG5wLkFhID0gMDtcbnAucWMgPSAwO1xucC5KYSA9ICExO1xucC5lID0gbnVsbDtcbnAuRiA9IG51bGw7XG5wLk0gPSBudWxsO1xucC5iYSA9IG51bGw7XG5wLlUgPSBudWxsO1xucC5yYiA9IG51bGw7XG5wLmVjID0gITA7XG5wLnlhID0gLTE7XG5wLktiID0gLTE7XG5wLmggPSAtMTtcbnAuViA9IDA7XG5wLmdhID0gMDtcbnAuZ2MgPSA1RTM7XG5wLkJjID0gMUU0O1xucC5rYiA9IDI7XG5wLkRiID0gMkU0O1xucC5vYSA9IDA7XG5wLlphID0gITE7XG5wLmhhID0gODtcbnZhciBKZCA9IDEsIExkID0gbmV3IFNiO1xuZnVuY3Rpb24gTWQoYSwgYikge1xuICBOLmNhbGwodGhpcywgXCJzdGF0ZXZlbnRcIiwgYSk7XG4gIHRoaXMuUGMgPSBiXG59XG55KE1kLCBOKTtcbmZ1bmN0aW9uIE5kKGEsIGIsIGMsIGQpIHtcbiAgTi5jYWxsKHRoaXMsIFwidGltaW5nZXZlbnRcIiwgYSk7XG4gIHRoaXMuc2l6ZSA9IGI7XG4gIHRoaXMuTmMgPSBjO1xuICB0aGlzLk1jID0gZFxufVxueShOZCwgTik7XG52YXIgamMgPSAxLCBwYyA9IDIsIG9jID0gMywgRmMgPSA0O1xuZnVuY3Rpb24gT2QoYSwgYikge1xuICBOLmNhbGwodGhpcywgXCJzZXJ2ZXJyZWFjaGFiaWxpdHlcIiwgYSk7XG4gIHRoaXMuTGMgPSBiXG59XG55KE9kLCBOKTtcbnZhciBzZCA9IDMsIHdkID0gNCwgeWQgPSA1LCBCZCA9IDYsIEFkID0gNywgRWQgPSA4LCBGZCA9IDksIEdkID0gMTAsIEhkID0gMTEsIENkID0gMTIsIHVjID0gMTMsIHZjID0gMTQsIHpjID0gMTUsIEFjID0gMTYsIEJjID0gMTcsIEhjID0gMTgsIERjID0gMjIsIGZkID0gXCJ5MmYlXCI7XG5wID0gSWQucHJvdG90eXBlO1xucC5nYiA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGYpIHtcbiAgdGhpcy5hLmRlYnVnKFwiY29ubmVjdCgpXCIpO1xuICBUKDApO1xuICB0aGlzLkggPSBiO1xuICB0aGlzLnhhID0gYyB8fCB7fTtcbiAgZCAmJiB2b2lkIDAgIT09IGYgJiYgKHRoaXMueGEuT1NJRCA9IGQsIHRoaXMueGEuT0FJRCA9IGYpO1xuICB0aGlzLmEuZGVidWcoXCJjb25uZWN0VGVzdF8oKVwiKTtcbiAgUGQodGhpcykgJiYgKHRoaXMuVSA9IG5ldyBxZCh0aGlzLCB0aGlzLmEpLCB0aGlzLlUuWSh0aGlzLnYpLCB0aGlzLlUuWmIodGhpcy5QKSwgdGhpcy5VLmdiKGEpKVxufTtcbnAuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmEuZGVidWcoXCJkaXNjb25uZWN0KClcIik7XG4gIFFkKHRoaXMpO1xuICBpZigzID09IHRoaXMuYykge1xuICAgIHZhciBhID0gdGhpcy5BYSsrLCBiID0gdGhpcy5MYS5uKCk7XG4gICAgSShiLCBcIlNJRFwiLCB0aGlzLlopO1xuICAgIEkoYiwgXCJSSURcIiwgYSk7XG4gICAgSShiLCBcIlRZUEVcIiwgXCJ0ZXJtaW5hdGVcIik7XG4gICAgUmQodGhpcywgYik7XG4gICAgYSA9IG5ldyBRKHRoaXMsIHRoaXMuYSwgdGhpcy5aLCBhLCB2b2lkIDApO1xuICAgIGEuc2EgPSAyO1xuICAgIGEuVCA9IEooYi5uKCkpO1xuICAgIGIgPSBuZXcgSW1hZ2U7XG4gICAgYi5zcmMgPSBhLlQ7XG4gICAgYi5vbmxvYWQgPSBiLm9uZXJyb3IgPSB3KGEubGMsIGEpO1xuICAgIGEucGEgPSB4KCk7XG4gICAgaWMoYSlcbiAgfVxuICBUZCh0aGlzKVxufTtcbmZ1bmN0aW9uIFFkKGEpIHtcbiAgYS5VICYmIChhLlUuYWJvcnQoKSwgYS5VID0gbnVsbCk7XG4gIGEuayAmJiAoYS5rLmNhbmNlbCgpLCBhLmsgPSBudWxsKTtcbiAgYS5NICYmIChxLmNsZWFyVGltZW91dChhLk0pLCBhLk0gPSBudWxsKTtcbiAgVWQoYSk7XG4gIGEubyAmJiAoYS5vLmNhbmNlbCgpLCBhLm8gPSBudWxsKTtcbiAgYS5GICYmIChxLmNsZWFyVGltZW91dChhLkYpLCBhLkYgPSBudWxsKVxufVxucC5ZID0gbShcInZcIik7XG5wLiRiID0gbShcIm9hXCIpO1xucC5IYiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gMCA9PSB0aGlzLmNcbn07XG5wLlpiID0gbShcIlBcIik7XG5mdW5jdGlvbiBWZChhKSB7XG4gIGEubyB8fCBhLkYgfHwgKGEuRiA9IFUodyhhLlJiLCBhKSwgMCksIGEuViA9IDApXG59XG5wLlJiID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLkYgPSBudWxsO1xuICB0aGlzLmEuZGVidWcoXCJzdGFydEZvcndhcmRDaGFubmVsX1wiKTtcbiAgaWYoUGQodGhpcykpIHtcbiAgICBpZih0aGlzLmMgPT0gSmQpIHtcbiAgICAgIGlmKGEpIHtcbiAgICAgICAgdGhpcy5hLkkoXCJOb3Qgc3VwcG9zZWQgdG8gcmV0cnkgdGhlIG9wZW5cIilcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdGhpcy5hLmRlYnVnKFwib3Blbl8oKVwiKTtcbiAgICAgICAgdGhpcy5BYSA9IE1hdGguZmxvb3IoMUU1ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIGEgPSB0aGlzLkFhKys7XG4gICAgICAgIHZhciBiID0gbmV3IFEodGhpcywgdGhpcy5hLCBcIlwiLCBhLCB2b2lkIDApO1xuICAgICAgICBiLlkodGhpcy52KTtcbiAgICAgICAgdmFyIGMgPSBXZCh0aGlzKSwgZCA9IHRoaXMuTGEubigpO1xuICAgICAgICBJKGQsIFwiUklEXCIsIGEpO1xuICAgICAgICB0aGlzLnZiICYmIEkoZCwgXCJDVkVSXCIsIHRoaXMudmIpO1xuICAgICAgICBSZCh0aGlzLCBkKTtcbiAgICAgICAgZmMoYiwgZCwgYyk7XG4gICAgICAgIHRoaXMubyA9IGI7XG4gICAgICAgIHRoaXMuYyA9IDJcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICAzID09IHRoaXMuYyAmJiAoYSA/IFhkKHRoaXMsIGEpIDogMCA9PSB0aGlzLnMubGVuZ3RoID8gdGhpcy5hLmRlYnVnKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF8gcmV0dXJuZWQ6IG5vdGhpbmcgdG8gc2VuZFwiKSA6IHRoaXMubyA/IHRoaXMuYS5JKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF8gcmV0dXJuZWQ6IGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiKSA6IChYZCh0aGlzKSwgdGhpcy5hLmRlYnVnKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF8gZmluaXNoZWQsIHNlbnQgcmVxdWVzdFwiKSkpXG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gWGQoYSwgYikge1xuICB2YXIgYywgZDtcbiAgYiA/IDYgPCBhLmhhID8gKGEucyA9IGEuUS5jb25jYXQoYS5zKSwgYS5RLmxlbmd0aCA9IDAsIGMgPSBhLkFhIC0gMSwgZCA9IFdkKGEpKSA6IChjID0gYi5CLCBkID0gYi5YKSA6IChjID0gYS5BYSsrLCBkID0gV2QoYSkpO1xuICB2YXIgZiA9IGEuTGEubigpO1xuICBJKGYsIFwiU0lEXCIsIGEuWik7XG4gIEkoZiwgXCJSSURcIiwgYyk7XG4gIEkoZiwgXCJBSURcIiwgYS55YSk7XG4gIFJkKGEsIGYpO1xuICBjID0gbmV3IFEoYSwgYS5hLCBhLlosIGMsIGEuViArIDEpO1xuICBjLlkoYS52KTtcbiAgYy5zZXRUaW1lb3V0KE1hdGgucm91bmQoMC41ICogYS5EYikgKyBNYXRoLnJvdW5kKDAuNSAqIGEuRGIgKiBNYXRoLnJhbmRvbSgpKSk7XG4gIGEubyA9IGM7XG4gIGZjKGMsIGYsIGQpXG59XG5mdW5jdGlvbiBSZChhLCBiKSB7XG4gIGlmKGEuZSkge1xuICAgIHZhciBjID0gYS5lLmdldEFkZGl0aW9uYWxQYXJhbXMoYSk7XG4gICAgYyAmJiBFKGMsIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIEkoYiwgYywgYSlcbiAgICB9KVxuICB9XG59XG5mdW5jdGlvbiBXZChhKSB7XG4gIHZhciBiID0gTWF0aC5taW4oYS5zLmxlbmd0aCwgMUUzKSwgYyA9IFtcImNvdW50PVwiICsgYl0sIGQ7XG4gIDYgPCBhLmhhICYmIDAgPCBiID8gKGQgPSBhLnNbMF0uTGIsIGMucHVzaChcIm9mcz1cIiArIGQpKSA6IGQgPSAwO1xuICBmb3IodmFyIGYgPSAwO2YgPCBiO2YrKykge1xuICAgIHZhciBnID0gYS5zW2ZdLkxiLCBoID0gYS5zW2ZdLm1hcCwgZyA9IDYgPj0gYS5oYSA/IGYgOiBnIC0gZDtcbiAgICB0cnkge1xuICAgICAgRShoLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGMucHVzaChcInJlcVwiICsgZyArIFwiX1wiICsgYiArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGEpKVxuICAgICAgfSlcbiAgICB9Y2F0Y2gobikge1xuICAgICAgYy5wdXNoKFwicmVxXCIgKyBnICsgXCJfdHlwZT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChcIl9iYWRtYXBcIikpLCBhLmUgJiYgYS5lLmJhZE1hcEVycm9yKGEsIGgpXG4gICAgfVxuICB9XG4gIGEuUSA9IGEuUS5jb25jYXQoYS5zLnNwbGljZSgwLCBiKSk7XG4gIHJldHVybiBjLmpvaW4oXCImXCIpXG59XG5mdW5jdGlvbiBZZChhKSB7XG4gIGEuayB8fCBhLk0gfHwgKGEudGIgPSAxLCBhLk0gPSBVKHcoYS5RYiwgYSksIDApLCBhLmdhID0gMClcbn1cbmZ1bmN0aW9uIFpkKGEpIHtcbiAgaWYoYS5rIHx8IGEuTSkge1xuICAgIHJldHVybiBhLmEuSShcIlJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKSwgITFcbiAgfVxuICBpZigzIDw9IGEuZ2EpIHtcbiAgICByZXR1cm4hMVxuICB9XG4gIGEuYS5kZWJ1ZyhcIkdvaW5nIHRvIHJldHJ5IEdFVFwiKTtcbiAgYS50YisrO1xuICBhLk0gPSBVKHcoYS5RYiwgYSksICRkKGEsIGEuZ2EpKTtcbiAgYS5nYSsrO1xuICByZXR1cm4hMFxufVxucC5RYiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLk0gPSBudWxsO1xuICBpZihQZCh0aGlzKSkge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIkNyZWF0aW5nIG5ldyBIdHRwUmVxdWVzdFwiKTtcbiAgICB0aGlzLmsgPSBuZXcgUSh0aGlzLCB0aGlzLmEsIHRoaXMuWiwgXCJycGNcIiwgdGhpcy50Yik7XG4gICAgdGhpcy5rLlkodGhpcy52KTtcbiAgICB0aGlzLmsuJGIodGhpcy5vYSk7XG4gICAgdmFyIGEgPSB0aGlzLnViLm4oKTtcbiAgICBJKGEsIFwiUklEXCIsIFwicnBjXCIpO1xuICAgIEkoYSwgXCJTSURcIiwgdGhpcy5aKTtcbiAgICBJKGEsIFwiQ0lcIiwgdGhpcy5yYiA/IFwiMFwiIDogXCIxXCIpO1xuICAgIEkoYSwgXCJBSURcIiwgdGhpcy55YSk7XG4gICAgUmQodGhpcywgYSk7XG4gICAgaWYoZWMoKSkge1xuICAgICAgSShhLCBcIlRZUEVcIiwgXCJ4bWxodHRwXCIpLCBoYyh0aGlzLmssIGEsICEwLCB0aGlzLkwsICExKVxuICAgIH1lbHNlIHtcbiAgICAgIEkoYSwgXCJUWVBFXCIsIFwiaHRtbFwiKTtcbiAgICAgIHZhciBiID0gdGhpcy5rLCBjID0gQm9vbGVhbih0aGlzLkwpO1xuICAgICAgYi5zYSA9IDM7XG4gICAgICBiLlQgPSBKKGEubigpKTtcbiAgICAgIENjKGIsIGMpXG4gICAgfVxuICAgIHRoaXMuYS5kZWJ1ZyhcIk5ldyBSZXF1ZXN0IGNyZWF0ZWRcIilcbiAgfVxufTtcbmZ1bmN0aW9uIFBkKGEpIHtcbiAgaWYoYS5lKSB7XG4gICAgdmFyIGIgPSBhLmUub2tUb01ha2VSZXF1ZXN0KGEpO1xuICAgIGlmKDAgIT0gYikge1xuICAgICAgcmV0dXJuIGEuYS5kZWJ1ZyhcIkhhbmRsZXIgcmV0dXJuZWQgZXJyb3IgY29kZSBmcm9tIG9rVG9NYWtlUmVxdWVzdFwiKSwgWihhLCBiKSwgITFcbiAgICB9XG4gIH1cbiAgcmV0dXJuITBcbn1cbmZ1bmN0aW9uIERkKGEsIGIsIGMpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEZpbmlzaGVkXCIpO1xuICBhLnJiID0gYS5lYyAmJiBjO1xuICBhLmggPSBiLmg7XG4gIGEuYS5kZWJ1ZyhcImNvbm5lY3RDaGFubmVsXygpXCIpO1xuICBhLmpjKEpkLCAwKTtcbiAgYS5MYSA9IHJkKGEsIGEuSCk7XG4gIFZkKGEpXG59XG5mdW5jdGlvbiB6ZChhLCBiKSB7XG4gIGEuYS5kZWJ1ZyhcIlRlc3QgQ29ubmVjdGlvbiBGYWlsZWRcIik7XG4gIGEuaCA9IGIuaDtcbiAgWihhLCAyKVxufVxucC5QYiA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYoMCAhPSB0aGlzLmMgJiYgKHRoaXMuayA9PSBhIHx8IHRoaXMubyA9PSBhKSkge1xuICAgIGlmKHRoaXMuaCA9IGEuaCwgdGhpcy5vID09IGEgJiYgMyA9PSB0aGlzLmMpIHtcbiAgICAgIGlmKDcgPCB0aGlzLmhhKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGMgPSB0aGlzLlAucGFyc2UoYilcbiAgICAgICAgfWNhdGNoKGQpIHtcbiAgICAgICAgICBjID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGlmKHMoYykgJiYgMyA9PSBjLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmID0gYztcbiAgICAgICAgICBpZigwID09IGZbMF0pIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgaWYodGhpcy5hLmRlYnVnKFwiU2VydmVyIGNsYWltcyBvdXIgYmFja2NoYW5uZWwgaXMgbWlzc2luZy5cIiksIHRoaXMuTSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYS5kZWJ1ZyhcIkJ1dCB3ZSBhcmUgY3VycmVudGx5IHN0YXJ0aW5nIHRoZSByZXF1ZXN0LlwiKVxuICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5rKSB7XG4gICAgICAgICAgICAgICAgICBpZih0aGlzLmsucGEgKyAzRTMgPCB0aGlzLm8ucGEpIHtcbiAgICAgICAgICAgICAgICAgICAgVWQodGhpcyksIHRoaXMuay5jYW5jZWwoKSwgdGhpcy5rID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hLiQoXCJXZSBkbyBub3QgaGF2ZSBhIEJhY2tDaGFubmVsIGVzdGFibGlzaGVkXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFpkKHRoaXMpO1xuICAgICAgICAgICAgICAgIFQoMTkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB0aGlzLktiID0gZlsxXSwgYyA9IHRoaXMuS2IgLSB0aGlzLnlhLCAwIDwgYyAmJiAoZiA9IGZbMl0sIHRoaXMuYS5kZWJ1ZyhmICsgXCIgYnl0ZXMgKGluIFwiICsgYyArIFwiIGFycmF5cykgYXJlIG91dHN0YW5kaW5nIG9uIHRoZSBCYWNrQ2hhbm5lbFwiKSwgMzc1MDAgPiBmICYmICh0aGlzLnJiICYmIDAgPT0gdGhpcy5nYSkgJiYgIXRoaXMuYmEgJiYgKHRoaXMuYmEgPSBVKHcodGhpcy5yYywgdGhpcyksIDZFMykpKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIHRoaXMuYS5kZWJ1ZyhcIkJhZCBQT1NUIHJlc3BvbnNlIGRhdGEgcmV0dXJuZWRcIiksIFoodGhpcywgMTEpXG4gICAgICAgIH1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgYiAhPSBmZCAmJiAodGhpcy5hLmRlYnVnKFwiQmFkIGRhdGEgcmV0dXJuZWQgLSBtaXNzaW5nL2ludmFsZCBtYWdpYyBjb29raWVcIiksIFoodGhpcywgMTEpKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKHRoaXMuayA9PSBhICYmIFVkKHRoaXMpLCAhL15bXFxzXFx4YTBdKiQvLnRlc3QoYikpIHtcbiAgICAgICAgYyA9IHRoaXMuUC5wYXJzZShiKTtcbiAgICAgICAgZm9yKHZhciBmID0gdGhpcy5lICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXMgPyBbXSA6IG51bGwsIGcgPSAwO2cgPCBjLmxlbmd0aDtnKyspIHtcbiAgICAgICAgICB2YXIgaCA9IGNbZ107XG4gICAgICAgICAgdGhpcy55YSA9IGhbMF07XG4gICAgICAgICAgaCA9IGhbMV07XG4gICAgICAgICAgMiA9PSB0aGlzLmMgPyBcImNcIiA9PSBoWzBdID8gKHRoaXMuWiA9IGhbMV0sIHRoaXMuTCA9IHRoaXMuY29ycmVjdEhvc3RQcmVmaXgoaFsyXSksIGggPSBoWzNdLCB0aGlzLmhhID0gbnVsbCAhPSBoID8gaCA6IDYsIHRoaXMuYyA9IDMsIHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbE9wZW5lZCh0aGlzKSwgdGhpcy51YiA9IHhkKHRoaXMsIHRoaXMuTCwgdGhpcy5IKSwgWWQodGhpcykpIDogXCJzdG9wXCIgPT0gaFswXSAmJiBaKHRoaXMsIDcpIDogMyA9PSB0aGlzLmMgJiYgKFwic3RvcFwiID09IGhbMF0gPyAoZiAmJiBmLmxlbmd0aCAmJiAodGhpcy5lLmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyh0aGlzLCBmKSwgZi5sZW5ndGggPSAwKSwgWih0aGlzLCA3KSkgOiBcIm5vb3BcIiAhPSBoWzBdICYmIChmID8gZi5wdXNoKGgpIDogdGhpcy5lICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlQXJyYXkodGhpcywgaCkpLCB0aGlzLmdhID0gMClcbiAgICAgICAgfVxuICAgICAgICBmICYmIGYubGVuZ3RoICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXModGhpcywgZilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5wLmNvcnJlY3RIb3N0UHJlZml4ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5mYyA/IHRoaXMuZSA/IHRoaXMuZS5jb3JyZWN0SG9zdFByZWZpeChhKSA6IGEgOiBudWxsXG59O1xucC5yYyA9IGZ1bmN0aW9uKCkge1xuICBudWxsICE9IHRoaXMuYmEgJiYgKHRoaXMuYmEgPSBudWxsLCB0aGlzLmsuY2FuY2VsKCksIHRoaXMuayA9IG51bGwsIFpkKHRoaXMpLCBUKDIwKSlcbn07XG5mdW5jdGlvbiBVZChhKSB7XG4gIG51bGwgIT0gYS5iYSAmJiAocS5jbGVhclRpbWVvdXQoYS5iYSksIGEuYmEgPSBudWxsKVxufVxucC5tYSA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5hLmRlYnVnKFwiUmVxdWVzdCBjb21wbGV0ZVwiKTtcbiAgdmFyIGI7XG4gIGlmKHRoaXMuayA9PSBhKSB7XG4gICAgVWQodGhpcyksIHRoaXMuayA9IG51bGwsIGIgPSAyXG4gIH1lbHNlIHtcbiAgICBpZih0aGlzLm8gPT0gYSkge1xuICAgICAgdGhpcy5vID0gbnVsbCwgYiA9IDFcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgdGhpcy5oID0gYS5oO1xuICBpZigwICE9IHRoaXMuYykge1xuICAgIGlmKGEuSikge1xuICAgICAgMSA9PSBiID8gKGIgPSB4KCkgLSBhLnBhLCBMZC5kaXNwYXRjaEV2ZW50KG5ldyBOZChMZCwgYS5YID8gYS5YLmxlbmd0aCA6IDAsIGIsIHRoaXMuVikpLCBWZCh0aGlzKSwgdGhpcy5RLmxlbmd0aCA9IDApIDogWWQodGhpcylcbiAgICB9ZWxzZSB7XG4gICAgICB2YXIgYyA9IGEuRWIoKTtcbiAgICAgIGlmKDMgPT0gYyB8fCA3ID09IGMgfHwgMCA9PSBjICYmIDAgPCB0aGlzLmgpIHtcbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiTm90IHJldHJ5aW5nIGR1ZSB0byBlcnJvciB0eXBlXCIpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIk1heWJlIHJldHJ5aW5nLCBsYXN0IGVycm9yOiBcIiArIGJjKGMsIHRoaXMuaCkpO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgaWYoZCA9IDEgPT0gYikge1xuICAgICAgICAgIHRoaXMubyB8fCB0aGlzLkYgPyAodGhpcy5hLkkoXCJSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksIGQgPSAhMSkgOiB0aGlzLmMgPT0gSmQgfHwgdGhpcy5WID49ICh0aGlzLkphID8gMCA6IHRoaXMua2IpID8gZCA9ICExIDogKHRoaXMuYS5kZWJ1ZyhcIkdvaW5nIHRvIHJldHJ5IFBPU1RcIiksIHRoaXMuRiA9IFUodyh0aGlzLlJiLCB0aGlzLCBhKSwgJGQodGhpcywgdGhpcy5WKSksIHRoaXMuVisrLCBkID0gITApXG4gICAgICAgIH1cbiAgICAgICAgaWYoZCB8fCAyID09IGIgJiYgWmQodGhpcykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmEuZGVidWcoXCJFeGNlZWRlZCBtYXggbnVtYmVyIG9mIHJldHJpZXNcIilcbiAgICAgIH1cbiAgICAgIHRoaXMuYS5kZWJ1ZyhcIkVycm9yOiBIVFRQIHJlcXVlc3QgZmFpbGVkXCIpO1xuICAgICAgc3dpdGNoKGMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIFoodGhpcywgNSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBaKHRoaXMsIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIFoodGhpcywgNik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBaKHRoaXMsIDEyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBaKHRoaXMsIDIpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gJGQoYSwgYikge1xuICB2YXIgYyA9IGEuZ2MgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhLkJjKTtcbiAgYS5pc0FjdGl2ZSgpIHx8IChhLmEuZGVidWcoXCJJbmFjdGl2ZSBjaGFubmVsXCIpLCBjICo9IDIpO1xuICByZXR1cm4gYyAqIGJcbn1cbnAuamMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKCEoMCA8PSBYYShhcmd1bWVudHMsIHRoaXMuYykpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYW5uZWwgc3RhdGU6IFwiICsgdGhpcy5jKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFooYSwgYikge1xuICBhLmEuaW5mbyhcIkVycm9yIGNvZGUgXCIgKyBiKTtcbiAgaWYoMiA9PSBiIHx8IDkgPT0gYikge1xuICAgIHZhciBjID0gbnVsbDtcbiAgICBhLmUgJiYgKGMgPSBhLmUuZ2V0TmV0d29ya1Rlc3RJbWFnZVVyaShhKSk7XG4gICAgdmFyIGQgPSB3KGEuRGMsIGEpO1xuICAgIGMgfHwgKGMgPSBuZXcgRihcIi8vd3d3Lmdvb2dsZS5jb20vaW1hZ2VzL2NsZWFyZG90LmdpZlwiKSwgSihjKSk7XG4gICAgcGQoYy50b1N0cmluZygpLCAxRTQsIGQpXG4gIH1lbHNlIHtcbiAgICBUKDIpXG4gIH1cbiAgYWUoYSwgYilcbn1cbnAuRGMgPSBmdW5jdGlvbihhKSB7XG4gIGEgPyAodGhpcy5hLmluZm8oXCJTdWNjZXNzZnVsbHkgcGluZ2VkIGdvb2dsZS5jb21cIiksIFQoMikpIDogKHRoaXMuYS5pbmZvKFwiRmFpbGVkIHRvIHBpbmcgZ29vZ2xlLmNvbVwiKSwgVCgxKSwgYWUodGhpcywgOCkpXG59O1xuZnVuY3Rpb24gYWUoYSwgYikge1xuICBhLmEuZGVidWcoXCJIdHRwQ2hhbm5lbDogZXJyb3IgLSBcIiArIGIpO1xuICBhLmMgPSAwO1xuICBhLmUgJiYgYS5lLmNoYW5uZWxFcnJvcihhLCBiKTtcbiAgVGQoYSk7XG4gIFFkKGEpXG59XG5mdW5jdGlvbiBUZChhKSB7XG4gIGEuYyA9IDA7XG4gIGEuaCA9IC0xO1xuICBpZihhLmUpIHtcbiAgICBpZigwID09IGEuUS5sZW5ndGggJiYgMCA9PSBhLnMubGVuZ3RoKSB7XG4gICAgICBhLmUuY2hhbm5lbENsb3NlZChhKVxuICAgIH1lbHNlIHtcbiAgICAgIGEuYS5kZWJ1ZyhcIk51bWJlciBvZiB1bmRlbGl2ZXJlZCBtYXBzLCBwZW5kaW5nOiBcIiArIGEuUS5sZW5ndGggKyBcIiwgb3V0Z29pbmc6IFwiICsgYS5zLmxlbmd0aCk7XG4gICAgICB2YXIgYiA9ICRhKGEuUSksIGMgPSAkYShhLnMpO1xuICAgICAgYS5RLmxlbmd0aCA9IDA7XG4gICAgICBhLnMubGVuZ3RoID0gMDtcbiAgICAgIGEuZS5jaGFubmVsQ2xvc2VkKGEsIGIsIGMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZChhLCBiKSB7XG4gIHZhciBjID0gdmQoYSwgbnVsbCwgYik7XG4gIGEuYS5kZWJ1ZyhcIkdldEZvcndhcmRDaGFubmVsVXJpOiBcIiArIGMpO1xuICByZXR1cm4gY1xufVxuZnVuY3Rpb24geGQoYSwgYiwgYykge1xuICBiID0gdmQoYSwgYS5ZYSgpID8gYiA6IG51bGwsIGMpO1xuICBhLmEuZGVidWcoXCJHZXRCYWNrQ2hhbm5lbFVyaTogXCIgKyBiKTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHZkKGEsIGIsIGMpIHtcbiAgdmFyIGQgPSBjIGluc3RhbmNlb2YgRiA/IGMubigpIDogbmV3IEYoYywgdm9pZCAwKTtcbiAgaWYoXCJcIiAhPSBkLmphKSB7XG4gICAgYiAmJiBmYihkLCBiICsgXCIuXCIgKyBkLmphKSwgZ2IoZCwgZC5CYSlcbiAgfWVsc2Uge1xuICAgIHZhciBmID0gd2luZG93LmxvY2F0aW9uLCBkID0gc2IoZi5wcm90b2NvbCwgYiA/IGIgKyBcIi5cIiArIGYuaG9zdG5hbWUgOiBmLmhvc3RuYW1lLCBmLnBvcnQsIGMpXG4gIH1cbiAgYS54YSAmJiBFKGEueGEsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBJKGQsIGIsIGEpXG4gIH0pO1xuICBJKGQsIFwiVkVSXCIsIGEuaGEpO1xuICBSZChhLCBkKTtcbiAgcmV0dXJuIGRcbn1cbnAuaGIgPSBmdW5jdGlvbihhKSB7XG4gIGlmKGEgJiYgIXRoaXMuWmEpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IGNyZWF0ZSBzZWNvbmRhcnkgZG9tYWluIGNhcGFibGUgWGhySW8gb2JqZWN0LlwiKTtcbiAgfVxuICBhID0gbmV3IGhkO1xuICBhLmNjID0gdGhpcy5aYTtcbiAgcmV0dXJuIGFcbn07XG5wLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiEhdGhpcy5lICYmIHRoaXMuZS5pc0FjdGl2ZSh0aGlzKVxufTtcbmZ1bmN0aW9uIFUoYSwgYikge1xuICBpZighaGEoYSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkZuIG11c3Qgbm90IGJlIG51bGwgYW5kIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICByZXR1cm4gcS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGEoKVxuICB9LCBiKVxufVxucC5HID0gZnVuY3Rpb24oYSkge1xuICBMZC5kaXNwYXRjaEV2ZW50KG5ldyBPZChMZCwgYSkpXG59O1xuZnVuY3Rpb24gVChhKSB7XG4gIExkLmRpc3BhdGNoRXZlbnQobmV3IE1kKExkLCBhKSlcbn1cbnAuWWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuWmEgfHwgIWVjKClcbn07XG5mdW5jdGlvbiBiZSgpIHtcbn1cbnAgPSBiZS5wcm90b3R5cGU7XG5wLmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyA9IG51bGw7XG5wLm9rVG9NYWtlUmVxdWVzdCA9IGJhKDApO1xucC5jaGFubmVsT3BlbmVkID0gZSgpO1xucC5jaGFubmVsSGFuZGxlQXJyYXkgPSBlKCk7XG5wLmNoYW5uZWxFcnJvciA9IGUoKTtcbnAuY2hhbm5lbENsb3NlZCA9IGUoKTtcbnAuZ2V0QWRkaXRpb25hbFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm57fVxufTtcbnAuZ2V0TmV0d29ya1Rlc3RJbWFnZVVyaSA9IGJhKG51bGwpO1xucC5pc0FjdGl2ZSA9IGJhKCEwKTtcbnAuYmFkTWFwRXJyb3IgPSBlKCk7XG5wLmNvcnJlY3RIb3N0UHJlZml4ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gYVxufTtcbnZhciAkLCBjZSwgZGUgPSBbXS5zbGljZTtcbmNlID0gezA6XCJPa1wiLCA0OlwiVXNlciBpcyBsb2dnaW5nIG91dFwiLCA2OlwiVW5rbm93biBzZXNzaW9uIElEXCIsIDc6XCJTdG9wcGVkIGJ5IHNlcnZlclwiLCA4OlwiR2VuZXJhbCBuZXR3b3JrIGVycm9yXCIsIDI6XCJSZXF1ZXN0IGZhaWxlZFwiLCA5OlwiQmxvY2tlZCBieSBhIG5ldHdvcmsgYWRtaW5pc3RyYXRvclwiLCA1OlwiTm8gZGF0YSBmcm9tIHNlcnZlclwiLCAxMDpcIkdvdCBiYWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcIiwgMTE6XCJHb3QgYSBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXCJ9O1xuJCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGMsIGQsIGYsIGcsIGgsIG4sIGssIHQsIGwsIHI7XG4gIHQgPSB0aGlzO1xuICBhIHx8IChhID0gXCJjaGFubmVsXCIpO1xuICBhLm1hdGNoKC86XFwvXFwvLykgJiYgYS5yZXBsYWNlKC9ed3MvLCBcImh0dHBcIik7XG4gIGIgfHwgKGIgPSB7fSk7XG4gIHMoYiB8fCBcInN0cmluZ1wiID09PSB0eXBlb2YgYikgJiYgKGIgPSB7fSk7XG4gIG4gPSBiLnJlY29ubmVjdFRpbWUgfHwgM0UzO1xuICByID0gZnVuY3Rpb24oYSkge1xuICAgIHQucmVhZHlTdGF0ZSA9IHQucmVhZHlTdGF0ZSA9IGFcbiAgfTtcbiAgcih0aGlzLkNMT1NFRCk7XG4gIGwgPSBudWxsO1xuICBnID0gYi5LYztcbiAgYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLCBiO1xuICAgIGIgPSBhcmd1bWVudHNbMF07XG4gICAgYSA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IGRlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5cImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0W2JdID8gdFtiXS5hcHBseSh0LCBhKSA6IHZvaWQgMFxuICAgIH1jYXRjaChjKSB7XG4gICAgICB0aHJvdyBhID0gYywgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNvbnNvbGUgJiYgbnVsbCAhPT0gY29uc29sZSAmJiBjb25zb2xlLmVycm9yKGEuc3RhY2spLCBhO1xuICAgIH1cbiAgfTtcbiAgZCA9IG5ldyBiZTtcbiAgZC5jaGFubmVsT3BlbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgZyA9IGw7XG4gICAgcigkLk9QRU4pO1xuICAgIHJldHVybiBjKFwib25vcGVuXCIpXG4gIH07XG4gIGYgPSBudWxsO1xuICBkLmNoYW5uZWxFcnJvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgZDtcbiAgICBkID0gY2VbYl07XG4gICAgZiA9IGI7XG4gICAgcigkLmNiKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGMoXCJvbmVycm9yXCIsIGQsIGIpXG4gICAgfWNhdGNoKGcpIHtcbiAgICB9XG4gIH07XG4gIGsgPSBudWxsO1xuICBkLmNoYW5uZWxDbG9zZWQgPSBmdW5jdGlvbihhLCBkLCBnKSB7XG4gICAgaWYodC5yZWFkeVN0YXRlICE9PSAkLkNMT1NFRCkge1xuICAgICAgbCA9IG51bGw7XG4gICAgICBhID0gZiA/IGNlW2ZdIDogXCJDbG9zZWRcIjtcbiAgICAgIHIoJC5DTE9TRUQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYyhcIm9uY2xvc2VcIiwgYSwgZCwgZylcbiAgICAgIH1jYXRjaChlZSkge1xuICAgICAgfVxuICAgICAgYi5yZWNvbm5lY3QgJiYgKDcgIT09IGYgJiYgMCAhPT0gZikgJiYgKGQgPSA2ID09PSBmID8gMCA6IG4sIGNsZWFyVGltZW91dChrKSwgayA9IHNldFRpbWVvdXQoaCwgZCkpO1xuICAgICAgcmV0dXJuIGYgPSBudWxsXG4gICAgfVxuICB9O1xuICBkLmNoYW5uZWxIYW5kbGVBcnJheSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYyhcIm9ubWVzc2FnZVwiLCBiKVxuICB9O1xuICBoID0gZnVuY3Rpb24oKSB7XG4gICAgaWYobCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJSZWNvbm5lY3QoKSBjYWxsZWQgZnJvbSBpbnZhbGlkIHN0YXRlXCIpO1xuICAgIH1cbiAgICByKCQuQ09OTkVDVElORyk7XG4gICAgYyhcIm9uY29ubmVjdGluZ1wiKTtcbiAgICBjbGVhclRpbWVvdXQoayk7XG4gICAgbCA9IG5ldyBJZChiLmFwcFZlcnNpb24sIG51bGwgIT0gZyA/IGcuQ2IgOiB2b2lkIDApO1xuICAgIGIuY3Jvc3NEb21haW5YaHIgJiYgKGwuWmEgPSAhMCk7XG4gICAgbC5lID0gZDtcbiAgICBmID0gbnVsbDtcbiAgICBpZihiLmZhaWxGYXN0KSB7XG4gICAgICB2YXIgaCA9IGw7XG4gICAgICBoLkphID0gITA7XG4gICAgICBoLmEuaW5mbyhcInNldEZhaWxGYXN0OiB0cnVlXCIpO1xuICAgICAgKGgubyB8fCBoLkYpICYmIGguViA+IChoLkphID8gMCA6IGgua2IpICYmIChoLmEuaW5mbyhcIlJldHJ5IGNvdW50IFwiICsgaC5WICsgXCIgPiBuZXcgbWF4UmV0cmllcyBcIiArIChoLkphID8gMCA6IGgua2IpICsgXCIuIEZhaWwgaW1tZWRpYXRlbHkhXCIpLCBoLm8gPyAoaC5vLmNhbmNlbCgpLCBoLm1hKGgubykpIDogKHEuY2xlYXJUaW1lb3V0KGguRiksIGguRiA9IG51bGwsIFooaCwgMikpKVxuICAgIH1cbiAgICByZXR1cm4gbC5nYihcIlwiICsgYSArIFwiL3Rlc3RcIiwgXCJcIiArIGEgKyBcIi9iaW5kXCIsIGIuZXh0cmFQYXJhbXMsIG51bGwgIT0gZyA/IGcuWiA6IHZvaWQgMCwgbnVsbCAhPSBnID8gZy55YSA6IHZvaWQgMClcbiAgfTtcbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYodC5yZWFkeVN0YXRlICE9PSB0LkNMT1NFRCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBbHJlYWR5IG9wZW5cIik7XG4gICAgfVxuICAgIHJldHVybiBoKClcbiAgfTtcbiAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dChrKTtcbiAgICBmID0gMDtcbiAgICBpZih0LnJlYWR5U3RhdGUgIT09ICQuQ0xPU0VEKSB7XG4gICAgICByZXR1cm4gcigkLmNiKSwgbC5kaXNjb25uZWN0KClcbiAgICB9XG4gIH07XG4gIHRoaXMuc2VuZE1hcCA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgYjtcbiAgICBpZigoYiA9IHQucmVhZHlTdGF0ZSkgPT09ICQuY2IgfHwgYiA9PT0gJC5DTE9TRUQpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNlbmQgdG8gYSBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB9XG4gICAgYiA9IGw7XG4gICAgaWYoMCA9PSBiLmMpIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBvcGVyYXRpb246IHNlbmRpbmcgbWFwIHdoZW4gc3RhdGUgaXMgY2xvc2VkXCIpO1xuICAgIH1cbiAgICAxRTMgPT0gYi5zLmxlbmd0aCAmJiBiLmEuSShcIkFscmVhZHkgaGF2ZSAxMDAwIHF1ZXVlZCBtYXBzIHVwb24gcXVldWVpbmcgXCIgKyBLYyhhKSk7XG4gICAgYi5zLnB1c2gobmV3IEtkKGIucWMrKywgYSkpO1xuICAgIDIgIT0gYi5jICYmIDMgIT0gYi5jIHx8IFZkKGIpXG4gIH07XG4gIHRoaXMuc2VuZCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kTWFwKHtKU09OOktjKGEpfSlcbiAgfTtcbiAgaCgpO1xuICByZXR1cm4gdGhpc1xufTtcbiQucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSAkLkNPTk5FQ1RJTkcgPSAkLkNPTk5FQ1RJTkcgPSAwO1xuJC5wcm90b3R5cGUuT1BFTiA9ICQuT1BFTiA9ICQuT1BFTiA9IDE7XG4kLnByb3RvdHlwZS5DTE9TSU5HID0gJC5DTE9TSU5HID0gJC5jYiA9IDI7XG4kLnByb3RvdHlwZS5DTE9TRUQgPSAkLkNMT1NFRCA9ICQuQ0xPU0VEID0gMztcbihcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZXhwb3J0cyAmJiBudWxsICE9PSBleHBvcnRzID8gZXhwb3J0cyA6IHdpbmRvdykuQkNTb2NrZXQgPSAkO1xuXG59KSgpO1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3MsX19kaXJuYW1lKXt2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYWNlcjtcblxuZnVuY3Rpb24gUmFjZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xufVxuXG51dGlsLm1lcmdlSW50byhSYWNlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBNYWtlIGNsYXNzZXMgYWNjZXNzaWJsZSBmb3IgdXNlIGJ5IHBsdWdpbnMgYW5kIHRlc3RzXG5SYWNlci5wcm90b3R5cGUuTW9kZWwgPSBNb2RlbDtcblJhY2VyLnByb3RvdHlwZS51dGlsID0gdXRpbDtcblxuLy8gU3VwcG9ydCBwbHVnaW5zIG9uIHJhY2VyIGluc3RhbmNlc1xuUmFjZXIucHJvdG90eXBlLnVzZSA9IHV0aWwudXNlO1xuXG5SYWNlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJhY2VyID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9IGRhdGEubm9kZUVudjtcblxuICAvLyBJbml0IGlzIGV4ZWN1dGVkIGFzeW5jIHNvIHRoYXQgcGx1Z2lucyBjYW4gZXh0ZW5kIFJhY2VyIGV2ZW4gaWYgdGhleSBhcmVcbiAgLy8gaW5jbHVkZWQgYWZ0ZXIgdGhlIG1haW4gZW50cnkgcG9pbnQgaW4gdGhlIGJ1bmRsZVxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbDtcblxuICAgIG1vZGVsLl9jcmVhdGVDb25uZWN0aW9uKGRhdGEpO1xuXG4gICAgcmFjZXIuZW1pdCgnbW9kZWwnLCBtb2RlbCk7XG5cbiAgICAvLyBSZS1jcmVhdGUgZG9jdW1lbnRzIGZvciBhbGwgbW9kZWwgZGF0YVxuICAgIGZvciAodmFyIGNvbGxlY3Rpb25OYW1lIGluIGRhdGEuY29sbGVjdGlvbnMpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gZGF0YS5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV07XG4gICAgICBmb3IgKHZhciBpZCBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBkb2MgPSBtb2RlbC5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQsIGNvbGxlY3Rpb25baWRdKTtcbiAgICAgICAgaWYgKGRvYy5zaGFyZURvYykge1xuICAgICAgICAgIG1vZGVsLl9sb2FkVmVyc2lvbnNbY29sbGVjdGlvbk5hbWUgKyAnLicgKyBpZF0gPSBkb2Muc2hhcmVEb2MudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFN1cHBvcnQgcmUtaW5pdCB3aGVuIHRoZXJlIGFyZSBjb250ZXh0cyBvdGhlciB0aGFuIHJvb3RcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHMucm9vdDtcbiAgICAvLyBSZS1zdWJzY3JpYmUgdG8gZG9jdW1lbnQgc3Vic2NyaXB0aW9uc1xuICAgIGZvciAodmFyIHBhdGggaW4gY29udGV4dC5zdWJzY3JpYmVkRG9jcykge1xuICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgbW9kZWwuc3Vic2NyaWJlRG9jKHNlZ21lbnRzWzBdLCBzZWdtZW50c1sxXSk7XG4gICAgICBtb2RlbC5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSBjb250ZXh0LnN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIH1cbiAgICAvLyBJbml0IGZldGNoZWREb2NzIGNvdW50c1xuICAgIGZvciAodmFyIHBhdGggaW4gY29udGV4dC5mZXRjaGVkRG9jcykge1xuICAgICAgbW9kZWwuX2ZldGNoZWREb2NzW3BhdGhdID0gY29udGV4dC5mZXRjaGVkRG9jc1twYXRoXTtcbiAgICB9XG5cbiAgICB2YXIgc2lsZW50TW9kZWwgPSBtb2RlbC5zaWxlbnQoKTtcbiAgICAvLyBSZS1jcmVhdGUgcmVmc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5yZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEucmVmc1tpXTtcbiAgICAgIHNpbGVudE1vZGVsLnJlZihpdGVtWzBdLCBpdGVtWzFdKTtcbiAgICB9XG4gICAgLy8gUmUtY3JlYXRlIHJlZkxpc3RzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlZkxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEucmVmTGlzdHNbaV07XG4gICAgICBzaWxlbnRNb2RlbC5yZWZMaXN0KGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10pO1xuICAgIH1cbiAgICAvLyBSZS1jcmVhdGUgZm5zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLmZuc1tpXTtcbiAgICAgIHNpbGVudE1vZGVsLnN0YXJ0LmFwcGx5KHNpbGVudE1vZGVsLCBpdGVtKTtcbiAgICB9XG4gICAgLy8gUmUtY3JlYXRlIGZpbHRlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLmZpbHRlcnNbaV07XG4gICAgICB2YXIgZmlsdGVyID0gbW9kZWwuX2ZpbHRlcnMuYWRkKGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0pO1xuICAgICAgZmlsdGVyLnJlZihpdGVtWzNdKTtcbiAgICB9XG4gICAgLy8gSW5pdCBhbmQgcmUtc3Vic2NyaWJlIHF1ZXJpZXMgYXMgYXBwcm9wcmlhdGVcbiAgICBtb2RlbC5faW5pdFF1ZXJpZXMoZGF0YS5xdWVyaWVzKTtcblxuICAgIHJhY2VyLl9tb2RlbCA9IG1vZGVsO1xuICAgIHJhY2VyLmVtaXQoJ3JlYWR5JywgbW9kZWwpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SYWNlci5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAvLyBDYWxsYmFjayBhc3luYyBpbiBjYXNlIHRoZSBjb2RlIGRlcGVuZHMgb24gc2NyaXB0cyBpbmNsdWRlZCBhZnRlciBpblxuICAgIC8vIHRoZSBidW5kbGUgYW5kIGlzIGdhdGVkIGJ5IGEgcmVhZHlcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IodGhpcy5fbW9kZWwpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm9uY2UoJ3JlYWR5JywgY2IpO1xufTtcblxudXRpbC5zZXJ2ZXJSZXF1aXJlKF9fZGlybmFtZSArICcvUmFjZXIuc2VydmVyLmpzJyk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxcIi9ub2RlX21vZHVsZXMvZGVyYnkvbm9kZV9tb2R1bGVzL3JhY2VyL2xpYlwiKSIsInZhciBhcHAgPSByZXF1aXJlKCdkZXJieScpXG4gIC5jcmVhdGVBcHAobW9kdWxlKVxuICAudXNlKHJlcXVpcmUoJy4uLy4uL3VpJykpXG4gIC51c2UocmVxdWlyZSgnZGVyYnktdWktZ2l0aHViLWJ1dHRvbnMnKSk7XG5cbnJlcXVpcmUoJ2RlcmJ5LWxhbmcnKS5hcHAoYXBwKTtcbnJlcXVpcmUoJy4vZXZlbnRzJykoYXBwKTtcbnJlcXVpcmUoJy4vcm91dGVzJykoYXBwKTtcbnJlcXVpcmUoJy4vdmlld0ZucycpKGFwcCk7IiwiKGZ1bmN0aW9uKF9fZmlsZW5hbWUpe3ZhciBjb25maWcgPSB7XG4gIGZpbGVuYW1lOiBfX2ZpbGVuYW1lLFxuICBzY3JpcHRzOiB7XG4gICAgY29ubmVjdGlvbkFsZXJ0OiByZXF1aXJlKCcuL2Nvbm5lY3Rpb25BbGVydCcpXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgb3B0aW9ucykge1xuICBhcHAuY3JlYXRlTGlicmFyeShjb25maWcsIG9wdGlvbnMpO1xufTtcbn0pKFwiL3VpL2luZGV4LmpzXCIpIiwiZXhwb3J0cy5zZXR1cCA9IGZ1bmN0aW9uKGxpYnJhcnkpIHtcbiAgbGlicmFyeS52aWV3LmZuKCdzZW50ZW5jZUNhc2UnLCBmdW5jdGlvbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgJiYgKHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnNsaWNlKDEpKTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICBtb2RlbC5zZXQoJ2hpZGVSZWNvbm5lY3QnLCB0cnVlKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBtb2RlbC5zZXQoJ2hpZGVSZWNvbm5lY3QnLCBmYWxzZSk7XG4gIH0sIDEwMDApO1xuICBtb2RlbC5yZWNvbm5lY3QoKTtcbn07XG5cbmV4cG9ydHMucmVsb2FkID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbn07IiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJyk7XG52YXIgY29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3Jyk7XG52YXIgdmlld01vZGVsID0gcmVxdWlyZSgnLi92aWV3TW9kZWwnKTtcbnZhciBpc1NlcnZlciA9IHJhY2VyLnV0aWwuaXNTZXJ2ZXI7XG52YXIgcGF0aHMgPSByZXF1aXJlKCcuL3BhdGhzJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlQXBwO1xuXG5mdW5jdGlvbiBjcmVhdGVBcHAoZGVyYnksIGFwcE1vZHVsZSkge1xuICB2YXIgYXBwID0gcmFjZXIudXRpbC5tZXJnZUludG8oYXBwTW9kdWxlLmV4cG9ydHMsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbiAgYXBwLnVzZSA9IHJhY2VyLnV0aWwudXNlO1xuICBjb21wb25lbnQoYXBwKTtcbiAgYXBwLmZpbGVuYW1lID0gYXBwTW9kdWxlLmZpbGVuYW1lO1xuICBhcHAudmlldyA9IG5ldyBWaWV3KGFwcC5fbGlicmFyaWVzLCBhcHAsIGFwcE1vZHVsZS5maWxlbmFtZSk7XG4gIGFwcC5mbiA9IGFwcEZuO1xuXG4gIGZ1bmN0aW9uIGFwcEZuKHZhbHVlLCBmbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBEb24ndCBiaW5kIHRoZSBmdW5jdGlvbiBvbiB0aGUgc2VydmVyLCBzaW5jZSBlYWNoXG4gICAgICAvLyByZW5kZXIgZ2V0cyBwYXNzZWQgYSBuZXcgbW9kZWwgYXMgcGFydCBvZiB0aGUgYXBwXG4gICAgICBwYXRocy5wYXRoTWVyZ2UoYXBwLCB2YWx1ZSwgZm4sIGJpbmRQYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMudHJlZU1lcmdlKGFwcCwgdmFsdWUsIGJpbmRQYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbiAgfVxuXG4gIGlmICghaXNTZXJ2ZXIpIHtcbiAgICB2YXIgYmluZFBhZ2UgPSBmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoYXBwLnBhZ2UsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBhcHAuX3ZpZXdNb2RlbHMgPSB7fTtcbiAgYXBwLnZpZXdNb2RlbCA9IHZpZXdNb2RlbC5jb25zdHJ1Y3QuYmluZChhcHApO1xuXG4gIHJldHVybiBhcHA7XG59XG4iLCIoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgcmFjZXIgPSByZXF1aXJlKCdyYWNlcicpXG4gICwgdHJhY2tzID0gcmVxdWlyZSgndHJhY2tzJylcbiAgLCBzaGFyZWRDcmVhdGVBcHAgPSByZXF1aXJlKCcuL2FwcCcpLmNyZWF0ZVxuICAsIGRlcmJ5TW9kZWwgPSByZXF1aXJlKCcuL2RlcmJ5Lk1vZGVsJylcbiAgLCBEb20gPSByZXF1aXJlKCcuL0RvbScpXG4gICwgdmlld01vZGVsID0gcmVxdWlyZSgnLi92aWV3TW9kZWwnKVxuICAsIHJlZnJlc2ggPSByZXF1aXJlKCcuL3JlZnJlc2gnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcmJ5QnJvd3NlcjtcblxuZnVuY3Rpb24gZGVyYnlCcm93c2VyKGRlcmJ5KSB7XG4gIC8vIFRoaXMgYXNzdW1lcyB0aGF0IG9ubHkgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhpcyBtb2R1bGUgY2FuIHJ1biBhdCBhIHRpbWUsXG4gIC8vIHdoaWNoIGlzIHJlYXNvbmFibGUgaW4gdGhlIGJyb3dzZXIuIFRoaXMgaXMgd3JpdHRlbiBsaWtlIHRoaXMgc28gdGhhdFxuICAvLyB0aGUgREVSQlkgZ2xvYmFsIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxpemUgdGVtcGxhdGVzIGFuZCBkYXRhLlxuICBnbG9iYWwuREVSQlkgPSBkZXJieTtcbiAgZGVyYnkuY3JlYXRlQXBwID0gY3JlYXRlQXBwO1xuICBkZXJieS5pbml0ID0gaW5pdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXBwKGFwcE1vZHVsZSkge1xuICBpZiAoZGVyYnlCcm93c2VyLmNyZWF0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcmJ5LmNyZWF0ZUFwcCgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgYnJvd3NlcicpO1xuICB9IGVsc2Uge1xuICAgIGRlcmJ5QnJvd3Nlci5jcmVhdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBhcHAgPSBzaGFyZWRDcmVhdGVBcHAodGhpcywgYXBwTW9kdWxlKVxuICBnbG9iYWwuREVSQlkuYXBwID0gYXBwO1xuXG4gIHJhY2VyLm9uY2UoJ21vZGVsJywgZnVuY3Rpb24obW9kZWwpIHtcbiAgICBhcHAuZW1pdCgnbW9kZWwnLCBtb2RlbCk7XG4gIH0pO1xuXG4gIC8vIEFkZHMgZ2V0LCBwb3N0LCBwdXQsIGRlbCwgZW50ZXIsIGFuZCBleGl0IG1ldGhvZHNcbiAgLy8gYXMgd2VsbCBhcyBoaXN0b3J5IHRvIGFwcFxuICB0cmFja3Muc2V0dXAoYXBwLCBjcmVhdGVQYWdlLCBvblJvdXRlKTtcblxuICBvblJlbmRlckVycm9yID0gZnVuY3Rpb24oZXJyLCB1cmwpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgd2luZG93LmxvY2F0aW9uID0gdXJsO1xuICAgIH0sIDApO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBhZ2UoYXBwKSB7XG4gICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgdGhpcy5tb2RlbCA9IGFwcC5tb2RlbDtcbiAgICB0aGlzLmRvbSA9IGFwcC5kb207XG4gICAgdGhpcy5oaXN0b3J5ID0gYXBwLmhpc3Rvcnk7XG4gICAgdGhpcy5fdmlld01vZGVscyA9IFtdO1xuICAgIHRoaXMuX3JvdXRpbmcgPSBmYWxzZTtcbiAgfVxuICBQYWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihucywgY3R4KSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGN0eCA9IG5zO1xuICAgICAgICBucyA9ICcnO1xuICAgICAgfVxuICAgICAgY3R4IHx8IChjdHggPSB7fSk7XG4gICAgICBjdHguJHVybCA9IHRoaXMucGFyYW1zLnVybDtcbiAgICAgIGFwcC52aWV3LnJlbmRlcih0aGlzLm1vZGVsLCBucywgY3R4KTtcbiAgICAgIHRoaXMuX3JvdXRpbmcgPSBmYWxzZTtcbiAgICAgIHRyYWNrcy5yZW5kZXIodGhpcywge1xuICAgICAgICB1cmw6IHRoaXMucGFyYW1zLnVybFxuICAgICAgLCBwcmV2aW91czogdGhpcy5wYXJhbXMucHJldmlvdXNcbiAgICAgICwgbWV0aG9kOiAnZW50ZXInXG4gICAgICAsIG5vTmF2aWdhdGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgb25SZW5kZXJFcnJvcihlcnIsIHRoaXMucGFyYW1zLnVybCk7XG4gICAgfVxuICB9O1xuICBQYWdlLnByb3RvdHlwZS5pbml0ID0gdmlld01vZGVsLnBhZ2VJbml0O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhZ2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlKGFwcCk7XG4gIH1cbiAgZnVuY3Rpb24gb25Sb3V0ZShjYWxsYmFjaywgcGFnZSwgcGFyYW1zLCBuZXh0LCBpc1RyYW5zaXRpb25hbCwgZG9uZSkge1xuICAgIGlmICghYXBwLl9pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaXNUcmFuc2l0aW9uYWwpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGNhbGxiYWNrKHBhZ2UubW9kZWwsIHBhcmFtcywgbmV4dCwgZG9uZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2socGFnZS5tb2RlbCwgcGFyYW1zLCBuZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdlbnRlcicgfHwgcGFyYW1zLm1ldGhvZCA9PT0gJ2V4aXQnKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwoYXBwLCBwYWdlLm1vZGVsLCBwYXJhbXMpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYWdlLl9yb3V0aW5nKSB7XG4gICAgICAgIHRyYWNrcy5yZW5kZXIocGFnZSwge1xuICAgICAgICAgIHVybDogcGFnZS5wYXJhbXMucHJldmlvdXNcbiAgICAgICAgLCBtZXRob2Q6ICdleGl0J1xuICAgICAgICAsIG5vTmF2aWdhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcC52aWV3Ll9iZWZvcmVSb3V0ZSgpO1xuICAgICAgfVxuICAgICAgcGFnZS5fcm91dGluZyA9IHRydWU7XG4gICAgICBjYWxsYmFjayhwYWdlLCBwYWdlLm1vZGVsLCBwYXJhbXMsIG5leHQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgb25SZW5kZXJFcnJvcihlcnIsIHBhZ2UucGFyYW1zLnVybCk7XG4gICAgfVxuICB9XG5cbiAgYXBwLnJlYWR5ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoYXBwLl9pbml0aWFsaXplZCkgcmV0dXJuIGZuLmNhbGwoYXBwLnBhZ2UsIGFwcC5tb2RlbCk7XG4gICAgYXBwLm9uY2UoJ3JlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICBmbi5jYWxsKGFwcC5wYWdlLCBhcHAubW9kZWwpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gYXBwO1xufVxuXG5mdW5jdGlvbiBpbml0KG1vZGVsQnVuZGxlLCBjdHgpIHtcbiAgdmFyIGFwcCA9IGdsb2JhbC5ERVJCWS5hcHBcbiAgICAsIG5zID0gY3R4LiRuc1xuICAgICwgcmVuZGVySGFzaCA9IGN0eC4kcmVuZGVySGFzaFxuICAgICwgZGVyYnkgPSB0aGlzXG5cbiAgLy8gVGhlIHJlYWR5IGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBtb2RlbCBkYXRhIGlzIGluaXRpYWxpemVkXG4gIHJhY2VyLnJlYWR5KGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgdmFyIGRvbSA9IG5ldyBEb20obW9kZWwpO1xuXG4gICAgYXBwLm1vZGVsID0gbW9kZWw7XG4gICAgYXBwLmRvbSA9IGRvbTtcblxuICAgIC8vIENhbGxpbmcgaGlzdG9yeS5wYWdlKCkgY3JlYXRlcyB0aGUgaW5pdGlhbCBwYWdlLCB3aGljaCBpcyBvbmx5XG4gICAgLy8gY3JlYXRlZCBvbmUgdGltZSBvbiB0aGUgY2xpZW50XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIHJhdGhlciBvYnR1c2UgbWVjaGFuaXNtXG4gICAgdmFyIHBhZ2UgPSBhcHAuaGlzdG9yeS5wYWdlKCk7XG4gICAgYXBwLnBhZ2UgPSBwYWdlO1xuICAgIHBhZ2UubW9kZWwgPSBtb2RlbDtcbiAgICBwYWdlLmRvbSA9IGRvbTtcblxuICAgIC8vIFJlaW5pdGlhbGl6ZSBhbnkgdmlld01vZGVscyB3aGljaCB3ZXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAvLyBkdXJpbmcgcmVuZGVyaW5nIG9uIHRoZSBzZXJ2ZXJcbiAgICBpZiAoY3R4LiR2aWV3TW9kZWxzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0eC4kdmlld01vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGN0eC4kdmlld01vZGVsc1tpXTtcbiAgICAgICAgdmFyIHZpZXdNb2RlbCA9IGFwcC5fdmlld01vZGVsc1tpdGVtWzBdXTtcbiAgICAgICAgaXRlbVsxXS51bnNoaWZ0KHBhZ2UpO1xuICAgICAgICB2aWV3TW9kZWwuaW5pdC5hcHBseSh2aWV3TW9kZWwsIGl0ZW1bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlcmJ5TW9kZWwuaW5pdChkZXJieSwgYXBwKTtcbiAgICAvLyBDYXRjaCBlcnJvcnMgdGhyb3duIHdoZW4gcmVuZGVyaW5nIGFuZCB0aGVuIHRocm93IGZyb20gYSBzZXRUaW1lb3V0LlxuICAgIC8vIFRoaXMgd2F5LCB0aGUgcmVtYWluaW5nIGluaXQgY29kZSBjYW4gcnVuIGFuZCB0aGUgYXBwIHN0aWxsIGNvbm5lY3RzXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlbmRlciBpbW1lZGlhdGVseSB1cG9uIGluaXRpYWxpemF0aW9uIHNvIHRoYXQgdGhlIHBhZ2UgaXMgaW5cbiAgICAgIC8vIEVYQUNUTFkgdGhlIHNhbWUgc3RhdGUgaXQgd2FzIHdoZW4gcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgICAgYXBwLnZpZXcucmVuZGVyKG1vZGVsLCBucywgY3R4LCByZW5kZXJIYXNoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBhcHAuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGFwcC5lbWl0KCdyZWFkeScpO1xuXG4gICAgdHJhY2tzLnJlbmRlcihhcHAuaGlzdG9yeS5wYWdlKCksIHtcbiAgICAgIHVybDogd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuICAgICwgbWV0aG9kOiAnZW50ZXInXG4gICAgLCBub05hdmlnYXRlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBEZWxheWluZyBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCByZWFkeSBjYWxsYmFja3MgYXJlIGNhbGxlZCBiZWZvcmVcbiAgICAvLyB0aGUgY3JlYXRlIGZ1bmN0aW9ucyBydW4gb24gdmFyaW91cyBjb21wb25lbnRzXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGFwcC52aWV3Ll9hZnRlclJlbmRlcihucywgY3R4KTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChjdHguJHNjcmlwdFBhdGgpIHtcbiAgICAgIG1vZGVsLmNoYW5uZWwuc2VuZCgnZGVyYnk6YXBwJywgY3R4LiRzY3JpcHRQYXRoKTtcbiAgICAgIHJlZnJlc2guYXV0b1JlZnJlc2goYXBwLnZpZXcsIG1vZGVsKTtcbiAgICB9XG4gIH0pO1xuICByYWNlci5pbml0KG1vZGVsQnVuZGxlKTtcbn1cblxufSkod2luZG93KSIsIihmdW5jdGlvbigpe3ZhciBFdmVudERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL0V2ZW50RGlzcGF0Y2hlcicpXG52YXIgUGF0aE1hcCA9IHJlcXVpcmUoJy4vUGF0aE1hcCcpXG52YXIgTW9kZWwgPSByZXF1aXJlKCdyYWNlcicpLk1vZGVsXG52YXIgdmFsdWVCaW5kaW5nID0gcmVxdWlyZSgnLi9WaWV3JykudmFsdWVCaW5kaW5nXG52YXIgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuXG4vLyBBZGQgc3VwcG9ydCBmb3IgY3JlYXRpbmcgYSBtb2RlbCBhbGlhcyBmcm9tIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IG9iamVjdFxuTW9kZWwucHJvdG90eXBlLl9fYXQgPSBNb2RlbC5wcm90b3R5cGUuYXQ7XG5Nb2RlbC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBpc05vZGUgPSBub2RlICYmIChub2RlLnBhcmVudE5vZGUgfHwgbm9kZS5qcXVlcnkgJiYgKG5vZGUgPSBub2RlWzBdKSk7XG4gIGlmICghaXNOb2RlKSByZXR1cm4gdGhpcy5fX2F0KG5vZGUpO1xuXG4gIHVwZGF0ZU1hcmtlcnMoKTtcblxuICB2YXIgYmxvY2tQYXRocyA9IHRoaXMucm9vdC5fX2Jsb2NrUGF0aHNcbiAgICAsIHBhdGhNYXAgPSB0aGlzLnJvb3QuX19wYXRoTWFwXG4gICAgLCBjaGlsZCwgaSwgaWQsIGxhc3QsIHBhdGgsIGJsb2NrUGF0aCwgY2hpbGRyZW4sIGxlbjtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS4kZGVyYnlNYXJrZXJQYXJlbnQgJiYgbGFzdCkge1xuICAgICAgbm9kZSA9IGxhc3Q7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGlmICghKGlkID0gbm9kZS4kZGVyYnlNYXJrZXJJZCkpIGNvbnRpbnVlO1xuICAgICAgICBibG9ja1BhdGggPSBibG9ja1BhdGhzW2lkXTtcbiAgICAgICAgaWYgKG5vZGUuJGRlcmJ5TWFya2VyRW5kIHx8ICFibG9ja1BhdGgpIGJyZWFrO1xuXG4gICAgICAgIHBhdGggPSBwYXRoTWFwLnBhdGhzW2Jsb2NrUGF0aC5pZF07XG4gICAgICAgIGlmICgoYmxvY2tQYXRoLnR5cGUgPT09ICdlYWNoJykgJiYgbGFzdCkge1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLicgKyBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG4gICAgICB9XG4gICAgICBsYXN0ID0gbGFzdC5wYXJlbnROb2RlO1xuICAgICAgbm9kZSA9IGxhc3QucGFyZW50Tm9kZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKGlkID0gbm9kZS5pZCkgJiYgKGJsb2NrUGF0aCA9IGJsb2NrUGF0aHNbaWRdKSkge1xuICAgICAgcGF0aCA9IHBhdGhNYXAucGF0aHNbYmxvY2tQYXRoLmlkXTtcbiAgICAgIGlmICgoYmxvY2tQYXRoLnR5cGUgPT09ICdlYWNoJykgJiYgbGFzdCkge1xuICAgICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gbGFzdCkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLicgKyBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbiAgICB9XG4gICAgbGFzdCA9IG5vZGU7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIC8vIEp1c3QgcmV0dXJuIHRoZSByb290IHNjb3BlIGlmIGEgcGF0aCBjYW4ndCBiZSBmb3VuZFxuICByZXR1cm4gdGhpcy5zY29wZSgpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXJrZXJzKCkge1xuICAvLyBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCA9PSAxMjhcbiAgdmFyIGNvbW1lbnRJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQuYm9keSwgMTI4LCBudWxsLCBmYWxzZSlcbiAgICAsIGNvbW1lbnQsIGlkO1xuICB3aGlsZSAoY29tbWVudCA9IGNvbW1lbnRJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgaWYgKGNvbW1lbnQuJGRlcmJ5Q2hlY2tlZCkgY29udGludWU7XG4gICAgY29tbWVudC4kZGVyYnlDaGVja2VkID0gdHJ1ZTtcbiAgICBpZCA9IGNvbW1lbnQuZGF0YTtcbiAgICBpZiAoaWQuY2hhckF0KDApICE9PSAnJCcpIGNvbnRpbnVlO1xuICAgIGlmIChpZC5jaGFyQXQoMSkgPT09ICckJykge1xuICAgICAgY29tbWVudC4kZGVyYnlNYXJrZXJFbmQgPSB0cnVlO1xuICAgICAgaWQgPSBpZC5zbGljZSgxKTtcbiAgICB9XG4gICAgY29tbWVudC4kZGVyYnlNYXJrZXJJZCA9IGlkO1xuICAgIGNvbW1lbnQucGFyZW50Tm9kZS4kZGVyYnlNYXJrZXJQYXJlbnQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXQoZGVyYnksIGFwcCkge1xuICB2YXIgbW9kZWwgPSBhcHAubW9kZWw7XG4gIHZhciBkb20gPSBhcHAuZG9tO1xuICB2YXIgcGF0aE1hcCA9IG1vZGVsLl9fcGF0aE1hcCA9IG5ldyBQYXRoTWFwO1xuICB2YXIgZXZlbnRzID0gbW9kZWwuX19ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICBvblRyaWdnZXI6IGRlcmJ5TW9kZWxUcmlnZ2VyXG4gICwgb25DbGVhbnVwOiBkZXJieU1vZGVsRXZlbnRzQ2xlYW51cFxuICB9KTtcblxuICBmdW5jdGlvbiBkZXJieU1vZGVsRXZlbnRzQ2xlYW51cChwYXRoSWQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkID0gbGlzdGVuZXJbMF07XG4gICAgcmV0dXJuICFkb20uaXRlbShpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXJieU1vZGVsVHJpZ2dlcihwYXRoSWQsIGxpc3RlbmVyLCB0eXBlLCBwYXNzLCB2YWx1ZSwgaW5kZXgsIGFyZykge1xuICAgIHZhciBpZCA9IGxpc3RlbmVyWzBdXG4gICAgICAsIGVsID0gZG9tLml0ZW0oaWQpO1xuXG4gICAgLy8gSWdub3JlIGlmIHRoZSBlbGVtZW50IGNhbid0IGJlIGZvdW5kLCBhbmQgY2xlYW51cCBhZnRlciBzb21lIGRlbGF5XG4gICAgaWYgKCFlbCkgcmV0dXJuIGV2ZW50cy5kZWxheWVkQ2xlYW51cChwYXRoSWQpO1xuXG4gICAgdmFyIG1ldGhvZCA9IGxpc3RlbmVyWzFdXG4gICAgICAsIHByb3BlcnR5ID0gbGlzdGVuZXJbMl1cbiAgICAgICwgcGFydGlhbCA9IGxpc3RlbmVyLnBhcnRpYWxcbiAgICAgICwgcGF0aCA9IHBhdGhNYXAucGF0aHNbcGF0aElkXVxuICAgICAgLCB0cmlnZ2VySWQ7XG5cbiAgICAvLyBIYW5kbGUgdGV4dCBPVCBldmVudHNcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcgfHwgdHlwZSA9PT0gJ3N0cmluZ1JlbW92ZScpIHtcbiAgICAgIGlmIChtZXRob2QgIT09ICdwcm9wT3QnIHx8IGVsID09PSBwYXNzLiRlbCkgcmV0dXJuO1xuICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICB9XG4gICAgLy8gSWdub3JlIHNpZGUtZWZmZWN0IGNoYW5nZSBldmVudHMgdGhhdCB3ZXJlIGFscmVhZHkgaGFuZGxlZFxuICAgIGlmIChtZXRob2QgPT09ICdwcm9wT3QnICYmIChwYXNzLiRvcmlnaW5hbCA9PT0gJ3N0cmluZ0luc2VydCcgfHwgcGFzcy4kb3JpZ2luYWwgPT09ICdzdHJpbmdSZW1vdmUnKSkgcmV0dXJuO1xuXG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIHRyaWdnZXJJZCA9IGlkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gJ2h0bWwnICYmIHR5cGUpIHtcbiAgICAgICAgaWYgKHBhcnRpYWwudHlwZSA9PT0gJ2VhY2gnKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGFycmF5IHVwZGF0ZXNcbiAgICAgICAgICBtZXRob2QgPSB0eXBlO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgdHJpZ2dlcklkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICBwYXJ0aWFsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgICAgICAgcGFydGlhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbW9kZWwuZ2V0KHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lci5nZXRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSBsaXN0ZW5lci5nZXRWYWx1ZShtb2RlbCwgcGF0aCk7XG4gICAgfVxuICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAvLyBUT0RPIEdldCByaWQgb2YgbW9kZWwuX19mbkN0eCBjYWNoZVxuICAgICAgLy8gV2FzIGNhdXNpbmcgaXNzdWVzIHdpdGggbm90IGVtaXR0aW5nIFwiaW5pdDpjaGlsZFwiIG9yIFwiY3JlYXRlOmNoaWxkXCJcbiAgICAgIC8vIHdoZW4gZHluYW1pY2FsbHkgcmVuZGVyaW5nIGEgY29tcG9uZW50IGluc2lkZSBhIHBhcmVudCBjb21wb25lbnRcbiAgICAgIC8vIHdpdGhpbiBhbiBlYWNoIGJsb2NrLlxuICAgICAgZGVsZXRlIG1vZGVsLl9fZm5DdHg7XG5cbiAgICAgIGlmIChtZXRob2QgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhbHVlICs9IHBhcnRpYWwobGlzdGVuZXIuY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZXNbaV0sIGluZGV4ICsgaSwgbGlzdGVuZXIpIHx8ICc8IS0tZW1wdHktLT4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnRpYWwobGlzdGVuZXIuY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZUJpbmRpbmcodmFsdWUpO1xuICAgIGRvbS51cGRhdGUoZWwsIG1ldGhvZCwgcGFzcy5pZ25vcmUsIHZhbHVlLCBwcm9wZXJ0eSwgaW5kZXgsIGFyZyk7XG4gICAgLy8gSEFDSzogVXNlIG9mIGdsb2JhbFxuICAgIERFUkJZLmFwcC52aWV3Ll9mbHVzaFVuY3JlYXRlZCgpO1xuICB9XG5cbiAgdmFyIHR5cGVzID0gT2JqZWN0LmtleXMoTW9kZWwuTVVUQVRPUl9FVkVOVFMpO1xuICB0eXBlcy5wdXNoKCdhbGwnKTtcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIGJlZm9yZVR5cGUgPSAnYmVmb3JlQmluZGluZzonICsgdHlwZTtcbiAgICBtb2RlbC5vbih0eXBlLCBmdW5jdGlvbihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgICBtb2RlbC5lbWl0KGJlZm9yZVR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICBtb2RlbC5vbignY2hhbmdlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkNoYW5nZShwYXRoLCB2YWx1ZSwgcHJldmlvdXMsIHBhc3MpIHtcbiAgICAvLyBGb3Igc2V0IG9wZXJhdGlvbnMgb24gYXJyYXkgaXRlbXMsIGFsc28gZW1pdCBhIHJlbW92ZSBhbmQgaW5zZXJ0IGluIGNhc2UgdGhlXG4gICAgLy8gYXJyYXkgaXMgYm91bmRcbiAgICBpZiAoL1xcLlxcZCskLy50ZXN0KHBhdGgpKSB7XG4gICAgICB2YXIgaSA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIHZhciBhcnJheVBhdGggPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgICAgdmFyIGluZGV4ID0gK3BhdGguc2xpY2UoaSArIDEpO1xuICAgICAgdHJpZ2dlckVhY2goYXJyYXlQYXRoLCAncmVtb3ZlJywgcGFzcywgaW5kZXgpO1xuICAgICAgdHJpZ2dlckVhY2goYXJyYXlQYXRoLCAnaW5zZXJ0JywgcGFzcywgW3ZhbHVlXSwgaW5kZXgpO1xuICAgIH1cbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaHRtbCcsIHBhc3MsIHZhbHVlKTtcbiAgfSk7XG5cbiAgbW9kZWwub24oJ2xvYWQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uTG9hZChwYXRoLCB2YWx1ZSwgcGFzcykge1xuICAgIHRyaWdnZXJFYWNoKHBhdGgsICdodG1sJywgcGFzcywgdmFsdWUpO1xuICB9KTtcblxuICBtb2RlbC5vbigndW5sb2FkJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbkxvYWQocGF0aCwgcHJldmlvdXMsIHBhc3MpIHtcbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaHRtbCcsIHBhc3MsIHZvaWQgMCk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdpbnNlcnQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uSW5zZXJ0KHBhdGgsIGluZGV4LCB2YWx1ZXMsIHBhc3MpIHtcbiAgICBwYXRoTWFwLm9uSW5zZXJ0KHBhdGgsIGluZGV4LCB2YWx1ZXMubGVuZ3RoKTtcbiAgICB0cmlnZ2VyRWFjaChwYXRoLCAnaW5zZXJ0JywgcGFzcywgdmFsdWVzLCBpbmRleCk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdyZW1vdmUnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uUmVtb3ZlKHBhdGgsIGluZGV4LCByZW1vdmVkLCBwYXNzKSB7XG4gICAgdmFyIGhvd01hbnkgPSByZW1vdmVkLmxlbmd0aDtcbiAgICB2YXIgZW5kID0gaW5kZXggKyBob3dNYW55O1xuICAgIHBhdGhNYXAub25SZW1vdmUocGF0aCwgaW5kZXgsIGhvd01hbnkpO1xuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHBhdGhNYXAuaWRzW3BhdGhdO1xuICAgICAgaWYgKGlkKSBldmVudHMudHJpZ2dlcihpZCwgJ3JlbW92ZScsIHBhc3MsIGluZGV4KTtcbiAgICB9XG4gICAgdHJpZ2dlclBhcmVudHMocGF0aCwgcGFzcyk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdtb3ZlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPbk1vdmUocGF0aCwgZnJvbSwgdG8sIGhvd01hbnksIHBhc3MpIHtcbiAgICBwYXRoTWFwLm9uTW92ZShwYXRoLCBmcm9tLCB0bywgaG93TWFueSk7XG4gICAgdHJpZ2dlckVhY2gocGF0aCwgJ21vdmUnLCBwYXNzLCBmcm9tLCB0bywgaG93TWFueSk7XG4gIH0pO1xuXG4gIG1vZGVsLm9uKCdzdHJpbmdJbnNlcnQnLCAnKionLCBmdW5jdGlvbiBkZXJieU9uU3RyaW5nSW5zZXJ0KHBhdGgsIGluZGV4LCBpbnNlcnRlZCwgcGFzcykge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKTtcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBldmVudHMudHJpZ2dlcihpZCwgJ3N0cmluZ0luc2VydCcsIHBhc3MsIHZhbHVlLCBpbmRleCwgaW5zZXJ0ZWQpO1xuICB9KTtcblxuICBtb2RlbC5vbignc3RyaW5nUmVtb3ZlJywgJyoqJywgZnVuY3Rpb24gZGVyYnlPblN0cmluZ1JlbW92ZShwYXRoLCBpbmRleCwgaG93TWFueSwgcGFzcykge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKTtcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBldmVudHMudHJpZ2dlcihpZCwgJ3N0cmluZ1JlbW92ZScsIHBhc3MsIHZhbHVlLCBpbmRleCwgaG93TWFueSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFYWNoKHBhdGgsIHR5cGUsIHBhc3MsIGFyZzAsIGFyZzEsIGFyZzIpIHtcbiAgICAvLyBUcmlnZ2VyIGFuIGV2ZW50IG9uIHRoZSBwYXRoIGlmIGl0IGhhcyBhIHBhdGhNYXAgSURcbiAgICB2YXIgaWQgPSBwYXRoTWFwLmlkc1twYXRoXTtcbiAgICBpZiAoaWQpIGV2ZW50cy50cmlnZ2VyKGlkLCB0eXBlLCBwYXNzLCBhcmcwLCBhcmcxLCBhcmcyKTtcbiAgICAvLyBUcmlnZ2VyIGEgcGF0dGVybiBldmVudCBmb3IgdGhlIHBhdGggYW5kIGVhY2ggb2YgaXRzIHBhcmVudCBwYXRoc1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSB2aWV3IGhlbHBlciBmdW5jdGlvbnMgdG8gbWF0Y2ggdXBkYXRlcyBvbiBhIHBhdGhcbiAgICAvLyBvciBhbnkgb2YgaXRzIGNoaWxkIHNlZ21lbnRzXG4gICAgdHJpZ2dlclBhcmVudHMocGF0aCwgcGFzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyUGFyZW50cyhwYXRoLCBwYXNzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gc2VnbWVudHMuc2xpY2UoMCwgaSkuam9pbignLicpICsgJyonO1xuICAgICAgdmFyIGlkID0gcGF0aE1hcC5pZHNbcGF0dGVybl07XG4gICAgICBpZiAoaWQpIGV2ZW50cy50cmlnZ2VyKGlkLCBudWxsLCBwYXNzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW9kZWw7XG59XG5cbn0pKCkiLCJ2YXIgcGF0aHMgPSByZXF1aXJlKCcuL3BhdGhzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFxufTtcblxuZnVuY3Rpb24gVmlld01vZGVsKG5hbWUsIHByb3RvKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMucHJvdG8gPSBwcm90bztcbn1cblZpZXdNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAvLyBWaWV3TW9kZWxzIGFyZSBhY3R1YWxseSBqdXN0IHNjb3BlZCBtb2RlbHMgZm9yIG5vd1xuICB2YXIgX3N1cGVyID0gcGFnZS5tb2RlbC5hdCh0aGlzLm5hbWUpO1xuICB2YXIgdmlld01vZGVsID0gX3N1cGVyLl9jaGlsZCgpO1xuXG4gIC8vIE1peGluIHZpZXdNb2RlbCBzcGVjaWZpYyBtZXRob2RzXG4gIHZpZXdNb2RlbC5fc3VwZXIgPSBfc3VwZXI7XG4gIHZpZXdNb2RlbC5wYWdlID0gcGFnZTtcbiAgdmlld01vZGVsLm1vZGVsID0gcGFnZS5tb2RlbDtcbiAgZm9yIChrZXkgaW4gdGhpcy5wcm90bykge1xuICAgIGlmIChrZXkgPT09ICdpbml0JykgY29udGludWU7XG4gICAgdmlld01vZGVsW2tleV0gPSB0aGlzLnByb3RvW2tleV0uYmluZCh2aWV3TW9kZWwpO1xuICB9XG4gIGlmICh0aGlzLnByb3RvLmluaXQpIHtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHZpZXdNb2RlbHMgdGhhdCB3ZXJlIGNyZWF0ZWQgc28gdGhhdFxuICAgIC8vIHRoZXkgY2FuIGJlIHJlY3JlYXRlZCBvbiB0aGUgY2xpZW50IGlmIGZpcnN0IHJlbmRlcmVkXG4gICAgLy8gb24gdGhlIHNlcnZlclxuICAgIHBhZ2UuX3ZpZXdNb2RlbHMucHVzaChbdGhpcy5uYW1lLCBhcmdzXSk7XG4gICAgdGhpcy5wcm90by5pbml0LmFwcGx5KHZpZXdNb2RlbCwgYXJncyk7XG4gIH1cblxuICAvLyBNYWtlIHZpZXdNb2RlbCBhdmFpbGFibGUgb24gdGhlIHBhZ2UgZm9yIHVzZSBpblxuICAvLyBldmVudCBjYWxsYmFja3MgYW5kIG90aGVyIGZ1bmN0aW9uc1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgdmFyIGxhc3QgPSBzZWdtZW50cy5wb3AoKTtcbiAgdmFyIG5vZGUgPSBwYXRocy50cmF2ZXJzZU5vZGUocGFnZSwgc2VnbWVudHMpO1xuICBub2RlW2xhc3RdID0gdmlld01vZGVsO1xuXG4gIHJldHVybiB2aWV3TW9kZWw7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdChuYW1lLCBwcm90bykge1xuICAvLyBLZWVwIGEgbWFwIG9mIGRlZmluZWQgdmlld01vZGVscyBzbyB0aGF0IHRoZXkgY2FuXG4gIC8vIGJlIHJlaW5pdGlhbGl6ZWQgZnJvbSB0aGVpciBuYW1lIG9uIHRoZSBjbGllbnRcbiAgdmFyIHZpZXdNb2RlbCA9IHRoaXMuX3ZpZXdNb2RlbHNbbmFtZV0gPSBuZXcgVmlld01vZGVsKG5hbWUsIHByb3RvKTtcbiAgcmV0dXJuIHZpZXdNb2RlbDtcbn1cbiIsIihmdW5jdGlvbihfX2Rpcm5hbWUpe21vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8vIEV4dGVuZCBtb2RlbCBvbiBib3RoIHNlcnZlciBhbmQgY2xpZW50IC8vXG5yZXF1aXJlKCcuL2V2ZW50cycpO1xucmVxdWlyZSgnLi9wYXRocycpO1xucmVxdWlyZSgnLi9jb2xsZWN0aW9ucycpO1xucmVxdWlyZSgnLi9tdXRhdG9ycycpO1xucmVxdWlyZSgnLi9zZXREaWZmJyk7XG5cbnJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xucmVxdWlyZSgnLi9zdWJzY3JpcHRpb25zJyk7XG5yZXF1aXJlKCcuL1F1ZXJ5Jyk7XG5yZXF1aXJlKCcuL2NvbnRleHRzJyk7XG5cbnJlcXVpcmUoJy4vZm4nKTtcbnJlcXVpcmUoJy4vZmlsdGVyJyk7XG5yZXF1aXJlKCcuL3JlZkxpc3QnKTtcbnJlcXVpcmUoJy4vcmVmJyk7XG5cbi8vIEV4dGVuZCBtb2RlbCBmb3Igc2VydmVyIC8vXG51dGlsLnNlcnZlclJlcXVpcmUoX19kaXJuYW1lICsgJy9idW5kbGUnKTtcbnV0aWwuc2VydmVyUmVxdWlyZShfX2Rpcm5hbWUgKyAnL2Nvbm5lY3Rpb24uc2VydmVyJyk7XG5cbn0pKFwiL25vZGVfbW9kdWxlcy9kZXJieS9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsXCIpIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRyYXZlcnNlTm9kZTogdHJhdmVyc2VOb2RlXG4sIHBhdGhNZXJnZTogcGF0aE1lcmdlXG4sIHRyZWVNZXJnZTogdHJlZU1lcmdlXG59O1xuXG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgc2VnbWVudHMpIHtcbiAgdmFyIGksIGxlbiwgc2VnbWVudFxuICBmb3IgKGkgPSAwLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBub2RlID0gbm9kZVtzZWdtZW50XSB8fCAobm9kZVtzZWdtZW50XSA9IHt9KTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgc2V0IG5lc3RlZCBvYmplY3RzIGJhc2VkIG9uIGEgcGF0aFxuZnVuY3Rpb24gcGF0aE1lcmdlKG5vZGUsIHBhdGgsIHZhbHVlLCBub2RlRm4pIHtcbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpXG4gICAgLCBsYXN0LCBpLCBsZW4sIHNlZ21lbnRcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBub2RlID0gdHJhdmVyc2VOb2RlKG5vZGUsIHNlZ21lbnRzKTtcbiAgICB0cmVlTWVyZ2Uobm9kZSwgdmFsdWUsIG5vZGVGbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxhc3QgPSBzZWdtZW50cy5wb3AoKTtcbiAgbm9kZSA9IHRyYXZlcnNlTm9kZShub2RlLCBzZWdtZW50cyk7XG4gIG5vZGVbbGFzdF0gPSAobm9kZUZuKSA/IG5vZGVGbih2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgc2V0IG9iamVjdHMgc3VjaCB0aGF0IHRoZSBub24tb2JqZWN0cyBhcmVcbi8vIG1lcmdlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHN0cnVjdHVyZSBvZiB0aGUgYmFzZSBub2RlXG5mdW5jdGlvbiB0cmVlTWVyZ2Uobm9kZSwgdHJlZSwgbm9kZUZuKSB7XG4gIHZhciBrZXksIGNoaWxkLCB2YWx1ZVxuICBmb3IgKGtleSBpbiB0cmVlKSB7XG4gICAgdmFsdWUgPSB0cmVlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNoaWxkID0gbm9kZVtrZXldIHx8IChub2RlW2tleV0gPSB7fSk7XG4gICAgICB0cmVlTWVyZ2UoY2hpbGQsIHZhbHVlLCBub2RlRm4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5vZGVba2V5XSA9IChub2RlRm4pID8gbm9kZUZuKHZhbHVlKSA6IHZhbHVlO1xuICB9XG59XG4iLCJmdW5jdGlvbiBlbXB0eSgpIHt9XG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXJOYW1lcygpIHt9XG5mdW5jdGlvbiBFdmVudERpc3BhdGNoZXJMaXN0ZW5lcnMoKSB7fVxuZnVuY3Rpb24gQ2xlYW51cFBlbmRpbmdNYXAoKSB7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGlzcGF0Y2hlcjtcblxuZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKG9wdGlvbnMpIHtcbiAgdGhpcy5fb25UcmlnZ2VyID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uVHJpZ2dlciB8fCBlbXB0eTtcbiAgdGhpcy5fb25CaW5kID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uQmluZCB8fCBlbXB0eTtcbiAgdGhpcy5fb25DbGVhbnVwID0gb3B0aW9ucyAmJiBvcHRpb25zLm9uQ2xlYW51cDtcbiAgdGhpcy5fY2xlYW51cFBlbmRpbmcgPSBuZXcgQ2xlYW51cFBlbmRpbmdNYXAoKTtcbiAgdGhpcy5jbGVhcigpO1xufVxuXG5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubmFtZXMgPSBuZXcgRXZlbnREaXNwYXRjaGVyTmFtZXMoKTtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyLCBhcmcwKSB7XG4gIHRoaXMuX29uQmluZChuYW1lLCBsaXN0ZW5lciwgYXJnMCk7XG4gIHZhciBvYmogPSB0aGlzLm5hbWVzW25hbWVdIHx8ICh0aGlzLm5hbWVzW25hbWVdID0gbmV3IEV2ZW50RGlzcGF0Y2hlckxpc3RlbmVycygpKTtcbiAgb2JqW0pTT04uc3RyaW5naWZ5KGxpc3RlbmVyKV0gPSBsaXN0ZW5lcjtcbiAgcmV0dXJuIG9iajtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGlmICghbmFtZSkgcmV0dXJuO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgdmFyIG9uVHJpZ2dlciA9IHRoaXMuX29uVHJpZ2dlcjtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGtleSwgbGlzdGVuZXI7XG4gIGZvciAoa2V5IGluIGxpc3RlbmVycykge1xuICAgIGxpc3RlbmVyID0gbGlzdGVuZXJzW2tleV07XG4gICAgY291bnQrKztcbiAgICBpZiAoZmFsc2UgIT09IG9uVHJpZ2dlcihuYW1lLCBsaXN0ZW5lciwgdmFsdWUsIGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGVsZXRlIGxpc3RlbmVyc1trZXldO1xuICAgIGNvdW50LS07XG4gIH1cbiAgaWYgKCFjb3VudCkgZGVsZXRlIHRoaXMubmFtZXNbbmFtZV07XG4gIHJldHVybiBjb3VudDtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGVsYXllZENsZWFudXAgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0aGlzLl9jbGVhbnVwUGVuZGluZ1tuYW1lXSkgcmV0dXJuO1xuICB0aGlzLl9jbGVhbnVwUGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gIHZhciBldmVudERpc3BhdGNoZXIgPSB0aGlzO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSBldmVudERpc3BhdGNoZXIuX2NsZWFudXBQZW5kaW5nW25hbWVdO1xuICAgIGV2ZW50RGlzcGF0Y2hlci5jbGVhbnVwKG5hbWUpO1xuICB9LCAwKTtcbn07XG5cbkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubmFtZXNbbmFtZV07XG4gIHZhciBoYXNLZXlzID0gZmFsc2U7XG4gIHZhciBrZXksIHJlbW92ZTtcbiAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgcmVtb3ZlID0gdGhpcy5fb25DbGVhbnVwKG5hbWUsIGxpc3RlbmVyc1trZXldKTtcbiAgICBpZiAocmVtb3ZlKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc0tleXMpIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUGF0aE1hcDtcblxuZnVuY3Rpb24gUGF0aE1hcCgpIHtcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblxuUGF0aE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pZHMgPSB7fTtcbiAgdGhpcy5wYXRocyA9IHt9O1xuICB0aGlzLmFycmF5cyA9IHt9O1xufTtcblxuUGF0aE1hcC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vIFJldHVybiB0aGUgcGF0aCBmb3IgYW4gaWQsIG9yIGNyZWF0ZSBhIG5ldyBpZCBhbmQgaW5kZXggaXRcbiAgdmFyIGlkID0gdGhpcy5pZHNbcGF0aF07XG4gIGlmIChpZCkgcmV0dXJuIGlkO1xuICBpZCA9ICgrK3RoaXMuY291bnQpLnRvU3RyaW5nKCk7XG4gIHRoaXMucGF0aHNbaWRdID0gcGF0aDtcbiAgdGhpcy5faW5kZXhBcnJheShwYXRoLCBpZCk7XG4gIHRoaXMuaWRzW3BhdGhdID0gaWQ7XG4gIHJldHVybiBpZDtcbn07XG5cblBhdGhNYXAucHJvdG90eXBlLl9pbmRleEFycmF5ID0gZnVuY3Rpb24ocGF0aCwgaWQpIHtcbiAgdmFyIGFyciwgaW5kZXgsIG1hdGNoLCBuZXN0ZWQsIHJlbWFpbmRlciwgc2V0LCBzZXRBcnJheXM7XG4gIHdoaWxlIChtYXRjaCA9IC9eKC4rKVxcLihcXGQrKShcXCo/KD86XFwuLit8JCkpLy5leGVjKHBhdGgpKSB7XG4gICAgcGF0aCA9IG1hdGNoWzFdO1xuICAgIGluZGV4ID0gK21hdGNoWzJdO1xuICAgIHJlbWFpbmRlciA9IG1hdGNoWzNdO1xuICAgIGFyciA9IHRoaXMuYXJyYXlzW3BhdGhdIHx8ICh0aGlzLmFycmF5c1twYXRoXSA9IFtdKTtcbiAgICBzZXQgPSBhcnJbaW5kZXhdIHx8IChhcnJbaW5kZXhdID0ge30pO1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIHNldEFycmF5cyA9IHNldC5hcnJheXMgfHwgKHNldC5hcnJheXMgPSB7fSk7XG4gICAgICBzZXRBcnJheXNbcmVtYWluZGVyXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFtpZF0gPSByZW1haW5kZXI7XG4gICAgfVxuICAgIG5lc3RlZCA9IHRydWU7XG4gIH1cbn07XG5cblBhdGhNYXAucHJvdG90eXBlLl9pbmNySXRlbXMgPSBmdW5jdGlvbihwYXRoLCBtYXAsIHN0YXJ0LCBlbmQsIGJ5TnVtLCBvbGRBcnJheXMsIG9sZFBhdGgpIHtcbiAgdmFyIGFycmF5TWFwLCBhcnJheVBhdGgsIGFycmF5UGF0aFRvLCBpLCBpZCwgaWRzLCBpdGVtUGF0aCwgcmVtYWluZGVyO1xuICBpZiAob2xkQXJyYXlzID09IG51bGwpIG9sZEFycmF5cyA9IHt9O1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZHMgPSBtYXBbaV07XG4gICAgaWYgKCFpZHMpIGNvbnRpbnVlO1xuXG4gICAgZm9yIChpZCBpbiBpZHMpIHtcbiAgICAgIHJlbWFpbmRlciA9IGlkc1tpZF07XG4gICAgICBpZiAoaWQgPT09ICdhcnJheXMnKSB7XG4gICAgICAgIGZvciAocmVtYWluZGVyIGluIGlkc1tpZF0pIHtcbiAgICAgICAgICBhcnJheVBhdGggPSAob2xkUGF0aCB8fCBwYXRoKSArICcuJyArIGkgKyByZW1haW5kZXI7XG4gICAgICAgICAgYXJyYXlNYXAgPSBvbGRBcnJheXNbYXJyYXlQYXRoXSB8fCB0aGlzLmFycmF5c1thcnJheVBhdGhdO1xuICAgICAgICAgIGlmIChhcnJheU1hcCkge1xuICAgICAgICAgICAgYXJyYXlQYXRoVG8gPSBwYXRoICsgJy4nICsgKGkgKyBieU51bSkgKyByZW1haW5kZXI7XG4gICAgICAgICAgICB0aGlzLmFycmF5c1thcnJheVBhdGhUb10gPSBhcnJheU1hcDtcbiAgICAgICAgICAgIHRoaXMuX2luY3JJdGVtcyhhcnJheVBhdGhUbywgYXJyYXlNYXAsIDAsIGFycmF5TWFwLmxlbmd0aCwgMCwgb2xkQXJyYXlzLCBhcnJheVBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbVBhdGggPSBwYXRoICsgJy4nICsgKGkgKyBieU51bSkgKyByZW1haW5kZXI7XG4gICAgICB0aGlzLnBhdGhzW2lkXSA9IGl0ZW1QYXRoO1xuICAgICAgdGhpcy5pZHNbaXRlbVBhdGhdID0gK2lkO1xuICAgIH1cbiAgfVxufTtcblxuUGF0aE1hcC5wcm90b3R5cGUuX2RlbEl0ZW1zID0gZnVuY3Rpb24ocGF0aCwgbWFwLCBzdGFydCwgZW5kLCBsZW4sIG9sZEFycmF5cykge1xuICB2YXIgYXJyYXlMZW4sIGFycmF5TWFwLCBhcnJheVBhdGgsIGksIGlkLCBpZHMsIGl0ZW1QYXRoLCByZW1haW5kZXI7XG4gIGlmIChvbGRBcnJheXMgPT0gbnVsbCkgb2xkQXJyYXlzID0ge307XG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgIGlkcyA9IG1hcFtpXTtcbiAgICBpZiAoIWlkcykgY29udGludWU7XG5cbiAgICBmb3IgKGlkIGluIGlkcykge1xuICAgICAgaWYgKGlkID09PSAnYXJyYXlzJykge1xuICAgICAgICBmb3IgKHJlbWFpbmRlciBpbiBpZHNbaWRdKSB7XG4gICAgICAgICAgYXJyYXlQYXRoID0gcGF0aCArICcuJyArIGkgKyByZW1haW5kZXI7XG4gICAgICAgICAgaWYgKGFycmF5TWFwID0gdGhpcy5hcnJheXNbYXJyYXlQYXRoXSkge1xuICAgICAgICAgICAgYXJyYXlMZW4gPSBhcnJheU1hcC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9kZWxJdGVtcyhhcnJheVBhdGgsIGFycmF5TWFwLCAwLCBhcnJheUxlbiwgYXJyYXlMZW4sIG9sZEFycmF5cyk7XG4gICAgICAgICAgICBvbGRBcnJheXNbYXJyYXlQYXRoXSA9IGFycmF5TWFwO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXJyYXlzW2FycmF5UGF0aF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtUGF0aCA9IHRoaXMucGF0aHNbaWRdO1xuICAgICAgZGVsZXRlIHRoaXMuaWRzW2l0ZW1QYXRoXTtcbiAgICAgIGlmIChpID4gZW5kKSBjb250aW51ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBhdGhzW2lkXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2xkQXJyYXlzO1xufTtcblxuUGF0aE1hcC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbihwYXRoLCBzdGFydCwgaG93TWFueSkge1xuICB2YXIgbWFwID0gdGhpcy5hcnJheXNbcGF0aF1cbiAgICAsIGVuZCwgbGVuLCBvbGRBcnJheXM7XG4gIGlmICghbWFwKSByZXR1cm47XG4gIGVuZCA9IHN0YXJ0ICsgaG93TWFueTtcbiAgbGVuID0gbWFwLmxlbmd0aDtcbiAgLy8gRGVsZXRlIGluZGljaWVzIGZvciByZW1vdmVkIGl0ZW1zXG4gIG9sZEFycmF5cyA9IHRoaXMuX2RlbEl0ZW1zKHBhdGgsIG1hcCwgc3RhcnQsIGVuZCArIDEsIGxlbik7XG4gIC8vIERlY3JlbWVudCBpbmRpY2llcyBvZiBsYXRlciBpdGVtc1xuICB0aGlzLl9pbmNySXRlbXMocGF0aCwgbWFwLCBlbmQsIGxlbiwgLWhvd01hbnksIG9sZEFycmF5cyk7XG4gIG1hcC5zcGxpY2Uoc3RhcnQsIGhvd01hbnkpO1xufTtcblxuUGF0aE1hcC5wcm90b3R5cGUub25JbnNlcnQgPSBmdW5jdGlvbihwYXRoLCBzdGFydCwgaG93TWFueSkge1xuICB2YXIgbWFwID0gdGhpcy5hcnJheXNbcGF0aF1cbiAgICAsIGVuZCwgbGVuLCBvbGRBcnJheXM7XG4gIGlmICghbWFwKSByZXR1cm47XG4gIGVuZCA9IHN0YXJ0ICsgaG93TWFueTtcbiAgbGVuID0gbWFwLmxlbmd0aDtcbiAgLy8gRGVsZXRlIGluZGljaWVzIGZvciBpdGVtcyBpbiBpbnNlcnRlZCBwb3NpdGlvbnNcbiAgb2xkQXJyYXlzID0gdGhpcy5fZGVsSXRlbXMocGF0aCwgbWFwLCBzdGFydCwgZW5kICsgMSwgbGVuKTtcbiAgLy8gSW5jcmVtZW50IGluZGljaWVzIG9mIGxhdGVyIGl0ZW1zXG4gIHRoaXMuX2luY3JJdGVtcyhwYXRoLCBtYXAsIHN0YXJ0LCBsZW4sIGhvd01hbnksIG9sZEFycmF5cyk7XG4gIHdoaWxlIChob3dNYW55LS0pIHtcbiAgICBtYXAuc3BsaWNlKHN0YXJ0LCAwLCB7fSk7XG4gIH1cbn07XG5cblBhdGhNYXAucHJvdG90eXBlLm9uTW92ZSA9IGZ1bmN0aW9uKHBhdGgsIGZyb20sIHRvLCBob3dNYW55KSB7XG4gIHZhciBtYXAgPSB0aGlzLmFycmF5c1twYXRoXVxuICAgICwgYWZ0ZXJGcm9tLCBhZnRlclRvLCBpdGVtcywgb2xkQXJyYXlzO1xuICBpZiAoIW1hcCkgcmV0dXJuO1xuICBhZnRlckZyb20gPSBmcm9tICsgaG93TWFueTtcbiAgYWZ0ZXJUbyA9IHRvICsgaG93TWFueTtcbiAgLy8gQWRqdXN0IHBhdGhzIGZvciBpdGVtcyBiZXR3ZWVuIGZyb20gYW5kIHRvXG4gIGlmIChmcm9tID4gdG8pIHtcbiAgICBvbGRBcnJheXMgPSB0aGlzLl9kZWxJdGVtcyhwYXRoLCBtYXAsIHRvLCBhZnRlckZyb20sIGFmdGVyRnJvbSk7XG4gICAgdGhpcy5faW5jckl0ZW1zKHBhdGgsIG1hcCwgdG8sIGZyb20sIGhvd01hbnksIG9sZEFycmF5cyk7XG4gIH0gZWxzZSB7XG4gICAgb2xkQXJyYXlzID0gdGhpcy5fZGVsSXRlbXMocGF0aCwgbWFwLCBmcm9tLCBhZnRlclRvLCBhZnRlclRvKTtcbiAgICB0aGlzLl9pbmNySXRlbXMocGF0aCwgbWFwLCBhZnRlckZyb20sIGFmdGVyVG8sIC1ob3dNYW55LCBvbGRBcnJheXMpO1xuICB9XG4gIC8vIEFkanVzdCBwYXRocyBmb3IgdGhlIG1vdmVkIGl0ZW0ocylcbiAgdGhpcy5faW5jckl0ZW1zKHBhdGgsIG1hcCwgZnJvbSwgYWZ0ZXJGcm9tLCB0byAtIGZyb20sIG9sZEFycmF5cyk7XG4gIC8vIEZpeCB0aGUgYXJyYXkgaW5kZXhcbiAgaXRlbXMgPSBtYXAuc3BsaWNlKGZyb20sIGhvd01hbnkpO1xuICBtYXAuc3BsaWNlLmFwcGx5KG1hcCwgW3RvLCAwXS5jb25jYXQoaXRlbXMpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgb25TdHJpbmdJbnNlcnQ6IG9uU3RyaW5nSW5zZXJ0XG4sIG9uU3RyaW5nUmVtb3ZlOiBvblN0cmluZ1JlbW92ZVxuLCBvblRleHRJbnB1dDogb25UZXh0SW5wdXRcbn07XG5cbmZ1bmN0aW9uIG9uU3RyaW5nSW5zZXJ0KGVsLCBwcmV2aW91cywgaW5kZXgsIHRleHQpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtQ3Vyc29yKGN1cnNvcikge1xuICAgIHJldHVybiAoaW5kZXggPCBjdXJzb3IpID8gY3Vyc29yICsgdGV4dC5sZW5ndGggOiBjdXJzb3I7XG4gIH1cbiAgdmFyIG5ld1RleHQgPSBwcmV2aW91cy5zbGljZSgwLCBpbmRleCkgKyB0ZXh0ICsgcHJldmlvdXMuc2xpY2UoaW5kZXgpO1xuICByZXBsYWNlVGV4dChlbCwgbmV3VGV4dCwgdHJhbnNmb3JtQ3Vyc29yKTtcbn1cblxuZnVuY3Rpb24gb25TdHJpbmdSZW1vdmUoZWwsIHByZXZpb3VzLCBpbmRleCwgaG93TWFueSkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1DdXJzb3IoY3Vyc29yKSB7XG4gICAgcmV0dXJuIChpbmRleCA8IGN1cnNvcikgPyBjdXJzb3IgLSBNYXRoLm1pbihob3dNYW55LCBjdXJzb3IgLSBpbmRleCkgOiBjdXJzb3I7XG4gIH1cbiAgdmFyIG5ld1RleHQgPSBwcmV2aW91cy5zbGljZSgwLCBpbmRleCkgKyBwcmV2aW91cy5zbGljZShpbmRleCArIGhvd01hbnkpO1xuICByZXBsYWNlVGV4dChlbCwgbmV3VGV4dCwgdHJhbnNmb3JtQ3Vyc29yKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRleHQoZWwsIG5ld1RleHQsIHRyYW5zZm9ybUN1cnNvcikge1xuICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0cmFuc2Zvcm1DdXJzb3IoZWwuc2VsZWN0aW9uU3RhcnQpO1xuICB2YXIgc2VsZWN0aW9uRW5kID0gdHJhbnNmb3JtQ3Vyc29yKGVsLnNlbGVjdGlvbkVuZCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGVsLnNjcm9sbFRvcDtcbiAgZWwudmFsdWUgPSBuZXdUZXh0O1xuICBpZiAoZWwuc2Nyb2xsVG9wICE9PSBzY3JvbGxUb3ApIHtcbiAgICBlbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gIH1cbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgZWwuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydDtcbiAgICBlbC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25UZXh0SW5wdXQobW9kZWwsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBwcmV2aW91cyA9IG1vZGVsLmdldChwYXRoKSB8fCAnJztcbiAgaWYgKHByZXZpb3VzID09PSB2YWx1ZSkgcmV0dXJuO1xuICB2YXIgc3RhcnQgPSAwO1xuICB3aGlsZSAocHJldmlvdXMuY2hhckF0KHN0YXJ0KSA9PSB2YWx1ZS5jaGFyQXQoc3RhcnQpKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB2YXIgZW5kID0gMDtcbiAgd2hpbGUgKFxuICAgIHByZXZpb3VzLmNoYXJBdChwcmV2aW91cy5sZW5ndGggLSAxIC0gZW5kKSA9PT0gdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEgLSBlbmQpICYmXG4gICAgZW5kICsgc3RhcnQgPCBwcmV2aW91cy5sZW5ndGggJiZcbiAgICBlbmQgKyBzdGFydCA8IHZhbHVlLmxlbmd0aFxuICApIHtcbiAgICBlbmQrKztcbiAgfVxuXG4gIGlmIChwcmV2aW91cy5sZW5ndGggIT09IHN0YXJ0ICsgZW5kKSB7XG4gICAgdmFyIGhvd01hbnkgPSBwcmV2aW91cy5sZW5ndGggLSBzdGFydCAtIGVuZDtcbiAgICBtb2RlbC5zdHJpbmdSZW1vdmUocGF0aCwgc3RhcnQsIGhvd01hbnkpO1xuICB9XG4gIGlmICh2YWx1ZS5sZW5ndGggIT09IHN0YXJ0ICsgZW5kKSB7XG4gICAgdmFyIGluc2VydGVkID0gdmFsdWUuc2xpY2Uoc3RhcnQsIHZhbHVlLmxlbmd0aCAtIGVuZCk7XG4gICAgbW9kZWwuc3RyaW5nSW5zZXJ0KHBhdGgsIHN0YXJ0LCBpbnNlcnRlZCk7XG4gIH1cbn1cbiIsIihmdW5jdGlvbihfX2ZpbGVuYW1lKXt2YXIgY29uZmlnID0ge1xuICBmaWxlbmFtZTogX19maWxlbmFtZSxcbiAgbnM6ICdnaGJ0bnMnLFxuICBzY3JpcHRzOiB7XG4gICAgYnV0dG9uOiByZXF1aXJlKCcuL2J1dHRvbicpXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXBwLCBvcHRpb25zKSB7XG4gIGFwcC5jcmVhdGVMaWJyYXJ5KGNvbmZpZywgb3B0aW9ucyk7XG59XG59KShcIi9ub2RlX21vZHVsZXMvZGVyYnktdWktZ2l0aHViLWJ1dHRvbnMvaW5kZXguanNcIikiLCJleHBvcnRzLmFwcCA9IHJlcXVpcmUoJy4vbGliL2FwcCcpO1xuZXhwb3J0cy5zZXJ2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZXJ2ZXInKTsiLCIoZnVuY3Rpb24ocHJvY2Vzcyl7ZnVuY3Rpb24gZmlsdGVyICh4cywgZm4pIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm4oeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBSZWdleCB0byBzcGxpdCBhIGZpbGVuYW1lIGludG8gWyosIGRpciwgYmFzZW5hbWUsIGV4dF1cbi8vIHBvc2l4IHZlcnNpb25cbnZhciBzcGxpdFBhdGhSZSA9IC9eKC4rXFwvKD8hJCl8XFwvKT8oKD86Lis/KT8oXFwuW14uXSopPykkLztcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG52YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG5mb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gIHZhciBwYXRoID0gKGkgPj0gMClcbiAgICAgID8gYXJndW1lbnRzW2ldXG4gICAgICA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgfHwgIXBhdGgpIHtcbiAgICBjb250aW51ZTtcbiAgfVxuXG4gIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4vLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuLy8gTm9ybWFsaXplIHRoZSBwYXRoXG5yZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG52YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLycsXG4gICAgdHJhaWxpbmdTbGFzaCA9IHBhdGguc2xpY2UoLTEpID09PSAnLyc7XG5cbi8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxucGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuICBcbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgcmV0dXJuIHAgJiYgdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBkaXIgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpWzFdIHx8ICcnO1xuICB2YXIgaXNXaW5kb3dzID0gZmFsc2U7XG4gIGlmICghZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZVxuICAgIHJldHVybiAnLic7XG4gIH0gZWxzZSBpZiAoZGlyLmxlbmd0aCA9PT0gMSB8fFxuICAgICAgKGlzV2luZG93cyAmJiBkaXIubGVuZ3RoIDw9IDMgJiYgZGlyLmNoYXJBdCgxKSA9PT0gJzonKSkge1xuICAgIC8vIEl0IGlzIGp1c3QgYSBzbGFzaCBvciBhIGRyaXZlIGxldHRlciB3aXRoIGEgc2xhc2hcbiAgICByZXR1cm4gZGlyO1xuICB9IGVsc2Uge1xuICAgIC8vIEl0IGlzIGEgZnVsbCBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIHJldHVybiBkaXIuc3Vic3RyaW5nKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoUmUuZXhlYyhwYXRoKVsyXSB8fCAnJztcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKHBhdGgpWzNdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgZGVlcElzID0gcmVxdWlyZSgnZGVlcC1pcycpO1xuXG52YXIgaXNTZXJ2ZXIgPSBwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3Nlcic7XG52YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU2VydmVyOiBpc1NlcnZlclxuLCBpc1Byb2R1Y3Rpb246IGlzUHJvZHVjdGlvblxuXG4sIGFzeW5jR3JvdXA6IGFzeW5jR3JvdXBcbiwgY29udGFpbnM6IGNvbnRhaW5zXG4sIGNvcHlPYmplY3Q6IGNvcHlPYmplY3RcbiwgZGVlcENvcHk6IGRlZXBDb3B5XG4sIGRlZXBFcXVhbDogZGVlcElzXG4sIGVxdWFsOiBlcXVhbFxuLCBlcXVhbHNOYU46IGVxdWFsc05hTlxuLCBsb29rdXA6IGxvb2t1cFxuLCBtZXJnZUludG86IG1lcmdlSW50b1xuLCBtYXlJbXBhY3Q6IG1heUltcGFjdFxuLCBtYXlJbXBhY3RBbnk6IG1heUltcGFjdEFueVxuLCBzZXJ2ZXJSZXF1aXJlOiBzZXJ2ZXJSZXF1aXJlXG4sIHVzZTogdXNlXG59O1xuXG5mdW5jdGlvbiBhc3luY0dyb3VwKGNiKSB7XG4gIHZhciBncm91cCA9IG5ldyBBc3luY0dyb3VwKGNiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jR3JvdXBBZGQoKSB7XG4gICAgcmV0dXJuIGdyb3VwLmFkZCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IoZXJyKVxuICovXG5mdW5jdGlvbiBBc3luY0dyb3VwKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Bc3luY0dyb3VwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb3VudCsrO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLmNvdW50LS07XG4gICAgaWYgKHNlbGYuaXNEb25lKSByZXR1cm47XG4gICAgaWYgKGVycikge1xuICAgICAgc2VsZi5pc0RvbmUgPSB0cnVlO1xuICAgICAgc2VsZi5jYihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5jb3VudCA+IDApIHJldHVybjtcbiAgICBzZWxmLmlzRG9uZSA9IHRydWU7XG4gICAgc2VsZi5jYigpO1xuICB9O1xufTtcblxuZnVuY3Rpb24gY29udGFpbnMoc2VnbWVudHMsIHRlc3RTZWdtZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNlZ21lbnRzW2ldICE9PSB0ZXN0U2VnbWVudHNbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29weU9iamVjdChvYmplY3QpIHtcbiAgdmFyIG91dCA9IG5ldyBvYmplY3QuY29uc3RydWN0b3I7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIG91dFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGRlZXBDb3B5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY29weTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvcHkgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB2YWx1ZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY29weVtpXSA9IGRlZXBDb3B5KHZhbHVlW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBjb3B5ID0gbmV3IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29weVtrZXldID0gZGVlcENvcHkodmFsdWVba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICByZXR1cm4gKGEgPT09IGIpIHx8IChlcXVhbHNOYU4oYSkgJiYgZXF1YWxzTmFOKGIpKTtcbn1cblxuZnVuY3Rpb24gZXF1YWxzTmFOKHgpIHtcbiAgcmV0dXJuIHggIT09IHg7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cChzZWdtZW50cywgdmFsdWUpIHtcbiAgaWYgKCFzZWdtZW50cykgcmV0dXJuIHZhbHVlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdmFsdWU7XG4gICAgdmFsdWUgPSB2YWx1ZVtzZWdtZW50c1tpXV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBtYXlJbXBhY3RBbnkoc2VnbWVudHNMaXN0LCB0ZXN0U2VnbWVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChtYXlJbXBhY3Qoc2VnbWVudHNMaXN0W2ldLCB0ZXN0U2VnbWVudHMpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1heUltcGFjdChzZWdtZW50cywgdGVzdFNlZ21lbnRzKSB7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihzZWdtZW50cy5sZW5ndGgsIHRlc3RTZWdtZW50cy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHNlZ21lbnRzW2ldICE9PSB0ZXN0U2VnbWVudHNbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbnRvKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG87XG59XG5cbmZ1bmN0aW9uIHNlcnZlclJlcXVpcmUobmFtZSkge1xuICBpZiAoIWlzU2VydmVyKSByZXR1cm47XG4gIC8vIFRyaWNrcyBCcm93c2VyaWZ5IGludG8gbm90IGxvZ2dpbmcgYSB3YXJuaW5nXG4gIHZhciBfcmVxdWlyZSA9IHJlcXVpcmU7XG4gIHJldHVybiBfcmVxdWlyZShuYW1lKTtcbn1cblxuZnVuY3Rpb24gdXNlKHBsdWdpbiwgb3B0aW9ucykge1xuICAvLyBTZXJ2ZXItc2lkZSBwbHVnaW5zIG1heSBiZSBpbmNsdWRlZCB2aWEgZmlsZW5hbWVcbiAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFpc1NlcnZlcikgcmV0dXJuIHRoaXM7XG4gICAgcGx1Z2luID0gc2VydmVyUmVxdWlyZShwbHVnaW4pO1xuICB9XG5cbiAgLy8gRG9uJ3QgaW5jbHVkZSBhIHBsdWdpbiBtb3JlIHRoYW4gb25jZVxuICB2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnMgfHwgKHRoaXMuX3BsdWdpbnMgPSBbXSk7XG4gIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICBwbHVnaW4odGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuICAsIHV0aWwgPSByZXF1aXJlKCdyYWNlcicpLnV0aWxcbiAgLCBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3JylcbiAgLCBhcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50UGx1Z2luO1xuXG5mdW5jdGlvbiBjb21wb25lbnRQbHVnaW4oYXBwKSB7XG4gIGFwcC5fbGlicmFyaWVzID0gW107XG4gIGFwcC5fbGlicmFyaWVzLm1hcCA9IHt9O1xuICBhcHAuY3JlYXRlTGlicmFyeSA9IGNyZWF0ZUxpYnJhcnk7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudFByb3RvKCkge31cbnV0aWwubWVyZ2VJbnRvKENvbXBvbmVudFByb3RvLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkNvbXBvbmVudFByb3RvLnByb3RvdHlwZS5lbWl0Q2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgLCBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cylcblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFyZ3MucHVzaChjYW5jZWwpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiBjYW5jZWxsZWQ7XG59O1xuXG5Db21wb25lbnRQcm90by5wcm90b3R5cGUuZW1pdERlbGF5YWJsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGVsYXllZCA9IGZhbHNlXG4gICAgLCBhcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpXG4gICAgLCBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV1cblxuICBmdW5jdGlvbiBkZWxheSgpIHtcbiAgICBkZWxheWVkID0gdHJ1ZTtcbiAgfVxuXG4gIGFyZ3MucHVzaChkZWxheSwgY2FsbGJhY2spO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIGlmICghZGVsYXllZCkgY2FsbGJhY2soKTtcbiAgcmV0dXJuIGRlbGF5ZWQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaWJyYXJ5KGNvbmZpZywgb3B0aW9ucykge1xuICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLmZpbGVuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yICgnQ29uZmlndXJhdGlvbiBhcmd1bWVudCB3aXRoIGEgZmlsZW5hbWUgaXMgcmVxdWlyZWQnKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIHJvb3QgPSBwYXRoLmRpcm5hbWUoY29uZmlnLmZpbGVuYW1lKTtcbiAgdmFyIG5zID0gb3B0aW9ucy5ucyB8fCBjb25maWcubnMgfHwgcGF0aC5iYXNlbmFtZShyb290KTtcbiAgdmFyIHNjcmlwdHMgPSBjb25maWcuc2NyaXB0cyB8fCB7fTtcbiAgdmFyIHZpZXcgPSBuZXcgVmlldztcbiAgdmFyIGNvbnN0cnVjdG9ycyA9IHt9O1xuICB2YXIgbGlicmFyeSA9IHtcbiAgICBuczogbnNcbiAgLCByb290OiByb290XG4gICwgdmlldzogdmlld1xuICAsIGNvbnN0cnVjdG9yczogY29uc3RydWN0b3JzXG4gICwgc3R5bGVzOiBjb25maWcuc3R5bGVzXG4gIH07XG5cbiAgdmlldy5wYXJlbnQgPSB0aGlzO1xuICB2aWV3Ll9zZWxmTnMgPSAnbGliJztcbiAgdmlldy5fc2VsZkxpYnJhcnkgPSBsaWJyYXJ5O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gc2NyaXB0cykge1xuICAgIHZhciBzY3JpcHQgPSBzY3JpcHRzW25hbWVdO1xuICAgIHNjcmlwdC5zZXR1cCAmJiBzY3JpcHQuc2V0dXAobGlicmFyeSk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24obW9kZWwsIHNjb3BlKSB7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgdGhpcy5oaXN0b3J5ID0gbnVsbDtcbiAgICAgIHRoaXMuZG9tID0gbnVsbDtcblxuICAgICAgLy8gRG9uJ3QgbGltaXQgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnNcbiAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gICAgICB2YXIgY29tcG9uZW50ID0gdGhpcztcbiAgICAgIG1vZGVsLl9fb24gPSBtb2RlbC5fb247XG4gICAgICBtb2RlbC5fb24gPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtb2RlbC5yZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBtb2RlbC5fX29uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH07XG4gICAgICBjb21wb25lbnQub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwuc2lsZW50KCkuZGVsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnRQcm90bygpO1xuICAgIHV0aWwubWVyZ2VJbnRvKHByb3RvLCBzY3JpcHQpO1xuXG4gICAgQ29tcG9uZW50LnZpZXcgPSB2aWV3O1xuICAgIENvbXBvbmVudC5ucyA9IENvbXBvbmVudC5wcm90b3R5cGUubnMgPSBucztcbiAgICBDb21wb25lbnQubmFtZSA9IENvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG5cbiAgICAvLyBOb3RlIHRoYXQgY29tcG9uZW50IG5hbWVzIGFyZSBhbGwgbG93ZXJjYXNlZFxuICAgIGNvbnN0cnVjdG9yc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gQ29tcG9uZW50O1xuICB9XG5cbiAgdmFyIHJlcGxhY2VkID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9saWJyYXJpZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgaWYgKHRoaXMuX2xpYnJhcmllc1tpXS5ucyA9PT0gbnMpIHtcbiAgICAgIHRoaXMuX2xpYnJhcmllc1tpXSA9IGxpYnJhcnk7XG4gICAgICByZXBsYWNlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmICghcmVwbGFjZWQpIHtcbiAgICB0aGlzLl9saWJyYXJpZXMucHVzaChsaWJyYXJ5KTtcbiAgfVxuICB0aGlzLl9saWJyYXJpZXMubWFwW25zXSA9IGxpYnJhcnk7XG4gIHJldHVybiBsaWJyYXJ5O1xufVxuIiwidmFyIFJvdXRlID0gcmVxdWlyZSgnLi4vdmVuZG9yL2V4cHJlc3Mvcm91dGVyL3JvdXRlJylcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5JylcbnZhciByb3V0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcm91dGVyJylcbnZhciBjb21wb3NlID0gcmVxdWlyZSgnLi9jb21wb3NlJylcblxucm91dGVyLnNldHVwID0gc2V0dXBcblxuZnVuY3Rpb24gc2V0dXAoYXBwLCBjcmVhdGVQYWdlLCBvblJvdXRlKSB7XG4gIHZhciByb3V0ZXMgPSB7XG4gICAgcXVldWU6IHt9XG4gICwgdHJhbnNpdGlvbmFsOiB7fVxuICAsIG9uUm91dGU6IG9uUm91dGVcbiAgfVxuICBhcHAuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcylcblxuICA7WydnZXQnLCAncG9zdCcsICdwdXQnLCAnZGVsJywgJ2VudGVyJywgJ2V4aXQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHZhciBxdWV1ZSA9IHJvdXRlcy5xdWV1ZVttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gcm91dGVzLnRyYW5zaXRpb25hbFttZXRob2RdID0gW11cbiAgICB2YXIgdHJhbnNpdGlvbmFsQ2FsbHMgPSBbXVxuXG4gICAgYXBwW21ldGhvZF0gPSBmdW5jdGlvbihwYXR0ZXJuLCBjYWxsYmFjaykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgICAgcGF0dGVybi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBhcHBbbWV0aG9kXShpdGVtLCBjYWxsYmFjaylcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGFwcFxuICAgICAgfVxuXG4gICAgICBpZiAocm91dGVyLmlzVHJhbnNpdGlvbmFsKHBhdHRlcm4pKSB7XG4gICAgICAgIHZhciBmcm9tID0gcGF0dGVybi5mcm9tXG4gICAgICAgIHZhciB0byA9IHBhdHRlcm4udG9cbiAgICAgICAgdmFyIGZvcndhcmQgPSBwYXR0ZXJuLmZvcndhcmQgfHwgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmZvcndhcmQpIHx8IGNhbGxiYWNrXG4gICAgICAgIHZhciBiYWNrID0gcGF0dGVybi5iYWNrIHx8IChjYWxsYmFjayAmJiBjYWxsYmFjay5iYWNrKVxuICAgICAgICB0cmFuc2l0aW9uYWxDYWxscy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBmcm9tXG4gICAgICAgICwgdG86IHRvXG4gICAgICAgICwgZm9yd2FyZDogZm9yd2FyZFxuICAgICAgICAsIGJhY2s6IGJhY2tcbiAgICAgICAgfSlcblxuICAgICAgICB2YXIgZnJvbVJvdXRlID0gbmV3IFJvdXRlKG1ldGhvZCwgZnJvbSwgYmFjaylcbiAgICAgICAgdmFyIHRvUm91dGUgPSBuZXcgUm91dGUobWV0aG9kLCB0bywgZm9yd2FyZClcbiAgICAgICAgZnJvbVJvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0b1JvdXRlLmlzVHJhbnNpdGlvbmFsID0gdHJ1ZVxuICAgICAgICB0cmFuc2l0aW9uYWwucHVzaCh7XG4gICAgICAgICAgZnJvbTogZnJvbVJvdXRlXG4gICAgICAgICwgdG86IHRvUm91dGVcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGJhY2spIHRyYW5zaXRpb25hbC5wdXNoKHtcbiAgICAgICAgICBmcm9tOiB0b1JvdXRlXG4gICAgICAgICwgdG86IGZyb21Sb3V0ZVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbXBvc2UudHJhbnNpdGlvbihhcHBbbWV0aG9kXSwgdHJhbnNpdGlvbmFsQ2FsbHMsIGZyb20sIHRvLCBmb3J3YXJkLCBiYWNrKVxuICAgICAgICByZXR1cm4gYXBwXG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnB1c2gobmV3IFJvdXRlKG1ldGhvZCwgcGF0dGVybiwgY2FsbGJhY2spKVxuICAgICAgcmV0dXJuIGFwcFxuICAgIH1cbiAgfSlcbn1cbiIsInZhciByYWNlciA9IHJlcXVpcmUoJ3JhY2VyJylcbiAgLCBkb21TaGltID0gcmVxdWlyZSgnZG9tLXNoaW0nKVxuICAsIEV2ZW50RGlzcGF0Y2hlciA9IHJlcXVpcmUoJy4vRXZlbnREaXNwYXRjaGVyJylcbiAgLCB2aWV3UGF0aCA9IHJlcXVpcmUoJy4vdmlld1BhdGgnKVxuICAsIGVzY2FwZUh0bWwgPSByZXF1aXJlKCdodG1sLXV0aWwnKS5lc2NhcGVIdG1sXG4gICwgdGV4dE90ID0gcmVxdWlyZSgnLi90ZXh0T3QnKVxuICAsIG1lcmdlID0gcmFjZXIudXRpbC5tZXJnZVxuICAsIG1hcmtlcnMgPSB7fVxuICAsIG1hcmtlcnNEaXJ0eSA9IHRydWVcbiAgLCBnbG9iYWxFbGVtZW50cyA9IHtcbiAgICAgICRfd2luOiB3aW5kb3dcbiAgICAsICRfZG9jOiBkb2N1bWVudFxuICAgIH1cbiAgLCBhZGRMaXN0ZW5lciwgcmVtb3ZlTGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9tO1xuXG5mdW5jdGlvbiBEb20obW9kZWwpIHtcbiAgdmFyIGRvbSA9IHRoaXNcbiAgdmFyIGZucyA9IHRoaXMuZm5zXG5cbiAgLy8gTWFwIGRvbSBldmVudCBuYW1lIC0+IHRydWVcbiAgdmFyIGxpc3RlbmVyQWRkZWQgPSB7fTtcbiAgdmFyIGNhcHR1cmVMaXN0ZW5lckFkZGVkID0ge31cblxuICAvLyBET00gbGlzdGVuZXIgY2FwdHVyaW5nIGFsbG93cyBibHVyIGFuZCBmb2N1cyB0byBiZSBkZWxlZ2F0ZWRcbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICB2YXIgY2FwdHVyZUV2ZW50cyA9IHRoaXMuX2NhcHR1cmVFdmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHtcbiAgICBvblRyaWdnZXI6IG9uQ2FwdHVyZVRyaWdnZXJcbiAgLCBvbkJpbmQ6IG9uQ2FwdHVyZUJpbmRcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uQ2FwdHVyZVRyaWdnZXIobmFtZSwgbGlzdGVuZXIsIGUpIHtcbiAgICB2YXIgaWQgPSBsaXN0ZW5lci5pZFxuICAgICAgLCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgIC8vIFJlbW92ZSBsaXN0ZW5lciBpZiBlbGVtZW50IGlzbid0IGZvdW5kXG4gICAgaWYgKCFlbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGVsLnRhZ05hbWUgPT09ICdIVE1MJyB8fCBlbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIG9uRG9tVHJpZ2dlcihuYW1lLCBsaXN0ZW5lciwgaWQsIGUsIGVsKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25DYXB0dXJlQmluZChuYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChjYXB0dXJlTGlzdGVuZXJBZGRlZFtuYW1lXSkgcmV0dXJuO1xuICAgIGFkZExpc3RlbmVyKGRvY3VtZW50LCBuYW1lLCBjYXB0dXJlVHJpZ2dlciwgdHJ1ZSk7XG4gICAgY2FwdHVyZUxpc3RlbmVyQWRkZWRbbmFtZV0gPSB0cnVlO1xuICB9XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIoe1xuICAgIG9uVHJpZ2dlcjogb25Eb21UcmlnZ2VyXG4gICwgb25CaW5kOiBvbkRvbUJpbmRcbiAgfSk7XG4gIGZ1bmN0aW9uIG9uRG9tVHJpZ2dlcihuYW1lLCBsaXN0ZW5lciwgaWQsIGUsIGVsLCBuZXh0KSB7XG4gICAgdmFyIGRlbGF5ID0gbGlzdGVuZXIuZGVsYXlcbiAgICAgICwgZmluaXNoID0gbGlzdGVuZXIuZm47XG5cbiAgICBlLnBhdGggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBtb2RlbC5fX3BhdGhNYXAucGF0aHNbbGlzdGVuZXIucGF0aElkXTtcbiAgICAgIHJldHVybiB2aWV3UGF0aC5jdHhQYXRoKGxpc3RlbmVyLnZpZXcsIGxpc3RlbmVyLmN0eCwgbmFtZSk7XG4gICAgfTtcbiAgICBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBwYXRoID0gZS5wYXRoKG5hbWUpO1xuICAgICAgcmV0dXJuIHZpZXdQYXRoLmRhdGFWYWx1ZShsaXN0ZW5lci52aWV3LCBsaXN0ZW5lci5jdHgsIG1vZGVsLCBwYXRoKTtcbiAgICB9O1xuICAgIGUuYXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gbW9kZWwuYXQoZS5wYXRoKG5hbWUpKTtcbiAgICB9O1xuXG4gICAgaWYgKCFmaW5pc2gpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgbW9kZWwgd2hlbiB0aGUgZWxlbWVudCdzIHZhbHVlIGNoYW5nZXNcbiAgICAgIGZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkb20uZ2V0TWV0aG9kc1tsaXN0ZW5lci5tZXRob2RdKGVsLCBsaXN0ZW5lci5wcm9wZXJ0eSlcbiAgICAgICAgICAsIHNldFZhbHVlID0gbGlzdGVuZXIuc2V0VmFsdWU7XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIGxpc3RlbmVyIHRvIG92ZXJyaWRlIHRoZSBzZXR0aW5nIGZ1bmN0aW9uXG4gICAgICAgIGlmIChzZXRWYWx1ZSkge1xuICAgICAgICAgIHNldFZhbHVlKG1vZGVsLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgbGlzdGVuZXIgaWYgaXRzIHBhdGggaWQgaXMgbm8gbG9uZ2VyIHJlZ2lzdGVyZWRcbiAgICAgICAgdmFyIHBhdGggPSBtb2RlbC5fX3BhdGhNYXAucGF0aHNbbGlzdGVuZXIucGF0aElkXTtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICAgIGlmIChtb2RlbC5nZXQocGF0aCkgPT09IHZhbHVlKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHNldHRlck1vZGVsID0gbW9kZWwucGFzcyh7JGU6IGUsICRlbDogZWx9KTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLm1ldGhvZCA9PT0gJ3Byb3BPdCcpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dE90Lm9uVGV4dElucHV0KHNldHRlck1vZGVsLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGVyTW9kZWwuc2V0KHBhdGgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsYXkgIT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dChmaW5pc2gsIGRlbGF5LCBlLCBlbCwgbmV4dCwgZG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKGUsIGVsLCBuZXh0LCBkb20pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvbkRvbUJpbmQobmFtZSwgbGlzdGVuZXIsIGV2ZW50TmFtZSkge1xuICAgIGlmIChsaXN0ZW5lckFkZGVkW2V2ZW50TmFtZV0pIHJldHVybjtcbiAgICBhZGRMaXN0ZW5lcihkb2N1bWVudCwgZXZlbnROYW1lLCB0cmlnZ2VyRG9tLCB0cnVlKTtcbiAgICBsaXN0ZW5lckFkZGVkW2V2ZW50TmFtZV0gPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlckRvbShlLCBlbCwgbm9CdWJibGUsIGNvbnRpbnVlZCkge1xuICAgIGlmICghZWwpIGVsID0gZS50YXJnZXQ7XG4gICAgdmFyIHByZWZpeCA9IGUudHlwZSArICc6J1xuICAgICAgLCBpZDtcblxuICAgIC8vIE5leHQgY2FuIGJlIGNhbGxlZCBmcm9tIGEgbGlzdGVuZXIgdG8gY29udGludWUgYnViYmxpbmdcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdHJpZ2dlckRvbShlLCBlbC5wYXJlbnROb2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQuZmlyc3RUcmlnZ2VyID0gIWNvbnRpbnVlZDtcbiAgICBpZiAobm9CdWJibGUgJiYgKGlkID0gZWwuaWQpKSB7XG4gICAgICByZXR1cm4gZXZlbnRzLnRyaWdnZXIocHJlZml4ICsgaWQsIGlkLCBlLCBlbCwgbmV4dCk7XG4gICAgfVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB3aGlsZSAoIShpZCA9IGVsLmlkKSkge1xuICAgICAgICBpZiAoIShlbCA9IGVsLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTdG9wIGJ1YmJsaW5nIG9uY2UgdGhlIGV2ZW50IGlzIGhhbmRsZWRcbiAgICAgIGlmIChldmVudHMudHJpZ2dlcihwcmVmaXggKyBpZCwgaWQsIGUsIGVsLCBuZXh0KSkgcmV0dXJuO1xuICAgICAgaWYgKCEoZWwgPSBlbC5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhcHR1cmVUcmlnZ2VyKGUpIHtcbiAgICBjYXB0dXJlRXZlbnRzLnRyaWdnZXIoZS50eXBlLCBlKTtcbiAgfVxuXG4gIHRoaXMudHJpZ2dlciA9IHRyaWdnZXJEb207XG4gIHRoaXMuY2FwdHVyZVRyaWdnZXIgPSBjYXB0dXJlVHJpZ2dlcjtcblxuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICB0aGlzLl9wZW5kaW5nVXBkYXRlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGNvbXBvbmVudENsZWFudXAoKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBkb20uX2NvbXBvbmVudHNcbiAgICAgICwgbWFwID0gZ2V0TWFya2VycygpXG4gICAgICAsIGksIGNvbXBvbmVudFxuICAgIGZvciAoaSA9IGNvbXBvbmVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgICAgaWYgKGNvbXBvbmVudCAmJiAhZ2V0TWFya2VyKG1hcCwgY29tcG9uZW50LnNjb3BlKSkge1xuICAgICAgICBjb21wb25lbnQuZW1pdCgnZGVzdHJveScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUT0RPIFRoaXMgJ2NsZWFudXAnIGV2ZW50IGlzIG5ldmVyIGVtaXR0ZWQ7IGRlYWwgd2l0aCBsYXRlclxuICAvLyBUaGlzIGNsZWFudXAgbGlzdGVuZXJzIGlzIHBsYWNlZCBhdCB0aGUgYmVnaW5uaW5nIHNvIHRoYXQgY29tcG9uZW50XG4gIC8vIHNjb3BlcyBhcmUgY2xlYXJlZCBiZWZvcmUgYW55IHJlZiBjbGVhbnVwcyBhcmUgY2hlY2tlZFxuICBtb2RlbC5saXN0ZW5lcnMoJ2NsZWFudXAnKS51bnNoaWZ0KGNvbXBvbmVudENsZWFudXApO1xufVxuXG5Eb20ucHJvdG90eXBlID0ge1xuICBjbGVhcjogZG9tQ2xlYXJcbiwgYmluZDogZG9tQmluZFxuLCBpdGVtOiBkb21JdGVtXG4sIG1hcmtlcjogZG9tTWFya2VyXG4sIHVwZGF0ZTogZG9tVXBkYXRlXG4sIGFkZExpc3RlbmVyOiBkb21BZGRMaXN0ZW5lclxuLCByZW1vdmVMaXN0ZW5lcjogZG9tUmVtb3ZlTGlzdGVuZXJcbiwgYWRkQ29tcG9uZW50OiBhZGRDb21wb25lbnRcbiwgX3NldERpcnR5OiBzZXREaXJ0eVxuXG4sIGdldE1ldGhvZHM6IHtcbiAgICBhdHRyOiBnZXRBdHRyXG4gICwgcHJvcDogZ2V0UHJvcFxuICAsIHByb3BPdDogZ2V0UHJvcE90XG4gICwgc3RyaW5nSW5zZXJ0OiBnZXRQcm9wT3RcbiAgLCBzdHJpbmdSZW1vdmU6IGdldFByb3BPdFxuICAsIGh0bWw6IGdldEh0bWxcbiAgICAvLyBUaGVzZSBtZXRob2RzIHJldHVybiBOYU4sIGJlY2F1c2UgaXQgbmV2ZXIgZXF1YWxzIGFueXRoaW5nIGVsc2UuIFRodXMsXG4gICAgLy8gd2hlbiBjb21wYXJlZCBhZ2FpbnN0IHRoZSBuZXcgdmFsdWUsIHRoZSBuZXcgdmFsdWUgd2lsbCBhbHdheXMgYmUgc2V0XG4gICwgaW5zZXJ0OiBnZXROYU5cbiAgLCByZW1vdmU6IGdldE5hTlxuICAsIG1vdmU6IGdldE5hTlxuICB9XG5cbiwgc2V0TWV0aG9kczoge1xuICAgIGF0dHI6IHNldEF0dHJcbiAgLCBwcm9wOiBzZXRQcm9wXG4gICwgcHJvcE90OiBzZXRQcm9wT3RcbiAgLCBzdHJpbmdJbnNlcnQ6IHNldFN0cmluZ0luc2VydFxuICAsIHN0cmluZ1JlbW92ZTogc2V0U3RyaW5nUmVtb3ZlXG4gICwgaHRtbDogc2V0SHRtbFxuICAsIGluc2VydDogc2V0SW5zZXJ0XG4gICwgcmVtb3ZlOiBzZXRSZW1vdmVcbiAgLCBtb3ZlOiBzZXRNb3ZlXG4gIH1cblxuLCBmbnM6IHtcbiAgICAkZm9yQ2hpbGRyZW46IGZvckNoaWxkcmVuXG4gICwgJGZvck5hbWU6IGZvck5hbWVcbiAgfVxufVxuXG5mdW5jdGlvbiBkb21DbGVhcigpIHtcbiAgdGhpcy5fZXZlbnRzLmNsZWFyKCk7XG4gIHRoaXMuX2NhcHR1cmVFdmVudHMuY2xlYXIoKTtcbiAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzXG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAsIGksIGNvbXBvbmVudFxuICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgcmVtb3ZlTGlzdGVuZXIuYXBwbHkobnVsbCwgbGlzdGVuZXJzW2ldKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgZm9yIChpID0gY29tcG9uZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgIGNvbXBvbmVudCAmJiBjb21wb25lbnQuZW1pdCgnZGVzdHJveScpO1xuICB9XG4gIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgbWFya2VycyA9IHt9O1xufVxuXG5mdW5jdGlvbiBkb21MaXN0ZW5lckhhc2goKSB7XG4gIHZhciBvdXQgPSB7fVxuICAgICwga2V5XG4gIGZvciAoa2V5IGluIHRoaXMpIHtcbiAgICBpZiAoa2V5ID09PSAndmlldycgfHwga2V5ID09PSAnY3R4JyB8fCBrZXkgPT09ICdwYXRoSWQnKSBjb250aW51ZTtcbiAgICBvdXRba2V5XSA9IHRoaXNba2V5XTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBkb21CaW5kKGV2ZW50TmFtZSwgaWQsIGxpc3RlbmVyKSB7XG4gIGxpc3RlbmVyLnRvSlNPTiA9IGRvbUxpc3RlbmVySGFzaDtcbiAgaWYgKGxpc3RlbmVyLmNhcHR1cmUpIHtcbiAgICBsaXN0ZW5lci5pZCA9IGlkO1xuICAgIHRoaXMuX2NhcHR1cmVFdmVudHMuYmluZChldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMuYmluZChcIlwiICsgZXZlbnROYW1lICsgXCI6XCIgKyBpZCwgbGlzdGVuZXIsIGV2ZW50TmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZG9tSXRlbShpZCkge1xuICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGdsb2JhbEVsZW1lbnRzW2lkXSB8fCBnZXRSYW5nZShpZCk7XG59XG5cbi8vIEhBQ0s6IENyYXBweSBpbnRlcmZhY2UuIFNob3VsZCByZWZhY3RvciBtYXJrZXIgZ2V0dGluZyB0byBiZSBhIHByb3RvdHlwZVxuLy8gbWV0aG9kIGFuZCBtYWtlIGRpcnR5IGEgcHJvcGVydHkgb2YgZG9tIGluc3RhbmNlXG5mdW5jdGlvbiBzZXREaXJ0eSh2YWx1ZSkge1xuICBtYXJrZXJzRGlydHkgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZG9tVXBkYXRlKGVsLCBtZXRob2QsIGlnbm9yZSwgdmFsdWUsIHByb3BlcnR5LCBpbmRleCwgYXJnKSB7XG4gIC8vIFdyYXBwZWQgaW4gYSB0cnkgLyBjYXRjaCBzbyB0aGF0IGVycm9ycyB0aHJvd24gb24gRE9NIHVwZGF0ZXMgZG9uJ3RcbiAgLy8gc3RvcCBzdWJzZXF1ZW50IGNvZGUgZnJvbSBydW5uaW5nXG4gIHRyeSB7XG4gICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB1cCB0byBkYXRlXG4gICAgaWYgKHZhbHVlID09PSB0aGlzLmdldE1ldGhvZHNbbWV0aG9kXShlbCwgcHJvcGVydHkpKSByZXR1cm47XG4gICAgdGhpcy5zZXRNZXRob2RzW21ldGhvZF0oZWwsIGlnbm9yZSwgdmFsdWUsIHByb3BlcnR5LCBpbmRleCwgYXJnKTtcbiAgICBtYXJrZXJzRGlydHkgPSB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvbUFkZExpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpIHtcbiAgdGhpcy5fbGlzdGVuZXJzLnB1c2goW2VsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXNdKTtcbiAgYWRkTGlzdGVuZXIoZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcyk7XG59XG5mdW5jdGlvbiBkb21SZW1vdmVMaXN0ZW5lcihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gIHJlbW92ZUxpc3RlbmVyKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpO1xufVxuXG5mdW5jdGlvbiBhZGRDb21wb25lbnQoY3R4LCBjb21wb25lbnQpIHtcbiAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzXG4gICAgLCBkb20gPSBjb21wb25lbnQuZG9tID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblxuICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgY29tcG9uZW50Lm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gY29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICAgIC8vIFRoZSBjb21wb25lbnRzIGFycmF5IGdldHMgcmVwbGFjZWQgb24gYSBkb20uY2xlYXIsIHNvIHdlIGFsbG93XG4gICAgLy8gaXQgdG8gZ2V0IHNwYXJzZSBhcyBpbmRpdmlkdWFsIGNvbXBvbmVudHMgYXJlIGRlc3Ryb3llZFxuICAgIGRlbGV0ZSBjb21wb25lbnRzW2luZGV4XTtcbiAgfSk7XG5cbiAgZG9tLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcykge1xuICAgIGNvbXBvbmVudC5vbignZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcyk7XG4gICAgfSk7XG4gICAgYWRkTGlzdGVuZXIoZWwsIG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcyk7XG4gIH07XG5cbiAgZG9tLmVsZW1lbnQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkID0gY3R4LiRlbGVtZW50c1tuYW1lXTtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICB9O1xuXG4gIHJldHVybiBkb207XG59XG5cblxuZnVuY3Rpb24gZ2V0QXR0cihlbCwgYXR0cikge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbn1cbmZ1bmN0aW9uIGdldFByb3AoZWwsIHByb3ApIHtcbiAgcmV0dXJuIGVsW3Byb3BdO1xufVxuZnVuY3Rpb24gZ2V0UHJvcE90KGVsLCBwcm9wKSB7XG4gIC8vIElFIGFuZCBPcGVyYSByZXBsYWNlIFxcbiB3aXRoIFxcclxcblxuICB2YXIgdmFsdWUgPSBlbFtwcm9wXTtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnJlcGxhY2UgJiYgdmFsdWUucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn1cbmZ1bmN0aW9uIGdldEh0bWwoZWwpIHtcbiAgcmV0dXJuIGVsLmlubmVySFRNTDtcbn1cbmZ1bmN0aW9uIGdldE5hTigpIHtcbiAgcmV0dXJuIE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cihlbCwgaWdub3JlLCB2YWx1ZSwgYXR0cikge1xuICBlbC5zZXRBdHRyaWJ1dGUgJiYgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldFByb3AoZWwsIGlnbm9yZSwgdmFsdWUsIHByb3ApIHtcbiAgZWxbcHJvcF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldFByb3BPdChlbCwgaWdub3JlLCB2YWx1ZSwgcHJvcCkge1xuICBlbFtwcm9wXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0U3RyaW5nSW5zZXJ0KGVsLCBpZ25vcmUsIHZhbHVlLCBwcm9wLCBpbmRleCwgdGV4dCkge1xuICB2YXIgcHJldmlvdXMgPSBnZXRQcm9wT3QoZWwsIHByb3ApO1xuICB0ZXh0T3Qub25TdHJpbmdJbnNlcnQoZWwsIHByZXZpb3VzLCBpbmRleCwgdGV4dCk7XG59XG5mdW5jdGlvbiBzZXRTdHJpbmdSZW1vdmUoZWwsIGlnbm9yZSwgdmFsdWUsIHByb3AsIGluZGV4LCBob3dNYW55KSB7XG4gIHZhciBwcmV2aW91cyA9IGdldFByb3BPdChlbCwgcHJvcCk7XG4gIHRleHRPdC5vblN0cmluZ1JlbW92ZShlbCwgcHJldmlvdXMsIGluZGV4LCBob3dNYW55KTtcbn1cblxuZnVuY3Rpb24gbWFrZVNWR0ZyYWdtZW50KGZyYWdtZW50LCBzdmdFbGVtZW50KSB7XG4gIC8vIFRPRE86IEFsbG93IG9wdGlvbmFsIG5hbWVzcGFjZSBkZWNsYXJhdGlvbnNcbiAgdmFyIHByZSA9ICc8c3ZnIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIHhtbG5zOnhsaW5rPWh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbms+JyBcbiAgICAsIHBvc3QgPSAnPC9zdmc+J1xuICAgICwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpXG4gIHJhbmdlLnNlbGVjdE5vZGUoc3ZnRWxlbWVudCk7XG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocHJlICsgZnJhZ21lbnQgKyBwb3N0KTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFNWRyhlbGVtZW50LCBmcmFnbWVudCwgc3ZnRWxlbWVudCkge1xuICB2YXIgZnJhZyA9IG1ha2VTVkdGcmFnbWVudChmcmFnbWVudCwgc3ZnRWxlbWVudClcbiAgICAsIGNoaWxkcmVuID0gZnJhZy5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNcbiAgICAsIGlcbiAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07KSB7XG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZHJlblswXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZVNWRyhlbGVtZW50LCBmcmFnbWVudCwgc3ZnRWxlbWVudCkge1xuICB2YXIgZnJhZyA9IG1ha2VTVkdGcmFnbWVudChmcmFnbWVudCwgc3ZnRWxlbWVudClcbiAgICAsIGNoaWxkcmVuID0gZnJhZy5jaGlsZE5vZGVzWzBdLmNoaWxkTm9kZXNcbiAgICAsIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZVxuICAgICwgaVxuICBmb3IgKGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTspIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkcmVuWzBdLCBlbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZWxlbWVudCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkTm9kZXNcbiAgICAsIGlcbiAgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07KSB7XG4gICAgZWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZHJlblswXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTVkcob2JqKSB7XG4gIHJldHVybiAhIW9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqLnRhZ05hbWUgPT09IFwic3ZnXCI7XG59XG5mdW5jdGlvbiBzdmdSb290KG9iaikge1xuICByZXR1cm4gb2JqLm93bmVyU1ZHRWxlbWVudCB8fCBvYmo7XG59XG5mdW5jdGlvbiBpc1JhbmdlKG9iaikge1xuICByZXR1cm4gISFvYmouY2xvbmVSYW5nZTtcbn1cblxuZnVuY3Rpb24gc2V0SHRtbChvYmosIGlnbm9yZSwgdmFsdWUsIGVzY2FwZSkge1xuICBpZiAoZXNjYXBlKSB2YWx1ZSA9IGVzY2FwZUh0bWwodmFsdWUpO1xuICBpZihpc1JhbmdlKG9iaikpIHtcbiAgICBpZihpc1NWRyhvYmouc3RhcnRDb250YWluZXIpKSB7XG4gICAgICAvLyBTVkcgRWxlbWVudFxuICAgICAgb2JqLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICB2YXIgc3ZnRWxlbWVudCA9IHN2Z1Jvb3Qob2JqLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgIG9iai5pbnNlcnROb2RlKG1ha2VTVkdGcmFnbWVudCh2YWx1ZSwgc3ZnRWxlbWVudCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSYW5nZVxuICAgICAgb2JqLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICBvYmouaW5zZXJ0Tm9kZShvYmouY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChpc1NWRyhvYmopKSB7XG4gICAgLy8gU1ZHIEVsZW1lbnRcbiAgICB2YXIgc3ZnRWxlbWVudCA9IHN2Z1Jvb3Qob2JqKTtcbiAgICByZW1vdmVDaGlsZHJlbihvYmopO1xuICAgIGFwcGVuZFNWRyhvYmosIHZhbHVlLCBzdmdFbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gSFRNTCBFbGVtZW50XG4gIGlmIChpZ25vcmUgJiYgb2JqLmlkID09PSBpZ25vcmUpIHJldHVybjtcbiAgb2JqLmlubmVySFRNTCA9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0SW5zZXJ0KG9iaiwgaWdub3JlLCB2YWx1ZSwgZXNjYXBlLCBpbmRleCkge1xuICBpZiAoZXNjYXBlKSB2YWx1ZSA9IGVzY2FwZUh0bWwodmFsdWUpO1xuICBpZiAob2JqLm5vZGVUeXBlKSB7XG4gICAgLy8gRWxlbWVudFxuICAgIGlmIChyZWYgPSBvYmouY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIGlmIChpc1NWRyhvYmopKSB7XG4gICAgICAgIHZhciBzdmdFbGVtZW50ID0gb2JqLm93bmVyU1ZHRWxlbWVudCB8fCBvYmo7XG4gICAgICAgIGluc2VydEJlZm9yZVNWRyhyZWYsIHZhbHVlLCBzdmdFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhvYmopO1xuICAgICAgb2JqLmluc2VydEJlZm9yZShyYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodmFsdWUpLCByZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNTVkcob2JqKSkge1xuICAgICAgICB2YXIgc3ZnRWxlbWVudCA9IG9iai5vd25lclNWR0VsZW1lbnQgfHwgb2JqO1xuICAgICAgICBhcHBlbmRTVkcob2JqLCB2YWx1ZSwgc3ZnRWxlbWVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMob2JqKTtcbiAgICAgIG9iai5hcHBlbmRDaGlsZChyYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQodmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmFuZ2VcbiAgICBpZiAoaXNTVkcob2JqLnN0YXJ0Q29udGFpbmVyKSkge1xuICAgICAgdmFyIGVsID0gb2JqLnN0YXJ0Q29udGFpbmVyXG4gICAgICAsIHJlZiA9IGVsLmNoaWxkTm9kZXNbb2JqLnN0YXJ0T2Zmc2V0ICsgaW5kZXhdO1xuICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBzdmdSb290KHJlZik7XG4gICAgICBlbC5pbnNlcnRCZWZvcmUobWFrZVNWR0ZyYWdtZW50KHZhbHVlLCBzdmdFbGVtZW50KSwgcmVmKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWwgPSBvYmouc3RhcnRDb250YWluZXJcbiAgICAgICAgLCByZWYgPSBlbC5jaGlsZE5vZGVzW29iai5zdGFydE9mZnNldCArIGluZGV4XTtcbiAgICAgIGVsLmluc2VydEJlZm9yZShvYmouY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHZhbHVlKSwgcmVmKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFJlbW92ZShlbCwgaWdub3JlLCBpbmRleCkge1xuICBpZiAoIWVsLm5vZGVUeXBlKSB7XG4gICAgLy8gUmFuZ2VcbiAgICBpbmRleCArPSBlbC5zdGFydE9mZnNldDtcbiAgICBlbCA9IGVsLnN0YXJ0Q29udGFpbmVyO1xuICB9XG4gIHZhciBjaGlsZCA9IGVsLmNoaWxkTm9kZXNbaW5kZXhdO1xuICBpZiAoY2hpbGQpIGVsLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHNldE1vdmUoZWwsIGlnbm9yZSwgZnJvbSwgcHJvcGVydHksIHRvLCBob3dNYW55KSB7XG4gIHZhciBjaGlsZCwgZnJhZ21lbnQsIG5leHRDaGlsZCwgb2Zmc2V0LCByZWYsIHRvRWw7XG4gIGlmICghZWwubm9kZVR5cGUpIHtcbiAgICBvZmZzZXQgPSBlbC5zdGFydE9mZnNldDtcbiAgICBmcm9tICs9IG9mZnNldDtcbiAgICB0byArPSBvZmZzZXQ7XG4gICAgZWwgPSBlbC5zdGFydENvbnRhaW5lcjtcbiAgfVxuICBjaGlsZCA9IGVsLmNoaWxkTm9kZXNbZnJvbV07XG5cbiAgLy8gRG9uJ3QgbW92ZSBpZiB0aGUgaXRlbSBhdCB0aGUgZGVzdGluYXRpb24gaXMgcGFzc2VkIGFzIHRoZSBpZ25vcmVcbiAgLy8gb3B0aW9uLCBzaW5jZSB0aGlzIGluZGljYXRlcyB0aGUgaW50ZW5kZWQgaXRlbSB3YXMgYWxyZWFkeSBtb3ZlZFxuICAvLyBBbHNvIGRvbid0IG1vdmUgaWYgdGhlIGNoaWxkIHRvIG1vdmUgbWF0Y2hlcyB0aGUgaWdub3JlIG9wdGlvblxuICBpZiAoIWNoaWxkIHx8IGlnbm9yZSAmJiAodG9FbCA9IGVsLmNoaWxkTm9kZXNbdG9dKSAmJlxuICAgICAgdG9FbC5pZCA9PT0gaWdub3JlIHx8IGNoaWxkLmlkID09PSBpZ25vcmUpIHJldHVybjtcblxuICByZWYgPSBlbC5jaGlsZE5vZGVzW3RvID4gZnJvbSA/IHRvICsgaG93TWFueSA6IHRvXTtcbiAgaWYgKGhvd01hbnkgPiAxKSB7XG4gICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgd2hpbGUgKGhvd01hbnktLSkge1xuICAgICAgbmV4dENoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBpZiAoIShjaGlsZCA9IG5leHRDaGlsZCkpIGJyZWFrO1xuICAgIH1cbiAgICBlbC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIHJlZik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsLmluc2VydEJlZm9yZShjaGlsZCwgcmVmKTtcbn1cblxuZnVuY3Rpb24gZm9yQ2hpbGRyZW4oZSwgZWwsIG5leHQsIGRvbSkge1xuICAvLyBQcmV2ZW50IGluZmludGUgZW1pc3Npb25cbiAgaWYgKCFuZXh0LmZpcnN0VHJpZ2dlcikgcmV0dXJuO1xuXG4gIC8vIFJlLXRyaWdnZXIgdGhlIGV2ZW50IG9uIGFsbCBjaGlsZCBlbGVtZW50c1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZE5vZGVzO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgIT09IDEpIGNvbnRpbnVlOyAgLy8gTm9kZS5FTEVNRU5UX05PREVcbiAgICBkb20udHJpZ2dlcihlLCBjaGlsZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZm9yQ2hpbGRyZW4oZSwgY2hpbGQsIG5leHQsIGRvbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yTmFtZShlLCBlbCwgbmV4dCwgZG9tKSB7XG4gIC8vIFByZXZlbnQgaW5maW50ZSBlbWlzc2lvblxuICBpZiAoIW5leHQuZmlyc3RUcmlnZ2VyKSByZXR1cm47XG5cbiAgdmFyIG5hbWUgPSBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgaWYgKCFuYW1lKSByZXR1cm47XG5cbiAgLy8gUmUtdHJpZ2dlciB0aGUgZXZlbnQgb24gYWxsIG90aGVyIGVsZW1lbnRzIHdpdGhcbiAgLy8gdGhlIHNhbWUgJ25hbWUnIGF0dHJpYnV0ZVxuICB2YXIgZWxlbWVudHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKVxuICAgICwgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuICBpZiAoIShsZW4gPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgIGlmIChlbGVtZW50ID09PSBlbCkgY29udGludWU7XG4gICAgZG9tLnRyaWdnZXIoZSwgZWxlbWVudCwgZmFsc2UsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgLy8gTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgPT0gMTI4XG4gIHZhciBjb21tZW50SXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LCAxMjgsIG51bGwsIGZhbHNlKTtcbiAgdmFyIGNvbW1lbnQ7XG4gIHdoaWxlIChjb21tZW50ID0gY29tbWVudEl0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICBtYXBbY29tbWVudC5kYXRhXSA9IGNvbW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VyKG1hcCwgbmFtZSkge1xuICB2YXIgbWFya2VyID0gbWFwW25hbWVdO1xuICBpZiAoIW1hcmtlcikgcmV0dXJuO1xuXG4gIC8vIENvbW1lbnQgbm9kZXMgbWF5IGNvbnRpbnVlIHRvIGV4aXN0IGV2ZW4gaWYgdGhleSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tXG4gIC8vIHRoZSBwYWdlLiBUaHVzLCBtYWtlIHN1cmUgdGhleSBhcmUgc3RpbGwgc29tZXdoZXJlIGluIHRoZSBwYWdlIGJvZHlcbiAgaWYgKCFkb2N1bWVudC5jb250YWlucyhtYXJrZXIpKSB7XG4gICAgZGVsZXRlIG1hcFtuYW1lXTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIG1hcmtlcjtcbn1cblxuZnVuY3Rpb24gZG9tTWFya2VyKG5hbWUpIHtcbiAgdmFyIG1hcmtlciA9IGdldE1hcmtlcihtYXJrZXJzLCBuYW1lKTtcbiAgaWYgKCFtYXJrZXIgJiYgbWFya2Vyc0RpcnR5KSB7XG4gICAgbWFya2VycyA9IGdldE1hcmtlcnMoKTtcbiAgICBtYXJrZXJzRGlydHkgPSBmYWxzZTtcbiAgICBtYXJrZXIgPSBnZXRNYXJrZXIobWFya2VycywgbmFtZSk7XG4gIH1cbiAgcmV0dXJuIG1hcmtlcjtcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZ2UobmFtZSkge1xuICB2YXIgc3RhcnQgPSBkb21NYXJrZXIobmFtZSk7XG4gIGlmICghc3RhcnQpIHJldHVybjtcbiAgdmFyIGVuZCA9IGRvbU1hcmtlcignJCcgKyBuYW1lKTtcbiAgaWYgKCFlbmQpIHJldHVybjtcblxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydEFmdGVyKHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kQmVmb3JlKGVuZCk7XG4gIHJldHVybiByYW5nZTtcbn1cblxuaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2FsbGJhY2ssIGNhcHR1cmVzKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMgfHwgZmFsc2UpO1xuICB9O1xuICByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsLCBuYW1lLCBjYWxsYmFjaywgY2FwdHVyZXMpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrLCBjYXB0dXJlcyB8fCBmYWxzZSk7XG4gIH07XG59XG4iLCJ2YXIgZXNjYXBlSHRtbCA9IHJlcXVpcmUoJ2h0bWwtdXRpbCcpLmVzY2FwZUh0bWxcbiAgLCBlcnJvcnMgPSB7fTtcblxuZXhwb3J0cy5lcnJvckh0bWwgPSBlcnJvckh0bWw7XG5leHBvcnRzLmF1dG9SZWZyZXNoID0gYXV0b1JlZnJlc2g7XG5cbmZ1bmN0aW9uIGVycm9ySHRtbChlcnJvcnMpIHtcbiAgdmFyIHRleHQgPSAnJ1xuICAgICwgdHlwZSwgZXJyO1xuICBmb3IgKHR5cGUgaW4gZXJyb3JzKSB7XG4gICAgZXJyID0gZXJyb3JzW3R5cGVdO1xuICAgIHRleHQgKz0gJzxoMz4nICsgZXNjYXBlSHRtbCh0eXBlKSArICcgRXJyb3I8L2gzPjxwcmU+JyArIGVzY2FwZUh0bWwoZXJyKSArICc8L3ByZT4nO1xuICB9XG4gIGlmICghdGV4dCkgcmV0dXJuO1xuICByZXR1cm4gJzxkaXYgaWQ9JF9kZXJieUVycm9yIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC43KTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDt0ZXh0LWFsaWduOmNlbnRlclwiPicgK1xuICAgICc8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZDojZmZmO3BhZGRpbmc6MjBweCA0MHB4O21hcmdpbjo2MHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246bGVmdFwiPicgK1xuICAgIHRleHQgKyAnPC9kaXY+PC9kaXY+Jztcbn1cblxuZnVuY3Rpb24gYXV0b1JlZnJlc2godmlldywgbW9kZWwpIHtcblxuICBtb2RlbC5jaGFubmVsLm9uKCdkZXJieTpyZWxvYWQnLCByZWxvYWRPblJlYWR5KTtcbiAgLy8gV2FpdCB0byByZWxvYWQgdW50aWwgdGhlIHNlcnZlciBpcyByZXNwb25zaXZlIGFnYWluIGFmdGVyIHJlc3RhcnRpbmdcbiAgZnVuY3Rpb24gcmVsb2FkT25SZWFkeSgpIHtcbiAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgICB9XG4gICAgICByZWxvYWRPblJlYWR5KCk7XG4gICAgfTtcbiAgICB4aHIub3BlbignR0VUJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cblxuICBtb2RlbC5jaGFubmVsLm9uKCdkZXJieTpyZWZyZXNoQ3NzJywgZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCckX2NzcycpO1xuICAgIGlmIChlbCkgZWwuaW5uZXJIVE1MID0gZGF0YS5jc3M7XG4gICAgdXBkYXRlRXJyb3IoJ0NTUycsIGRhdGEuZXJyVGV4dCk7XG4gIH0pO1xuXG4gIG1vZGVsLmNoYW5uZWwub24oJ2RlcmJ5OnJlZnJlc2hIdG1sJywgZnVuY3Rpb24oZGF0YSkge1xuICAgIHZpZXcuX21ha2VBbGwoZGF0YS50ZW1wbGF0ZXMsIGRhdGEuaW5zdGFuY2VzKTtcbiAgICB2aWV3Ll9tYWtlQ29tcG9uZW50cyhkYXRhLmxpYnJhcnlEYXRhKTtcbiAgICB2YXIgZXJyVGV4dCA9IGRhdGEuZXJyVGV4dDtcbiAgICB0cnkge1xuICAgICAgdmlldy5hcHAuaGlzdG9yeS5yZWZyZXNoKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJUZXh0IHx8IChlcnJUZXh0ID0gZXJyLnN0YWNrKTtcbiAgICB9XG4gICAgdXBkYXRlRXJyb3IoJ1RlbXBsYXRlJywgZGF0YS5lcnJUZXh0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVycm9yKHR5cGUsIGVycikge1xuICBpZiAoZXJyKSB7XG4gICAgZXJyb3JzW3R5cGVdID0gZXJyO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlcnJvcnNbdHlwZV07XG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJyRfZGVyYnlFcnJvcicpXG4gICAgLCBodG1sID0gZXJyb3JIdG1sKGVycm9ycylcbiAgICAsIGZyYWdtZW50LCByYW5nZTtcbiAgaWYgKGh0bWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLm91dGVySFRNTCA9IGh0bWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jdW1lbnQuYm9keSk7XG4gICAgICBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZWwpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICB9XG59XG4iLCJ2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICB2YXIgZmlsZW5hbWUgPSBtb2RlbC5nZXQoJ2ZpbGVuYW1lJykgfHwgJ2dpdGh1Yi1idG4uaHRtbCdcbiAgICAsIGZpbGV1cmwgPSBtb2RlbC5nZXQoJ2ZpbGV1cmwnKVxuICAgICwgZG9tYWluID0gbW9kZWwuZ2V0KCdkb21haW4nKSB8fCAnZ2hidG5zLmNvbSdcbiAgICAsIGdpdHVybCA9IG1vZGVsLmdldCgnZ2l0dXJsJylcbiAgICAsIGhlaWdodCA9IG1vZGVsLmdldCgnaGVpZ2h0JylcbiAgICAsIHByb3RvY29sID0gbW9kZWwuZ2V0KCdzZWN1cmUnKSA/ICdodHRwcycgOiAnaHR0cCdcbiAgICAsIHJlcG8gPSBtb2RlbC5nZXQoJ3JlcG8nKVxuICAgICwgc2l6ZSA9IG1vZGVsLmdldCgnc2l6ZScpXG4gICAgLCB0eXBlID0gbW9kZWwuZ2V0KCd0eXBlJylcbiAgICAsIHVzZXIgPSBtb2RlbC5nZXQoJ3VzZXInKTtcblxuICBpZiAoIWdpdHVybCAmJiAoIXVzZXIgfHwgIXJlcG8pKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2doYnRuczpidXR0b246IGdpdHVybCBvciB1c2VyL3JlcG8gcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghdHlwZSkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdnaGJ0bnM6YnV0dG9uOiB0eXBlIHJlcXVpcmVkJyk7XG4gIH1cblxuICBpZiAoIWZpbGV1cmwpIHtcbiAgICBtb2RlbC5zZXQoJ2ZpbGV1cmwnLCBwcm90b2NvbCArICc6Ly8nICsgZG9tYWluICsgJy8nICsgZmlsZW5hbWUpO1xuICB9XG5cbiAgaWYgKGdpdHVybCkge1xuICAgIHZhciBnaXRwYXRoID0gdXJsLnBhcnNlKGdpdHVybCkucGF0aC5zcGxpdCgnLycpO1xuICAgIG1vZGVsLnNldCgncmVwbycsIGdpdHBhdGhbMl0uc2xpY2UoMCwgLTQpKTtcbiAgICBtb2RlbC5zZXQoJ3VzZXInLCBnaXRwYXRoWzFdKTtcbiAgfVxuXG4gIGlmICghaGVpZ2h0KSB7XG4gICAgbW9kZWwuc2V0KCdoZWlnaHQnLCBzaXplID09PSAnbGFyZ2UnID8gJzMwJyA6ICcyMCcpO1xuICB9XG5cbiAgbW9kZWwuc2V0KCdzaG93JywgdHJ1ZSk7XG59OyIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgT2JqZWN0X2tleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgICA/IE9iamVjdC5rZXlzXG4gICAgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG47XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIGVuZm9yY2UgT2JqZWN0LmlzICswICE9PSAtMFxuICBpZiAoYWN0dWFsID09PSAwICYmIGV4cGVjdGVkID09PSAwKSB7XG4gICAgcmV0dXJuIGFyZVplcm9zRXF1YWwoYWN0dWFsLCBleHBlY3RlZCk7XG5cbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIH0gZWxzZSBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIH0gZWxzZSBpZiAoaXNOdW1iZXJOYU4oYWN0dWFsKSkge1xuICAgIHJldHVybiBpc051bWJlck5hTihleHBlY3RlZCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlck5hTih2YWx1ZSkge1xuICAvLyBOYU4gPT09IE5hTiAtPiBmYWxzZVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYXJlWmVyb3NFcXVhbCh6ZXJvQSwgemVyb0IpIHtcbiAgLy8gKDEgLyArMHwwKSAtPiBJbmZpbml0eSwgYnV0ICgxIC8gLTApIC0+IC1JbmZpbml0eSBhbmQgKEluZmluaXR5ICE9PSAtSW5maW5pdHkpXG4gIHJldHVybiAoMSAvIHplcm9BKSA9PT0gKDEgLyB6ZXJvQik7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gT2JqZWN0X2tleXMoYSksXG4gICAgICAgIGtiID0gT2JqZWN0X2tleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwidmFyIGRvYyA9IGRvY3VtZW50XG4gICwgZWxlbWVudFByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlXG4gICwgbm9kZVByb3RvID0gTm9kZS5wcm90b3R5cGVcblxuLy8gQWRkIHN1cHBvcnQgZm9yIE5vZGUuY29udGFpbnMgZm9yIEZpcmVmb3ggPCA5XG5pZiAoIWRvYy5jb250YWlucykge1xuICBub2RlUHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiAxNilcbiAgfVxufVxuXG4vLyBBZGQgc3VwcG9ydCBmb3IgaW5zZXJ0QWRqYWNlbnRIVE1MIGZvciBGaXJlZm94IDwgOFxuLy8gQmFzZWQgb24gaW5zZXJ0QWRqYWNlbnRIVE1MLmpzIGJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cbmlmICghZG9jLmJvZHkuaW5zZXJ0QWRqYWNlbnRIVE1MKSB7XG4gIGVsZW1lbnRQcm90by5pbnNlcnRBZGphY2VudEhUTUwgPSBmdW5jdGlvbihwb3NpdGlvbiwgaHRtbCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uLnRvTG93ZXJDYXNlKClcbiAgICAgICwgcmVmID0gdGhpc1xuICAgICAgLCBwYXJlbnQgPSByZWYucGFyZW50Tm9kZVxuICAgICAgLCBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSlcbiAgICAgICwgZmlyc3RDaGlsZCwgbmV4dFNpYmxpbmcsIG5vZGVcblxuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYmVmb3JlZW5kJykge1xuICAgICAgd2hpbGUgKG5vZGUgPSBjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICByZWYuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYmVmb3JlYmVnaW4nKSB7XG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcmVmKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdhZnRlcmVuZCcpIHtcbiAgICAgIG5leHRTaWJsaW5nID0gcmVmLm5leHRTaWJsaW5nXG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHRTaWJsaW5nKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdhZnRlcmJlZ2luJykge1xuICAgICAgZmlyc3RDaGlsZCA9IHJlZi5maXJzdENoaWxkXG4gICAgICB3aGlsZSAobm9kZSA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgZmlyc3RDaGlsZCA9IHJlZi5pbnNlcnRCZWZvcmUobm9kZSwgZmlyc3RDaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZWxlbWVudFByb3RvLm1hdGNoZXMgPVxuICBlbGVtZW50UHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIGVsZW1lbnRQcm90by5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgZWxlbWVudFByb3RvLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgZWxlbWVudFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4iLCJ2YXIgcHVueWNvZGUgPSB7IGVuY29kZSA6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzIH0gfTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFycmF5LCBzdWJqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaWYoYXJyYXlbaV0gPT0gc3ViamVjdCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgIT09IE9iamVjdChvYmplY3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICByZXR1cm4ga2V5cztcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSskLyxcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnficsICdbJywgJ10nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ11cbiAgICAgIC5jb25jYXQodW53aXNlKS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgbm9uQXV0aENoYXJzID0gWycvJywgJ0AnLCAnPycsICcjJ10uY29uY2F0KGRlbGltcyksXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16QS1aMC05XVthLXowLTlBLVpfLV17MCw2Mn0pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgaGF2ZSBhIHBhdGggY29tcG9uZW50LlxuICAgIHBhdGhlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB0eXBlb2YodXJsKSA9PT0gJ29iamVjdCcgJiYgdXJsLmhyZWYpIHJldHVybiB1cmw7XG5cbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciBvdXQgPSB7fSxcbiAgICAgIHJlc3QgPSB1cmw7XG5cbiAgLy8gY3V0IG9mZiBhbnkgZGVsaW1pdGVycy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCI8aHR0cDovL2Zvby5jb20+XCJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhcnJheUluZGV4T2YoZGVsaW1zLCByZXN0LmNoYXJBdChpKSkgPT09IC0xKSBicmVhaztcbiAgfVxuICBpZiAoaSAhPT0gMCkgcmVzdCA9IHJlc3Quc3Vic3RyKGkpO1xuXG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIG91dC5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIG91dC5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vIGRvbid0IGVuZm9yY2UgZnVsbCBSRkMgY29ycmVjdG5lc3MsIGp1c3QgYmUgdW5zdHVwaWQgYWJvdXQgaXQuXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgbm9uLWF1dGggY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgdmFyIGF0U2lnbiA9IGFycmF5SW5kZXhPZihyZXN0LCAnQCcpO1xuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICAvLyB0aGVyZSAqbWF5IGJlKiBhbiBhdXRoXG4gICAgICB2YXIgaGFzQXV0aCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkF1dGhDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyYXlJbmRleE9mKHJlc3QsIG5vbkF1dGhDaGFyc1tpXSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggPCBhdFNpZ24pIHtcbiAgICAgICAgICAvLyBub3QgYSB2YWxpZCBhdXRoLiAgU29tZXRoaW5nIGxpa2UgaHR0cDovL2Zvby5jb20vYmFyQGJhei9cbiAgICAgICAgICBoYXNBdXRoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNBdXRoKSB7XG4gICAgICAgIC8vIHBsdWNrIG9mZiB0aGUgYXV0aCBwb3J0aW9uLlxuICAgICAgICBvdXQuYXV0aCA9IHJlc3Quc3Vic3RyKDAsIGF0U2lnbik7XG4gICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihhdFNpZ24gKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmlyc3ROb25Ib3N0ID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheUluZGV4T2YocmVzdCwgbm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEgJiZcbiAgICAgICAgICAoZmlyc3ROb25Ib3N0IDwgMCB8fCBpbmRleCA8IGZpcnN0Tm9uSG9zdCkpIGZpcnN0Tm9uSG9zdCA9IGluZGV4O1xuICAgIH1cblxuICAgIGlmIChmaXJzdE5vbkhvc3QgIT09IC0xKSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Quc3Vic3RyKDAsIGZpcnN0Tm9uSG9zdCk7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoZmlyc3ROb25Ib3N0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmhvc3QgPSByZXN0O1xuICAgICAgcmVzdCA9ICcnO1xuICAgIH1cblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdmFyIHAgPSBwYXJzZUhvc3Qob3V0Lmhvc3QpO1xuICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIG91dFtrZXldID0gcFtrZXldO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAob3V0Lmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IG91dC5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgb3V0Lmhvc3RuYW1lID0gb3V0Lmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgdmFyIGRvbWFpbkFycmF5ID0gb3V0Lmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIG5ld091dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICB9XG4gICAgb3V0Lmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcblxuICAgIG91dC5ob3N0ID0gKG91dC5ob3N0bmFtZSB8fCAnJykgK1xuICAgICAgICAoKG91dC5wb3J0KSA/ICc6JyArIG91dC5wb3J0IDogJycpO1xuICAgIG91dC5ocmVmICs9IG91dC5ob3N0O1xuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuXG4gICAgLy8gTm93IG1ha2Ugc3VyZSB0aGF0IGRlbGltcyBuZXZlciBhcHBlYXIgaW4gYSB1cmwuXG4gICAgdmFyIGNob3AgPSByZXN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRlbGltcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjID0gYXJyYXlJbmRleE9mKHJlc3QsIGRlbGltc1tpXSk7XG4gICAgICBpZiAoYyAhPT0gLTEpIHtcbiAgICAgICAgY2hvcCA9IE1hdGgubWluKGMsIGNob3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zdWJzdHIoMCwgY2hvcCk7XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gYXJyYXlJbmRleE9mKHJlc3QsICcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICBvdXQuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IGFycmF5SW5kZXhPZihyZXN0LCAnPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgb3V0LnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICBvdXQucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICBvdXQucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZShvdXQucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgb3V0LnNlYXJjaCA9ICcnO1xuICAgIG91dC5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSBvdXQucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW3Byb3RvXSAmJlxuICAgICAgb3V0Lmhvc3RuYW1lICYmICFvdXQucGF0aG5hbWUpIHtcbiAgICBvdXQucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmIChvdXQucGF0aG5hbWUgfHwgb3V0LnNlYXJjaCkge1xuICAgIG91dC5wYXRoID0gKG91dC5wYXRobmFtZSA/IG91dC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAob3V0LnNlYXJjaCA/IG91dC5zZWFyY2ggOiAnJyk7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgb3V0LmhyZWYgPSB1cmxGb3JtYXQob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIG9iaiA9IHVybFBhcnNlKG9iaik7XG5cbiAgdmFyIGF1dGggPSBvYmouYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gYXV0aC5zcGxpdCgnQCcpLmpvaW4oJyU0MCcpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG5BQyA9IG5vbkF1dGhDaGFyc1tpXTtcbiAgICAgIGF1dGggPSBhdXRoLnNwbGl0KG5BQykuam9pbihlbmNvZGVVUklDb21wb25lbnQobkFDKSk7XG4gICAgfVxuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gb2JqLnByb3RvY29sIHx8ICcnLFxuICAgICAgaG9zdCA9IChvYmouaG9zdCAhPT0gdW5kZWZpbmVkKSA/IGF1dGggKyBvYmouaG9zdCA6XG4gICAgICAgICAgb2JqLmhvc3RuYW1lICE9PSB1bmRlZmluZWQgPyAoXG4gICAgICAgICAgICAgIGF1dGggKyBvYmouaG9zdG5hbWUgK1xuICAgICAgICAgICAgICAob2JqLnBvcnQgPyAnOicgKyBvYmoucG9ydCA6ICcnKVxuICAgICAgICAgICkgOlxuICAgICAgICAgIGZhbHNlLFxuICAgICAgcGF0aG5hbWUgPSBvYmoucGF0aG5hbWUgfHwgJycsXG4gICAgICBxdWVyeSA9IG9iai5xdWVyeSAmJlxuICAgICAgICAgICAgICAoKHR5cGVvZiBvYmoucXVlcnkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0S2V5cyhvYmoucXVlcnkpLmxlbmd0aCkgP1xuICAgICAgICAgICAgICAgICBxdWVyeXN0cmluZy5zdHJpbmdpZnkob2JqLnF1ZXJ5KSA6XG4gICAgICAgICAgICAgICAgICcnKSB8fCAnJyxcbiAgICAgIHNlYXJjaCA9IG9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnLFxuICAgICAgaGFzaCA9IG9iai5oYXNoIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKG9iai5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn1cblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxGb3JtYXQodXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSk7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuXG4gIHNvdXJjZSA9IHVybFBhcnNlKHVybEZvcm1hdChzb3VyY2UpLCBmYWxzZSwgdHJ1ZSk7XG4gIHJlbGF0aXZlID0gdXJsUGFyc2UodXJsRm9ybWF0KHJlbGF0aXZlKSwgZmFsc2UsIHRydWUpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICBzb3VyY2UuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIHJlbGF0aXZlLnByb3RvY29sID0gc291cmNlLnByb3RvY29sO1xuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgJiYgIXJlbGF0aXZlLnBhdGhuYW1lKSB7XG4gICAgICByZWxhdGl2ZS5wYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgIHJldHVybiByZWxhdGl2ZTtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gc291cmNlLnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgcmVsYXRpdmUuaHJlZiA9IHVybEZvcm1hdChyZWxhdGl2ZSk7XG4gICAgICByZXR1cm4gcmVsYXRpdmU7XG4gICAgfVxuICAgIHNvdXJjZS5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlbGF0aXZlLnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfVxuICAgIHNvdXJjZS5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc291cmNlLmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHNvdXJjZS5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHNvdXJjZS5wYXRobmFtZSAhPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgc291cmNlLnBhdGggPSAoc291cmNlLnBhdGhuYW1lID8gc291cmNlLnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICBzb3VyY2Uuc2xhc2hlcyA9IHNvdXJjZS5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2UuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gc291cmNlLnBhdGhuYW1lICYmIHNvdXJjZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSBzb3VyY2UucHJvdG9jb2wgJiZcbiAgICAgICAgICAhc2xhc2hlZFByb3RvY29sW3NvdXJjZS5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gc291cmNlLnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcblxuICAgIGRlbGV0ZSBzb3VyY2UuaG9zdG5hbWU7XG4gICAgZGVsZXRlIHNvdXJjZS5wb3J0O1xuICAgIGlmIChzb3VyY2UuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gc291cmNlLmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChzb3VyY2UuaG9zdCk7XG4gICAgfVxuICAgIGRlbGV0ZSBzb3VyY2UuaG9zdDtcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIGRlbGV0ZSByZWxhdGl2ZS5ob3N0bmFtZTtcbiAgICAgIGRlbGV0ZSByZWxhdGl2ZS5wb3J0O1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgc291cmNlLmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiBzb3VyY2UuaG9zdDtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiBzb3VyY2UuaG9zdG5hbWU7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCdzZWFyY2gnIGluIHJlbGF0aXZlKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgc291cmNlLmhvc3RuYW1lID0gc291cmNlLmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gc291cmNlLmhvc3QgJiYgYXJyYXlJbmRleE9mKHNvdXJjZS5ob3N0LCAnQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHNvdXJjZS5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHNvdXJjZS5wYXRobmFtZSAhPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgc291cmNlLnBhdGggPSAoc291cmNlLnBhdGhuYW1lID8gc291cmNlLnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIGRlbGV0ZSBzb3VyY2UucGF0aG5hbWU7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghc291cmNlLnNlYXJjaCkge1xuICAgICAgc291cmNlLnBhdGggPSAnLycgKyBzb3VyY2Uuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgc291cmNlLnBhdGg7XG4gICAgfVxuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHNvdXJjZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIGFycmF5SW5kZXhPZihzb3VyY2UuaG9zdCwgJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgc291cmNlLmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHNvdXJjZS5ob3N0ID0gc291cmNlLmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChzb3VyY2UuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgc291cmNlLnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKHNvdXJjZS5wYXRobmFtZSAhPT0gdW5kZWZpbmVkIHx8IHNvdXJjZS5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc291cmNlLnNlYXJjaCA/IHNvdXJjZS5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgc291cmNlLmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHNvdXJjZS5hdXRoO1xuICBzb3VyY2Uuc2xhc2hlcyA9IHNvdXJjZS5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG9zdChob3N0KSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIG91dC5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSBvdXQuaG9zdG5hbWUgPSBob3N0O1xuICByZXR1cm4gb3V0O1xufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG4vLyBUaGlzIG1hcCBkZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBnZXQgcmUtZW1pdHRlZCBhcyBhbiAnYWxsJyBldmVudFxuTW9kZWwuTVVUQVRPUl9FVkVOVFMgPSB7XG4gIGNoYW5nZTogdHJ1ZVxuLCBpbnNlcnQ6IHRydWVcbiwgcmVtb3ZlOiB0cnVlXG4sIG1vdmU6IHRydWVcbiwgc3RyaW5nSW5zZXJ0OiB0cnVlXG4sIHN0cmluZ1JlbW92ZTogdHJ1ZVxuLCBsb2FkOiB0cnVlXG4sIHVubG9hZDogdHJ1ZVxufTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvLyBTZXQgbWF4IGxpc3RlbmVycyB0byB1bmxpbWl0ZWRcbiAgbW9kZWwuc2V0TWF4TGlzdGVuZXJzKDApO1xuXG4gIC8vIFVzZWQgaW4gYXN5bmMgbWV0aG9kcyB0byBlbWl0IGFuIGVycm9yIGV2ZW50IGlmIGEgY2FsbGJhY2sgaXMgbm90IHN1cHBsaWVkLlxuICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXMgbm8gaGFuZGxlciBmb3IgbW9kZWwub24oJ2Vycm9yJylcbiAgbW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrID0gZGVmYXVsdENhbGxiYWNrO1xuICBmdW5jdGlvbiBkZWZhdWx0Q2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSBlcnIgPSBuZXcgRXJyb3IoZXJyKTtcbiAgICBpZiAoZXJyKSBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBtb2RlbC5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gIG1vZGVsLl9wYXNzID0gbmV3IFBhc3NlZCh7fSwge30pO1xufSk7XG5cbnV0aWwubWVyZ2VJbnRvKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24sIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIsIGFuZFxuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlIHJldHVybiBgdGhpc2AuIFRoZSBNb2RlbCBlcXVpdmFsZW50cyByZXR1cm5cbi8vIHRoZSBsaXN0ZW5lciBpbnN0ZWFkLCBzaW5jZSBpdCBpcyBtYWRlIGludGVybmFsbHkgZm9yIG1ldGhvZCBzdWJzY3JpcHRpb25zXG4vLyBhbmQgbWF5IG5lZWQgdG8gYmUgcGFzc2VkIHRvIHJlbW92ZUxpc3RlbmVyLlxuXG5Nb2RlbC5wcm90b3R5cGUuX2VtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5Nb2RlbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKE1vZGVsLk1VVEFUT1JfRVZFTlRTW3R5cGVdKSB7XG4gICAgaWYgKHRoaXMuX3NpbGVudCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBldmVudEFyZ3MgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUpIHtcbiAgICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUucHVzaChbdHlwZSwgc2VnbWVudHMsIGV2ZW50QXJnc10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLl9lbWl0KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIHRoaXMuX2VtaXQoJ2FsbCcsIHNlZ21lbnRzLCBbdHlwZV0uY29uY2F0KGV2ZW50QXJncykpO1xuICAgIHdoaWxlICh0aGlzLnJvb3QuX211dGF0b3JFdmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIHF1ZXVlZCA9IHRoaXMucm9vdC5fbXV0YXRvckV2ZW50UXVldWUuc2hpZnQoKTtcbiAgICAgIHR5cGUgPSBxdWV1ZWRbMF07XG4gICAgICBzZWdtZW50cyA9IHF1ZXVlZFsxXTtcbiAgICAgIGV2ZW50QXJncyA9IHF1ZXVlZFsyXTtcbiAgICAgIHRoaXMuX2VtaXQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncyk7XG4gICAgICB0aGlzLl9lbWl0KCdhbGwnLCBzZWdtZW50cywgW3R5cGVdLmNvbmNhdChldmVudEFyZ3MpKTtcbiAgICB9XG4gICAgdGhpcy5yb290Ll9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fb24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuTW9kZWwucHJvdG90eXBlLmFkZExpc3RlbmVyID1cbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIGNiKSB7XG4gIHZhciBsaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXIodGhpcywgcGF0dGVybiwgY2IpO1xuICB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgcGF0dGVybiwgY2IpIHtcbiAgdmFyIGxpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcih0aGlzLCBwYXR0ZXJuLCBjYik7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChtYXRjaGVzKSB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICB9XG4gIHRoaXMuX29uKHR5cGUsIGcpO1xuICByZXR1cm4gZztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlQWxsTGlzdGVuZXJzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM7XG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSwgc3VicGF0dGVybikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gSWYgYSBwYXR0ZXJuIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGV2ZW50IHR5cGUsIHJlbW92ZSBhbGwgbW9kZWwgZXZlbnRcbiAgLy8gbGlzdGVuZXJzIHVuZGVyIHRoYXQgcGF0dGVybiBmb3IgYWxsIGV2ZW50c1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXksIHN1YnBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXRoKHN1YnBhdHRlcm4pO1xuICAvLyBJZiBubyBwYXR0ZXJuIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgbGlrZSBub3JtYWxcbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQgdW5kZXIgYSBwYXR0ZXJuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyh0eXBlKTtcbiAgdmFyIHNlZ21lbnRzID0gcGF0dGVybi5zcGxpdCgnLicpO1xuICAvLyBNYWtlIHN1cmUgdG8gaXRlcmF0ZSBpbiByZXZlcnNlLCBzaW5jZSB0aGUgYXJyYXkgbWlnaHQgYmVcbiAgLy8gbXV0YXRlZCBhcyBsaXN0ZW5lcnMgYXJlIHJlbW92ZWRcbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKHBhdHRlcm5Db250YWluZWQocGF0dGVybiwgc2VnbWVudHMsIGxpc3RlbmVyKSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBwYXR0ZXJuQ29udGFpbmVkKHBhdHRlcm4sIHNlZ21lbnRzLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdGVuZXJTZWdtZW50cyA9IGxpc3RlbmVyLnBhdHRlcm5TZWdtZW50cztcbiAgaWYgKCFsaXN0ZW5lclNlZ21lbnRzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYXR0ZXJuID09PSBsaXN0ZW5lci5wYXR0ZXJuIHx8IHBhdHRlcm4gPT09ICcqKicpIHJldHVybiB0cnVlO1xuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAobGVuID4gbGlzdGVuZXJTZWdtZW50cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gbGlzdGVuZXJTZWdtZW50c1tpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uKG9iamVjdCwgaW52ZXJ0KSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9wYXNzID0gKGludmVydCkgP1xuICAgIG5ldyBQYXNzZWQob2JqZWN0LCB0aGlzLl9wYXNzKSA6XG4gICAgbmV3IFBhc3NlZCh0aGlzLl9wYXNzLCBvYmplY3QpO1xuICByZXR1cm4gbW9kZWw7XG59O1xuXG5mdW5jdGlvbiBQYXNzZWQocHJldmlvdXMsIHZhbHVlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcmV2aW91cykge1xuICAgIHRoaXNba2V5XSA9IHByZXZpb3VzW2tleV07XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWVba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXR1cm5lZCBNb2RlbCB3aWxsIG9yIHdvbid0IHRyaWdnZXIgZXZlbnQgaGFuZGxlcnMgd2hlbiB0aGUgbW9kZWwgZW1pdHNcbiAqIGV2ZW50cywgZGVwZW5kaW5nIG9uIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Qm9vbGVhbnxOdWxsfSB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMuX2NoaWxkKCk7XG4gIG1vZGVsLl9zaWxlbnQgPSAodmFsdWUgPT0gbnVsbCkgPyB0cnVlIDogdmFsdWU7XG4gIHJldHVybiBtb2RlbDtcbn07XG5cbmZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIobW9kZWwsIHN1YnBhdHRlcm4sIGNiKSB7XG4gIGlmIChjYikge1xuICAgIC8vIEZvciBzaWduYXR1cmVzOlxuICAgIC8vIG1vZGVsLm9uKCdjaGFuZ2UnLCAnZXhhbXBsZS5zdWJwYXRoJywgY2FsbGJhY2spXG4gICAgLy8gbW9kZWwuYXQoJ2V4YW1wbGUnKS5vbignY2hhbmdlJywgJ3N1YnBhdGgnLCBjYWxsYmFjaylcbiAgICB2YXIgcGF0dGVybiA9IG1vZGVsLnBhdGgoc3VicGF0dGVybik7XG4gICAgcmV0dXJuIG1vZGVsRXZlbnRMaXN0ZW5lcihwYXR0ZXJuLCBjYik7XG4gIH1cbiAgdmFyIHBhdGggPSBtb2RlbC5wYXRoKCk7XG4gIGNiID0gYXJndW1lbnRzWzFdO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5hdCgnZXhhbXBsZScpLm9uKCdjaGFuZ2UnLCBjYWxsYmFjaylcbiAgaWYgKHBhdGgpIHJldHVybiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0aCwgY2IpO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5vbignbm9ybWFsRXZlbnQnLCBjYWxsYmFjaylcbiAgcmV0dXJuIGNiO1xufVxuXG5mdW5jdGlvbiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0dGVybiwgY2IpIHtcbiAgdmFyIHBhdHRlcm5TZWdtZW50cyA9IHBhdHRlcm4uc3BsaXQoJy4nKTtcbiAgdmFyIHRlc3RGbiA9IHRlc3RQYXR0ZXJuRm4ocGF0dGVybiwgcGF0dGVyblNlZ21lbnRzKTtcblxuICBmdW5jdGlvbiBtb2RlbExpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSB0ZXN0Rm4oc2VnbWVudHMpO1xuICAgIGlmICghY2FwdHVyZXMpIHJldHVybjtcblxuICAgIHZhciBhcmdzID0gKGNhcHR1cmVzLmxlbmd0aCkgPyBjYXB0dXJlcy5jb25jYXQoZXZlbnRBcmdzKSA6IGV2ZW50QXJncztcbiAgICBjYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgaW4gTW9kZWwjcmVtb3ZlQWxsTGlzdGVuZXJzXG4gIG1vZGVsTGlzdGVuZXIucGF0dGVybiA9IHBhdHRlcm47XG4gIG1vZGVsTGlzdGVuZXIucGF0dGVyblNlZ21lbnRzID0gcGF0dGVyblNlZ21lbnRzO1xuXG4gIHJldHVybiBtb2RlbExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiB0ZXN0UGF0dGVybkZuKHBhdHRlcm4sIHBhdHRlcm5TZWdtZW50cykge1xuICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgIHJldHVybiBmdW5jdGlvbiB0ZXN0UGF0dGVybihzZWdtZW50cykge1xuICAgICAgcmV0dXJuIFtzZWdtZW50cy5qb2luKCcuJyldO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5kaW5nUmVzdCA9IHN0cmlwUmVzdFdpbGRjYXJkKHBhdHRlcm5TZWdtZW50cyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRlc3RQYXR0ZXJuKHNlZ21lbnRzKSB7XG4gICAgLy8gQW55IHBhdHRlcm4gd2l0aCBtb3JlIHNlZ21lbnRzIGRvZXMgbm90IG1hdGNoXG4gICAgdmFyIHBhdHRlcm5MZW4gPSBwYXR0ZXJuU2VnbWVudHMubGVuZ3RoO1xuICAgIGlmIChwYXR0ZXJuTGVuID4gc2VnbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvLyBBIHBhdHRlcm4gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2Ygc2VnbWVudHMgbWF0Y2hlcyBpZiBlYWNoXG4gICAgLy8gb2YgdGhlIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuIEEgc2hvcnRlciBwYXR0ZXJuIG1hdGNoZXNcbiAgICAvLyBpZiBpdCBlbmRzIGluIGEgcmVzdCB3aWxkY2FyZCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuXG4gICAgaWYgKHBhdHRlcm5MZW4gPT09IHNlZ21lbnRzLmxlbmd0aCB8fCBlbmRpbmdSZXN0KSB7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuU2VnbWVudCA9IHBhdHRlcm5TZWdtZW50c1tpXTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHBhdHRlcm5TZWdtZW50ID09PSAnKicgfHwgcGF0dGVyblNlZ21lbnQgPT09ICcqKicpIHtcbiAgICAgICAgICBjYXB0dXJlcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuU2VnbWVudCAhPT0gc2VnbWVudCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuZGluZ1Jlc3QpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHNlZ21lbnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcbiAgICAgICAgY2FwdHVyZXMucHVzaChyZW1haW5kZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmVzO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBSZXN0V2lsZGNhcmQoc2VnbWVudHMpIHtcbiAgLy8gWydleGFtcGxlJywgJyoqJ10gLT4gWydleGFtcGxlJ107IHJldHVybiB0cnVlXG4gIHZhciBsYXN0SW5kZXggPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuICBpZiAoc2VnbWVudHNbbGFzdEluZGV4XSA9PT0gJyoqJykge1xuICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIFsnZXhhbXBsZScsICdzdWJwYXRoKionXSAtPiBbJ2V4YW1wbGUnLCAnc3VicGF0aCddOyByZXR1cm4gdHJ1ZVxuICB2YXIgbWF0Y2ggPSAvXihbXlxcKl0rKVxcKlxcKiQvLmV4ZWMoc2VnbWVudHNbbGFzdEluZGV4XSk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWxzZTtcbiAgc2VnbWVudHNbbGFzdEluZGV4XSA9IG1hdGNoWzFdO1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuZXhwb3J0cy5taXhpbiA9IHt9O1xuXG5Nb2RlbC5wcm90b3R5cGUuX3NwbGl0UGF0aCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHJldHVybiAocGF0aCAmJiBwYXRoLnNwbGl0KCcuJykpIHx8IFtdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIGVxdWl2YWxlbnQgdG8gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgc2NvcGVkIG1vZGVsIHBsdXNcbiAqIChvcHRpb25hbGx5KSBhIHN1ZmZpeCBzdWJwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBzdWJwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGFic29sdXRlIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICBpZiAoc3VicGF0aCA9PSBudWxsIHx8IHN1YnBhdGggPT09ICcnKSByZXR1cm4gKHRoaXMuX2F0KSA/IHRoaXMuX2F0IDogJyc7XG4gIGlmICh0eXBlb2Ygc3VicGF0aCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHN1YnBhdGggPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICh0aGlzLl9hdCkgPyB0aGlzLl9hdCArICcuJyArIHN1YnBhdGggOiAnJyArIHN1YnBhdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdWJwYXRoLnBhdGggPT09ICdmdW5jdGlvbicpIHJldHVybiBzdWJwYXRoLnBhdGgoKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pc1BhdGggPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHJldHVybiB0aGlzLnBhdGgoc3VicGF0aCkgIT0gbnVsbDtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zY29wZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5fY2hpbGQoKTtcbiAgbW9kZWwuX2F0ID0gcGF0aDtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBtb2RlbCBvYmplY3Qgc2NvcGVkIHRvIGEgcGFydGljdWxhciBwYXRoLlxuICogRXhhbXBsZTpcbiAqICAgICB2YXIgdXNlciA9IG1vZGVsLmF0KCd1c2Vycy4xJyk7XG4gKiAgICAgdXNlci5zZXQoJ3VzZXJuYW1lJywgJ2JyaWFuJyk7XG4gKiAgICAgdXNlci5vbigncHVzaCcsICd0b2RvcycsIGZ1bmN0aW9uICh0b2RvKSB7XG4gKiAgICAgICAvLyAuLi5cbiAqICAgICB9KTtcbiAqXG4gKiAgQHBhcmFtIHtTdHJpbmd9IHNlZ21lbnRcbiAqICBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqICBAYXBpIHB1YmxpY1xuICovXG5Nb2RlbC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHZhciBwYXRoID0gdGhpcy5wYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG1vZGVsIHNjb3BlIHRoYXQgaXMgYSBudW1iZXIgb2YgbGV2ZWxzIGFib3ZlIHRoZSBjdXJyZW50IHNjb3BlZFxuICogcGF0aC4gTnVtYmVyIG9mIGxldmVscyBkZWZhdWx0cyB0byAxLCBzbyB0aGlzIG1ldGhvZCBjYWxsZWQgd2l0aG91dFxuICogYXJndW1lbnRzIHJldHVybnMgdGhlIG1vZGVsIHNjb3BlJ3MgcGFyZW50IG1vZGVsIHNjb3BlLlxuICpcbiAqIEBvcHRpb25hbCBAcGFyYW0ge051bWJlcn0gbGV2ZWxzXG4gKiBAcmV0dXJuIHtNb2RlbH0gYSBzY29wZWQgbW9kZWxcbiAqL1xuTW9kZWwucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKGxldmVscykge1xuICBpZiAobGV2ZWxzID09IG51bGwpIGxldmVscyA9IDE7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aCgpO1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgc2VnbWVudHMubGVuZ3RoIC0gbGV2ZWxzKTtcbiAgdmFyIHBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBsZW4pLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUocGF0aCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgcHJvcGVydHkgc2VnbWVudCBvZiB0aGUgY3VycmVudCBtb2RlbCBzY29wZSBwYXRoXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbk1vZGVsLnByb3RvdHlwZS5sZWFmID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXBhdGgpIHBhdGggPSB0aGlzLnBhdGgoKTtcbiAgdmFyIGkgPSBwYXRoLmxhc3RJbmRleE9mKCcuJyk7XG4gIHJldHVybiBwYXRoLnNsaWNlKGkgKyAxKTtcbn07XG4iLCJ2YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgTG9jYWxEb2MgPSByZXF1aXJlKCcuL0xvY2FsRG9jJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gQ29sbGVjdGlvbk1hcCgpIHt9XG5mdW5jdGlvbiBNb2RlbERhdGEoKSB7fVxuZnVuY3Rpb24gRG9jTWFwKCkge31cbmZ1bmN0aW9uIENvbGxlY3Rpb25EYXRhKCkge31cblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5yb290LmNvbGxlY3Rpb25zID0gbmV3IENvbGxlY3Rpb25NYXA7XG4gIG1vZGVsLnJvb3QuZGF0YSA9IG5ldyBNb2RlbERhdGE7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmdldENvbGxlY3Rpb24gPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSkge1xuICByZXR1cm4gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5yb290LmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kb2NzW2lkXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9nZXQoc2VnbWVudHMpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHV0aWwubG9va3VwKHNlZ21lbnRzLCB0aGlzLnJvb3QuZGF0YSk7XG59O1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV07XG4gIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgdmFyIERvYyA9IHRoaXMuX2dldERvY0NvbnN0cnVjdG9yKG5hbWUpO1xuICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24odGhpcy5yb290LCBuYW1lLCBEb2MpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbbmFtZV0gPSBjb2xsZWN0aW9uO1xuICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2dldERvY0NvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgY3JlYXRlIGxvY2FsIGRvY3VtZW50cy4gVGhpcyBpcyBvdmVycmlkZW4gaW4gLi9jb25uZWN0aW9uLmpzLCBzbyB0aGF0XG4gIC8vIHRoZSBSZW1vdGVEb2MgYmVoYXZpb3IgY2FuIGJlIHNlbGVjdGl2ZWx5IGluY2x1ZGVkXG4gIHJldHVybiBMb2NhbERvYztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBleGlzdGluZyBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbi4gSWYgdGhlIGRvY3VtZW50IGRvZXNcbiAqIG5vdCBleGlzdCwgdGhlbiBjcmVhdGVzIHRoZSBkb2N1bWVudCB3aXRoIGlkIGluIGEgY29sbGVjdGlvbiBhbmQgcmV0dXJucyB0aGVcbiAqIG5ldyBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIGRhdGEgdG8gY3JlYXRlIGlmIGRvYyB3aXRoIGlkIGRvZXMgbm90IGV4aXN0IGluIGNvbGxlY3Rpb25cbiAqL1xuTW9kZWwucHJvdG90eXBlLmdldE9yQ3JlYXRlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5nZXRPckNyZWF0ZUNvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICByZXR1cm4gY29sbGVjdGlvbi5kb2NzW2lkXSB8fCBjb2xsZWN0aW9uLmFkZChpZCwgZGF0YSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICovXG5Nb2RlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lKSB7XG4gIC8vIFRPRE86IG5vbi1jb2xsZWN0aW9uc1xuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSk7XG4gIGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5kZXN0cm95KCk7XG4gIHRoaXMucmVtb3ZlQWxsUmVmcyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMuc3RvcEFsbChjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsRmlsdGVycyhjb2xsZWN0aW9uTmFtZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG51bGwsIGNvbGxlY3Rpb25OYW1lKTtcbn07XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obW9kZWwsIG5hbWUsIERvYykge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuRG9jID0gRG9jO1xuICB0aGlzLmRvY3MgPSBuZXcgRG9jTWFwKCk7XG4gIHRoaXMuZGF0YSA9IG1vZGVsLmRhdGFbbmFtZV0gPSBuZXcgQ29sbGVjdGlvbkRhdGEoKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZG9jdW1lbnQgd2l0aCBgaWRgIGFuZCBgZGF0YWAgdG8gYHRoaXNgIENvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtMb2NhbERvY3xSZW1vdGVEb2N9IGRvY1xuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpZCwgZGF0YSkge1xuICB2YXIgZG9jID0gbmV3IHRoaXMuRG9jKHRoaXMubW9kZWwsIHRoaXMubmFtZSwgaWQsIGRhdGEpO1xuICB0aGlzLmRvY3NbaWRdID0gZG9jO1xuICByZXR1cm4gZG9jO1xufTtcbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMubW9kZWwuY29sbGVjdGlvbnNbdGhpcy5uYW1lXTtcbiAgZGVsZXRlIHRoaXMubW9kZWwuZGF0YVt0aGlzLm5hbWVdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCB3aXRoIGBpZGAgZnJvbSBgdGhpc2AgQ29sbGVjdGlvbi4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAqIGRvY3VtZW50cyBpbiB0aGUgQ29sbGVjdGlvbiBhZnRlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgaXMgcmVtb3ZlZCwgdGhlbiB0aGlzXG4gKiBhbHNvIGRlc3Ryb3lzIHRoZSBDb2xsZWN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLmRvY3NbaWRdO1xuICBkZWxldGUgdGhpcy5kYXRhW2lkXTtcbiAgaWYgKG5vS2V5cyh0aGlzLmRvY3MpKSB0aGlzLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBtYXBzIGRvYyBpZHMgdG8gZnVsbHkgcmVzb2x2ZWQgZG9jdW1lbnRzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YTtcbn07XG5cbmZ1bmN0aW9uIG5vS2V5cyhvYmplY3QpIHtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX211dGF0ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdmFyIGNvbGxlY3Rpb25OYW1lID0gc2VnbWVudHNbMF07XG4gIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICBpZiAoIWNvbGxlY3Rpb25OYW1lIHx8ICFpZCkge1xuICAgIHZhciBtZXNzYWdlID0gZm4ubmFtZSArICcgbXVzdCBiZSBwZXJmb3JtZWQgdW5kZXIgYSBjb2xsZWN0aW9uICcgK1xuICAgICAgJ2FuZCBkb2N1bWVudCBpZC4gSW52YWxpZCBwYXRoOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHZhciBkb2MgPSB0aGlzLmdldE9yQ3JlYXRlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICByZXR1cm4gZm4oZG9jLCBkb2NTZWdtZW50cywgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2V0KHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHNldCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldEVhY2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIG9iamVjdCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgb2JqZWN0ID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIG9iamVjdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zZXRFYWNoKHNlZ21lbnRzLCBvYmplY3QsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldEVhY2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2JqZWN0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrKTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIHRoaXMuX3NldChzZWdtZW50cy5jb25jYXQoa2V5KSwgdmFsdWUsIGdyb3VwKCkpO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fYWRkKHNlZ21lbnRzLCB2YWx1ZSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHZhciBtZXNzYWdlID0gJ2FkZCByZXF1aXJlcyBhbiBvYmplY3QgdmFsdWUuIEludmFsaWQgdmFsdWU6ICcgKyB2YWx1ZTtcbiAgICBjYiB8fCAoY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjayk7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH1cbiAgdmFyIGlkID0gdmFsdWUuaWQgfHwgdGhpcy5pZCgpO1xuICB2YWx1ZS5pZCA9IGlkO1xuICB0aGlzLl9zZXQoc2VnbWVudHMuY29uY2F0KGlkKSwgdmFsdWUsIGNiKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldE51bGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldE51bGwoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXROdWxsID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0TnVsbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmdldChkb2NTZWdtZW50cyk7XG4gICAgaWYgKHByZXZpb3VzICE9IG51bGwpIHtcbiAgICAgIGZuQ2IoKTtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gICAgZG9jLnNldChkb2NTZWdtZW50cywgdmFsdWUsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXROdWxsLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVsKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIGRlbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZm5DYik7XG4gICAgLy8gV2hlbiBkZWxldGluZyBhbiBlbnRpcmUgZG9jdW1lbnQsIGFsc28gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlXG4gICAgLy8gZG9jdW1lbnQgb2JqZWN0IGZyb20gaXRzIGNvbGxlY3Rpb25cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgICAgIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICAgICAgbW9kZWwucm9vdC5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV0ucmVtb3ZlKGlkKTtcbiAgICB9XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2b2lkIDAsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBkZWwsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGJ5TnVtYmVyLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgYnlOdW1iZXIgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5faW5jcmVtZW50KHNlZ21lbnRzLCBieU51bWJlciwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5faW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgaWYgKGJ5TnVtYmVyID09IG51bGwpIGJ5TnVtYmVyID0gMTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5jcmVtZW50KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgdmFsdWUgPSBkb2MuaW5jcmVtZW50KGRvY1NlZ21lbnRzLCBieU51bWJlciwgZm5DYik7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUgLSBieU51bWJlcjtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5jcmVtZW50LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcHVzaChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBwdXNoKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnB1c2goZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBwdXNoLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgY2IgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fdW5zaGlmdChzZWdtZW50cywgdmFsdWUsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiB1bnNoaWZ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgbGVuZ3RoID0gZG9jLnVuc2hpZnQoZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgWzAsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCB1bnNoaWZ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdmFsdWVzLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3IgaW5zZXJ0JykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZXMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX2luc2VydChzZWdtZW50cywgK2luZGV4LCB2YWx1ZXMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgaW5zZXJ0ZWQgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgIHZhciBsZW5ndGggPSBkb2MuaW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgaW5zZXJ0ZWQsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIGluc2VydGVkLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcG9wKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHBvcChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2MucG9wKGRvY1NlZ21lbnRzLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2hpZnQoc2VnbWVudHMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzaGlmdChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2Muc2hpZnQoZG9jU2VnbWVudHMsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ3JlbW92ZScsIHNlZ21lbnRzLCBbMCwgW3ZhbHVlXSwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIGluZGV4ID0gc2VnbWVudHMucG9wKCk7XG4gIHJldHVybiB0aGlzLl9yZW1vdmUoc2VnbWVudHMsICtpbmRleCwgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgaWYgKGhvd01hbnkgPT0gbnVsbCkgaG93TWFueSA9IDE7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHJlbW92ZShkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpbmRleCwgcmVtb3ZlZCwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBmcm9tLCB0bywgaG93TWFueSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIG1vdmUnKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZyb20gPSBhcmd1bWVudHNbMV07XG4gICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1szXTtcbiAgICBjYiA9IGFyZ3VtZW50c1s0XTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9tb3ZlKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIGlmIChob3dNYW55ID09IG51bGwpIGhvd01hbnkgPSAxO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBtb3ZlKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICAvLyBDYXN0IHRvIG51bWJlcnNcbiAgICBmcm9tID0gK2Zyb207XG4gICAgdG8gPSArdG87XG4gICAgLy8gQ29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIGludG8gcG9zaXRpdmVcbiAgICBpZiAoZnJvbSA8IDAgfHwgdG8gPCAwKSB7XG4gICAgICB2YXIgbGVuID0gZG9jLmdldChkb2NTZWdtZW50cykubGVuZ3RoO1xuICAgICAgaWYgKGZyb20gPCAwKSBmcm9tICs9IGxlbjtcbiAgICAgIGlmICh0byA8IDApIHRvICs9IGxlbjtcbiAgICB9XG4gICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMsIFtmcm9tLCB0bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdGV4dCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIHN0cmluZ0luc2VydCcpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB0ZXh0ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHRleHQgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc3RyaW5nSW5zZXJ0KHNlZ21lbnRzLCBpbmRleCwgdGV4dCwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB0ZXh0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc3RyaW5nSW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgdGV4dCwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nSW5zZXJ0Jywgc2VnbWVudHMsIFtpbmRleCwgdGV4dCwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICB2YXIgcGFzcyA9IG1vZGVsLnBhc3MoeyRvcmlnaW5hbDogJ3N0cmluZ0luc2VydCd9KS5fcGFzcztcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgcGFzc10pO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Igc3RyaW5nUmVtb3ZlJykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICBjYiA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zdHJpbmdSZW1vdmUoc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzdHJpbmdSZW1vdmUoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5zdHJpbmdSZW1vdmUoZG9jU2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBwYXNzID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBwYXNzXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHN0cmluZ1JlbW92ZSwgY2IpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vUXVlcnknKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICBtb2RlbC5yb290LmZldGNoT25seSA9IG9wdGlvbnMuZmV0Y2hPbmx5O1xuICBtb2RlbC5yb290LnVubG9hZERlbGF5ID0gb3B0aW9ucy51bmxvYWREZWxheSB8fCAxMDAwO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBjb3VudCBvZiBmZXRjaGVzICh0aGF0IGhhdmVuJ3QgYmVlbiB1bmRvbmUgYnkgYW5cbiAgLy8gdW5mZXRjaCkgcGVyIGRvYy4gTWFwcyBkb2MgaWQgdG8gdGhlIGZldGNoIGNvdW50LlxuICBtb2RlbC5yb290Ll9mZXRjaGVkRG9jcyA9IG5ldyBGZXRjaGVkRG9jcztcblxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgY291bnQgb2Ygc3Vic2NyaWJlcyAodGhhdCBoYXZlbid0IGJlZW4gdW5kb25lIGJ5IGFuXG4gIC8vIHVuc3Vic2NyaWJlKSBwZXIgZG9jLiBNYXBzIGRvYyBpZCB0byB0aGUgc3Vic2NyaWJlIGNvdW50LlxuICBtb2RlbC5yb290Ll9zdWJzY3JpYmVkRG9jcyA9IG5ldyBTdWJzY3JpYmVkRG9jcztcblxuICAvLyBNYXBzIGRvYyBwYXRoIHRvIGRvYyB2ZXJzaW9uXG4gIG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9ucyA9IG5ldyBMb2FkVmVyc2lvbnM7XG59KTtcblxuZnVuY3Rpb24gRmV0Y2hlZERvY3MoKSB7fVxuZnVuY3Rpb24gU3Vic2NyaWJlZERvY3MoKSB7fVxuZnVuY3Rpb24gTG9hZFZlcnNpb25zKCkge31cblxuTW9kZWwucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdmZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUudW5mZXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9mb3JTdWJzY3JpYmFibGUoYXJndW1lbnRzLCAndW5mZXRjaCcpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICdzdWJzY3JpYmUnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICd1bnN1YnNjcmliZScpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBhcmd1bWVudHNPYmplY3QgY2FuIHRha2UgMSBvZiB0d28gZm9ybXNcbiAqICAgMS4gW1tzdWJzY3JpYmFibGVPYmplY3RzLi4uXSwgY2JdXG4gKiAgIDIuIFtzdWJzY3JpYmFibGVPYmplY3RzLi4uLCBjYl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgY2FuIGJlICdmZXRjaCcsICd1bmZldGNoJywgJ3N1YnNjcmliZScsICd1bnN1YnNjcmliZSdcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9mb3JTdWJzY3JpYmFibGUgPSBmdW5jdGlvbihhcmd1bWVudHNPYmplY3QsIG1ldGhvZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNPYmplY3RbMF0pKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNPYmplY3RbMF07XG4gICAgdmFyIGNiID0gYXJndW1lbnRzT2JqZWN0WzFdIHx8IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzT2JqZWN0KTtcbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgY2IgPSAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpID8gYXJncy5wb3AoKSA6IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB9XG4gIC8vIElmIG5vIHF1ZXJpZXMgb3IgcGF0aHMgYXJlIHBhc3NlZCBpbiwgdHJ5IHRvIHVzZSB0aGlzIG1vZGVsJ3Mgc2NvcGVcbiAgaWYgKCFhcmdzLmxlbmd0aCkgYXJncy5wdXNoKG51bGwpO1xuICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICB2YXIgZG9jTWV0aG9kID0gbWV0aG9kICsgJ0RvYyc7XG5cbiAgdmFyIGZpbmlzaGVkID0gZ3JvdXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUXVlcnkpIHtcbiAgICAgIGl0ZW1bbWV0aG9kXShncm91cCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2UodGhpcy5fc3BsaXRQYXRoKGl0ZW0pKTtcbiAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gRG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBmb3IgYSBzaW5nbGUgZG9jdW1lbnQuXG4gICAgICAgIHRoaXNbZG9jTWV0aG9kXShzZWdtZW50c1swXSwgc2VnbWVudHNbMV0sIGdyb3VwKCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gTWFrZSBhIHF1ZXJ5IHRvIGFuIGVudGlyZSBjb2xsZWN0aW9uLlxuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5KHNlZ21lbnRzWzBdLCB7fSk7XG4gICAgICAgIHF1ZXJ5W21ldGhvZF0oZ3JvdXAoKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ05vIHBhdGggc3BlY2lmaWVkIGZvciAnICsgbWV0aG9kKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ0Nhbm5vdCAnICsgbWV0aG9kICsgJyB0byBhIHBhdGggd2l0aGluIGEgZG9jdW1lbnQ6ICcgK1xuICAgICAgICAgICAgc2VnbWVudHMuam9pbignLicpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaGVkKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFscmVhZHlMb2FkZWRcbiAqL1xuTW9kZWwucHJvdG90eXBlLmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYiwgYWxyZWFkeUxvYWRlZCkge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuXG4gIC8vIE1haW50YWluIGEgY291bnQgb2YgZmV0Y2hlcyBzbyB0aGF0IHdlIGNhbiB1bmxvYWQgdGhlIGRvY3VtZW50IHdoZW5cbiAgLy8gdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgZm9yIHRoYXQgZG9jdW1lbnRcbiAgdmFyIHBhdGggPSBjb2xsZWN0aW9uTmFtZSArICcuJyArIGlkO1xuICB0aGlzLmVtaXQoJ2ZldGNoRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHRoaXMucm9vdC5fZmV0Y2hlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9mZXRjaGVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG5cbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKGFscmVhZHlMb2FkZWQpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZldGNoRG9jQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGRvYy5zaGFyZURvYy5mZXRjaChmZXRjaERvY0NhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBmZXRjaERvY0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIGlmIChkb2Muc2hhcmVEb2MudmVyc2lvbiAhPT0gbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdKSB7XG4gICAgICBtb2RlbC5yb290Ll9sb2FkVmVyc2lvbnNbcGF0aF0gPSBkb2Muc2hhcmVEb2MudmVyc2lvbjtcbiAgICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2xvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW2RvYy5nZXQoKSwgbW9kZWwuX3Bhc3NdKTtcbiAgICB9XG4gICAgY2IoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBvZiB0aGUgZG9jdW1lbnQgd2Ugd2FudCB0byBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuTW9kZWwucHJvdG90eXBlLnN1YnNjcmliZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcblxuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgnc3Vic2NyaWJlRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHZhciBjb3VudCA9IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSAodGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jc1twYXRoXSB8fCAwKSArIDE7XG4gIC8vIEFscmVhZHkgcmVxdWVzdGVkIGEgc3Vic2NyaWJlLCBzbyBqdXN0IHJldHVyblxuICBpZiAoY291bnQgPiAxKSByZXR1cm4gY2IoKTtcblxuICAvLyBTdWJzY3JpYmUgaWYgY3VycmVudGx5IHVuc3Vic2NyaWJlZFxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICB2YXIgZG9jID0gdGhpcy5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICBpZiAodGhpcy5yb290LmZldGNoT25seSkge1xuICAgIC8vIE9ubHkgZmV0Y2ggaWYgdGhlIGRvY3VtZW50IGlzbid0IGFscmVhZHkgbG9hZGVkXG4gICAgaWYgKGRvYy5nZXQoKSA9PT0gdm9pZCAwKSB7XG4gICAgICBkb2Muc2hhcmVEb2MuZmV0Y2goc3Vic2NyaWJlRG9jQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9jLnNoYXJlRG9jLnN1YnNjcmliZShzdWJzY3JpYmVEb2NDYWxsYmFjayk7XG4gIH1cbiAgZnVuY3Rpb24gc3Vic2NyaWJlRG9jQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgaWYgKCFkb2MuY3JlYXRlZExvY2FsbHkgJiYgZG9jLnNoYXJlRG9jLnZlcnNpb24gIT09IG1vZGVsLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXSkge1xuICAgICAgbW9kZWwucm9vdC5fbG9hZFZlcnNpb25zW3BhdGhdID0gZG9jLnNoYXJlRG9jLnZlcnNpb247XG4gICAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgICBtb2RlbC5lbWl0KCdsb2FkJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFtkb2MuZ2V0KCksIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICAgIGNiKCk7XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5mZXRjaERvYycsIHBhdGgsIHRoaXMuX2NvbnRleHQsIHRoaXMuX3Bhc3MpO1xuICB2YXIgZmV0Y2hlZERvY3MgPSB0aGlzLnJvb3QuX2ZldGNoZWREb2NzO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgZG9jdW1lbnQgaGFzIG5vIGZldGNoIGNvdW50XG4gIGlmICghZmV0Y2hlZERvY3NbcGF0aF0pIHJldHVybiBjYigpO1xuXG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGlmICh0aGlzLnJvb3QudW5sb2FkRGVsYXkgJiYgIXRoaXMuX3Bhc3MuJHF1ZXJ5KSB7XG4gICAgc2V0VGltZW91dChmaW5pc2hVbmZldGNoRG9jLCB0aGlzLnJvb3QudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuZmV0Y2hEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbmZldGNoRG9jKCkge1xuICAgIHZhciBjb3VudCA9IC0tZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuICAgIGRlbGV0ZSBmZXRjaGVkRG9jc1twYXRoXTtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuTW9kZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVEb2MnLCBwYXRoLCB0aGlzLl9jb250ZXh0LCB0aGlzLl9wYXNzKTtcbiAgdmFyIHN1YnNjcmliZWREb2NzID0gdGhpcy5yb290Ll9zdWJzY3JpYmVkRG9jcztcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgc3Vic2NyaWJlZFxuICBpZiAoIXN1YnNjcmliZWREb2NzW3BhdGhdKSByZXR1cm4gY2IoKTtcblxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBpZiAodGhpcy5yb290LnVubG9hZERlbGF5ICYmICF0aGlzLl9wYXNzLiRxdWVyeSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5zdWJzY3JpYmVEb2MsIHRoaXMucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbnN1YnNjcmliZURvYygpIHtcbiAgICB2YXIgY291bnQgPSAtLXN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJlbWFpbmluZyBzdWJzY3JpcHRpb25zLCBvbmx5IGRlY3JlbWVudCB0aGUgY291bnRcbiAgICAvLyBhbmQgY2FsbGJhY2sgd2l0aCBob3cgbWFueSBzdWJzY3JpcHRpb25zIGFyZSByZW1haW5pbmdcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSByZW1haW5pbmcgc3Vic2NyaXB0aW9uLCBhY3R1YWxseSB1bnN1YnNjcmliZVxuICAgIGRlbGV0ZSBzdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICBpZiAobW9kZWwucm9vdC5mZXRjaE9ubHkpIHtcbiAgICAgIHVuc3Vic2NyaWJlRG9jQ2FsbGJhY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNoYXJlRG9jID0gbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gICAgICBpZiAoIXNoYXJlRG9jKSB7XG4gICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NoYXJlIGRvY3VtZW50IG5vdCBmb3VuZCBmb3I6ICcgKyBwYXRoKSk7XG4gICAgICB9XG4gICAgICBzaGFyZURvYy51bnN1YnNjcmliZSh1bnN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdW5zdWJzY3JpYmVEb2NDYWxsYmFjayhlcnIpIHtcbiAgICBtb2RlbC5fbWF5YmVVbmxvYWREb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKTtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiB0aGUgbW9kZWwgbm8gbG9uZ2VyIGhhcyBhbnlcbiAqIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgb24gcGF0aC5cbiAqIENhbGxlZCBmcm9tIE1vZGVsLnByb3RvdHlwZS51bmZldGNoRG9jIGFuZCBNb2RlbC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgYXNcbiAqIHBhcnQgb2YgYXR0ZW1wdGVkIGNsZWFudXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9tYXliZVVubG9hZERvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgcGF0aCkge1xuICB2YXIgZG9jID0gdGhpcy5nZXREb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKCFkb2MpIHJldHVybjtcbiAgLy8gUmVtb3ZlIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBsb2NhbCBtb2RlbCBpZiBpdCBubyBsb25nZXIgaGFzIGFueVxuICAvLyByZW1haW5pbmcgZmV0Y2hlcyBvciBzdWJzY3JpYmVzXG4gIGlmICh0aGlzLnJvb3QuX2ZldGNoZWREb2NzW3BhdGhdIHx8IHRoaXMucm9vdC5fc3Vic2NyaWJlZERvY3NbcGF0aF0pIHJldHVybjtcbiAgdmFyIHByZXZpb3VzID0gZG9jLmdldCgpO1xuICB0aGlzLnJvb3QuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdLnJlbW92ZShpZCk7XG4gIGlmIChkb2Muc2hhcmVEb2MpIGRvYy5zaGFyZURvYy5kZXN0cm95KCk7XG4gIGRlbGV0ZSB0aGlzLnJvb3QuX2xvYWRWZXJzaW9uc1twYXRoXTtcbiAgdGhpcy5lbWl0KCd1bmxvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ByZXZpb3VzLCB0aGlzLl9wYXNzXSk7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBDb250ZXh0cyBhcmUgdXNlZnVsIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBvcmlnaW4gb2Ygc3Vic2NyaWJlcy5cbiAqL1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL1F1ZXJ5Jyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fY29udGV4dHMgPSBuZXcgQ29udGV4dHM7XG4gIG1vZGVsLnNldENvbnRleHQoJ3Jvb3QnKTtcbiAgWyAnZmV0Y2hEb2MnLCAnc3Vic2NyaWJlRG9jJywgJ3VuZmV0Y2hEb2MnLCAndW5zdWJzY3JpYmVEb2MnXG4gICwgJ2ZldGNoUXVlcnknLCAnc3Vic2NyaWJlUXVlcnknLCAndW5mZXRjaFF1ZXJ5JywgJ3Vuc3Vic2NyaWJlUXVlcnknXG4gIF0uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgIG1vZGVsLm9uKGV2ZW50LCBmdW5jdGlvbihpdGVtLCBjb250ZXh0LCBwYXNzKSB7XG4gICAgICBjb250ZXh0W2V2ZW50XShpdGVtLCBwYXNzKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLl9jaGlsZCgpO1xuICBtb2RlbC5zZXRDb250ZXh0KGlkKTtcbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdIHx8IG5ldyBDb250ZXh0KHRoaXMsIGlkKTtcbiAgdGhpcy5fY29udGV4dCA9IHRoaXMucm9vdC5fY29udGV4dHNbaWRdID0gY29udGV4dDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGNvbnRleHQgPSAoaWQpID8gdGhpcy5yb290Ll9jb250ZXh0c1tpZF0gOiB0aGlzLl9jb250ZXh0O1xuICBjb250ZXh0LnVubG9hZCgpO1xufTtcblxuZnVuY3Rpb24gQ29udGV4dHMoKSB7fVxuXG5mdW5jdGlvbiBGZXRjaGVkRG9jcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkRG9jcygpIHt9XG5mdW5jdGlvbiBGZXRjaGVkUXVlcmllcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkUXVlcmllcygpIHt9XG5cbmZ1bmN0aW9uIENvbnRleHQobW9kZWwsIGlkKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmZldGNoZWREb2NzID0gbmV3IEZldGNoZWREb2NzO1xuICB0aGlzLnN1YnNjcmliZWREb2NzID0gbmV3IFN1YnNjcmliZWREb2NzO1xuICB0aGlzLmZldGNoZWRRdWVyaWVzID0gbmV3IEZldGNoZWRRdWVyaWVzO1xuICB0aGlzLnN1YnNjcmliZWRRdWVyaWVzID0gbmV3IFN1YnNjcmliZWRRdWVyaWVzO1xufVxuXG5Db250ZXh0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBmZXRjaGVkRG9jczogdGhpcy5mZXRjaGVkRG9jc1xuICAsIHN1YnNjcmliZWREb2NzOiB0aGlzLnN1YnNjcmliZWREb2NzXG4gICwgZmV0Y2hlZFF1ZXJpZXM6IHRoaXMuZmV0Y2hlZFF1ZXJpZXNcbiAgLCBzdWJzY3JpYmVkUXVlcmllczogdGhpcy5zdWJzY3JpYmVkUXVlcmllc1xuICB9O1xufTtcblxuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBJbmNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwSW5jcmVtZW50KHRoaXMuc3Vic2NyaWJlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnVuZmV0Y2hEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgPSBmdW5jdGlvbihwYXRoLCBwYXNzKSB7XG4gIGlmIChwYXNzLiRxdWVyeSkgcmV0dXJuO1xuICBtYXBEZWNyZW1lbnQodGhpcy5zdWJzY3JpYmVkRG9jcywgcGF0aCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuZmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLmZldGNoZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcEluY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS51bmZldGNoUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBEZWNyZW1lbnQodGhpcy5mZXRjaGVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5zdWJzY3JpYmVRdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIG1hcERlY3JlbWVudCh0aGlzLnN1YnNjcmliZWRRdWVyaWVzLCBxdWVyeS5oYXNoKTtcbn07XG5mdW5jdGlvbiBtYXBJbmNyZW1lbnQobWFwLCBrZXkpIHtcbiAgbWFwW2tleV0gPSAobWFwW2tleV0gfHwgMCkgKyAxO1xufVxuZnVuY3Rpb24gbWFwRGVjcmVtZW50KG1hcCwga2V5KSB7XG4gIG1hcFtrZXldICYmIG1hcFtrZXldLS07XG4gIGlmICghbWFwW2tleV0pIGRlbGV0ZSBtYXBba2V5XTtcbn1cblxuQ29udGV4dC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIGZvciAodmFyIGhhc2ggaW4gdGhpcy5mZXRjaGVkUXVlcmllcykge1xuICAgIHZhciBxdWVyeSA9IG1vZGVsLnJvb3QuX3F1ZXJpZXMubWFwW2hhc2hdO1xuICAgIGlmICghcXVlcnkpIGNvbnRpbnVlO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZFF1ZXJpZXNbaGFzaF07XG4gICAgd2hpbGUgKGNvdW50LS0pIHF1ZXJ5LnVuZmV0Y2gobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLnN1YnNjcmliZWRRdWVyaWVzKSB7XG4gICAgdmFyIHF1ZXJ5ID0gbW9kZWwucm9vdC5fcXVlcmllcy5tYXBbaGFzaF07XG4gICAgaWYgKCFxdWVyeSkgY29udGludWU7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkUXVlcmllc1toYXNoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkudW5zdWJzY3JpYmUobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgcGF0aCBpbiB0aGlzLmZldGNoZWREb2NzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgd2hpbGUgKGNvdW50LS0pIG1vZGVsLnVuZmV0Y2hEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBmb3IgKHZhciBwYXRoIGluIHRoaXMuc3Vic2NyaWJlZERvY3MpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgbW9kZWwudW5zdWJzY3JpYmVEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBtb2RlbC5fY29udGV4dCA9IG1vZGVsLnJvb3QuX2NvbnRleHRzW3RoaXMuaWRdID0gbmV3IENvbnRleHQobW9kZWwsIHRoaXMuaWQpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGRlZmF1bHRGbnMgPSByZXF1aXJlKCcuL2RlZmF1bHRGbnMnKTtcblxuZnVuY3Rpb24gTmFtZWRGbnMoKSB7fVxuXG5Nb2RlbC5JTklUUy5wdXNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gIG1vZGVsLnJvb3QuX25hbWVkRm5zID0gbmV3IE5hbWVkRm5zKCk7XG4gIG1vZGVsLnJvb3QuX2ZucyA9IG5ldyBGbnMobW9kZWwpO1xuICBtb2RlbC5vbignYWxsJywgZm5MaXN0ZW5lcik7XG4gIGZ1bmN0aW9uIGZuTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZm5zLmZyb21NYXA7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHZhciBmbiA9IG1hcFtwYXRoXTtcbiAgICAgIGlmIChwYXNzLiRmbiA9PT0gZm4pIGNvbnRpbnVlO1xuICAgICAgaWYgKHV0aWwubWF5SW1wYWN0QW55KGZuLmlucHV0c1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIGlucHV0IHBhdGhcbiAgICAgICAgZm4ub25JbnB1dChwYXNzKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5tYXlJbXBhY3QoZm4uZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIG91dHB1dCBwYXRoXG4gICAgICAgIGZuLm9uT3V0cHV0KHBhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbk1vZGVsLnByb3RvdHlwZS5mbiA9IGZ1bmN0aW9uKG5hbWUsIGZucykge1xuICB0aGlzLnJvb3QuX25hbWVkRm5zW25hbWVdID0gZm5zO1xufTtcblxuZnVuY3Rpb24gcGFyc2VTdGFydEFyZ3VtZW50cyhtb2RlbCwgYXJncywgaGFzUGF0aCkge1xuICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZm5zID0gYXJnc1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XG4gIH1cbiAgaWYgKGhhc1BhdGgpIHtcbiAgICB2YXIgcGF0aCA9IG1vZGVsLnBhdGgoYXJnc1sxXSk7XG4gICAgdmFyIGlucHV0UGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRQYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICB9XG4gIHZhciBpID0gaW5wdXRQYXRocy5sZW5ndGggLSAxO1xuICBpZiAobW9kZWwuaXNQYXRoKGlucHV0UGF0aHNbaV0pKSB7XG4gICAgaW5wdXRQYXRoc1tpXSA9IG1vZGVsLnBhdGgoaW5wdXRQYXRoc1tpXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9wdGlvbnMgPSBpbnB1dFBhdGhzLnBvcCgpO1xuICB9XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpbnB1dFBhdGhzW2ldID0gbW9kZWwucGF0aChpbnB1dFBhdGhzW2ldKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWVcbiAgLCBwYXRoOiBwYXRoXG4gICwgaW5wdXRQYXRoczogaW5wdXRQYXRoc1xuICAsIGZuczogZm5zXG4gICwgb3B0aW9uczogb3B0aW9uc1xuICB9O1xufVxuXG5Nb2RlbC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIGZhbHNlKTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZm5zLmdldChhcmdzLm5hbWUsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBzdWJwYXRoKSB7XG4gIHZhciBhcmdzID0gcGFyc2VTdGFydEFyZ3VtZW50cyh0aGlzLCBhcmd1bWVudHMsIHRydWUpO1xuICByZXR1cm4gdGhpcy5yb290Ll9mbnMuc3RhcnQoYXJncy5uYW1lLCBhcmdzLnBhdGgsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHRoaXMucm9vdC5fZm5zLnN0b3AocGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcEFsbCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZm5zID0gdGhpcy5yb290Ll9mbnMuZnJvbU1hcDtcbiAgZm9yICh2YXIgZnJvbSBpbiBmbnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZm5zW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMuc3RvcChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRm5zKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5uYW1lTWFwID0gbW9kZWwucm9vdC5fbmFtZWRGbnM7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucykge1xuICBmbnMgfHwgKGZucyA9IHRoaXMubmFtZU1hcFtuYW1lXSB8fCBkZWZhdWx0Rm5zW25hbWVdKTtcbiAgdmFyIGZuID0gbmV3IEZuKHRoaXMubW9kZWwsIG5hbWUsIG51bGwsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucyk7XG4gIHJldHVybiBmbi5nZXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpIHtcbiAgZm5zIHx8IChmbnMgPSB0aGlzLm5hbWVNYXBbbmFtZV0gfHwgZGVmYXVsdEZuc1tuYW1lXSk7XG4gIHZhciBmbiA9IG5ldyBGbih0aGlzLm1vZGVsLCBuYW1lLCBwYXRoLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpO1xuICB0aGlzLmZyb21NYXBbcGF0aF0gPSBmbjtcbiAgcmV0dXJuIGZuLm9uSW5wdXQoKTtcbn07XG5cbkZucy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW3BhdGhdO1xuICBkZWxldGUgdGhpcy5mcm9tTWFwW3BhdGhdO1xuICByZXR1cm4gZm47XG59O1xuXG5GbnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZuID0gdGhpcy5mcm9tTWFwW2Zyb21dO1xuICAgIC8vIERvbid0IHRyeSB0byBidW5kbGUgbm9uLW5hbWVkIGZ1bmN0aW9ucyB0aGF0IHdlcmUgc3RhcnRlZCB2aWFcbiAgICAvLyBtb2RlbC5zdGFydCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZuLm5hbWUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmbi5uYW1lLCBmbi5mcm9tXS5jb25jYXQoZm4uaW5wdXRQYXRocykpO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBGbihtb2RlbCwgbmFtZSwgZnJvbSwgaW5wdXRQYXRocywgZm5zLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbC5wYXNzKHskZm46IHRoaXN9KTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5mcm9tID0gZnJvbTtcbiAgdGhpcy5pbnB1dFBhdGhzID0gaW5wdXRQYXRocztcbiAgaWYgKCFmbnMpIHtcbiAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignTW9kZWwgZnVuY3Rpb24gbm90IGZvdW5kOiAnICsgbmFtZSk7XG4gICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG4gIHRoaXMuZ2V0Rm4gPSBmbnMuZ2V0IHx8IGZucztcbiAgdGhpcy5zZXRGbiA9IGZucy5zZXQ7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcuJyk7XG4gIHRoaXMuaW5wdXRzU2VnbWVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0UGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmlucHV0UGF0aHNbaV0uc3BsaXQoJy4nKTtcbiAgICB0aGlzLmlucHV0c1NlZ21lbnRzLnB1c2goc2VnbWVudHMpO1xuICB9XG4gIHZhciBjb3B5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5jb3B5KSB8fCAnb3V0cHV0JztcbiAgdGhpcy5jb3B5SW5wdXQgPSAoY29weSA9PT0gJ2lucHV0JyB8fCBjb3B5ID09PSAnYm90aCcpO1xuICB0aGlzLmNvcHlPdXRwdXQgPSAoY29weSA9PT0gJ291dHB1dCcgfHwgY29weSA9PT0gJ2JvdGgnKTtcbn1cblxuRm4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZm4sIGlucHV0cykge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5pbnB1dHNTZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpbnB1dCA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlucHV0c1NlZ21lbnRzW2ldKTtcbiAgICBpbnB1dHMucHVzaCh0aGlzLmNvcHlJbnB1dCA/IHV0aWwuZGVlcENvcHkoaW5wdXQpIDogaW5wdXQpO1xuICB9XG4gIHJldHVybiBmbi5hcHBseSh0aGlzLm1vZGVsLCBpbnB1dHMpO1xufTtcblxuRm4ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5hcHBseSh0aGlzLmdldEZuLCBbXSk7XG59O1xuXG52YXIgZGlmZk9wdGlvbnMgPSB7ZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcbnZhciBlYWNoRGlmZk9wdGlvbnMgPSB7ZWFjaDogdHJ1ZSwgZXF1YWw6IHV0aWwuZGVlcEVxdWFsfTtcblxuRm4ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHZhbHVlLCBwYXNzKSB7XG4gIGlmICghdGhpcy5zZXRGbikgcmV0dXJuO1xuICB2YXIgb3V0ID0gdGhpcy5hcHBseSh0aGlzLnNldEZuLCBbdmFsdWVdKTtcbiAgaWYgKCFvdXQpIHJldHVybjtcbiAgdmFyIGlucHV0c1NlZ21lbnRzID0gdGhpcy5pbnB1dHNTZWdtZW50cztcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICBmb3IgKHZhciBrZXkgaW4gb3V0KSB7XG4gICAgaWYgKGtleSA9PT0gJ2VhY2gnKSB7XG4gICAgICB2YXIgZWFjaCA9IG91dFtrZXldO1xuICAgICAgZm9yIChrZXkgaW4gZWFjaCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkoZWFjaFtrZXldKSA6IGVhY2hba2V5XTtcbiAgICAgICAgbW9kZWwuX3NldERpZmYoaW5wdXRzU2VnbWVudHNba2V5XSwgdmFsdWUsIGVhY2hEaWZmT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gKHRoaXMuY29weU91dHB1dCkgPyB1dGlsLmRlZXBDb3B5KG91dFtrZXldKSA6IG91dFtrZXldO1xuICAgIG1vZGVsLl9zZXREaWZmKGlucHV0c1NlZ21lbnRzW2tleV0sIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIH1cbn07XG5cbkZuLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24ocGFzcykge1xuICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkodGhpcy5nZXQoKSkgOiB0aGlzLmdldCgpO1xuICB0aGlzLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSkuX3NldERpZmYodGhpcy5mcm9tU2VnbWVudHMsIHZhbHVlLCBkaWZmT3B0aW9ucyk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbkZuLnByb3RvdHlwZS5vbk91dHB1dCA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuZnJvbVNlZ21lbnRzKTtcbiAgcmV0dXJuIHRoaXMuc2V0KHZhbHVlLCBwYXNzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBkZWZhdWx0Rm5zID0gcmVxdWlyZSgnLi9kZWZhdWx0Rm5zJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fZmlsdGVycyA9IG5ldyBGaWx0ZXJzKG1vZGVsKTtcbiAgbW9kZWwub24oJ2FsbCcsIGZpbHRlckxpc3RlbmVyKTtcbiAgZnVuY3Rpb24gZmlsdGVyTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbWFwID0gbW9kZWwucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICB2YXIgZmlsdGVyID0gbWFwW3BhdGhdO1xuICAgICAgaWYgKHBhc3MuJGZpbHRlciA9PT0gZmlsdGVyKSBjb250aW51ZTtcbiAgICAgIGlmICh1dGlsLm1heUltcGFjdChmaWx0ZXIuaW5wdXRTZWdtZW50cywgc2VnbWVudHMpKSB7XG4gICAgICAgIGZpbHRlci51cGRhdGUocGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBmbik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMucm9vdC5fZmlsdGVycy5hZGQoaW5wdXRQYXRoLCBudWxsLCBmbiB8fCAnYXNjJyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsRmlsdGVycyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgZmlsdGVycyA9IHRoaXMucm9vdC5fZmlsdGVycy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIGZpbHRlcnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZmlsdGVyc1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICBmaWx0ZXJzW2Zyb21dLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRmlsdGVycyhtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GaWx0ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcywgaW5wdXRQYXRoLCBmaWx0ZXJGbiwgc29ydEZuKTtcbn07XG5cbkZpbHRlcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgICAvLyBEb24ndCB0cnkgdG8gYnVuZGxlIGlmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZpbHRlci5idW5kbGUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmaWx0ZXIuaW5wdXRQYXRoLCBmaWx0ZXIuZmlsdGVyTmFtZSwgZmlsdGVyLnNvcnROYW1lLCBmcm9tXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIEZpbHRlcihmaWx0ZXJzLCBpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgdGhpcy5tb2RlbCA9IGZpbHRlcnMubW9kZWwucGFzcyh7JGZpbHRlcjogdGhpc30pO1xuICB0aGlzLmlucHV0UGF0aCA9IGlucHV0UGF0aDtcbiAgdGhpcy5pbnB1dFNlZ21lbnRzID0gaW5wdXRQYXRoLnNwbGl0KCcuJyk7XG4gIHRoaXMuZmlsdGVyTmFtZSA9IG51bGw7XG4gIHRoaXMuc29ydE5hbWUgPSBudWxsO1xuICB0aGlzLmJ1bmRsZSA9IHRydWU7XG4gIHRoaXMuZmlsdGVyRm4gPSBudWxsO1xuICB0aGlzLnNvcnRGbiA9IG51bGw7XG4gIGlmIChmaWx0ZXJGbikgdGhpcy5maWx0ZXIoZmlsdGVyRm4pO1xuICBpZiAoc29ydEZuKSB0aGlzLnNvcnQoc29ydEZuKTtcbiAgdGhpcy5pZHNTZWdtZW50cyA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gbnVsbDtcbn1cblxuRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5maWx0ZXJGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmZpbHRlck5hbWUgPSBmbjtcbiAgICB0aGlzLmZpbHRlckZuID0gdGhpcy5tb2RlbC5yb290Ll9uYW1lZEZuc1tmbl0gfHwgZGVmYXVsdEZuc1tmbl07XG4gICAgaWYgKCF0aGlzLmZpbHRlckZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignRmlsdGVyIGZ1bmN0aW9uIG5vdCBmb3VuZDogJyArIGZuKTtcbiAgICAgIHRoaXMubW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICghZm4pIGZuID0gJ2FzYyc7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLnNvcnRGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnNvcnROYW1lID0gZm47XG4gICAgdGhpcy5zb3J0Rm4gPSB0aGlzLm1vZGVsLnJvb3QuX25hbWVkRm5zW2ZuXSB8fCBkZWZhdWx0Rm5zW2ZuXTtcbiAgICBpZiAoIXRoaXMuc29ydEZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IFR5cGVFcnJvcignU29ydCBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBmbik7XG4gICAgICB0aGlzLm1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmlkcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIGlkcyA9IFtdO1xuICBpZiAoIWl0ZW1zKSByZXR1cm4gaWRzO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2ldLCBpLCBpdGVtcykpIHtcbiAgICAgICAgICBpZHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSBpZHMucHVzaChpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZHMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkcyA9IE9iamVjdC5rZXlzKGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgdmFyIHNvcnRGbiA9IHRoaXMuc29ydEZuO1xuICBpZiAoc29ydEZuKSB7XG4gICAgaWRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpZHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5pbnB1dFNlZ21lbnRzKTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1tpXSwgaSwgaXRlbXMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gaXRlbXMuc2xpY2UoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuZmlsdGVyRm4pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpdGVtcykge1xuICAgICAgICBpZiAoaXRlbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgIHRoaXMuZmlsdGVyRm4uY2FsbCh0aGlzLm1vZGVsLCBpdGVtc1trZXldLCBrZXksIGl0ZW1zKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnNvcnRGbikgcmVzdWx0cy5zb3J0KHRoaXMuc29ydEZuKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHBhc3MpIHtcbiAgdmFyIGlkcyA9IHRoaXMuaWRzKCk7XG4gIHRoaXMubW9kZWwucGFzcyhwYXNzLCB0cnVlKS5fc2V0RGlmZih0aGlzLmlkc1NlZ21lbnRzLCBpZHMpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihmcm9tKSB7XG4gIGZyb20gPSB0aGlzLm1vZGVsLnBhdGgoZnJvbSk7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLmZpbHRlcnMuZnJvbU1hcFtmcm9tXSA9IHRoaXM7XG4gIHRoaXMuaWRzU2VnbWVudHMgPSBbJyRmaWx0ZXJzJywgZnJvbS5yZXBsYWNlKC9cXC4vZywgJ3wnKV07XG4gIHRoaXMudXBkYXRlKCk7XG4gIHJldHVybiB0aGlzLm1vZGVsLnJlZkxpc3QoZnJvbSwgdGhpcy5pbnB1dFBhdGgsIHRoaXMuaWRzU2VnbWVudHMuam9pbignLicpKTtcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5maWx0ZXJzLmZyb21NYXBbdGhpcy5mcm9tXTtcbiAgdGhpcy5tb2RlbC5yZW1vdmVSZWZMaXN0KHRoaXMuZnJvbSk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLmlkc1NlZ21lbnRzKTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgcm9vdCA9IG1vZGVsLnJvb3Q7XG4gIHJvb3QuX3JlZkxpc3RzID0gbmV3IFJlZkxpc3RzKHJvb3QpO1xuICBmb3IgKHZhciB0eXBlIGluIE1vZGVsLk1VVEFUT1JfRVZFTlRTKSB7XG4gICAgYWRkTGlzdGVuZXIocm9vdCwgdHlwZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSkge1xuICBtb2RlbC5vbih0eXBlLCByZWZMaXN0TGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0TGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICAvLyBDaGVjayBmb3IgdXBkYXRlcyBvbiBvciB1bmRlcm5lYXRoIHBhdGhzXG4gICAgdmFyIGZyb21NYXAgPSBtb2RlbC5fcmVmTGlzdHMuZnJvbU1hcDtcbiAgICBmb3IgKHZhciBmcm9tIGluIGZyb21NYXApIHtcbiAgICAgIHZhciByZWZMaXN0ID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmIChwYXNzLiRyZWZMaXN0ID09PSByZWZMaXN0KSBjb250aW51ZTtcbiAgICAgIHJlZkxpc3Qub25NdXRhdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50QXJnc1xuICogQHBhcmFtIHtSZWZMaXN0fSByZWZMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhdGNoRnJvbUV2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHJlZkxpc3QpIHtcbiAgdmFyIGZyb21MZW5ndGggPSByZWZMaXN0LmZyb21TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGBmcm9tYCBvdXRwdXQgaXRzZWxmXG4gIGlmIChzZWdtZW50c0xlbmd0aCA9PT0gZnJvbUxlbmd0aCkge1xuICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHZhbHVlcyA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5pZHNTZWdtZW50cywgaW5kZXgsIGlkcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgICB2YXIgaWRzID0gbW9kZWwuX3JlbW92ZShyZWZMaXN0Lmlkc1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSk7XG4gICAgICAvLyBEZWxldGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1zIHVuZGVybmVhdGggYHRvYCBpZiB0aGUgYGRlbGV0ZVJlbW92ZWRgXG4gICAgICAvLyBvcHRpb24gd2FzIHNldCB0cnVlXG4gICAgICBpZiAocmVmTGlzdC5kZWxldGVSZW1vdmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZWZMaXN0Lml0ZW1CeUlkKGlkc1tpXSk7XG4gICAgICAgICAgbW9kZWwuX2RlbChyZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1syXTtcbiAgICAgIG1vZGVsLl9tb3ZlKHJlZkxpc3QuaWRzU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2Ugb2YgdGhlIGVudGlyZSBvdXRwdXRcbiAgICB2YXIgdmFsdWVzID0gKHR5cGUgPT09ICdjaGFuZ2UnKSA/XG4gICAgICBldmVudEFyZ3NbMF0gOiBtb2RlbC5fZ2V0KHJlZkxpc3QuZnJvbVNlZ21lbnRzKTtcbiAgICAvLyBTZXQgaWRzIHRvIGVtcHR5IGxpc3QgaWYgb3V0cHV0IGlzIHNldCB0byBudWxsXG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIG1vZGVsLl9zZXQocmVmTGlzdC5pZHNTZWdtZW50cywgW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZW50aXJlIG91dHB1dCBpcyBzZXQsIGNyZWF0ZSBhIGxpc3Qgb2YgaWRzIGJhc2VkIG9uIHRoZSBvdXRwdXQsXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtc1xuICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICBtb2RlbC5fc2V0KHJlZkxpc3QuaWRzU2VnbWVudHMsIGlkcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbXV0YXRpb24gaXMgb24gYSBwYXJlbnQgb2YgYGZyb21gLCB3ZSBtaWdodCBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgLy8gZW50aXJlIHJlZkxpc3Qgb3V0cHV0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA8IGZyb21MZW5ndGgpIHtcbiAgICBtb2RlbC5fc2V0QXJyYXlEaWZmKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCByZWZMaXN0LmdldCgpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5kZXggPSBzZWdtZW50c1tmcm9tTGVuZ3RoXTtcbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChyZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdmFyIHRvU2VnbWVudHMgPSByZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0odmFsdWUpO1xuXG4gIC8vIE11dGF0aW9uIHVuZGVybmVhdGggYSBjaGlsZCBvZiB0aGUgYGZyb21gIG9iamVjdC5cbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID4gZnJvbUxlbmd0aCArIDEpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdNdXRhdGlvbiBvbiBkZXNjZW5kYW50IG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGBmcm9tYCBvYmplY3RcblxuICAvLyBJZiBjaGFuZ2luZyB0aGUgaXRlbSBpdHNlbGYsIGl0IHdpbGwgYWxzbyBoYXZlIHRvIGJlIHJlLXNldCBvbiB0aGVcbiAgLy8gb3JpZ2luYWwgb2JqZWN0XG4gIGlmICh0eXBlID09PSAnY2hhbmdlJykge1xuICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRoZSBzYW1lIGdvZXMgZm9yIHN0cmluZyBtdXRhdGlvbnMsIHNpbmNlIHN0cmluZ3MgYXJlIGltbXV0YWJsZVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHN0cmluZ1ZhbHVlID0gZXZlbnRBcmdzWzFdO1xuICAgIG1vZGVsLl9zdHJpbmdJbnNlcnQodG9TZWdtZW50cywgc3RyaW5nSW5kZXgsIHN0cmluZ1ZhbHVlKTtcbiAgICB1cGRhdGVJZEZvclZhbHVlKG1vZGVsLCByZWZMaXN0LCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ1JlbW92ZScpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV07XG4gICAgbW9kZWwuX3N0cmluZ1JlbW92ZSh0b1NlZ21lbnRzLCBzdHJpbmdJbmRleCwgaG93TWFueSk7XG4gICAgdXBkYXRlSWRGb3JWYWx1ZShtb2RlbCwgcmVmTGlzdCwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIHZhciBtZXNzYWdlID0gJ0FycmF5IG11dGF0aW9uIG9uIGNoaWxkIG9mIHJlZkxpc3QgYGZyb21gIHNob3VsZCBoYXZlIGJlZW4gZGVyZWZlcmVuY2VkOiAnICsgc2VnbWVudHMuam9pbignLicpO1xuICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmTGlzdH0gcmVmTGlzdFxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHNldE5ld1RvVmFsdWVzKG1vZGVsLCByZWZMaXN0LCB2YWx1ZXMsIGZuKSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SXRlbSh2YWx1ZSk7XG4gICAgaWYgKGlkID09PSB2b2lkIDAgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWQgPSB2YWx1ZS5pZCA9IG1vZGVsLmlkKCk7XG4gICAgfVxuICAgIHZhciB0b1NlZ21lbnRzID0gcmVmTGlzdC50b1NlZ21lbnRzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoaWQgPT09IHZvaWQgMCB8fCB0b1NlZ21lbnRzID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1VuYWJsZSB0byBhZGQgaXRlbSB0byByZWZMaXN0OiAnICsgdmFsdWU7XG4gICAgICByZXR1cm4gbW9kZWwuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIH1cbiAgICBpZiAobW9kZWwuX2dldCh0b1NlZ21lbnRzKSAhPT0gdmFsdWUpIHtcbiAgICAgIG1vZGVsLl9zZXQodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIH1cbiAgICBpZHMucHVzaChpZCk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICB2YXIgaWQgPSByZWZMaXN0LmlkQnlJdGVtKHZhbHVlKTtcbiAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5pZHNTZWdtZW50cy5jb25jYXQoaW5kZXgpO1xuICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCBpZCk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCByZWZMaXN0KSB7XG4gIHZhciB0b0xlbmd0aCA9IHJlZkxpc3QudG9TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGB0b2Agb2JqZWN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPT09IHRvTGVuZ3RoKSB7XG4gICAgaWYgKHR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICB2YXIgaW5zZXJ0SW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChpbmRpY2VzW2pdKTtcbiAgICAgICAgICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JlbW92ZScpIHtcbiAgICAgIHZhciByZW1vdmVJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gcmVtb3ZlSW5kZXgsIGxlbiA9IHJlbW92ZUluZGV4ICsgaG93TWFueTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlc1tpXSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBpbmRpY2VzTGVuID0gaW5kaWNlcy5sZW5ndGg7IGogPCBpbmRpY2VzTGVuOyBqKyspIHtcbiAgICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kaWNlc1tqXSk7XG4gICAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIC8vIE1vdmluZyBpdGVtcyBpbiB0aGUgYHRvYCBvYmplY3Qgc2hvdWxkIGhhdmUgbm8gZWZmZWN0IG9uIHRoZSBvdXRwdXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBNdXRhdGlvbiBvbiBvciBhYm92ZSB0aGUgYHRvYCBvYmplY3RcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoIDw9IHRvTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgdG9gIG9iamVjdCBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTXV0YXRpb24gdW5kZXJuZWF0aCBhIGNoaWxkIG9mIHRoZSBgdG9gIG9iamVjdC4gVGhlIGl0ZW0gd2lsbCBhbHJlYWR5XG4gIC8vIGJlIHVwIHRvIGRhdGUsIHNpbmNlIGl0IGlzIHVuZGVyIGFuIG9iamVjdCByZWZlcmVuY2UuIEp1c3QgcmUtZW1pdFxuICBpZiAoc2VnbWVudHNMZW5ndGggPiB0b0xlbmd0aCArIDEpIHtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzLnNsaWNlKDAsIHRvTGVuZ3RoICsgMSkpO1xuICAgIHZhciBpbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICBpZiAoIWluZGljZXMpIHJldHVybjtcbiAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UodG9MZW5ndGggKyAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGljZXNbaV07XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4LCByZW1haW5pbmcpO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIG11dGF0aW9uIG9mIGEgY2hpbGQgb2YgdGhlIGB0b2Agb2JqZWN0XG5cbiAgLy8gSWYgY2hhbmdpbmcgdGhlIGl0ZW0gaXRzZWxmLCBpdCB3aWxsIGFsc28gaGF2ZSB0byBiZSByZS1zZXQgb24gdGhlXG4gIC8vIGFycmF5IGNyZWF0ZWQgYnkgdGhlIHJlZkxpc3RcbiAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnIHx8IHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAndW5sb2FkJykge1xuICAgIHZhciB2YWx1ZSwgcHJldmlvdXM7XG4gICAgaWYgKHR5cGUgPT09ICdjaGFuZ2UnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gZXZlbnRBcmdzWzFdO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgICB2YWx1ZSA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHByZXZpb3VzID0gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VubG9hZCcpIHtcbiAgICAgIHZhbHVlID0gdm9pZCAwO1xuICAgICAgcHJldmlvdXMgPSBldmVudEFyZ3NbMF07XG4gICAgfVxuICAgIHZhciBuZXdJbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHZhbHVlKTtcbiAgICB2YXIgb2xkSW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbShwcmV2aW91cyk7XG4gICAgaWYgKCFuZXdJbmRpY2VzICYmICFvbGRJbmRpY2VzKSByZXR1cm47XG4gICAgaWYgKG9sZEluZGljZXMgJiYgIWVxdWl2YWxlbnRBcnJheXMob2xkSW5kaWNlcywgbmV3SW5kaWNlcykpIHtcbiAgICAgIC8vIFRoZSBjaGFuZ2VkIGl0ZW0gdXNlZCB0byByZWZlciB0byBzb21lIGluZGljZXMsIGJ1dCBubyBsb25nZXIgZG9lc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChvbGRJbmRpY2VzW2ldKTtcbiAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQobmV3SW5kaWNlc1tpXSk7XG4gICAgICAgIG1vZGVsLl9zZXQob3V0U2VnbWVudHMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cy5zbGljZSgwLCB0b0xlbmd0aCArIDEpKTtcbiAgdmFyIGluZGljZXMgPSByZWZMaXN0LmluZGljZXNCeUl0ZW0odmFsdWUpO1xuICBpZiAoIWluZGljZXMpIHJldHVybjtcblxuICAvLyBUaGUgc2FtZSBnb2VzIGZvciBzdHJpbmcgbXV0YXRpb25zLCBzaW5jZSBzdHJpbmdzIGFyZSBpbW11dGFibGVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdJbnNlcnQnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciB2YWx1ZSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ0luc2VydChvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlID09PSAnc3RyaW5nUmVtb3ZlJykge1xuICAgIHZhciBzdHJpbmdJbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzKGluZGljZXNbaV0pO1xuICAgICAgbW9kZWwuX3N0cmluZ1JlbW92ZShvdXRTZWdtZW50cywgc3RyaW5nSW5kZXgsIGhvd01hbnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdpbnNlcnQnIHx8IHR5cGUgPT09ICdyZW1vdmUnIHx8IHR5cGUgPT09ICdtb3ZlJykge1xuICAgIC8vIEFycmF5IG11dGF0aW9ucyB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHVwZGF0ZWQgdmlhIGFuIG9iamVjdFxuICAgIC8vIHJlZmVyZW5jZSwgc28gb25seSByZS1lbWl0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGljZXNbaV0pO1xuICAgICAgZGVyZWZlcmVuY2VkID0gbW9kZWwuX2RlcmVmZXJlbmNlKGRlcmVmZXJlbmNlZCwgbnVsbCwgcmVmTGlzdCk7XG4gICAgICBldmVudEFyZ3MgPSBldmVudEFyZ3Muc2xpY2UoKTtcbiAgICAgIGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV0gPSBtb2RlbC5fcGFzcztcbiAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXF1aXZhbGVudEFycmF5cyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBhdGNoSWRzRXZlbnQodHlwZSwgc2VnbWVudHMsIGV2ZW50QXJncywgcmVmTGlzdCkge1xuICB2YXIgaWRzTGVuZ3RoID0gcmVmTGlzdC5pZHNTZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gQW4gYXJyYXkgbXV0YXRpb24gb2YgdGhlIGlkcyBzaG91bGQgYmUgbWlycm9yZWQgd2l0aCBhIGxpa2UgY2hhbmdlIGluXG4gIC8vIHRoZSBvdXRwdXQgYXJyYXlcbiAgaWYgKHNlZ21lbnRzTGVuZ3RoID09PSBpZHNMZW5ndGgpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2luc2VydCcpIHtcbiAgICAgIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICAgIHZhciBpbnNlcnRlZCA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zZXJ0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVmTGlzdC5pdGVtQnlJZChpbnNlcnRlZFtpXSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5mcm9tU2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAncmVtb3ZlJykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgICAgbW9kZWwuX3JlbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgaW5kZXgsIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnbW92ZScpIHtcbiAgICAgIHZhciBmcm9tID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gICAgICBtb2RlbC5fbW92ZShyZWZMaXN0LmZyb21TZWdtZW50cywgZnJvbSwgdG8sIGhvd01hbnkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIE11dGF0aW9uIG9uIHRoZSBgaWRzYCBsaXN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPD0gaWRzTGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlIGVudGlyZSBgaWRzYCBhcnJheSBpcyB1cGRhdGVkLCB3ZSBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBlbnRpcmUgcmVmTGlzdCBvdXRwdXQgYW5kIGFwcGx5IHdoYXQgaXMgZGlmZmVyZW50XG4gICAgbW9kZWwuX3NldEFycmF5RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkaXJlY3QgbXV0YXRpb24gb2YgYSBjaGlsZCBpbiB0aGUgYGlkc2Agb2JqZWN0IG9yIG11dGF0aW9uXG4gIC8vIHVuZGVybmVhdGggYW4gaXRlbSBpbiB0aGUgYGlkc2AgbGlzdC4gVXBkYXRlIHRoZSBpdGVtIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgLy8gaWQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgdmFyIGluZGV4ID0gc2VnbWVudHNbaWRzTGVuZ3RoXTtcbiAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SW5kZXgoaW5kZXgpO1xuICB2YXIgaXRlbSA9IHJlZkxpc3QuaXRlbUJ5SWQoaWQpO1xuICB2YXIgaXRlbVNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgaWYgKG1vZGVsLl9nZXQoaXRlbVNlZ21lbnRzKSAhPT0gaXRlbSkge1xuICAgIG1vZGVsLl9zZXQoaXRlbVNlZ21lbnRzLCBpdGVtKTtcbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUucmVmTGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJvbSwgdG8sIGlkcywgb3B0aW9ucztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0aGlzLmlzUGF0aChhcmd1bWVudHNbMl0pKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWRzID0gYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB0byA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHRvKSkge1xuICAgIHZhciB0b1BhdGggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b1BhdGgucHVzaCh0aGlzLnBhdGgodG9baV0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvUGF0aCA9IHRoaXMucGF0aCh0byk7XG4gIH1cbiAgdmFyIGlkc1BhdGggPSB0aGlzLnBhdGgoaWRzKTtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBpZHNQYXRoLCBvcHRpb25zKTtcbiAgdGhpcy5wYXNzKHskcmVmTGlzdDogcmVmTGlzdH0pLl9zZXRBcnJheURpZmYocmVmTGlzdC5mcm9tU2VnbWVudHMsIHJlZkxpc3QuZ2V0KCkpO1xuICByZXR1cm4gdGhpcy5zY29wZShmcm9tUGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlUmVmTGlzdCA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB2YXIgcmVmTGlzdCA9IHRoaXMucm9vdC5fcmVmTGlzdHMucmVtb3ZlKGZyb21QYXRoKTtcbiAgaWYgKHJlZkxpc3QpIHRoaXMuX2RlbChyZWZMaXN0LmZyb21TZWdtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBSZWZMaXN0KG1vZGVsLCBmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbCAmJiBtb2RlbC5wYXNzKHskcmVmTGlzdDogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuaWRzID0gaWRzO1xuICB0aGlzLmZyb21TZWdtZW50cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0byAmJiB0by5zcGxpdCgnLicpO1xuICB0aGlzLmlkc1NlZ21lbnRzID0gaWRzICYmIGlkcy5zcGxpdCgnLicpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmRlbGV0ZVJlbW92ZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsZXRlUmVtb3ZlZDtcbn1cblxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBpZHMgYXJyYXkgaXMgYSBmbGF0IGxpc3Qgb2Zcbi8vIGtleXMgb24gdGhlIHRvIG9iamVjdC4gSWRlYWxseSwgdGhpcyBtYXBwaW5nIGNvdWxkIGJlIGN1c3RvbWl6ZWQgdmlhXG4vLyBpbmhlcml0aW5nIGZyb20gUmVmTGlzdCBhbmQgb3ZlcnJpZGluZyB0aGVzZSBtZXRob2RzIHdpdGhvdXQgaGF2aW5nIHRvXG4vLyBtb2RpZnkgdGhlIGFib3ZlIGV2ZW50IGhhbmRsaW5nIGNvZGUuXG4vLyBcbi8vIEluIHRoZSBkZWZhdWx0IHJlZkxpc3QgaW1wbGVtZW50YXRpb24sIGBrZXlgIGFuZCBgaWRgIGFyZSBlcXVhbC5cbi8vIFxuLy8gVGVybXMgaW4gdGhlIGJlbG93IG1ldGhvZHM6XG4vLyAgIGBpdGVtYCAgLSBPYmplY3Qgb24gdGhlIGB0b2AgcGF0aCwgd2hpY2ggZ2V0cyBtaXJyb3JlZCBvbiB0aGUgYGZyb21gIHBhdGhcbi8vICAgYGtleWAgICAtIFRoZSBwcm9wZXJ0eSB1bmRlciBgdG9gIGF0IHdoaWNoIGFuIGl0ZW0gaXMgbG9jYXRlZFxuLy8gICBgaWRgICAgIC0gU3RyaW5nIG9yIG9iamVjdCBpbiB0aGUgYXJyYXkgYXQgdGhlIGBpZHNgIHBhdGhcbi8vICAgYGluZGV4YCAtIFRoZSBpbmRleCBvZiBhbiBpZCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gYW4gaW5kZXggb24gYGZyb21gXG5SZWZMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzKTtcbiAgaWYgKCFpZHMpIHJldHVybiBbXTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMudG9TZWdtZW50cyk7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgIG91dC5wdXNoKGl0ZW1zICYmIGl0ZW1zW2tleV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgaSkge1xuICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SW5kZXgocmVtYWluaW5nWzBdKTtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJlbWFpbmluZ1swXSA9IGtleTtcbiAgcmV0dXJuIHRoaXMudG9TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbn07XG5SZWZMaXN0LnByb3RvdHlwZS50b1NlZ21lbnRzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SXRlbShpdGVtKTtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSByZXR1cm47XG4gIHJldHVybiB0aGlzLnRvU2VnbWVudHMuY29uY2F0KGtleSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIGlmIChpdGVtICYmIGl0ZW0uaWQpIHJldHVybiBpdGVtLmlkO1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy50b1NlZ21lbnRzKTtcbiAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW0gPT09IGl0ZW1zW2tleV0pIHJldHVybiBrZXk7XG4gIH1cbn07XG5SZWZMaXN0LnByb3RvdHlwZS5pbmRpY2VzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgaWQgPSB0aGlzLmlkQnlJdGVtKGl0ZW0pO1xuICB2YXIgaWRzID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuaWRzU2VnbWVudHMpO1xuICBpZiAoIWlkcykgcmV0dXJuO1xuICB2YXIgaW5kaWNlcztcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSBpZHMuaW5kZXhPZihpZCwgaW5kZXggKyAxKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRpY2VzO1xufTtcblJlZkxpc3QucHJvdG90eXBlLml0ZW1CeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLnRvU2VnbWVudHMuY29uY2F0KGlkKSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xufTtcblJlZkxpc3QucHJvdG90eXBlLm9uTXV0YXRpb24gPSBmdW5jdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLnRvU2VnbWVudHMsIHNlZ21lbnRzKSkge1xuICAgIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfSBlbHNlIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLmlkc1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaElkc0V2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHRoaXMpO1xuICB9IGVsc2UgaWYgKHV0aWwubWF5SW1wYWN0KHRoaXMuZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaEZyb21FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5cbmZ1bmN0aW9uIFJlZkxpc3RzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG59XG5cblJlZkxpc3RzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHZhciByZWZMaXN0ID0gbmV3IFJlZkxpc3QodGhpcy5tb2RlbCwgZnJvbSwgdG8sIGlkcywgb3B0aW9ucyk7XG4gIHRoaXMuZnJvbU1hcFtmcm9tXSA9IHJlZkxpc3Q7XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIGRlbGV0ZSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZkxpc3QuZnJvbSwgcmVmTGlzdC50bywgcmVmTGlzdC5pZHMsIHJlZkxpc3Qub3B0aW9uc10pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL01vZGVsJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgdmFyIHJvb3QgPSBtb2RlbC5yb290O1xuICByb290Ll9yZWZzID0gbmV3IFJlZnMocm9vdCk7XG4gIGFkZEluZGV4TGlzdGVuZXJzKHJvb3QpO1xuICBhZGRMaXN0ZW5lcihyb290LCAnY2hhbmdlJywgcmVmQ2hhbmdlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ2xvYWQnLCByZWZMb2FkKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3VubG9hZCcsIHJlZlVubG9hZCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdpbnNlcnQnLCByZWZJbnNlcnQpO1xuICBhZGRMaXN0ZW5lcihyb290LCAncmVtb3ZlJywgcmVmUmVtb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ21vdmUnLCByZWZNb3ZlKTtcbiAgYWRkTGlzdGVuZXIocm9vdCwgJ3N0cmluZ0luc2VydCcsIHJlZlN0cmluZ0luc2VydCk7XG4gIGFkZExpc3RlbmVyKHJvb3QsICdzdHJpbmdSZW1vdmUnLCByZWZTdHJpbmdSZW1vdmUpO1xufSk7XG5cbmZ1bmN0aW9uIGFkZEluZGV4TGlzdGVuZXJzKG1vZGVsKSB7XG4gIG1vZGVsLm9uKCdpbnNlcnQnLCBmdW5jdGlvbiByZWZJbnNlcnRJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBwYXRjaEluc2VydChyZWZJbmRleCkge1xuICAgICAgcmV0dXJuIChpbmRleCA8PSByZWZJbmRleCkgPyByZWZJbmRleCArIGhvd01hbnkgOiByZWZJbmRleDtcbiAgICB9XG4gICAgb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2hJbnNlcnQpO1xuICB9KTtcbiAgbW9kZWwub24oJ3JlbW92ZScsIGZ1bmN0aW9uIHJlZlJlbW92ZUluZGV4KHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHBhdGNoUmVtb3ZlKHJlZkluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4IDw9IHJlZkluZGV4KSA/IHJlZkluZGV4IC0gaG93TWFueSA6IHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaFJlbW92ZSk7XG4gIH0pO1xuICBtb2RlbC5vbignbW92ZScsIGZ1bmN0aW9uIHJlZk1vdmVJbmRleChzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHRvID0gZXZlbnRBcmdzWzFdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzJdO1xuICAgIGZ1bmN0aW9uIHBhdGNoTW92ZShyZWZJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IHdhcyBtb3ZlZCBpdHNlbGZcbiAgICAgIGlmIChmcm9tIDw9IHJlZkluZGV4ICYmIHJlZkluZGV4IDwgZnJvbSArIGhvd01hbnkpIHtcbiAgICAgICAgcmV0dXJuIHJlZkluZGV4ICsgdG8gLSBmcm9tO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIHBhcnQgb2YgYSBtb3ZlXG4gICAgICBpZiAoZnJvbSA8PSByZWZJbmRleCkgcmVmSW5kZXggLT0gaG93TWFueTtcbiAgICAgIC8vIEluc2VydCBwYXJ0IG9mIGEgbW92ZVxuICAgICAgaWYgKHRvIDw9IHJlZkluZGV4KSByZWZJbmRleCArPSBob3dNYW55O1xuICAgICAgcmV0dXJuIHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaE1vdmUpO1xuICB9KTtcbiAgZnVuY3Rpb24gb25JbmRleENoYW5nZShzZWdtZW50cywgcGF0Y2gpIHtcbiAgICB2YXIgZnJvbU1hcCA9IG1vZGVsLl9yZWZzLmZyb21NYXA7XG4gICAgZm9yICh2YXIgZnJvbSBpbiBmcm9tTWFwKSB7XG4gICAgICB2YXIgcmVmID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmICghKHJlZi51cGRhdGVJbmRpY2VzICYmXG4gICAgICAgIHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZi50b1NlZ21lbnRzKSAmJlxuICAgICAgICByZWYudG9TZWdtZW50cy5sZW5ndGggPiBzZWdtZW50cy5sZW5ndGgpKSBjb250aW51ZTtcbiAgICAgIHZhciBpbmRleCA9ICtyZWYudG9TZWdtZW50c1tzZWdtZW50cy5sZW5ndGhdO1xuICAgICAgdmFyIHBhdGNoZWQgPSBwYXRjaChpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPT09IHBhdGNoZWQpIGNvbnRpbnVlO1xuICAgICAgbW9kZWwuX3JlZnMucmVtb3ZlKGZyb20pO1xuICAgICAgcmVmLnRvU2VnbWVudHNbc2VnbWVudHMubGVuZ3RoXSA9ICcnICsgcGF0Y2hlZDtcbiAgICAgIHJlZi50byA9IHJlZi50b1NlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICAgIG1vZGVsLl9yZWZzLl9hZGQocmVmKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmQ2hhbmdlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZMb2FkKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgdmFsdWUgPSBldmVudEFyZ3NbMF07XG4gIG1vZGVsLl9zZXQoZGVyZWZlcmVuY2VkLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiByZWZVbmxvYWQobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIG1vZGVsLl9kZWwoZGVyZWZlcmVuY2VkKTtcbn1cbmZ1bmN0aW9uIHJlZkluc2VydChtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5faW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiByZWZSZW1vdmUobW9kZWwsIGRlcmVmZXJlbmNlZCwgZXZlbnRBcmdzKSB7XG4gIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICBtb2RlbC5fcmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmTW92ZShtb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpIHtcbiAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gIHZhciB0byA9IGV2ZW50QXJnc1sxXTtcbiAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gIG1vZGVsLl9tb3ZlKGRlcmVmZXJlbmNlZCwgZnJvbSwgdG8sIGhvd01hbnkpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nSW5zZXJ0KG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciB0ZXh0ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nSW5zZXJ0KGRlcmVmZXJlbmNlZCwgaW5kZXgsIHRleHQpO1xufVxuZnVuY3Rpb24gcmVmU3RyaW5nUmVtb3ZlKG1vZGVsLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncykge1xuICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdO1xuICBtb2RlbC5fc3RyaW5nUmVtb3ZlKGRlcmVmZXJlbmNlZCwgaW5kZXgsIGhvd01hbnkpO1xufVxuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSwgZm4pIHtcbiAgbW9kZWwub24odHlwZSwgcmVmTGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0ZW5lcihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICAgIC8vIEZpbmQgY2FzZXMgd2hlcmUgYW4gZXZlbnQgaXMgZW1pdHRlZCBvbiBhIHBhdGggd2hlcmUgYSByZWZlcmVuY2VcbiAgICAvLyBpcyBwb2ludGluZy4gQWxsIG9yaWdpbmFsIG11dGF0aW9ucyBoYXBwZW4gb24gdGhlIGZ1bGx5IGRlcmVmZXJlbmNlZFxuICAgIC8vIGxvY2F0aW9uLCBzbyB0aGlzIGRldGVjdGlvbiBvbmx5IG5lZWRzIHRvIGhhcHBlbiBpbiBvbmUgZGlyZWN0aW9uXG4gICAgdmFyIHRvTWFwID0gbW9kZWwuX3JlZnMudG9NYXA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3VicGF0aCA9IChzdWJwYXRoKSA/IHN1YnBhdGggKyAnLicgKyBzZWdtZW50c1tpXSA6IHNlZ21lbnRzW2ldO1xuICAgICAgLy8gSWYgYSByZWYgaXMgZm91bmQgcG9pbnRpbmcgdG8gYSBtYXRjaGluZyBzdWJwYXRoLCByZS1lbWl0IG9uIHRoZVxuICAgICAgLy8gcGxhY2Ugd2hlcmUgdGhlIHJlZmVyZW5jZSBpcyBjb21pbmcgZnJvbSBhcyBpZiB0aGUgbXV0YXRpb24gYWxzb1xuICAgICAgLy8gb2NjdXJlZCBhdCB0aGF0IHBhdGhcbiAgICAgIHZhciByZWZzID0gdG9NYXBbc3VicGF0aF07XG4gICAgICBpZiAoIXJlZnMpIGNvbnRpbnVlO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHNlZ21lbnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgICAgdmFyIHJlZiA9IHJlZnNbcmVmSW5kZXhdO1xuICAgICAgICB2YXIgZGVyZWZlcmVuY2VkID0gcmVmLmZyb21TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG1heSBhbHJlYWR5IGJlIHVwIHRvIGRhdGUgdmlhIG9iamVjdCByZWZlcmVuY2UuIElmIHNvLFxuICAgICAgICAvLyBzaW1wbHkgcmUtZW1pdCB0aGUgZXZlbnQuIE90aGVyd2lzZSwgcGVyZm9ybSB0aGUgc2FtZSBtdXRhdGlvbiBvblxuICAgICAgICAvLyB0aGUgcmVmJ3MgcGF0aFxuICAgICAgICBpZiAocGFzcy4kb3JpZ2luYWwgfHwgbW9kZWwuX2dldChkZXJlZmVyZW5jZWQpID09PSBtb2RlbC5fZ2V0KHNlZ21lbnRzKSkge1xuICAgICAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZXR0ZXJNb2RlbCA9IHJlZi5tb2RlbC5wYXNzKHBhc3MsIHRydWUpO1xuICAgICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgICBmbihzZXR0ZXJNb2RlbCwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGEgcmVmIHBvaW50cyB0byBhIGNoaWxkIG9mIGEgbWF0Y2hpbmcgc3VicGF0aCwgZ2V0IHRoZSB2YWx1ZSBpblxuICAgIC8vIGNhc2UgaXQgaGFzIGNoYW5nZWQgYW5kIHNldCBpZiBkaWZmZXJlbnRcbiAgICB2YXIgcGFyZW50VG9NYXAgPSBtb2RlbC5fcmVmcy5wYXJlbnRUb01hcDtcbiAgICB2YXIgcmVmcyA9IHBhcmVudFRvTWFwW3N1YnBhdGhdO1xuICAgIGlmICghcmVmcykgcmV0dXJuO1xuICAgIGZvciAodmFyIHJlZkluZGV4ID0gMCwgbnVtUmVmcyA9IHJlZnMubGVuZ3RoOyByZWZJbmRleCA8IG51bVJlZnM7IHJlZkluZGV4KyspIHtcbiAgICAgIHZhciByZWYgPSByZWZzW3JlZkluZGV4XTtcbiAgICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQocmVmLnRvU2VnbWVudHMpO1xuICAgICAgdmFyIHByZXZpb3VzID0gbW9kZWwuX2dldChyZWYuZnJvbVNlZ21lbnRzKTtcbiAgICAgIGlmIChwcmV2aW91cyAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFyIHNldHRlck1vZGVsID0gcmVmLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG4gICAgICAgIHNldHRlck1vZGVsLl9kZXJlZmVyZW5jZSA9IG5vb3BEZXJlZmVyZW5jZTtcbiAgICAgICAgc2V0dGVyTW9kZWwuX3NldChyZWYuZnJvbVNlZ21lbnRzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZyb20sIHRvLCBvcHRpb25zO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodGhpcy5pc1BhdGgoYXJndW1lbnRzWzFdKSkge1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIHZhciB0b1BhdGggPSB0aGlzLnBhdGgodG8pO1xuICB2YXIgZnJvbVNlZ21lbnRzID0gZnJvbVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKGZyb21TZWdtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAncmVmIG11c3QgYmUgcGVyZm9ybWVkIHVuZGVyIGEgY29sbGVjdGlvbiAnICtcbiAgICAgICdhbmQgZG9jdW1lbnQgaWQuIEludmFsaWQgcGF0aDogJyArIGZyb21QYXRoO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICB9XG4gIHRoaXMucm9vdC5fcmVmcy5yZW1vdmUoZnJvbVBhdGgpO1xuICB2YXIgdmFsdWUgPSB0aGlzLmdldCh0byk7XG4gIHRoaXMuX3NldChmcm9tU2VnbWVudHMsIHZhbHVlKTtcbiAgdGhpcy5yb290Ll9yZWZzLmFkZChmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuc2NvcGUoZnJvbVBhdGgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnJlbW92ZVJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB0aGlzLnJvb3QuX3JlZnMucmVtb3ZlKGZyb21QYXRoKTtcbiAgdGhpcy5kZWwoZnJvbSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsUmVmcyA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGZvciAodmFyIGZyb20gaW4gcmVmcykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKHNlZ21lbnRzLCByZWZzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmKGZyb20pO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBmcm9tIGluIHJlZkxpc3RzKSB7XG4gICAgaWYgKHV0aWwuY29udGFpbnMoc2VnbWVudHMsIHJlZkxpc3RzW2Zyb21dLmZyb21TZWdtZW50cykpIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVmTGlzdChmcm9tKTtcbiAgICB9XG4gIH1cbn07XG5cbk1vZGVsLnByb3RvdHlwZS5kZXJlZmVyZW5jZSA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpLmpvaW4oJy4nKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yLCBpZ25vcmUpIHtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHNlZ21lbnRzO1xuICB2YXIgcmVmcyA9IHRoaXMucm9vdC5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLnJvb3QuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGRvIHtcbiAgICB2YXIgc3VicGF0aCA9ICcnO1xuICAgIHZhciBkb0FnYWluID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdWJwYXRoID0gKHN1YnBhdGgpID8gc3VicGF0aCArICcuJyArIHNlZ21lbnRzW2ldIDogc2VnbWVudHNbaV07XG5cbiAgICAgIHZhciByZWYgPSByZWZzW3N1YnBhdGhdO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICBzZWdtZW50cyA9IHJlZi50b1NlZ21lbnRzLmNvbmNhdChyZW1haW5pbmcpO1xuICAgICAgICBkb0FnYWluID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZMaXN0ID0gcmVmTGlzdHNbc3VicGF0aF07XG4gICAgICBpZiAocmVmTGlzdCAmJiByZWZMaXN0ICE9PSBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGJlbG93RGVzY2VuZGFudCA9IGkgKyAyIDwgbGVuO1xuICAgICAgICB2YXIgYmVsb3dDaGlsZCA9IGkgKyAxIDwgbGVuO1xuICAgICAgICBpZiAoIShiZWxvd0Rlc2NlbmRhbnQgfHwgZm9yQXJyYXlNdXRhdG9yICYmIGJlbG93Q2hpbGQpKSBjb250aW51ZTtcbiAgICAgICAgc2VnbWVudHMgPSByZWZMaXN0LmRlcmVmZXJlbmNlKHNlZ21lbnRzLCBpKTtcbiAgICAgICAgZG9BZ2FpbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoZG9BZ2Fpbik7XG4gIC8vIElmIGEgZGVyZWZlcmVuY2UgZmFpbHMsIHJldHVybiBhIHBhdGggdGhhdCB3aWxsIHJlc3VsdCBpbiBhIG51bGwgdmFsdWVcbiAgLy8gaW5zdGVhZCBvZiBhIHBhdGggdG8gZXZlcnl0aGluZyBpbiB0aGUgbW9kZWxcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFsnJG51bGwnXTtcbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuZnVuY3Rpb24gbm9vcERlcmVmZXJlbmNlKHNlZ21lbnRzKSB7XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gUmVmKG1vZGVsLCBmcm9tLCB0bywgb3B0aW9ucykge1xuICB0aGlzLm1vZGVsID0gbW9kZWwgJiYgbW9kZWwucGFzcyh7JHJlZjogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0by5zcGxpdCgnLicpO1xuICB0aGlzLnBhcmVudFRvcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy50b1NlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcmVudFRvID0gdGhpcy50b1NlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKTtcbiAgICB0aGlzLnBhcmVudFRvcy5wdXNoKHBhcmVudFRvKTtcbiAgfVxuICB0aGlzLnVwZGF0ZUluZGljZXMgPSBvcHRpb25zICYmIG9wdGlvbnMudXBkYXRlSW5kaWNlcztcbn1cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gVG9NYXAoKSB7fVxuXG5mdW5jdGlvbiBSZWZzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG4gIHRoaXMudG9NYXAgPSBuZXcgVG9NYXA7XG4gIHRoaXMucGFyZW50VG9NYXAgPSBuZXcgVG9NYXA7XG59XG5cblJlZnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciByZWYgPSBuZXcgUmVmKHRoaXMubW9kZWwsIGZyb20sIHRvLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXMuX2FkZChyZWYpO1xufTtcblxuUmVmcy5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uKHJlZikge1xuICB0aGlzLmZyb21NYXBbcmVmLmZyb21dID0gcmVmO1xuICBsaXN0TWFwQWRkKHRoaXMudG9NYXAsIHJlZi50bywgcmVmKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlZi5wYXJlbnRUb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaXN0TWFwQWRkKHRoaXMucGFyZW50VG9NYXAsIHJlZi5wYXJlbnRUb3NbaV0sIHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlZjtcbn07XG5cblJlZnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZiA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgaWYgKCFyZWYpIHJldHVybjtcbiAgZGVsZXRlIHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgbGlzdE1hcFJlbW92ZSh0aGlzLnRvTWFwLCByZWYudG8sIHJlZik7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWYucGFyZW50VG9zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGlzdE1hcFJlbW92ZSh0aGlzLnBhcmVudFRvTWFwLCByZWYucGFyZW50VG9zW2ldLCByZWYpO1xuICB9XG4gIHJldHVybiByZWY7XG59O1xuXG5SZWZzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBmcm9tIGluIHRoaXMuZnJvbU1hcCkge1xuICAgIHZhciByZWYgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZi5mcm9tLCByZWYudG9dKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuZnVuY3Rpb24gbGlzdE1hcEFkZChtYXAsIG5hbWUsIGl0ZW0pIHtcbiAgbWFwW25hbWVdIHx8IChtYXBbbmFtZV0gPSBbXSk7XG4gIG1hcFtuYW1lXS5wdXNoKGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBsaXN0TWFwUmVtb3ZlKG1hcCwgbmFtZSwgaXRlbSkge1xuICB2YXIgaXRlbXMgPSBtYXBbbmFtZV07XG4gIGlmICghaXRlbXMpIHJldHVybjtcbiAgdmFyIGluZGV4ID0gaXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgZGVsZXRlIG1hcFtuYW1lXTtcbn1cbiIsInZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cblxuLyohXG4gKiBxdWVyeXN0cmluZ1xuICogQ29weXJpZ2h0KGMpIDIwMTAgVEogSG9sb3dheWNodWsgPHRqQHZpc2lvbi1tZWRpYS5jYT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTGlicmFyeSB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICcwLjMuMSc7XG5cbi8qKlxuICogT2JqZWN0I3RvU3RyaW5nKCkgcmVmIGZvciBzdHJpbmdpZnkoKS5cbiAqL1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBub3RpbnQgPSAvW14wLTldLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gcXVlcnkgYHN0cmAsIHJldHVybmluZyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc3RyKXtcbiAgaWYgKG51bGwgPT0gc3RyIHx8ICcnID09IHN0cikgcmV0dXJuIHt9O1xuXG4gIGZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgICBpZiAocGFyZW50W2tleV0ubGVuZ3RoID09IDApIHJldHVybiBwYXJlbnRba2V5XSA9IHt9O1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICAgIHBhcmVudFtrZXldID0gdDtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoc3RyKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLnJlZHVjZShmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgICAgdHJ5eyBcbiAgICAgICAgcGFpciA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cblxuICAgICAgdmFyIGVxbCA9IHBhaXIuaW5kZXhPZignPScpXG4gICAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgICAsIGtleSA9IHBhaXIuc3Vic3RyKDAsIGJyYWNlIHx8IGVxbClcbiAgICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgICAsIHZhbCA9IHZhbC5zdWJzdHIodmFsLmluZGV4T2YoJz0nKSArIDEsIHZhbC5sZW5ndGgpXG4gICAgICAgICwgcGFyZW50ID0gcmV0O1xuXG4gICAgICAvLyA/Zm9vXG4gICAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcblxuICAgICAgLy8gbmVzdGVkXG4gICAgICBpZiAofmtleS5pbmRleE9mKCddJykpIHtcbiAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICAgICAsIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICAgICwgbGFzdCA9IGxlbiAtIDE7XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2UocGFydHMsIHBhcmVudCwga2V5KSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgICAgICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgICAgICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHBhcmVudFtrZXldID0gcGFyZW50W2tleV0gfHwgW107XG4gICAgICAgICAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmICgnJyAhPSB2YWwpIG9iai5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICAgICAgICAgIG9ialtvYmplY3RLZXlzKG9iaikubGVuZ3RoXSA9IHZhbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvcFxuICAgICAgICAgICAgfSBlbHNlIGlmICh+cGFydC5pbmRleE9mKCddJykpIHtcbiAgICAgICAgICAgICAgcGFydCA9IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmKG5vdGludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICAgICAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQpO1xuICAgICAgICAgICAgLy8ga2V5XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZihub3RpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgICAgICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZShwYXJ0cywgcGFyZW50LCAnYmFzZScpO1xuICAgICAgLy8gb3B0aW1pemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub3RpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICAgICAgdmFyIHQgPSB7fTtcbiAgICAgICAgICBmb3IodmFyIGsgaW4gcGFyZW50LmJhc2UpIHRba10gPSBwYXJlbnQuYmFzZVtrXTtcbiAgICAgICAgICBwYXJlbnQuYmFzZSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KHBhcmVudC5iYXNlLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSwge2Jhc2U6IHt9fSkuYmFzZTtcbn07XG5cbi8qKlxuICogVHVybiB0aGUgZ2l2ZW4gYG9iamAgaW50byBhIHF1ZXJ5IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24ob2JqLCBwcmVmaXgpIHtcbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheShvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ1tvYmplY3QgT2JqZWN0XScgPT0gdG9TdHJpbmcuY2FsbChvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcob2JqLCBwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4XG4gICAgICA/IHByZWZpeCArICdbJyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJ10nXG4gICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG4iLCJ2YXIgZGVmYXVsdEZucyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IERlZmF1bHRGbnM7XG5cbmRlZmF1bHRGbnMucmV2ZXJzZSA9IG5ldyBGblBhaXIoZ2V0UmV2ZXJzZSwgc2V0UmV2ZXJzZSk7XG5kZWZhdWx0Rm5zLmFzYyA9IGFzYztcbmRlZmF1bHRGbnMuZGVzYyA9IGRlc2M7XG5cbmZ1bmN0aW9uIERlZmF1bHRGbnMoKSB7fVxuZnVuY3Rpb24gRm5QYWlyKGdldCwgc2V0KSB7XG4gIHRoaXMuZ2V0ID0gZ2V0O1xuICB0aGlzLnNldCA9IHNldDtcbn1cblxuZnVuY3Rpb24gZ2V0UmV2ZXJzZShhcnJheSkge1xuICByZXR1cm4gYXJyYXkgJiYgYXJyYXkuc2xpY2UoKS5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBzZXRSZXZlcnNlKHZhbHVlcykge1xuICByZXR1cm4gezA6IGdldFJldmVyc2UodmFsdWVzKX07XG59XG5cbmZ1bmN0aW9uIGFzYyhhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGRlc2MoYSwgYikge1xuICBpZiAoYSA+IGIpIHJldHVybiAtMTtcbiAgaWYgKGEgPCBiKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHApIHtcbiAgcmVxdWlyZSgnLi9yZWFjdGl2ZUZucycpKGFwcCk7XG4gIHJlcXVpcmUoJy4vdmlld0ZucycpKGFwcCk7XG59OyIsIihmdW5jdGlvbihnbG9iYWwpe3ZhciBodG1sVXRpbCA9IHJlcXVpcmUoJ2h0bWwtdXRpbCcpXG52YXIgbWQ1ID0gcmVxdWlyZSgnTUQ1JylcbnZhciBwYXJzZUh0bWwgPSBodG1sVXRpbC5wYXJzZVxudmFyIHRyaW1UZXh0ID0gaHRtbFV0aWwudHJpbVRleHRcbnZhciB1bmVzY2FwZUVudGl0aWVzID0gaHRtbFV0aWwudW5lc2NhcGVFbnRpdGllc1xudmFyIGVzY2FwZUh0bWwgPSBodG1sVXRpbC5lc2NhcGVIdG1sXG52YXIgZXNjYXBlQXR0cmlidXRlID0gaHRtbFV0aWwuZXNjYXBlQXR0cmlidXRlXG52YXIgaXNWb2lkID0gaHRtbFV0aWwuaXNWb2lkXG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gaHRtbFV0aWwuY29uZGl0aW9uYWxDb21tZW50XG52YXIgbWFya3VwID0gcmVxdWlyZSgnLi9tYXJrdXAnKVxudmFyIHZpZXdQYXRoID0gcmVxdWlyZSgnLi92aWV3UGF0aCcpXG52YXIgd3JhcFJlbWFpbmRlciA9IHZpZXdQYXRoLndyYXBSZW1haW5kZXJcbnZhciBjdHhQYXRoID0gdmlld1BhdGguY3R4UGF0aFxudmFyIGV4dHJhY3RQbGFjZWhvbGRlciA9IHZpZXdQYXRoLmV4dHJhY3RQbGFjZWhvbGRlclxudmFyIGRhdGFWYWx1ZSA9IHZpZXdQYXRoLmRhdGFWYWx1ZVxudmFyIHBhdGhGbkFyZ3MgPSB2aWV3UGF0aC5wYXRoRm5BcmdzXG52YXIgaXNCb3VuZCA9IHZpZXdQYXRoLmlzQm91bmRcbnZhciBldmVudEJpbmRpbmcgPSByZXF1aXJlKCcuL2V2ZW50QmluZGluZycpXG52YXIgc3BsaXRFdmVudHMgPSBldmVudEJpbmRpbmcuc3BsaXRFdmVudHNcbnZhciBmbkxpc3RlbmVyID0gZXZlbnRCaW5kaW5nLmZuTGlzdGVuZXJcbnZhciBkZXJieSA9IHJlcXVpcmUoJy4vZGVyYnknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG5cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICByZXR1cm4gJyc7XG59XG5cbnZhciBkZWZhdWx0Q3R4ID0ge1xuICAkYWxpYXNlczoge31cbiwgJHBhdGhzOiBbXVxuLCAkaW5kaWNlczogW11cbn07XG5cbnZhciBDQU1FTF9SRUdFWFAgPSAvKFthLXpdKShbQS1aXSkvZztcblxudmFyIGRlZmF1bHRHZXRGbnMgPSB7XG4gIGVxdWFsOiBmdW5jdGlvbiBnZXRFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiwgbm90OiBmdW5jdGlvbiBnZXROb3QodmFsdWUpIHtcbiAgICByZXR1cm4gIXZhbHVlO1xuICB9XG4sIG9yOiBmdW5jdGlvbiBnZXRPcigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChhcmcpIHJldHVybiBhcmc7XG4gICAgfTtcbiAgICByZXR1cm4gYXJnO1xuICB9XG4sIGFuZDogZnVuY3Rpb24gZ2V0QW5kKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKCFhcmcpIHJldHVybiBhcmc7XG4gICAgfTtcbiAgICByZXR1cm4gYXJnO1xuICB9XG4sIGd0OiBmdW5jdGlvbiBnZXRHdChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPiBiO1xuICB9XG4sIGx0OiBmdW5jdGlvbiBnZXRMdChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiO1xuICB9XG4sIGd0ZTogZnVuY3Rpb24gZ2V0R3RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+PSBiO1xuICB9XG4sIGx0ZTogZnVuY3Rpb24gZ2V0THRlKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8PSBiO1xuICB9XG4sIGRhc2g6IGZ1bmN0aW9uIGdldERhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWVcbiAgICAgIC5yZXBsYWNlKC9bOl9cXHNdL2csICctJylcbiAgICAgIC5yZXBsYWNlKENBTUVMX1JFR0VYUCwgJyQxLSQyJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gIH1cbiwgam9pbjogZnVuY3Rpb24gZ2V0Sm9pbihpdGVtcywgcHJvcGVydHksIHNlcGFyYXRvcikge1xuICAgIHZhciBsaXN0LCBpO1xuICAgIGlmICghaXRlbXMpIHJldHVybjtcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGxpc3QgPSBbXTtcbiAgICAgIGZvciAoaSA9IGl0ZW1zLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBsaXN0W2ldID0gaXRlbXNbaV1bcHJvcGVydHldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gaXRlbXM7XG4gICAgfVxuICAgIHJldHVybiBsaXN0LmpvaW4oc2VwYXJhdG9yIHx8ICcsICcpO1xuICB9XG4sIGxvZzogZnVuY3Rpb24gZ2V0TG9nKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH1cbiwgdHJhY2U6IGZ1bmN0aW9uIGdldFRyYWNlKCkge1xuICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgfVxuLCBkZWJ1Z2dlcjogZnVuY3Rpb24gZ2V0RGVidWdnZXIoKSB7XG4gICAgZGVidWdnZXI7XG4gIH1cbiwgcGF0aDogZnVuY3Rpb24gZ2V0UGF0aChuYW1lKSB7XG4gICAgcmV0dXJuIGN0eFBhdGgodGhpcy52aWV3LCB0aGlzLmN0eCwgbmFtZSk7XG4gIH1cbiwgbm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9XG4sIGxvb2t1cDogdmlld1BhdGgubG9va3VwXG59O1xuXG52YXIgZGVmYXVsdFNldEZucyA9IHtcbiAgZXF1YWw6IGZ1bmN0aW9uIHNldEVxdWFsKHZhbHVlLCBhLCBiKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIFtiXTtcbiAgfVxuLCBub3Q6IGZ1bmN0aW9uIHNldE5vdCh2YWx1ZSkge1xuICAgIHJldHVybiBbIXZhbHVlXTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVmlldyhsaWJyYXJpZXMsIGFwcCwgYXBwRmlsZW5hbWUpIHtcbiAgdGhpcy5fbGlicmFyaWVzID0gbGlicmFyaWVzIHx8IFtdO1xuICB0aGlzLmFwcCA9IGFwcCB8fCB7fTtcbiAgdGhpcy5fYXBwRmlsZW5hbWUgPSBhcHBGaWxlbmFtZTtcbiAgdGhpcy5faW5saW5lID0gJyc7XG4gIHRoaXMuY2xlYXIoKTtcbiAgdGhpcy5nZXRGbnMgPSBkZXJieS51dGlsLmNvcHlPYmplY3QoZGVmYXVsdEdldEZucyk7XG4gIHRoaXMuc2V0Rm5zID0gZGVyYnkudXRpbC5jb3B5T2JqZWN0KGRlZmF1bHRTZXRGbnMpO1xuICBpZiAodGhpcy5faW5pdCkgdGhpcy5faW5pdCgpO1xuICB0aGlzLl9pZENvdW50ID0gMDtcbiAgdGhpcy5fdW5jcmVhdGVkID0gW107XG59XG5WaWV3LnByb3RvdHlwZSA9IHtcbiAgZGVmYXVsdFZpZXdzOiB7XG4gICAgZG9jdHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJzwhRE9DVFlQRSBodG1sPic7XG4gICAgfVxuICAsIHJvb3Q6IGVtcHR5XG4gICwgY2hhcnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJzxtZXRhIGNoYXJzZXQ9dXRmLTg+JztcbiAgICB9XG4gICwgdGl0bGUkczogZW1wdHlcbiAgLCBoZWFkOiBlbXB0eVxuICAsIGhlYWRlcjogZW1wdHlcbiAgLCBib2R5OiBlbXB0eVxuICAsIGZvb3RlcjogZW1wdHlcbiAgLCBzY3JpcHRzOiBlbXB0eVxuICAsIHRhaWw6IGVtcHR5XG4gIH1cblxuLCBfc2VsZk5zOiAnYXBwJ1xuXG4gIC8vIEFsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgaWRzIHN0YXJ0IHdpdGggYSBkb2xsYXIgc2lnblxuICAvLyBUT0RPOiBjaGFuZ2UgdGhpcyBzaW5jZSBpdCBtZXNzZXMgdXAgcXVlcnkgc2VsZWN0b3JzIHVubGVzcyBlc2NhcGVkXG4sIF91bmlxdWVJZDogdW5pcXVlSWRcblxuLCBjbGVhcjogY2xlYXJcbiwgX3Jlc2V0Rm9yUmVuZGVyOiByZXNldEZvclJlbmRlclxuLCBtYWtlOiBtYWtlXG4sIF9tYWtlQWxsOiBtYWtlQWxsXG4sIF9tYWtlQ29tcG9uZW50czogbWFrZUNvbXBvbmVudHNcbiwgX2ZpbmRWaWV3OiBmaW5kVmlld1xuLCBfZmluZDogZmluZFxuLCBnZXQ6IGdldFxuLCBmbjogZm5cbiwgcmVuZGVyOiByZW5kZXJcbiwgY29tcG9uZW50c0J5TmFtZTogY29tcG9uZW50c0J5TmFtZVxuLCBfY29tcG9uZW50Q29uc3RydWN0b3I6IGNvbXBvbmVudENvbnN0cnVjdG9yXG4sIF9mbHVzaFVuY3JlYXRlZDogZmx1c2hVbmNyZWF0ZWRcbiwgX2JlZm9yZVJlbmRlcjogYmVmb3JlUmVuZGVyXG4sIF9hZnRlclJlbmRlcjogYWZ0ZXJSZW5kZXJcbiwgX2JlZm9yZVJvdXRlOiBiZWZvcmVSb3V0ZVxuXG4sIGlubGluZTogZW1wdHlcblxuLCBlc2NhcGVIdG1sOiBlc2NhcGVIdG1sXG4sIGVzY2FwZUF0dHJpYnV0ZTogZXNjYXBlQXR0cmlidXRlXG59XG5cblZpZXcudmFsdWVCaW5kaW5nID0gdmFsdWVCaW5kaW5nO1xuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgdGhpcy5fdmlld3MgPSBkZXJieS51dGlsLmNvcHlPYmplY3QodGhpcy5kZWZhdWx0Vmlld3MpO1xuICB0aGlzLl9yZW5kZXJzID0ge307XG4gIHRoaXMuX3Jlc2V0Rm9yUmVuZGVyKCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Rm9yUmVuZGVyKG1vZGVsLCBjb21wb25lbnRJbnN0YW5jZXMpIHtcbiAgY29tcG9uZW50SW5zdGFuY2VzIHx8IChjb21wb25lbnRJbnN0YW5jZXMgPSB7fSk7XG4gIGlmIChtb2RlbCkgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLl9jb21wb25lbnRJbnN0YW5jZXMgPSBjb21wb25lbnRJbnN0YW5jZXM7XG4gIHZhciBsaWJyYXJpZXMgPSB0aGlzLl9saWJyYXJpZXNcbiAgICAsIGlcbiAgZm9yIChpID0gbGlicmFyaWVzLmxlbmd0aDsgaS0tOykge1xuICAgIGxpYnJhcmllc1tpXS52aWV3Ll9yZXNldEZvclJlbmRlcihtb2RlbCwgY29tcG9uZW50SW5zdGFuY2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRzQnlOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudEluc3RhbmNlc1tuYW1lXSB8fCBbXTtcbn1cblxuZnVuY3Rpb24gY29tcG9uZW50Q29uc3RydWN0b3IobmFtZSkge1xuICByZXR1cm4gdGhpcy5fc2VsZkxpYnJhcnkgJiYgdGhpcy5fc2VsZkxpYnJhcnkuY29uc3RydWN0b3JzW25hbWVdO1xufVxuXG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgcmV0dXJuICckJyArICh0aGlzLl9pZENvdW50KyspLnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFrZShuYW1lLCB0ZW1wbGF0ZSwgb3B0aW9ucywgdGVtcGxhdGVQYXRoKSB7XG4gIHZhciB2aWV3ID0gdGhpc1xuICAgICwgaXNTdHJpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMubGl0ZXJhbFxuICAgICwgbm9NaW5pZnkgPSBpc1N0cmluZ1xuICAgICwgb25CaW5kLCByZW5kZXJlciwgcmVuZGVyLCBtYXRjaFRpdGxlO1xuXG4gIGlmICh0ZW1wbGF0ZVBhdGggJiYgKHJlbmRlciA9IHRoaXMuX3JlbmRlcnNbdGVtcGxhdGVQYXRoXSkpIHtcbiAgICB0aGlzLl92aWV3c1tuYW1lXSA9IHJlbmRlcjtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIG1hdGNoVGl0bGUgPSAvKD86XnxcXDopdGl0bGUoXFwkcyk/JC8uZXhlYyhuYW1lKTtcbiAgaWYgKG1hdGNoVGl0bGUpIHtcbiAgICBpc1N0cmluZyA9ICEhbWF0Y2hUaXRsZVsxXTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIG9uQmluZCA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSkge1xuICAgICAgICByZXR1cm4gYmluZEV2ZW50cyhldmVudHMsIG5hbWUsIHJlbmRlciwgWyckX2RvYycsICdwcm9wJywgJ3RpdGxlJ10pO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYWtlKG5hbWUgKyAnJHMnLCB0ZW1wbGF0ZSwgb3B0aW9ucywgdGVtcGxhdGVQYXRoKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIgPSBmdW5jdGlvbihjdHgsIG1vZGVsLCB0cmlnZ2VySWQpIHtcbiAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlciA9IHBhcnNlKHZpZXcsIG5hbWUsIHRlbXBsYXRlLCBpc1N0cmluZywgb25CaW5kLCBub01pbmlmeSk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJlcihjdHgsIG1vZGVsLCB0cmlnZ2VySWQpO1xuICB9XG5cbiAgcmVuZGVyLm5vbnZvaWQgPSBvcHRpb25zICYmIG9wdGlvbnMubm9udm9pZDtcblxuICB0aGlzLl92aWV3c1tuYW1lXSA9IHJlbmRlcjtcbiAgaWYgKHRlbXBsYXRlUGF0aCkgdGhpcy5fcmVuZGVyc1t0ZW1wbGF0ZVBhdGhdID0gcmVuZGVyO1xufVxuXG5mdW5jdGlvbiBtYWtlQWxsKHRlbXBsYXRlcywgaW5zdGFuY2VzKSB7XG4gIHZhciBuYW1lLCBpbnN0YW5jZSwgb3B0aW9ucywgdGVtcGxhdGVQYXRoO1xuICBpZiAoIWluc3RhbmNlcykgcmV0dXJuO1xuICB0aGlzLmNsZWFyKCk7XG4gIGZvciAobmFtZSBpbiBpbnN0YW5jZXMpIHtcbiAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tuYW1lXTtcbiAgICB0ZW1wbGF0ZVBhdGggPSBpbnN0YW5jZVswXTtcbiAgICBvcHRpb25zID0gaW5zdGFuY2VbMV07XG4gICAgdGhpcy5tYWtlKG5hbWUsIHRlbXBsYXRlc1t0ZW1wbGF0ZVBhdGhdLCBvcHRpb25zLCB0ZW1wbGF0ZVBhdGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VDb21wb25lbnRzKGNvbXBvbmVudHMpIHtcbiAgdmFyIGxpYnJhcmllc01hcCA9IHRoaXMuX2xpYnJhcmllcy5tYXBcbiAgICAsIG5hbWUsIGNvbXBvbmVudCwgbGlicmFyeTtcbiAgZm9yIChuYW1lIGluIGNvbXBvbmVudHMpIHtcbiAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW25hbWVdO1xuICAgIGxpYnJhcnkgPSBsaWJyYXJpZXNNYXBbbmFtZV07XG4gICAgbGlicmFyeSAmJiBsaWJyYXJ5LnZpZXcuX21ha2VBbGwoY29tcG9uZW50LnRlbXBsYXRlcywgY29tcG9uZW50Lmluc3RhbmNlcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFZpZXcobmFtZSwgbnMpIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5fdmlld3NcbiAgICAsIGl0ZW0sIGksIHNlZ21lbnRzLCB0ZXN0TnM7XG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChucykge1xuICAgIG5zID0gbnMudG9Mb3dlckNhc2UoKTtcbiAgICBpdGVtID0gaXRlbXNbbnMgKyAnOicgKyBuYW1lXTtcbiAgICBpZiAoaXRlbSkgcmV0dXJuIGl0ZW07XG5cbiAgICBzZWdtZW50cyA9IG5zLnNwbGl0KCc6Jyk7XG4gICAgZm9yIChpID0gc2VnbWVudHMubGVuZ3RoOyBpLS0gPiAxOykge1xuICAgICAgdGVzdE5zID0gc2VnbWVudHMuc2xpY2UoMCwgaSkuam9pbignOicpO1xuICAgICAgaXRlbSA9IGl0ZW1zW3Rlc3ROcyArICc6JyArIG5hbWVdO1xuICAgICAgaWYgKGl0ZW0pIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXNbbmFtZV07XG59XG5cbmZ1bmN0aW9uIGZpbmQobmFtZSwgbnMsIG9wdGlvbmFsKSB7XG4gIHZhciB2aWV3ID0gdGhpcy5fZmluZFZpZXcobmFtZSwgbnMpO1xuICBpZiAodmlldykgcmV0dXJuIHZpZXc7XG4gIGlmIChvcHRpb25hbCkgcmV0dXJuIGVtcHR5O1xuICBpZiAobnMpIG5hbWUgPSBucyArICc6JyArIG5hbWU7XG4gIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgdGVtcGxhdGU6IFxcbiAgXCIgKyBuYW1lICsgJ1xcblxcbicgK1xuICAgICdBdmFpbGFibGUgdGVtcGxhdGVzOiBcXG4gICcgKyBPYmplY3Qua2V5cyh0aGlzLl92aWV3cykuam9pbignXFxuICAnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXQobmFtZSwgbnMsIGN0eCkge1xuICBpZiAodHlwZW9mIG5zID09PSAnb2JqZWN0Jykge1xuICAgIGN0eCA9IG5zO1xuICAgIG5zID0gJyc7XG4gIH1cbiAgY3R4ID0gY3R4ID8gZXh0ZW5kKGN0eCwgZGVmYXVsdEN0eCkgOiBkZXJieS51dGlsLmNvcHlPYmplY3QoZGVmYXVsdEN0eCk7XG4gIHRoaXMuYXBwLm1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY3R4LiRmbkN0eCA9IFt0aGlzLmFwcF07XG4gIGN0eC4kcGF0aElkcyA9IHt9O1xuICByZXR1cm4gdGhpcy5fZmluZChuYW1lLCBucykoY3R4KTtcbn1cblxuZnVuY3Rpb24gZm4obmFtZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGsgaW4gbmFtZSkge1xuICAgICAgdGhpcy5mbihrLCBuYW1lW2tdKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBnZXQsIHNldDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBnZXQgPSB2YWx1ZS5nZXQ7XG4gICAgc2V0ID0gdmFsdWUuc2V0O1xuICB9IGVsc2Uge1xuICAgIGdldCA9IHZhbHVlO1xuICB9XG4gIHRoaXMuZ2V0Rm5zW25hbWVdID0gZ2V0O1xuICBpZiAoc2V0KSB0aGlzLnNldEZuc1tuYW1lXSA9IHNldDtcbn1cblxuZnVuY3Rpb24gZW1pdFJlbmRlcih2aWV3LCBucywgY3R4LCBuYW1lKSB7XG4gIGlmICh2aWV3LmlzU2VydmVyKSByZXR1cm47XG4gIHZpZXcuYXBwLmVtaXQobmFtZSwgY3R4KTtcbiAgaWYgKG5zKSB2aWV3LmFwcC5lbWl0KG5hbWUgKyAnOicgKyBucywgY3R4KTtcbn1cbmZ1bmN0aW9uIGJlZm9yZVJlbmRlcihtb2RlbCwgbnMsIGN0eCkge1xuICBjdHggPSAoY3R4ICYmIE9iamVjdC5jcmVhdGUoY3R4KSkgfHwge307XG4gIGN0eC4kbnMgPSBucztcbiAgZW1pdFJlbmRlcih0aGlzLCBucywgY3R4LCAncHJlOnJlbmRlcicpO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gYWZ0ZXJSZW5kZXIobnMsIGN0eCkge1xuICBlbWl0UmVuZGVyKHRoaXMsIG5zLCBjdHgsICdyZW5kZXInKTtcbn1cbmZ1bmN0aW9uIGJlZm9yZVJvdXRlKCkge1xuICB0aGlzLmFwcC5kb20uY2xlYXIoKTtcbiAgLy8gUmVtb3ZlIGFsbCBkYXRhLCByZWZzLCBsaXN0ZW5lcnMsIGFuZCByZWFjdGl2ZSBmdW5jdGlvbnNcbiAgLy8gZm9yIHRoZSBwcmV2aW91cyBwYWdlXG4gIHZhciBzaWxlbnRNb2RlbCA9IHRoaXMubW9kZWwuc2lsZW50KCk7XG4gIHNpbGVudE1vZGVsLmRlc3Ryb3koJ19wYWdlJyk7XG4gIHNpbGVudE1vZGVsLmRlc3Ryb3koJyRjb21wb25lbnRzJyk7XG4gIC8vIFVuZmV0Y2ggYW5kIHVuc3Vic2NyaWJlIGZyb20gYWxsIHF1ZXJpZXMgYW5kIGRvY3VtZW50c1xuICBzaWxlbnRNb2RlbC51bmxvYWQoKTtcbiAgdmFyIGxhc3RSZW5kZXIgPSB0aGlzLl9sYXN0UmVuZGVyO1xuICBpZiAoIWxhc3RSZW5kZXIpIHJldHVybjtcbiAgZW1pdFJlbmRlcih0aGlzLCBsYXN0UmVuZGVyLm5zLCBsYXN0UmVuZGVyLmN0eCwgJ3JlcGxhY2UnKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKG1vZGVsLCBucywgY3R4LCByZW5kZXJIYXNoKSB7XG4gIGlmICh0eXBlb2YgbnMgPT09ICdvYmplY3QnKSB7XG4gICAgcmVuZGVySGFzaCA9IGN0eDtcbiAgICBjdHggPSBucztcbiAgICBucyA9ICcnO1xuICB9XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICBpZiAoIWN0eC4kaXNTZXJ2ZXIpIGN0eCA9IHRoaXMuX2JlZm9yZVJlbmRlcihtb2RlbCwgbnMsIGN0eCk7XG4gIHRoaXMuX2xhc3RSZW5kZXIgPSB7XG4gICAgbnM6IG5zXG4gICwgY3R4OiBjdHhcbiAgfTtcblxuICB0aGlzLl9yZXNldEZvclJlbmRlcigpO1xuICBtb2RlbC5fX3BhdGhNYXAuY2xlYXIoKTtcbiAgbW9kZWwuX19ldmVudHMuY2xlYXIoKTtcbiAgbW9kZWwuX19ibG9ja1BhdGhzID0ge307XG4gIHRoaXMuYXBwLmRvbS5jbGVhcigpO1xuICBtb2RlbC5zaWxlbnQoKS5kZXN0cm95KCckY29tcG9uZW50cycpO1xuXG4gIHZhciB0aXRsZSA9IHRoaXMuZ2V0KCd0aXRsZSRzJywgbnMsIGN0eClcbiAgICAsIGhlYWRIdG1sID0gdGhpcy5nZXQoJ2hlYWQnLCBucywgY3R4KVxuICAgICwgcm9vdEh0bWwgPSB0aGlzLmdldCgncm9vdCcsIG5zLCBjdHgpXG4gICAgLCBib2R5SHRtbCA9IHRoaXMuZ2V0KCdoZWFkZXInLCBucywgY3R4KSArXG4gICAgICAgIHRoaXMuZ2V0KCdib2R5JywgbnMsIGN0eCkgK1xuICAgICAgICB0aGlzLmdldCgnZm9vdGVyJywgbnMsIGN0eClcbiAgICAsIGRvYyA9IHdpbmRvdy5kb2N1bWVudFxuICAgICwgZXJyXG5cbiAgaWYgKHJlbmRlckhhc2gpIHtcbiAgICAvLyBDaGVjayBoYXNoZXMgaW4gZGV2ZWxvcG1lbnQgdG8gaGVscCBmaW5kIHJlbmRlcmluZyBidWdzXG4gICAgaWYgKHJlbmRlckhhc2ggPT09IG1kNShib2R5SHRtbCkpIHtcbiAgICAgIHRoaXMuX2ZsdXNoVW5jcmVhdGVkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVyciA9IG5ldyBFcnJvcignU2VydmVyIGFuZCBjbGllbnQgcGFnZSByZW5kZXJzIGRvIG5vdCBtYXRjaCcpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSwgMCk7XG4gIH0gZWxzZSBpZiAoY3R4LiRpc1NlcnZlcikge1xuICAgIC8vIERvbid0IGZpbmlzaCByZW5kZXJpbmcgY2xpZW50IHNpZGUgb24gdGhlIHZlcnkgZmlyc3QgbG9hZCwgc2luY2VcbiAgICAvLyB0aGUgcGFnZSBzaG91bGQgYWxyZWFkeSBoYXZlIHRoZSBzYW1lIEhUTUwgZnJvbSB0aGUgc2VydmVyXG4gICAgdGhpcy5fZmx1c2hVbmNyZWF0ZWQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudFxuICAgICwgYXR0cnMgPSBkb2N1bWVudEVsZW1lbnQuYXR0cmlidXRlc1xuICAgICwgaSwgYXR0ciwgZmFrZVJvb3QsIGJvZHk7XG5cbiAgLy8gUmVtb3ZlIGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgb24gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgcmVwbGFjZVxuICAvLyB0aGVtIHdpdGggdGhlIGF0dHJpYnV0ZXMgaW4gdGhlIHJlbmRlcmVkIHJvb3RIdG1sXG4gIGZvciAoaSA9IGF0dHJzLmxlbmd0aDsgaS0tOykge1xuICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSk7XG4gIH1cbiAgLy8gVXNpbmcgdGhlIERPTSB0byBnZXQgdGhlIGF0dHJpYnV0ZXMgb24gYW4gPGh0bWw+IHRhZyB3b3VsZCByZXF1aXJlXG4gIC8vIHNvbWUgc29ydCBvZiBpZnJhbWUgaGFjayB1bnRpbCBET01QYXJzZXIgaGFzIGJldHRlciBicm93c2VyIHN1cHBvcnQuXG4gIC8vIFN0cmluZyBwYXJzaW5nIHRoZSBodG1sIHNob3VsZCBiZSBzaW1wbGVyIGFuZCBtb3JlIGVmZmljaWVudFxuICBwYXJzZUh0bWwocm9vdEh0bWwsIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCB0YWdOYW1lLCBhdHRycykge1xuICAgICAgaWYgKHRhZ05hbWUgIT09ICdodG1sJykgcmV0dXJuO1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZha2VSb290ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgZmFrZVJvb3QuaW5uZXJIVE1MID0gYm9keUh0bWw7XG4gIGJvZHkgPSBmYWtlUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICBkb2N1bWVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGJvZHksIGRvYy5ib2R5KTtcbiAgZG9jLnRpdGxlID0gdGl0bGU7XG5cbiAgdGhpcy5hcHAuZG9tLl9zZXREaXJ0eSh0cnVlKTtcbiAgdGhpcy5fZmx1c2hVbmNyZWF0ZWQoKTtcbiAgdGhpcy5fYWZ0ZXJSZW5kZXIobnMsIGN0eCk7XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgb2JqKSB7XG4gIHZhciBvdXQgPSBPYmplY3QuY3JlYXRlKHBhcmVudClcbiAgICAsIGtleTtcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgb3V0W2tleV0gPSBvYmpba2V5XTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBtb2RlbExpc3RlbmVyKHBhcmFtcywgdHJpZ2dlcklkLCBibG9ja1BhdGhzLCBwYXRoSWQsIHBhcnRpYWwsIGN0eCwgc2F2ZUJsb2NrUGF0aCkge1xuICB2YXIgbGlzdGVuZXIgPSB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nXG4gICAgPyBwYXJhbXModHJpZ2dlcklkLCBibG9ja1BhdGhzLCBzYXZlQmxvY2tQYXRoICYmIHBhdGhJZClcbiAgICA6IHBhcmFtcztcbiAgbGlzdGVuZXIucGFydGlhbCA9IHBhcnRpYWw7XG4gIGxpc3RlbmVyLmN0eCA9IGN0eC4kc3RyaW5nQ3R4IHx8IGN0eDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiBiaW5kUGF0aEV2ZW50KGV2ZW50cywgYmluZE5hbWUsIGdldE5hbWUsIHBhcnRpYWwsIHBhcmFtcywgc2F2ZUJsb2NrUGF0aCkge1xuICBldmVudHMucHVzaChmdW5jdGlvbihjdHgsIG1vZGVsRXZlbnRzLCBkb20sIHBhdGhNYXAsIHZpZXcsIGJsb2NrUGF0aHMsIHRyaWdnZXJJZCkge1xuICAgIHZhciBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIGJpbmROYW1lKVxuICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgIHZhciBwYXRoSWQgPSBwYXRoTWFwLmlkKHBhdGgpO1xuICAgIHZhciBsaXN0ZW5lciA9IG1vZGVsTGlzdGVuZXIocGFyYW1zLCB0cmlnZ2VySWQsIGJsb2NrUGF0aHMsIHBhdGhJZCwgcGFydGlhbCwgY3R4LCBzYXZlQmxvY2tQYXRoKTtcbiAgICBpZiAoYmluZE5hbWUgIT09IGdldE5hbWUpIHtcbiAgICAgIGxpc3RlbmVyLmdldFZhbHVlID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBnZXROYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIG1vZGVsRXZlbnRzLmJpbmQocGF0aElkLCBsaXN0ZW5lcik7XG4gIH0pO1xufVxuZnVuY3Rpb24gYmluZEVhY2hQYXRoRXZlbnQoZXZlbnRzLCBuYW1lLCBnZXROYW1lLCBwYXJ0aWFsLCBwYXJhbXMpIHtcbiAgdmFyIGJyYWNrZXRJbmRleCA9IG5hbWUuaW5kZXhPZignWycpO1xuICBpZiAofmJyYWNrZXRJbmRleCkge1xuICAgIC8vIEJpbmQgdG8gZWFjaCBvZiB0aGUgaXRlbXMgaW5zaWRlIGJyYWNrZXRzXG4gICAgdmFyIHBhdGhzID0gdmlld1BhdGguc3F1YXJlQnJhY2tldHNBcmdzKG5hbWUpO1xuICAgIGZvciAodmFyIGkgPSBwYXRocy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGJpbmRFYWNoUGF0aEV2ZW50KGV2ZW50cywgcGF0aHNbaV0sIGdldE5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG4gICAgfVxuICAgIC8vIEJpbmQgdG8gYW55dGhpbmcgdW5kZXIgdGhlIHJvb3QuIFRoaXMgaW5zJ3QgdmVyeSBlZmZpY2VudCwgYnV0IGl0XG4gICAgLy8gc2hvdWxkIGNvdmVyIHZhcmlvdXMgY2FzZXMgdGhhdCB3b3VsZCByZXF1aXJlIHVwZGF0aW5nIHRoZSBiaW5kaW5nc1xuICAgIC8vIHdoZW4gdGhlIGFyZ3VtZW50cyBpbnNpZGUgb2YgdGhlIGJyYWNrZXRzIGNoYW5nZSwgd2hpY2ggSSBkb24ndCBmZWVsXG4gICAgLy8gbGlrZSBmaWd1cmluZyBvdXQgYXQgdGhlIG1vbWVudFxuICAgIHZhciBiZWZvcmUgPSBuYW1lLnNsaWNlKDAsIGJyYWNrZXRJbmRleCk7XG4gICAgaWYgKGJlZm9yZSkgYmluZEVhY2hQYXRoRXZlbnQoZXZlbnRzLCBiZWZvcmUgKyAnKicsIGdldE5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC8oXFwuKikoLiopLy5leGVjKG5hbWUpO1xuICB2YXIgcHJlZml4ID0gbWF0Y2hbMV0gfHwgJyc7XG4gIHZhciByZWxhdGl2ZU5hbWUgPSBtYXRjaFsyXSB8fCAnJztcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmVOYW1lLnNwbGl0KCcuJyk7XG4gIC8vIFRoaXMgbG9vcCBzdG9wcyBiZWZvcmUgcmVhY2hpbmcgemVyb1xuICB2YXIgc2F2ZUJsb2NrUGF0aCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGk7IGktLSkge1xuICAgIHZhciBiaW5kTmFtZSA9IHByZWZpeCArIHNlZ21lbnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKTtcbiAgICBiaW5kUGF0aEV2ZW50KGV2ZW50cywgYmluZE5hbWUsIGdldE5hbWUsIHBhcnRpYWwsIHBhcmFtcywgc2F2ZUJsb2NrUGF0aCk7XG4gICAgc2F2ZUJsb2NrUGF0aCA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBiaW5kRXZlbnRzKGV2ZW50cywgbmFtZSwgcGFydGlhbCwgcGFyYW1zKSB7XG4gIGlmICh+bmFtZS5pbmRleE9mKCcoJykpIHtcbiAgICB2YXIgYXJncyA9IHBhdGhGbkFyZ3MobmFtZSk7XG4gICAgZm9yICh2YXIgaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICBiaW5kRWFjaFBhdGhFdmVudChldmVudHMsIGFyZ3NbaV0gKyAnKicsIG5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBiaW5kRWFjaFBhdGhFdmVudChldmVudHMsIG5hbWUsIG5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGJpbmRFdmVudHNCeUlkKGV2ZW50cywgbmFtZSwgcGFydGlhbCwgYXR0cnMsIG1ldGhvZCwgcHJvcCwgYmxvY2tUeXBlKSB7XG4gIGZ1bmN0aW9uIHBhcmFtcyh0cmlnZ2VySWQsIGJsb2NrUGF0aHMsIHBhdGhJZCkge1xuICAgIHZhciBpZCA9IGF0dHJzLl9pZCB8fCBhdHRycy5pZDtcbiAgICBpZiAoYmxvY2tUeXBlICYmIHBhdGhJZCkge1xuICAgICAgYmxvY2tQYXRoc1tpZF0gPSB7aWQ6IHBhdGhJZCwgdHlwZTogYmxvY2tUeXBlfTtcbiAgICB9XG4gICAgcmV0dXJuIFtpZCwgbWV0aG9kLCBwcm9wXTtcbiAgfVxuICBiaW5kRXZlbnRzKGV2ZW50cywgbmFtZSwgcGFydGlhbCwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50c0J5SWRTdHJpbmcoZXZlbnRzLCBuYW1lLCBwYXJ0aWFsLCBhdHRycywgbWV0aG9kLCBwcm9wKSB7XG4gIGZ1bmN0aW9uIHBhcmFtcyh0cmlnZ2VySWQpIHtcbiAgICB2YXIgaWQgPSB0cmlnZ2VySWQgfHwgYXR0cnMuX2lkIHx8IGF0dHJzLmlkO1xuICAgIHJldHVybiBbaWQsIG1ldGhvZCwgcHJvcF07XG4gIH1cbiAgYmluZEV2ZW50cyhldmVudHMsIG5hbWUsIHBhcnRpYWwsIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGFkZElkKHZpZXcsIGF0dHJzKSB7XG4gIGlmIChhdHRycy5pZCA9PSBudWxsKSB7XG4gICAgYXR0cnMuaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhdHRycy5faWQgPSB2aWV3Ll91bmlxdWVJZCgpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFZhbHVlKGh0bWwsIGksIHZhbHVlLCBpc0F0dHIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGkgPSBodG1sLnB1c2godmFsdWUsICcnKSAtIDE7XG4gIH0gZWxzZSB7XG4gICAgaHRtbFtpXSArPSBpc0F0dHIgPyBlc2NhcGVBdHRyaWJ1dGUodmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVN0YWNrKHN0YWNrKSB7XG4gIHZhciBodG1sID0gWycnXVxuICAgICwgaSA9IDBcbiAgICAsIGF0dHJzLCBib29sLCBpdGVtLCBrZXksIHZhbHVlLCBqLCBsZW47XG5cbiAgZm9yIChqID0gMCwgbGVuID0gc3RhY2subGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICBpdGVtID0gc3RhY2tbal07XG4gICAgc3dpdGNoIChpdGVtWzBdKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIGh0bWxbaV0gKz0gJzwnICsgaXRlbVsxXTtcbiAgICAgICAgYXR0cnMgPSBpdGVtWzJdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaWQgYXR0cmlidXRlIGlzIHJlbmRlcmVkIGZpcnN0XG4gICAgICAgIGlmICgnaWQnIGluIGF0dHJzKSB7XG4gICAgICAgICAgaHRtbFtpXSArPSAnIGlkPSc7XG4gICAgICAgICAgaSA9IHB1c2hWYWx1ZShodG1sLCBpLCBhdHRycy5pZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnaWQnKSBjb250aW51ZTtcbiAgICAgICAgICB2YWx1ZSA9IGF0dHJzW2tleV07XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChib29sID0gdmFsdWUuYm9vbCkge1xuICAgICAgICAgICAgICBpID0gcHVzaFZhbHVlKGh0bWwsIGksIGJvb2wpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWxbaV0gKz0gJyAnICsga2V5ICsgJz0nO1xuICAgICAgICAgICAgaSA9IHB1c2hWYWx1ZShodG1sLCBpLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWxbaV0gKz0gJyAnICsga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sW2ldICs9ICc+JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgaSA9IHB1c2hWYWx1ZShodG1sLCBpLCBpdGVtWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICBodG1sW2ldICs9ICc8LycgKyBpdGVtWzFdICsgJz4nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21hcmtlcic6XG4gICAgICAgIGh0bWxbaV0gKz0gJzwhLS0nICsgaXRlbVsxXTtcbiAgICAgICAgaSA9IHB1c2hWYWx1ZShodG1sLCBpLCBpdGVtWzJdLmlkKTtcbiAgICAgICAgaHRtbFtpXSArPSAnLS0+JztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcmVyKHZpZXcsIGl0ZW1zLCBldmVudHMsIG9uUmVuZGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjdHgsIG1vZGVsLCB0cmlnZ2VySWQpIHtcbiAgICBpZiAoIW1vZGVsKSBtb2RlbCA9IHZpZXcubW9kZWw7ICAvLyBOZWVkZWQsIHNpbmNlIG1vZGVsIHBhcmFtZXRlciBpcyBvcHRpb25hbFxuXG4gICAgaWYgKG9uUmVuZGVyKSBjdHggPSBvblJlbmRlcihjdHgpO1xuXG4gICAgdmFyIGh0bWwgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGh0bWwgKz0gKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKSA/IGl0ZW0oY3R4LCBtb2RlbCkgfHwgJycgOiBpdGVtO1xuICAgIH1cbiAgICBpZiAodmlldy5pc1NlcnZlcikgcmV0dXJuIGh0bWw7XG5cbiAgICB2YXIgcGF0aE1hcCA9IG1vZGVsLl9fcGF0aE1hcDtcbiAgICB2YXIgbW9kZWxFdmVudHMgPSBtb2RlbC5fX2V2ZW50cztcbiAgICB2YXIgYmxvY2tQYXRocyA9IG1vZGVsLl9fYmxvY2tQYXRocztcbiAgICB2YXIgZG9tID0gZ2xvYmFsLkRFUkJZICYmIGdsb2JhbC5ERVJCWS5hcHAuZG9tO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgZXZlbnRzIGFycmF5IGNhbiBncm93IGR1cmluZyByZW5kZXJpbmdcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGV2ZW50O1xuICAgIHdoaWxlIChldmVudCA9IGV2ZW50c1tpKytdKSB7XG4gICAgICBldmVudChjdHgsIG1vZGVsRXZlbnRzLCBkb20sIHBhdGhNYXAsIHZpZXcsIGJsb2NrUGF0aHMsIHRyaWdnZXJJZCk7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRDb21wb25lbnRFdmVudChjb21wb25lbnQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIGlmIChuYW1lID09PSAnaW5pdCcgfHwgbmFtZSA9PT0gJ2NyZWF0ZScpIHtcbiAgICBjb21wb25lbnQub25jZShuYW1lLCBsaXN0ZW5lci5mbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXh0cmEgaW5kaXJlY3Rpb24gYWxsb3dzIGxpc3RlbmVyIHRvIG92ZXJ3cml0ZSBpdHNlbGYgYWZ0ZXIgZmlyc3QgcnVuXG4gICAgY29tcG9uZW50Lm9uKG5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgbGlzdGVuZXIuZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYmluZENvbXBvbmVudEV2ZW50cyhjdHgsIGNvbXBvbmVudCwgZXZlbnRzKSB7XG4gIHZhciB2aWV3ID0gZXZlbnRzLiR2aWV3XG4gICAgLCBpdGVtcyA9IGV2ZW50cy4kZXZlbnRzXG4gICAgLCBsaXN0ZW5lckN0eCA9IE9iamVjdC5jcmVhdGUoY3R4KVxuICAgICwgaSwgaXRlbSwgbmFtZSwgbGlzdGVuZXJcbiAgLy8gVGhlIGZuQ3R4IHdpbGwgaW5jbHVkZSB0aGlzIGNvbXBvbmVudCwgYnV0IHdlIHdhbnQgdG8gZW1pdFxuICAvLyBvbiB0aGUgcGFyZW50IGNvbXBvbmVudCBvciBhcHBcbiAgbGlzdGVuZXJDdHguJGZuQ3R4ID0gbGlzdGVuZXJDdHguJGZuQ3R4LnNsaWNlKDAsIC0xKTtcbiAgZm9yIChpID0gaXRlbXMubGVuZ3RoOyBpLS07KSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIG5hbWUgPSBpdGVtWzBdO1xuICAgIGxpc3RlbmVyID0gZm5MaXN0ZW5lcih2aWV3LCBsaXN0ZW5lckN0eCwgaXRlbVsyXSk7XG4gICAgYmluZENvbXBvbmVudEV2ZW50KGNvbXBvbmVudCwgbmFtZSwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCh2aWV3LCBtb2RlbCwgQ29tcG9uZW50LCBzY29wZSwgY3R4LCBtYWNyb0N0eCkge1xuICB2YXIgc2NvcGVkID0gbW9kZWwuc2NvcGUoc2NvcGUpO1xuICB2YXIgbWFya2VyID0gJzwhLS0nICsgc2NvcGUgKyAnLS0+JztcbiAgdmFyIHByZWZpeCA9IHNjb3BlICsgJy4nO1xuICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudChzY29wZWQsIHNjb3BlKTtcbiAgdmFyIHBhcmVudEZuQ3R4ID0gbW9kZWwuX19mbkN0eCB8fCBjdHguJGZuQ3R4O1xuICB2YXIgc2lsZW50Q3R4ID0gT2JqZWN0LmNyZWF0ZShjdHgpO1xuICBzaWxlbnRDdHguJHNpbGVudCA9IHRydWU7XG4gIHZhciBzaWxlbnRNb2RlbCA9IG1vZGVsLnNpbGVudCgpO1xuICB2YXIgaSwga2V5LCBwYXRoLCB2YWx1ZSwgaW5zdGFuY2VOYW1lLCBpbnN0YW5jZXM7XG5cbiAgY3R4LiRmbkN0eCA9IG1vZGVsLl9fZm5DdHggPSBwYXJlbnRGbkN0eC5jb25jYXQoY29tcG9uZW50KTtcblxuICAvLyBIQUNLOiBFbnN1cmUgdGhhdCBzY29wZWQgbW9kZWwgaGFzIHNvbWV0aGluZyBzZXRcbiAgc2NvcGVkLnNldCgnJG51bGwnLCBudWxsKTtcblxuICBmb3IgKGtleSBpbiBtYWNyb0N0eCkge1xuICAgIHZhbHVlID0gbWFjcm9DdHhba2V5XTtcbiAgICBpZiAoa2V5ID09PSAnYmluZCcpIHtcbiAgICAgIGJpbmRDb21wb25lbnRFdmVudHMoY3R4LCBjb21wb25lbnQsIHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuJG1hdGNoTmFtZSkge1xuICAgICAgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCB2YWx1ZS4kbWF0Y2hOYW1lKTtcbiAgICAgIGlmICh2YWx1ZS4kYm91bmQpIHtcbiAgICAgICAgc2lsZW50TW9kZWwucmVmKHByZWZpeCArIGtleSwgcGF0aCwge3VwZGF0ZUluZGljZXM6IHRydWV9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBwYXRoKTtcbiAgICAgIHNpbGVudE1vZGVsLnNldChwcmVmaXggKyBrZXksIHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyB0byBnZXQgdmFsdWUgb2YgdGVtcGxhdGl6ZWQgYXR0cmlidXRlc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgIHNpbGVudE1vZGVsLnNldChwcmVmaXggKyBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIGluc3RhbmNlTmFtZSA9IHNjb3BlZC5nZXQoJ25hbWUnKTtcbiAgaWYgKGluc3RhbmNlTmFtZSkge1xuICAgIGluc3RhbmNlcyA9IHZpZXcuX2NvbXBvbmVudEluc3RhbmNlc1tpbnN0YW5jZU5hbWVdIHx8XG4gICAgICAodmlldy5fY29tcG9uZW50SW5zdGFuY2VzW2luc3RhbmNlTmFtZV0gPSBbXSk7XG4gICAgaW5zdGFuY2VzLnB1c2goY29tcG9uZW50KTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuaW5pdCkgY29tcG9uZW50LmluaXQoc2NvcGVkKTtcbiAgY29tcG9uZW50LmVtaXQoJ2luaXQnLCBjb21wb25lbnQpO1xuXG4gIGlmICh2aWV3LmlzU2VydmVyIHx8IGN0eC4kc2lsZW50KSByZXR1cm4gbWFya2VyO1xuXG4gIHZhciBhcHAgPSBnbG9iYWwuREVSQlkgJiYgZ2xvYmFsLkRFUkJZLmFwcFxuICAgICwgZG9tID0gYXBwLmRvbVxuICBjb21wb25lbnQuZG9tID0gZG9tO1xuICBjb21wb25lbnQuaGlzdG9yeSA9IGFwcC5oaXN0b3J5O1xuXG4gIHZhciB1bmNyZWF0ZWQgPSBuZXcgVW5jcmVhdGVkQ29tcG9uZW50KGNvbXBvbmVudCwgc2NvcGVkLCBkb20sIHNjb3BlLCBjdHgpO1xuICB2aWV3Ll91bmNyZWF0ZWQucHVzaCh1bmNyZWF0ZWQpO1xuXG4gIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIFVuY3JlYXRlZENvbXBvbmVudChjb21wb25lbnQsIG1vZGVsLCBkb20sIHNjb3BlLCBjdHgpIHtcbiAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5kb20gPSBkb207XG4gIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgdGhpcy5jdHggPSBjdHg7XG59XG5VbmNyZWF0ZWRDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUT0RPOiBGaWd1cmUgb3V0IHVuZGVybHlpbmcgaXNzdWUgYW5kIHJlbW92ZVxuICAvLyBJZiBmb3Igc29tZSByZWFzb24sIGNvbXBvbmVudCdzIHNjb3BlZCBtb2RlbCBkb2VzIG5vdCBoYXZlIGFueSBkYXRhLFxuICAvLyBkbyBub3RoaW5nLiBOb3Qgc3VyZSB3aHkgaXQgd291bGQgZ2V0IHRvIHRoaXMgc3RhdGUsIGJ1dCBpdCBkb2VzLlxuICBpZiAoIXRoaXMubW9kZWwuZ2V0KCkpIHJldHVybjtcblxuICAvLyBEZXN0cm95IGluIGNhc2UgY29tcG9uZW50IHdhcyBjcmVhdGVkIGFuZCByZXBsYWNlZCB3aXRoaW4gcmVuZGVyaW5nXG4gIGlmICghdGhpcy5kb20ubWFya2VyKHRoaXMuc2NvcGUpKSB7XG4gICAgdGhpcy5jb21wb25lbnQuZW1pdCgnZGVzdHJveScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZG9tLmFkZENvbXBvbmVudCh0aGlzLmN0eCwgdGhpcy5jb21wb25lbnQpO1xuICBpZiAodGhpcy5jb21wb25lbnQuY3JlYXRlKSB0aGlzLmNvbXBvbmVudC5jcmVhdGUodGhpcy5tb2RlbCwgdGhpcy5jb21wb25lbnQuZG9tKTtcbiAgdGhpcy5jb21wb25lbnQuZW1pdCgnY3JlYXRlJywgdGhpcy5jb21wb25lbnQpO1xufTtcblxuZnVuY3Rpb24gZmx1c2hVbmNyZWF0ZWQoKSB7XG4gIHZhciB1bmNyZWF0ZWQ7XG4gIHdoaWxlICh1bmNyZWF0ZWQgPSB0aGlzLl91bmNyZWF0ZWQuc2hpZnQoKSkge1xuICAgIHVuY3JlYXRlZC5jcmVhdGUoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgdmFsdWUsIG5hbWUsIGFsaWFzLCBpc0VhY2gpIHtcbiAgdmFyIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSlcbiAgICAsIGFsaWFzZXM7XG4gIGN0eCA9IGV4dGVuZChjdHgsIHZhbHVlKTtcbiAgY3R4Wyd0aGlzJ10gPSB2YWx1ZTtcbiAgaWYgKGFsaWFzKSB7XG4gICAgYWxpYXNlcyA9IGN0eC4kYWxpYXNlcyA9IE9iamVjdC5jcmVhdGUoY3R4LiRhbGlhc2VzKTtcbiAgICBhbGlhc2VzW2FsaWFzXSA9IGN0eC4kcGF0aHMubGVuZ3RoO1xuICAgIGlmIChpc0VhY2gpIGFsaWFzZXNbYWxpYXNdKys7XG4gIH1cbiAgaWYgKHBhdGgpIHtcbiAgICBjdHguJHBhdGhzID0gW3BhdGhdLmNvbmNhdChjdHguJHBhdGhzKTtcbiAgfVxuICBjdHguJHBhdGhJZHMgPSBPYmplY3QuY3JlYXRlKGN0eC4kcGF0aElkcyk7XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHBhcnRpYWxWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGxpc3RlbmVyKSByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBuYW1lID8gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUpIDogdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFydGlhbEZuKHZpZXcsIG5hbWUsIHR5cGUsIGFsaWFzLCByZW5kZXIsIG5zLCBtYWNyb0N0eCkge1xuICBmdW5jdGlvbiBwYXJ0aWFsQmxvY2sgKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgIC8vIEluaGVyaXQgJiByZW5kZXIgYXR0cmlidXRlIGNvbnRleHQgdmFsdWVzXG4gICAgdmFyIHJlbmRlck1hY3JvQ3R4ID0ge31cbiAgICAgICwgcGFyZW50TWFjcm9DdHggPSBjdHguJG1hY3JvQ3R4XG4gICAgICAsIG1lcmdlZE1hY3JvQ3R4ID0gbWFjcm9DdHhcbiAgICAgICwga2V5LCB2YWwsIG1hdGNoTmFtZVxuICAgIGlmIChtYWNyb0N0eC5pbmhlcml0KSB7XG4gICAgICBtZXJnZWRNYWNyb0N0eCA9IHt9O1xuICAgICAgZGVyYnkudXRpbC5tZXJnZUludG8obWVyZ2VkTWFjcm9DdHgsIHBhcmVudE1hY3JvQ3R4KTtcbiAgICAgIGRlcmJ5LnV0aWwubWVyZ2VJbnRvKG1lcmdlZE1hY3JvQ3R4LCBtYWNyb0N0eCk7XG4gICAgICBkZWxldGUgbWVyZ2VkTWFjcm9DdHguaW5oZXJpdDtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gbWVyZ2VkTWFjcm9DdHgpIHtcbiAgICAgIHZhbCA9IG1lcmdlZE1hY3JvQ3R4W2tleV07XG4gICAgICBpZiAodmFsICYmIHZhbC4kbWF0Y2hOYW1lKSB7XG4gICAgICAgIG1hdGNoTmFtZSA9IGN0eFBhdGgodmlldywgY3R4LCB2YWwuJG1hdGNoTmFtZSk7XG4gICAgICAgIGlmIChtYXRjaE5hbWUuY2hhckF0KDApID09PSAnQCcpIHtcbiAgICAgICAgICB2YWwgPSBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbWF0Y2hOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBkZXJieS51dGlsLmNvcHlPYmplY3QodmFsKTtcbiAgICAgICAgICB2YWwuJG1hdGNoTmFtZSA9IG1hdGNoTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVuZGVyTWFjcm9DdHhba2V5XSA9IHZhbDtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBhcHByb3ByaWF0ZSBwYXJ0aWFsIHRlbXBsYXRlXG4gICAgdmFyIHBhcnRpYWxOcywgcGFydGlhbE5hbWUsIHBhcnRpYWxPcHRpb25hbCwgYXJyO1xuICAgIGlmIChuYW1lID09PSAnZGVyYnk6dmlldycpIHtcbiAgICAgIHBhcnRpYWxOcyA9IG1lcmdlZE1hY3JvQ3R4Lm5zIHx8IHZpZXcuX3NlbGZOcztcbiAgICAgIHBhcnRpYWxOYW1lID0gbWVyZ2VkTWFjcm9DdHgudmlldztcbiAgICAgIHBhcnRpYWxPcHRpb25hbCA9IG1lcmdlZE1hY3JvQ3R4Lm9wdGlvbmFsO1xuICAgICAgaWYgKCFwYXJ0aWFsTmFtZSkgdGhyb3cgbmV3IEVycm9yKCc8ZGVyYnk6dmlldz4gdGFnIHdpdGhvdXQgYSBcInZpZXdcIiBhdHRyaWJ1dGUnKVxuICAgICAgaWYgKHBhcnRpYWxOcy4kbWF0Y2hOYW1lKSB7XG4gICAgICAgIHBhcnRpYWxOcyA9IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBwYXJ0aWFsTnMuJG1hdGNoTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbE5hbWUuJG1hdGNoTmFtZSkge1xuICAgICAgICBwYXJ0aWFsTmFtZSA9IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBwYXJ0aWFsTmFtZS4kbWF0Y2hOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJyID0gc3BsaXRQYXJ0aWFsKG5hbWUpO1xuICAgICAgcGFydGlhbE5zID0gYXJyWzBdO1xuICAgICAgcGFydGlhbE5hbWUgPSBhcnJbMV07XG4gICAgfVxuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHVzaW5nIDxkZXJieTp2aWV3IHZpZXc9e3suLi59fT5cbiAgICBpZiAodHlwZW9mIHBhcnRpYWxOYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJ0aWFsTmFtZSA9IHBhcnRpYWxOYW1lKE9iamVjdC5jcmVhdGUoY3R4KSwgbW9kZWwpO1xuICAgIH1cbiAgICB2YXIgcGFydGlhbFZpZXcgPSBuc1ZpZXcodmlldywgcGFydGlhbE5zKVxuICAgICAgLCByZW5kZXIgPSBwYXJ0aWFsVmlldy5fZmluZChwYXJ0aWFsTmFtZSwgbnMsIHBhcnRpYWxPcHRpb25hbClcbiAgICAgICwgQ29tcG9uZW50ID0gcGFydGlhbFZpZXcuX2NvbXBvbmVudENvbnN0cnVjdG9yKHBhcnRpYWxOYW1lKVxuICAgICAgLCByZW5kZXJDdHgsIHNjb3BlLCBvdXQsIG1hcmtlclxuXG4gICAgLy8gUHJlcGFyZSB0aGUgY29udGV4dCBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgc2NvcGUgPSAnJGNvbXBvbmVudHMuJyArIHZpZXcuX3VuaXF1ZUlkKCk7XG4gICAgICByZW5kZXJDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCBudWxsLCBzY29wZSwgJ3NlbGYnKTtcbiAgICAgIHJlbmRlckN0eC4kZWxlbWVudHMgPSB7fTtcbiAgICAgIG1hcmtlciA9IGNyZWF0ZUNvbXBvbmVudCh2aWV3LCBtb2RlbCwgQ29tcG9uZW50LCBzY29wZSwgcmVuZGVyQ3R4LCByZW5kZXJNYWNyb0N0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlckN0eCA9IE9iamVjdC5jcmVhdGUoY3R4KTtcbiAgICB9XG4gICAgcmVuZGVyQ3R4LiRtYWNyb0N0eCA9IHJlbmRlck1hY3JvQ3R4O1xuXG4gICAgb3V0ID0gcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChtb2RlbC5fX2ZuQ3R4KSB7XG4gICAgICAgIG1vZGVsLl9fZm5DdHggPSBtb2RlbC5fX2ZuQ3R4LnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIG91dCA9IG1hcmtlciArIG91dDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhCbG9jayhjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICB2YWx1ZSA9IHBhcnRpYWxWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCB2YWx1ZSwgbGlzdGVuZXIpO1xuICAgIHZhciByZW5kZXJDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCB2YWx1ZSwgbmFtZSwgYWxpYXMpO1xuICAgIHJldHVybiByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gIH1cblxuICBmdW5jdGlvbiBpZkJsb2NrKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcikge1xuICAgIHZhbHVlID0gcGFydGlhbFZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIHZhbHVlLCBsaXN0ZW5lcik7XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiB2YWx1ZSkpIHJldHVybjtcbiAgICB2YXIgcmVuZGVyQ3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgdmFsdWUsIG5hbWUsIGFsaWFzKTtcbiAgICByZXR1cm4gcmVuZGVyKHJlbmRlckN0eCwgbW9kZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5sZXNzQmxvY2soY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgdmFsdWUgPSBwYXJ0aWFsVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiB2YWx1ZSkgcmV0dXJuO1xuICAgIHZhciByZW5kZXJDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCB2YWx1ZSwgbmFtZSwgYWxpYXMpO1xuICAgIHJldHVybiByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gIH1cblxuICBmdW5jdGlvbiBlYWNoQmxvY2soY3R4LCBtb2RlbCwgdHJpZ2dlcklkLCB2YWx1ZSwgaW5kZXgsIGxpc3RlbmVyKSB7XG4gICAgdmFsdWUgPSBwYXJ0aWFsVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUsIGxpc3RlbmVyKTtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG4gICAgaWYgKGxpc3RlbmVyICYmICFpc0FycmF5KSB7XG4gICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuO1xuICAgICAgdmFyIGxpc3RDdHggPSBleHRlbmRDdHgodmlldywgY3R4LCBudWxsLCBuYW1lLCBhbGlhcywgdHJ1ZSk7XG4gICAgICB2YXIgaXRlbVBhdGggPSBsaXN0Q3R4LiRwYXRoc1swXSArICcuJyArIGluZGV4O1xuICAgICAgdmFyIGl0ZW0gPSBwYXJ0aWFsVmFsdWUodmlldywgbGlzdEN0eCwgbW9kZWwsIGl0ZW1QYXRoLCB2YWx1ZSwgbGlzdGVuZXIpO1xuICAgICAgcmVuZGVyQ3R4ID0gZXh0ZW5kKGxpc3RDdHgsIGl0ZW0pO1xuICAgICAgcmVuZGVyQ3R4Wyd0aGlzJ10gPSBpdGVtO1xuICAgICAgcmVuZGVyQ3R4LiRpbmRpY2VzID0gW2luZGV4XS5jb25jYXQocmVuZGVyQ3R4LiRpbmRpY2VzKTtcbiAgICAgIHJlbmRlckN0eC4kaW5kZXggPSBpbmRleDtcbiAgICAgIHJlbmRlckN0eC4kcGF0aHMgPSBbaXRlbVBhdGhdLmNvbmNhdChyZW5kZXJDdHguJHBhdGhzKTtcbiAgICAgIHJldHVybiByZW5kZXIocmVuZGVyQ3R4LCBtb2RlbCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5IHx8ICF2YWx1ZS5sZW5ndGgpIHJldHVybjtcblxuICAgIHZhciBsaXN0Q3R4ID0gZXh0ZW5kQ3R4KHZpZXcsIGN0eCwgbnVsbCwgbmFtZSwgYWxpYXMsIHRydWUpO1xuXG4gICAgdmFyIG91dCA9ICcnO1xuICAgIHZhciBpbmRpY2VzID0gbGlzdEN0eC4kaW5kaWNlcztcbiAgICB2YXIgcGF0aHMgPSBsaXN0Q3R4LiRwYXRocztcbiAgICB2YXIgYmFzZVBhdGggPSBwYXRoc1swXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gdmFsdWVbaV07XG4gICAgICB2YXIgcmVuZGVyQ3R4ID0gZXh0ZW5kKGxpc3RDdHgsIGl0ZW0pO1xuICAgICAgcmVuZGVyQ3R4Wyd0aGlzJ10gPSBpdGVtO1xuICAgICAgcmVuZGVyQ3R4LiRpbmRpY2VzID0gW2ldLmNvbmNhdChpbmRpY2VzKTtcbiAgICAgIHJlbmRlckN0eC4kaW5kZXggPSBpO1xuICAgICAgcmVuZGVyQ3R4LiRwYXRocyA9IFtiYXNlUGF0aCArICcuJyArIGldLmNvbmNhdChwYXRocyk7XG4gICAgICBvdXQgKz0gKGl0ZW0gPT09IHZvaWQgMCkgP1xuICAgICAgICAnPCEtLWVtcHR5LS0+JyA6XG4gICAgICAgIHJlbmRlcihyZW5kZXJDdHgsIG1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIHZhciBibG9jayA9XG4gICAgICAodHlwZSA9PT0gJ3BhcnRpYWwnKSA/IHBhcnRpYWxCbG9ja1xuICAgIDogKHR5cGUgPT09ICd3aXRoJyB8fCB0eXBlID09PSAnZWxzZScpID8gd2l0aEJsb2NrXG4gICAgOiAodHlwZSA9PT0gJ2lmJyB8fCB0eXBlID09PSAnZWxzZSBpZicpID8gaWZCbG9ja1xuICAgIDogKHR5cGUgPT09ICd1bmxlc3MnKSA/IHVubGVzc0Jsb2NrXG4gICAgOiAodHlwZSA9PT0gJ2VhY2gnKSA/IGVhY2hCbG9ja1xuICAgIDogbnVsbFxuXG4gIGlmICghYmxvY2spIHRocm93IG5ldyBFcnJvcignVW5rbm93biBibG9jayB0eXBlOiAnICsgdHlwZSk7XG4gIGJsb2NrLnR5cGUgPSB0eXBlO1xuICByZXR1cm4gYmxvY2s7XG59XG5cbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgYXJyYXlUb1N0cmluZyA9IEFycmF5LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdmFsdWVCaW5kaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOlxuICAgICh2YWx1ZS50b1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcgfHwgdmFsdWUudG9TdHJpbmcgPT09IGFycmF5VG9TdHJpbmcpID9cbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdmFsdWVUZXh0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZUJpbmRpbmcodmFsdWUpLnRvU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHRleHRGbih2aWV3LCBuYW1lLCBlc2NhcGUsIGZvcmNlKSB7XG4gIHZhciBmaWx0ZXIgPSBlc2NhcGUgPyBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBlc2NhcGUodmFsdWVUZXh0KHZhbHVlKSk7XG4gIH0gOiB2YWx1ZVRleHQ7XG4gIHJldHVybiBmdW5jdGlvbihjdHgsIG1vZGVsKSB7XG4gICAgcmV0dXJuIGRhdGFWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBmaWx0ZXIsIGZvcmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWN0aW9uRm4odmlldywgcXVldWUpIHtcbiAgdmFyIHJlbmRlciA9IHJlbmRlcmVyKHZpZXcsIHJlZHVjZVN0YWNrKHF1ZXVlLnN0YWNrKSwgcXVldWUuZXZlbnRzKTtcbiAgdmFyIGJsb2NrID0gcXVldWUuYmxvY2s7XG4gIHJldHVybiBwYXJ0aWFsRm4odmlldywgYmxvY2submFtZSwgYmxvY2sudHlwZSwgYmxvY2suYWxpYXMsIHJlbmRlcik7XG59XG5cbmZ1bmN0aW9uIGJsb2NrRm4odmlldywgc2VjdGlvbnMpIHtcbiAgdmFyIGxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcbiAgaWYgKCFsZW4pIHJldHVybjtcbiAgaWYgKGxlbiA9PT0gMSkge1xuICAgIHJldHVybiBzZWN0aW9uRm4odmlldywgc2VjdGlvbnNbMF0pO1xuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGZucyA9IFtdXG4gICAgICAsIGksIG91dDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZucy5wdXNoKHNlY3Rpb25Gbih2aWV3LCBzZWN0aW9uc1tpXSkpO1xuICAgIH1cbiAgICBvdXQgPSBmdW5jdGlvbihjdHgsIG1vZGVsLCB0cmlnZ2VySWQsIHZhbHVlLCBpbmRleCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBvdXQ7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3V0ID0gZm5zW2ldKGN0eCwgbW9kZWwsIHRyaWdnZXJJZCwgdmFsdWUsIGluZGV4LCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChvdXQgIT0gbnVsbCkgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU1hcmt1cCh0eXBlLCBhdHRyLCB0YWdOYW1lLCBldmVudHMsIGF0dHJzLCB2YWx1ZSkge1xuICB2YXIgcGFyc2VyID0gbWFya3VwW3R5cGVdW2F0dHJdXG4gICAgLCBhbnlPdXQsIGFueVBhcnNlciwgZWxPdXQsIGVsUGFyc2VyLCBvdXQ7XG4gIGlmICghcGFyc2VyKSByZXR1cm47XG4gIGlmIChhbnlQYXJzZXIgPSBwYXJzZXJbJyonXSkge1xuICAgIGFueU91dCA9IGFueVBhcnNlcihldmVudHMsIGF0dHJzLCB2YWx1ZSk7XG4gIH1cbiAgaWYgKGVsUGFyc2VyID0gcGFyc2VyW3RhZ05hbWVdKSB7XG4gICAgZWxPdXQgPSBlbFBhcnNlcihldmVudHMsIGF0dHJzLCB2YWx1ZSk7XG4gIH1cbiAgb3V0ID0gYW55T3V0ID8gZXh0ZW5kKGFueU91dCwgZWxPdXQpIDogZWxPdXQ7XG4gIGlmIChvdXQgJiYgb3V0LmRlbCkgZGVsZXRlIGF0dHJzW2F0dHJdO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwdXNoVGV4dChzdGFjaywgdGV4dCkge1xuICBpZiAodGV4dCkgc3RhY2sucHVzaChbJ3RleHQnLCB0ZXh0XSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hWYXJGbih2aWV3LCBzdGFjaywgZm4sIG5hbWUsIGVzY2FwZUZuKSB7XG4gIGlmIChmbikge1xuICAgIHB1c2hUZXh0KHN0YWNrLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgcHVzaFRleHQoc3RhY2ssIHRleHRGbih2aWV3LCBuYW1lLCBlc2NhcGVGbikpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzUGFydGlhbCh2aWV3LCB0YWdOYW1lKSB7XG4gIGlmICh0YWdOYW1lID09PSAnZGVyYnk6dmlldycpIHJldHVybiB0cnVlO1xuICB2YXIgc3BsaXQgPSBzcGxpdFBhcnRpYWwodGFnTmFtZSk7XG4gIGlmICghc3BsaXQpIHJldHVybiBmYWxzZTtcbiAgdmFyIHRhZ05zID0gc3BsaXRbMF07XG4gIHJldHVybiAoXG4gICAgdGFnTnMgPT09ICdhcHAnIHx8XG4gICAgdGFnTnMgPT09ICdsaWInIHx8XG4gICAgISFsaWJyYXJ5Rm9yTnModmlldywgdGFnTnMpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUGFydGlhbFNlY3Rpb24odGFnTmFtZSkge1xuICByZXR1cm4gdGFnTmFtZS5jaGFyQXQoMCkgPT09ICdAJztcbn1cblxuZnVuY3Rpb24gcGFydGlhbFNlY3Rpb25OYW1lKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGlzUGFydGlhbFNlY3Rpb24odGFnTmFtZSkgPyB0YWdOYW1lLnNsaWNlKDEpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gbGlicmFyeUZvck5zKHZpZXcsIG5zKSB7XG4gIHZhciBsaWJyYXJ5ID0gdmlldy5fbGlicmFyaWVzLm1hcFtuc107XG4gIGlmIChsaWJyYXJ5KSByZXR1cm4gbGlicmFyeTtcbiAgaWYgKHZpZXcucGFyZW50KSByZXR1cm4gdmlldy5wYXJlbnQudmlldy5fbGlicmFyaWVzLm1hcFtuc107XG59XG5cbmZ1bmN0aW9uIG5zVmlldyh2aWV3LCBucykge1xuICBpZiAobnMgPT09IHZpZXcuX3NlbGZOcykgcmV0dXJuIHZpZXc7XG4gIGlmICh2aWV3LnBhcmVudCAmJiBucyA9PT0gdmlldy5wYXJlbnQudmlldy5fc2VsZk5zKSByZXR1cm4gdmlldy5wYXJlbnQudmlldztcbiAgdmFyIGxpYnJhcnkgPSBsaWJyYXJ5Rm9yTnModmlldywgbnMpO1xuICBpZiAoIWxpYnJhcnkpIHRocm93IG5ldyBFcnJvcignTm8gbGlicmFyeSBmb3VuZCB3aXRoIG5hbWVzcGFjZSAnICsgbnMpO1xuICB2YXIgcGFydGlhbFZpZXcgPSBsaWJyYXJ5LnZpZXc7XG4gIHBhcnRpYWxWaWV3Ll91bmlxdWVJZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2aWV3Ll91bmlxdWVJZCgpO1xuICB9O1xuICBwYXJ0aWFsVmlldy5tb2RlbCA9IHZpZXcubW9kZWw7XG4gIHBhcnRpYWxWaWV3Ll91bmNyZWF0ZWQgPSB2aWV3Ll91bmNyZWF0ZWQ7XG4gIHJldHVybiBwYXJ0aWFsVmlldztcbn1cblxuZnVuY3Rpb24gc3BsaXRQYXJ0aWFsKHBhcnRpYWwpIHtcbiAgdmFyIGkgPSBwYXJ0aWFsLmluZGV4T2YoJzonKTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm47XG4gIHZhciBwYXJ0aWFsTnMgPSBwYXJ0aWFsLnNsaWNlKDAsIGkpO1xuICB2YXIgcGFydGlhbE5hbWUgPSBwYXJ0aWFsLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIFtwYXJ0aWFsTnMsIHBhcnRpYWxOYW1lXTtcbn1cblxuZnVuY3Rpb24gZmluZENvbXBvbmVudCh2aWV3LCBwYXJ0aWFsLCBucykge1xuICB2YXIgYXJyID0gc3BsaXRQYXJ0aWFsKHBhcnRpYWwpXG4gICAgLCBwYXJ0aWFsTnMgPSBhcnJbMF1cbiAgICAsIHBhcnRpYWxOYW1lID0gYXJyWzFdXG4gICAgLCBwYXJ0aWFsVmlldyA9IG5zVmlldyh2aWV3LCBwYXJ0aWFsTnMpXG4gIHJldHVybiBwYXJ0aWFsVmlldy5fZmluZChwYXJ0aWFsTmFtZSwgbnMpO1xufVxuXG5mdW5jdGlvbiBpc1ZvaWRDb21wb25lbnQodmlldywgcGFydGlhbCwgbnMpIHtcbiAgaWYgKHBhcnRpYWwgPT09ICdkZXJieTp2aWV3JykgcmV0dXJuIHRydWU7XG4gIHJldHVybiAhZmluZENvbXBvbmVudCh2aWV3LCBwYXJ0aWFsLCBucykubm9udm9pZDtcbn1cblxuZnVuY3Rpb24gcHVzaFZhcih2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgcmVtYWluZGVyLCBtYXRjaCwgZm4pIHtcbiAgdmFyIG5hbWUgPSBtYXRjaC5uYW1lXG4gICAgLCBwYXJ0aWFsID0gbWF0Y2gucGFydGlhbFxuICAgICwgZXNjYXBlRm4gPSBtYXRjaC5lc2NhcGVkICYmIGVzY2FwZUh0bWxcbiAgICAsIGF0dHIsIGF0dHJzLCBib3VuZE91dCwgbGFzdCwgdGFnTmFtZSwgd3JhcDtcblxuICBpZiAocGFydGlhbCkge1xuICAgIGZuID0gcGFydGlhbEZuKHZpZXcsIHBhcnRpYWwsICdwYXJ0aWFsJywgbnVsbCwgbnVsbCwgbnMsIG1hdGNoLm1hY3JvQ3R4KTtcbiAgfVxuXG4gIGVsc2UgaWYgKG1hdGNoLmJvdW5kKSB7XG4gICAgbGFzdCA9IGxhc3RJdGVtKHN0YWNrKTtcbiAgICB3cmFwID0gbWF0Y2gucHJlIHx8XG4gICAgICAhbGFzdCB8fFxuICAgICAgKGxhc3RbMF0gIT09ICdzdGFydCcpIHx8XG4gICAgICBpc1ZvaWQodGFnTmFtZSA9IGxhc3RbMV0pIHx8XG4gICAgICB3cmFwUmVtYWluZGVyKHRhZ05hbWUsIHJlbWFpbmRlcik7XG5cbiAgICBpZiAod3JhcCkge1xuICAgICAgc3RhY2sucHVzaChbJ21hcmtlcicsICcnLCBhdHRycyA9IHt9XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJzID0gbGFzdFsyXTtcbiAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICBwYXJzZU1hcmt1cCgnYm91bmRQYXJlbnQnLCBhdHRyLCB0YWdOYW1lLCBldmVudHMsIGF0dHJzLCBtYXRjaCk7XG4gICAgICB9XG4gICAgICBib3VuZE91dCA9IHBhcnNlTWFya3VwKCdib3VuZFBhcmVudCcsICcqJywgdGFnTmFtZSwgZXZlbnRzLCBhdHRycywgbWF0Y2gpO1xuICAgICAgaWYgKGJvdW5kT3V0KSB7XG4gICAgICAgIGJpbmRFdmVudHNCeUlkKGV2ZW50cywgbmFtZSwgbnVsbCwgYXR0cnMsIGJvdW5kT3V0Lm1ldGhvZCwgYm91bmRPdXQucHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRJZCh2aWV3LCBhdHRycyk7XG5cbiAgICBpZiAoIWJvdW5kT3V0KSB7XG4gICAgICBiaW5kRXZlbnRzQnlJZChldmVudHMsIG5hbWUsIGZuLCBhdHRycywgJ2h0bWwnLCAhZm4gJiYgZXNjYXBlRm4sIG1hdGNoLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hWYXJGbih2aWV3LCBzdGFjaywgZm4sIG5hbWUsIGVzY2FwZUZuKTtcbiAgaWYgKHdyYXApIHtcbiAgICBzdGFjay5wdXNoKFtcbiAgICAgICdtYXJrZXInXG4gICAgLCAnJCdcbiAgICAsIHsgaWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXR0cnMuX2lkIH0gfVxuICAgIF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hWYXJTdHJpbmcodmlldywgbnMsIHN0YWNrLCBldmVudHMsIHJlbWFpbmRlciwgbWF0Y2gsIGZuKSB7XG4gIHZhciBuYW1lID0gbWF0Y2gubmFtZVxuICAgICwgZXNjYXBlRm4gPSAhbWF0Y2guZXNjYXBlZCAmJiB1bmVzY2FwZUVudGl0aWVzO1xuICBmdW5jdGlvbiBiaW5kT25jZShjdHgpIHtcbiAgICBjdHguJG9uQmluZChldmVudHMsIG5hbWUpO1xuICAgIGJpbmRPbmNlID0gZW1wdHk7XG4gIH1cbiAgaWYgKG1hdGNoLmJvdW5kKSB7XG4gICAgZXZlbnRzLnB1c2goZnVuY3Rpb24oY3R4KSB7XG4gICAgICBiaW5kT25jZShjdHgpO1xuICAgIH0pO1xuICB9XG4gIHB1c2hWYXJGbih2aWV3LCBzdGFjaywgZm4sIG5hbWUsIGVzY2FwZUZuKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNYXRjaEVycm9yKHRleHQsIG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyAnXFxuXFxuJyArIHRleHQgKyAnXFxuJyk7XG59XG5cbmZ1bmN0aW9uIG9uQmxvY2soc3RhcnQsIGVuZCwgYmxvY2ssIHF1ZXVlcywgY2FsbGJhY2tzKSB7XG4gIHZhciBsYXN0UXVldWUsIHF1ZXVlO1xuICBpZiAoZW5kKSB7XG4gICAgbGFzdFF1ZXVlID0gcXVldWVzLnBvcCgpO1xuICAgIHF1ZXVlID0gbGFzdEl0ZW0ocXVldWVzKTtcbiAgICBxdWV1ZS5zZWN0aW9ucy5wdXNoKGxhc3RRdWV1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUgPSBsYXN0SXRlbShxdWV1ZXMpO1xuICB9XG5cbiAgaWYgKHN0YXJ0KSB7XG4gICAgcXVldWUgPSB7XG4gICAgICBzdGFjazogW11cbiAgICAsIGV2ZW50czogW11cbiAgICAsIGJsb2NrOiBibG9ja1xuICAgICwgc2VjdGlvbnM6IFtdXG4gICAgfTtcbiAgICBxdWV1ZXMucHVzaChxdWV1ZSk7XG4gICAgY2FsbGJhY2tzLm9uU3RhcnQocXVldWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbmQpIHtcbiAgICAgIGNhbGxiYWNrcy5vblN0YXJ0KHF1ZXVlKTtcbiAgICAgIGNhbGxiYWNrcy5vbkVuZChxdWV1ZS5zZWN0aW9ucyk7XG4gICAgICBxdWV1ZS5zZWN0aW9ucyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFja3Mub25Db250ZW50KGJsb2NrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VNYXRjaCh0ZXh0LCBtYXRjaCwgcXVldWVzLCBjYWxsYmFja3MpIHtcbiAgdmFyIGhhc2ggPSBtYXRjaC5oYXNoXG4gICAgLCB0eXBlID0gbWF0Y2gudHlwZVxuICAgICwgbmFtZSA9IG1hdGNoLm5hbWVcbiAgICAsIGJsb2NrID0gbGFzdEl0ZW0ocXVldWVzKS5ibG9ja1xuICAgICwgYmxvY2tUeXBlID0gYmxvY2sgJiYgYmxvY2sudHlwZVxuICAgICwgc3RhcnRCbG9jaywgZW5kQmxvY2s7XG5cbiAgaWYgKHR5cGUgPT09ICdpZicgfHwgdHlwZSA9PT0gJ3VubGVzcycgfHwgdHlwZSA9PT0gJ2VhY2gnIHx8IHR5cGUgPT09ICd3aXRoJykge1xuICAgIGlmIChoYXNoID09PSAnIycpIHtcbiAgICAgIHN0YXJ0QmxvY2sgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzaCA9PT0gJy8nKSB7XG4gICAgICBlbmRCbG9jayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCB0eXBlICsgJyBibG9ja3MgbXVzdCBiZWdpbiB3aXRoIGEgIycpO1xuICAgIH1cblxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlbHNlJyB8fCB0eXBlID09PSAnZWxzZSBpZicpIHtcbiAgICBpZiAoaGFzaCkge1xuICAgICAgcGFyc2VNYXRjaEVycm9yKHRleHQsIHR5cGUgKyAnIGJsb2NrcyBtYXkgbm90IHN0YXJ0IHdpdGggJyArIGhhc2gpO1xuICAgIH1cbiAgICBpZiAoYmxvY2tUeXBlICE9PSAnaWYnICYmIGJsb2NrVHlwZSAhPT0gJ2Vsc2UgaWYnICYmXG4gICAgICAgIGJsb2NrVHlwZSAhPT0gJ3VubGVzcycgJiYgYmxvY2tUeXBlICE9PSAnZWFjaCcpIHtcbiAgICAgIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCB0eXBlICsgJyBtYXkgb25seSBmb2xsb3cgYGlmYCwgYGVsc2UgaWZgLCBgdW5sZXNzYCwgb3IgYGVhY2hgJyk7XG4gICAgfVxuICAgIHN0YXJ0QmxvY2sgPSB0cnVlO1xuICAgIGVuZEJsb2NrID0gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGhhc2ggPT09ICcvJykge1xuICAgIGVuZEJsb2NrID0gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGhhc2ggPT09ICcjJykge1xuICAgIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCAnIyBtdXN0IGJlIGZvbGxvd2VkIGJ5IGBpZmAsIGB1bmxlc3NgLCBgZWFjaGAsIG9yIGB3aXRoYCcpO1xuICB9XG5cbiAgaWYgKGVuZEJsb2NrICYmICFibG9jaykge1xuICAgIHBhcnNlTWF0Y2hFcnJvcih0ZXh0LCAnVW5tYXRjaGVkIHRlbXBsYXRlIGVuZCB0YWcnKTtcbiAgfVxuXG4gIG9uQmxvY2soc3RhcnRCbG9jaywgZW5kQmxvY2ssIG1hdGNoLCBxdWV1ZXMsIGNhbGxiYWNrcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXR0cih2aWV3LCB2aWV3TmFtZSwgZXZlbnRzLCB0YWdOYW1lLCBhdHRycywgYXR0cikge1xuICB2YXIgdmFsdWUgPSBhdHRyc1thdHRyXTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gIHZhciBhdHRyT3V0ID0gcGFyc2VNYXJrdXAoJ2F0dHInLCBhdHRyLCB0YWdOYW1lLCBldmVudHMsIGF0dHJzLCB2YWx1ZSkgfHwge31cbiAgICAsIGJvdW5kT3V0LCBtYXRjaCwgbmFtZSwgcmVuZGVyLCBtZXRob2QsIHByb3BlcnR5O1xuICBpZiAoYXR0ck91dC5hZGRJZCkgYWRkSWQodmlldywgYXR0cnMpO1xuXG4gIGlmIChtYXRjaCA9IGV4dHJhY3RQbGFjZWhvbGRlcih2YWx1ZSkpIHtcbiAgICBuYW1lID0gbWF0Y2gubmFtZTtcblxuICAgIGlmIChtYXRjaC5wcmUgfHwgbWF0Y2gucG9zdCkge1xuICAgICAgLy8gQXR0cmlidXRlcyBtdXN0IGJlIGEgc2luZ2xlIHN0cmluZywgc28gY3JlYXRlIGEgc3RyaW5nIHBhcnRpYWxcbiAgICAgIGFkZElkKHZpZXcsIGF0dHJzKTtcbiAgICAgIHJlbmRlciA9IHBhcnNlKHZpZXcsIHZpZXdOYW1lLCB2YWx1ZSwgdHJ1ZSwgZnVuY3Rpb24oZXZlbnRzLCBuYW1lKSB7XG4gICAgICAgIGJpbmRFdmVudHNCeUlkU3RyaW5nKGV2ZW50cywgbmFtZSwgcmVuZGVyLCBhdHRycywgJ2F0dHInLCBhdHRyKTtcbiAgICAgIH0pO1xuXG4gICAgICBhdHRyc1thdHRyXSA9IGF0dHIgPT09ICdpZCcgPyBmdW5jdGlvbihjdHgsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBhdHRycy5faWQgPSBlc2NhcGVBdHRyaWJ1dGUocmVuZGVyKGN0eCwgbW9kZWwpKTtcbiAgICAgIH0gOiBmdW5jdGlvbihjdHgsIG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVBdHRyaWJ1dGUocmVuZGVyKGN0eCwgbW9kZWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2guYm91bmQpIHtcbiAgICAgIGJvdW5kT3V0ID0gcGFyc2VNYXJrdXAoJ2JvdW5kJywgYXR0ciwgdGFnTmFtZSwgZXZlbnRzLCBhdHRycywgbWF0Y2gpIHx8IHt9O1xuICAgICAgYWRkSWQodmlldywgYXR0cnMpO1xuICAgICAgbWV0aG9kID0gYm91bmRPdXQubWV0aG9kIHx8ICdhdHRyJztcbiAgICAgIHByb3BlcnR5ID0gYm91bmRPdXQucHJvcGVydHkgfHwgYXR0cjtcbiAgICAgIGJpbmRFdmVudHNCeUlkKGV2ZW50cywgbmFtZSwgbnVsbCwgYXR0cnMsIG1ldGhvZCwgcHJvcGVydHkpO1xuICAgIH1cblxuICAgIGlmICghYXR0ck91dC5kZWwpIHtcbiAgICAgIGF0dHJzW2F0dHJdID0gYXR0ck91dC5ib29sID8ge1xuICAgICAgICBib29sOiBmdW5jdGlvbihjdHgsIG1vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIChkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSkpID8gJyAnICsgYXR0ciA6ICcnO1xuICAgICAgICB9XG4gICAgICB9IDogdGV4dEZuKHZpZXcsIG5hbWUsIGVzY2FwZUF0dHJpYnV0ZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFydGlhbEF0dHIodmlldywgdmlld05hbWUsIGV2ZW50cywgYXR0cnMsIGF0dHIpIHtcbiAgdmFyIHZhbHVlID0gYXR0cnNbYXR0cl1cbiAgICAsIG1hdGNoO1xuXG4gIGlmICghdmFsdWUpIHtcbiAgICAvLyBBIHRydWUgYm9vbGVhbiBhdHRyaWJ1dGUgd2lsbCBoYXZlIGEgdmFsdWUgb2YgbnVsbFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgYXR0cnNbYXR0cl0gPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhdHRyID09PSAnYmluZCcpIHtcbiAgICBhdHRyc1thdHRyXSA9IHskZXZlbnRzOiBzcGxpdEV2ZW50cyh2YWx1ZSksICR2aWV3OiB2aWV3fTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAobWF0Y2ggPSBleHRyYWN0UGxhY2Vob2xkZXIodmFsdWUpKSB7XG4gICAgLy8gVGhpcyBhdHRyaWJ1dGUgbmVlZHMgdG8gYmUgdHJlYXRlZCBhcyBhIHNlY3Rpb25cbiAgICBpZiAobWF0Y2gucHJlIHx8IG1hdGNoLnBvc3QpIHJldHVybiB0cnVlO1xuXG4gICAgYXR0cnNbYXR0cl0gPSB7JG1hdGNoTmFtZTogbWF0Y2gubmFtZSwgJGJvdW5kOiBtYXRjaC5ib3VuZH07XG5cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgYXR0cnNbYXR0cl0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgYXR0cnNbYXR0cl0gPSBmYWxzZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgYXR0cnNbYXR0cl0gPSBudWxsO1xuICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICBhdHRyc1thdHRyXSA9ICt2YWx1ZTtcbiAgfSBlbHNlIGlmICgvXlt7W10vLnRlc3QodmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF0dHJzW2F0dHJdID0gSlNPTi5wYXJzZSh2YWx1ZSlcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGFzdEl0ZW0oYXJyKSB7XG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiBwYXJzZSh2aWV3LCB2aWV3TmFtZSwgdGVtcGxhdGUsIGlzU3RyaW5nLCBvbkJpbmQsIG5vTWluaWZ5KSB7XG4gIHZhciBxdWV1ZXMsIHN0YWNrLCBldmVudHMsIG9uUmVuZGVyLCBwdXNoO1xuXG4gIHF1ZXVlcyA9IFt7XG4gICAgc3RhY2s6IHN0YWNrID0gW11cbiAgLCBldmVudHM6IGV2ZW50cyA9IFtdXG4gICwgc2VjdGlvbnM6IFtdXG4gIH1dO1xuXG4gIGZ1bmN0aW9uIG9uU3RhcnQocXVldWUpIHtcbiAgICBzdGFjayA9IHF1ZXVlLnN0YWNrO1xuICAgIGV2ZW50cyA9IHF1ZXVlLmV2ZW50cztcbiAgfVxuXG4gIGlmIChpc1N0cmluZykge1xuICAgIHB1c2ggPSBwdXNoVmFyU3RyaW5nO1xuICAgIG9uUmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoY3R4LiRzdHJpbmdDdHgpIHJldHVybiBjdHg7XG4gICAgICBjdHggPSBPYmplY3QuY3JlYXRlKGN0eCk7XG4gICAgICBjdHguJG9uQmluZCA9IG9uQmluZDtcbiAgICAgIGN0eC4kc3RyaW5nQ3R4ID0gY3R4O1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCA9IHB1c2hWYXI7XG4gIH1cblxuICB2YXIgaW5kZXggPSB2aWV3TmFtZS5sYXN0SW5kZXhPZignOicpXG4gICAgLCBucyA9IH5pbmRleCA/IHZpZXdOYW1lLnNsaWNlKDAsIGluZGV4KSA6ICcnXG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydCh0YWcsIHRhZ05hbWUsIGF0dHJzKSB7XG4gICAgdmFyIGF0dHIsIGJsb2NrLCBvdXQsIHBhcnNlciwgaXNTZWN0aW9uLCBhdHRyQmxvY2tcbiAgICBpZiAoJ3gtbm8tbWluaWZ5JyBpbiBhdHRycykge1xuICAgICAgZGVsZXRlIGF0dHJzWyd4LW5vLW1pbmlmeSddO1xuICAgICAgbm9NaW5pZnkgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc1BhcnRpYWwodmlldywgdGFnTmFtZSkpIHtcbiAgICAgIGJsb2NrID0ge1xuICAgICAgICBwYXJ0aWFsOiB0YWdOYW1lXG4gICAgICAsIG1hY3JvQ3R4OiBhdHRyc1xuICAgICAgfTtcbiAgICAgIG9uQmxvY2sodHJ1ZSwgZmFsc2UsIGJsb2NrLCBxdWV1ZXMsIHtvblN0YXJ0OiBvblN0YXJ0fSk7XG5cbiAgICAgIGZvciAoYXR0ciBpbiBhdHRycykge1xuICAgICAgICBpc1NlY3Rpb24gPSBwYXJzZVBhcnRpYWxBdHRyKHZpZXcsIHZpZXdOYW1lLCBldmVudHMsIGF0dHJzLCBhdHRyKTtcbiAgICAgICAgaWYgKCFpc1NlY3Rpb24pIGNvbnRpbnVlO1xuICAgICAgICBhdHRyQmxvY2sgPSB7XG4gICAgICAgICAgcGFydGlhbDogJ0AnICsgYXR0clxuICAgICAgICAsIG1hY3JvQ3R4OiBsYXN0SXRlbShxdWV1ZXMpLmJsb2NrLm1hY3JvQ3R4XG4gICAgICAgIH07XG4gICAgICAgIG9uQmxvY2sodHJ1ZSwgZmFsc2UsIGF0dHJCbG9jaywgcXVldWVzLCB7b25TdGFydDogb25TdGFydH0pO1xuICAgICAgICBwYXJzZVRleHQoYXR0cnNbYXR0cl0pO1xuICAgICAgICBwYXJzZUVuZCh0YWcsICdAJyArIGF0dHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNWb2lkQ29tcG9uZW50KHZpZXcsIHRhZ05hbWUsIG5zKSkge1xuICAgICAgICBvbkJsb2NrKGZhbHNlLCB0cnVlLCBudWxsLCBxdWV1ZXMsIHtcbiAgICAgICAgICBvblN0YXJ0OiBvblN0YXJ0XG4gICAgICAgICwgb25FbmQ6IGZ1bmN0aW9uKHF1ZXVlcykge1xuICAgICAgICAgICAgcHVzaCh2aWV3LCBucywgc3RhY2ssIGV2ZW50cywgJycsIGJsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUGFydGlhbFNlY3Rpb24odGFnTmFtZSkpIHtcbiAgICAgIGJsb2NrID0ge1xuICAgICAgICBwYXJ0aWFsOiB0YWdOYW1lXG4gICAgICAsIG1hY3JvQ3R4OiBsYXN0SXRlbShxdWV1ZXMpLmJsb2NrLm1hY3JvQ3R4XG4gICAgICB9O1xuICAgICAgb25CbG9jayh0cnVlLCBmYWxzZSwgYmxvY2ssIHF1ZXVlcywge29uU3RhcnQ6IG9uU3RhcnR9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VyID0gbWFya3VwLmVsZW1lbnRbdGFnTmFtZV0pIHtcbiAgICAgIG91dCA9IHBhcnNlcihldmVudHMsIGF0dHJzKTtcbiAgICAgIGlmIChvdXQgIT0gbnVsbCA/IG91dC5hZGRJZCA6IHZvaWQgMCkge1xuICAgICAgICBhZGRJZCh2aWV3LCBhdHRycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChhdHRyIGluIGF0dHJzKSB7XG4gICAgICBwYXJzZUF0dHIodmlldywgdmlld05hbWUsIGV2ZW50cywgdGFnTmFtZSwgYXR0cnMsIGF0dHIpO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKFsnc3RhcnQnLCB0YWdOYW1lLCBhdHRyc10pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQsIGlzUmF3VGV4dCwgcmVtYWluZGVyKSB7XG4gICAgdmFyIG1hdGNoID0gZXh0cmFjdFBsYWNlaG9sZGVyKHRleHQpXG4gICAgICAsIHBvc3QsIHByZTtcbiAgICBpZiAoIW1hdGNoIHx8IGlzUmF3VGV4dCkge1xuICAgICAgaWYgKCFub01pbmlmeSkge1xuICAgICAgICB0ZXh0ID0gaXNTdHJpbmcgPyB1bmVzY2FwZUVudGl0aWVzKHRyaW1UZXh0KHRleHQpKSA6IHRyaW1UZXh0KHRleHQpO1xuICAgICAgfVxuICAgICAgcHVzaFRleHQoc3RhY2ssIHRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZSA9IG1hdGNoLnByZTtcbiAgICBwb3N0ID0gbWF0Y2gucG9zdDtcbiAgICBpZiAoaXNTdHJpbmcpIHByZSA9IHVuZXNjYXBlRW50aXRpZXMocHJlKTtcbiAgICBwdXNoVGV4dChzdGFjaywgcHJlKTtcbiAgICByZW1haW5kZXIgPSBwb3N0IHx8IHJlbWFpbmRlcjtcblxuICAgIHBhcnNlTWF0Y2godGV4dCwgbWF0Y2gsIHF1ZXVlcywge1xuICAgICAgb25TdGFydDogb25TdGFydFxuICAgICwgb25FbmQ6IGZ1bmN0aW9uKHNlY3Rpb25zKSB7XG4gICAgICAgIHZhciBmbiA9IGJsb2NrRm4odmlldywgc2VjdGlvbnMpO1xuICAgICAgICBwdXNoKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCByZW1haW5kZXIsIHNlY3Rpb25zWzBdLmJsb2NrLCBmbik7XG4gICAgICB9XG4gICAgLCBvbkNvbnRlbnQ6IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgIHB1c2godmlldywgbnMsIHN0YWNrLCBldmVudHMsIHJlbWFpbmRlciwgbWF0Y2gpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBvc3QpIHJldHVybiBwYXJzZVRleHQocG9zdCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZCh0YWcsIHRhZ05hbWUpIHtcbiAgICB2YXIgc2VjdGlvbk5hbWUgPSBwYXJ0aWFsU2VjdGlvbk5hbWUodGFnTmFtZSlcbiAgICAgICwgZW5kc1BhcnRpYWwgPSBpc1BhcnRpYWwodmlldywgdGFnTmFtZSlcbiAgICBpZiAoZW5kc1BhcnRpYWwgJiYgaXNWb2lkQ29tcG9uZW50KHZpZXcsIHRhZ05hbWUsIG5zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmQgdGFnIFwiJyArIHRhZyArICdcIiBpcyBub3QgYWxsb3dlZCBmb3Igdm9pZCBjb21wb25lbnQnKVxuICAgIH1cbiAgICBpZiAoc2VjdGlvbk5hbWUgfHwgZW5kc1BhcnRpYWwpIHtcbiAgICAgIG9uQmxvY2soZmFsc2UsIHRydWUsIG51bGwsIHF1ZXVlcywge1xuICAgICAgICBvblN0YXJ0OiBvblN0YXJ0XG4gICAgICAsIG9uRW5kOiBmdW5jdGlvbihxdWV1ZXMpIHtcbiAgICAgICAgICB2YXIgcXVldWUgPSBxdWV1ZXNbMF1cbiAgICAgICAgICAgICwgYmxvY2sgPSBxdWV1ZS5ibG9ja1xuICAgICAgICAgICAgLCBmbiA9IHJlbmRlcmVyKHZpZXcsIHJlZHVjZVN0YWNrKHF1ZXVlLnN0YWNrKSwgcXVldWUuZXZlbnRzKVxuICAgICAgICAgIGZuLnVuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHNlY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBibG9jay5tYWNyb0N0eFtzZWN0aW9uTmFtZV0gPSBmbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHV0IHRoZSByZW1haW5pbmcgY29udGVudCBub3QgaW4gYSBzZWN0aW9uIGluIHRoZSBkZWZhdWx0IFwiY29udGVudFwiIHNlY3Rpb24sXG4gICAgICAgICAgLy8gdW5sZXNzIFwiaW5oZXJpdFwiIGlzIHNwZWNpZmllZCBhbmQgdGhlcmUgaXMgbm8gY29udGVudCwgc28gdGhhdCB0aGUgcGFyZW50XG4gICAgICAgICAgLy8gY29udGVudCBjYW4gYmUgaW5oZXJpdGVkXG4gICAgICAgICAgaWYgKHF1ZXVlLnN0YWNrLmxlbmd0aCB8fCAhYmxvY2subWFjcm9DdHguaW5oZXJpdCkge1xuICAgICAgICAgICAgYmxvY2subWFjcm9DdHguY29udGVudCA9IGZuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoKHZpZXcsIG5zLCBzdGFjaywgZXZlbnRzLCAnJywgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKFsnZW5kJywgdGFnTmFtZV0pO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgcGFyc2VUZXh0KHRlbXBsYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZUh0bWwodGVtcGxhdGUsIHtcbiAgICAgIHN0YXJ0OiBwYXJzZVN0YXJ0XG4gICAgLCB0ZXh0OiBwYXJzZVRleHRcbiAgICAsIGVuZDogcGFyc2VFbmRcbiAgICAsIGNvbW1lbnQ6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50KHRhZykpIHB1c2hUZXh0KHN0YWNrLCB0YWcpO1xuICAgICAgfVxuICAgICwgb3RoZXI6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICBwdXNoVGV4dChzdGFjaywgdGFnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVuZGVyZXIodmlldywgcmVkdWNlU3RhY2soc3RhY2spLCBldmVudHMsIG9uUmVuZGVyKTtcbn1cblxufSkod2luZG93KSIsInZhciBldmVudEJpbmRpbmcgPSByZXF1aXJlKCcuL2V2ZW50QmluZGluZycpXG4gICwgc3BsaXRFdmVudHMgPSBldmVudEJpbmRpbmcuc3BsaXRFdmVudHNcbiAgLCBjb250YWluc0V2ZW50ID0gZXZlbnRCaW5kaW5nLmNvbnRhaW5zRXZlbnRcbiAgLCBhZGREb21FdmVudCA9IGV2ZW50QmluZGluZy5hZGREb21FdmVudFxuICAsIFRFWFRfRVZFTlRTID0gJ2tleXVwLGtleWRvd24vMCxjdXQvMCxwYXN0ZS8wLGRyYWdvdmVyLzAsYmx1cidcbiAgLCBBVVRPQ09NUExFVEVfT0ZGID0ge1xuICAgICAgY2hlY2tib3g6IHRydWVcbiAgICAsIHJhZGlvOiB0cnVlXG4gICAgfVxuICAsIG9uQmluZEEsIG9uQmluZEZvcm07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBib3VuZDoge1xuICAgICd2YWx1ZSc6IHtcbiAgICAgICdpbnB1dCc6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIG1hdGNoKSB7XG4gICAgICAgIHZhciB0eXBlID0gYXR0cnMudHlwZVxuICAgICAgICAgICwgZXZlbnROYW1lcywgbWV0aG9kO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlID09PSAncmFuZ2UnIHx8ICd4LWJsdXInIGluIGF0dHJzKSB7XG4gICAgICAgICAgLy8gT25seSB1cGRhdGUgYWZ0ZXIgdGhlIGVsZW1lbnQgbG9zZXMgZm9jdXNcbiAgICAgICAgICBkZWxldGUgYXR0cnNbJ3gtYmx1ciddO1xuICAgICAgICAgIGV2ZW50TmFtZXMgPSAnY2hhbmdlLGJsdXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHVwZGF0ZSBhcyB0aGUgdXNlciB0eXBlc1xuICAgICAgICAgIGV2ZW50TmFtZXMgPSBURVhUX0VWRU5UUztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3gtYXRvbWljJyBpbiBhdHRycykge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1sneC1hdG9taWMnXTtcbiAgICAgICAgICBtZXRob2QgPSAncHJvcCc7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RleHQnIHx8ICF0eXBlKSB7XG4gICAgICAgICAgbWV0aG9kID0gJ3Byb3BPdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kID0gJ3Byb3AnO1xuICAgICAgICB9XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMsIG1hdGNoLCB7XG4gICAgICAgICAgbWV0aG9kOiBtZXRob2RcbiAgICAgICAgLCBwcm9wZXJ0eTogJ3ZhbHVlJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHttZXRob2Q6IG1ldGhvZH07XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ2NoZWNrZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgwqBhdHRycywgbWF0Y2gpIHtcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgJ2NoYW5nZScsIG1hdGNoLCB7XG4gICAgICAgICAgbWV0aG9kOiAncHJvcCdcbiAgICAgICAgLCBwcm9wZXJ0eTogJ2NoZWNrZWQnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21ldGhvZDogJ3Byb3AnfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnc2VsZWN0ZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIG1hdGNoKSB7XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsICdjaGFuZ2UnLCBtYXRjaCwge1xuICAgICAgICAgIG1ldGhvZDogJ3Byb3AnXG4gICAgICAgICwgcHJvcGVydHk6ICdzZWxlY3RlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7bWV0aG9kOiAncHJvcCd9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdkaXNhYmxlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7bWV0aG9kOiAncHJvcCd9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4sIGJvdW5kUGFyZW50OiB7XG4gICAgJ2NvbnRlbnRlZGl0YWJsZSc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgbWF0Y2gpIHtcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgVEVYVF9FVkVOVFMsIG1hdGNoLCB7XG4gICAgICAgICAgbWV0aG9kOiAnaHRtbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICwgJyonOiB7XG4gICAgICAndGV4dGFyZWEnOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBtYXRjaCkge1xuICAgICAgICBpZiAoJ3gtYXRvbWljJyBpbiBhdHRycykge1xuICAgICAgICAgIGRlbGV0ZSBhdHRyc1sneC1hdG9taWMnXTtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gJ3Byb3AnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtZXRob2QgPSAncHJvcE90JztcbiAgICAgICAgfVxuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBURVhUX0VWRU5UUywgbWF0Y2gsIHtcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgICAsIHByb3BlcnR5OiAndmFsdWUnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge21ldGhvZDogbWV0aG9kLCBwcm9wZXJ0eTogJ3ZhbHVlJ307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiwgZWxlbWVudDoge1xuICAgICdzZWxlY3QnOiBmdW5jdGlvbihldmVudHMsIGF0dHJzKSB7XG4gICAgICAvLyBEaXN0cmlidXRlIGNoYW5nZSBldmVudCB0byBjaGlsZCBub2RlcyBvZiBzZWxlY3QgZWxlbWVudHNcbiAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsICdjaGFuZ2U6JGZvckNoaWxkcmVuJyk7XG4gICAgICByZXR1cm4ge2FkZElkOiB0cnVlfTtcbiAgICB9XG5cbiAgLCAnaW5wdXQnOiBmdW5jdGlvbihldmVudHMsIGF0dHJzKSB7XG4gICAgICBpZiAoQVVUT0NPTVBMRVRFX09GRlthdHRycy50eXBlXSAmJiAhKCdhdXRvY29tcGxldGUnIGluIGF0dHJzKSkge1xuICAgICAgICBhdHRycy5hdXRvY29tcGxldGUgPSAnb2ZmJztcbiAgICAgIH1cbiAgICAgIGlmIChhdHRycy50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIC8vIERpc3RyaWJ1dGUgY2hhbmdlIGV2ZW50cyB0byBvdGhlciBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgICAgYWRkRG9tRXZlbnQoZXZlbnRzLCBhdHRycywgJ2NoYW5nZTokZm9yTmFtZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4sIGF0dHI6IHtcbiAgICAneC1iaW5kJzoge1xuICAgICAgJyonOiBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBldmVudE5hbWVzKSB7XG4gICAgICAgIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMpO1xuICAgICAgICByZXR1cm4ge2FkZElkOiB0cnVlLCBkZWw6IHRydWV9O1xuICAgICAgfVxuXG4gICAgLCAnYSc6IG9uQmluZEEgPSBmdW5jdGlvbihldmVudHMsIGF0dHJzLCBldmVudE5hbWVzKSB7XG4gICAgICAgIGlmIChjb250YWluc0V2ZW50KGV2ZW50TmFtZXMsIFsnY2xpY2snLCAnZm9jdXMnXSkgJiYgISgnaHJlZicgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgYXR0cnMuaHJlZiA9ICcjJztcbiAgICAgICAgICBpZiAoISgnb25jbGljaycgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICBhdHRycy5vbmNsaWNrID0gJ3JldHVybiBmYWxzZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAsICdmb3JtJzogb25CaW5kRm9ybSA9IGZ1bmN0aW9uKGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zRXZlbnQoZXZlbnROYW1lcywgJ3N1Ym1pdCcpKSB7XG4gICAgICAgICAgaWYgKCEoJ29uc3VibWl0JyBpbiBhdHRycykpIHtcbiAgICAgICAgICAgIGF0dHJzLm9uc3VibWl0ID0gJ3JldHVybiBmYWxzZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ3gtY2FwdHVyZSc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgZXZlbnROYW1lcykge1xuICAgICAgICBhZGREb21FdmVudChldmVudHMsIGF0dHJzLCBldmVudE5hbWVzLCBudWxsLCB7Y2FwdHVyZTogdHJ1ZX0pO1xuICAgICAgICByZXR1cm4ge2FkZElkOiB0cnVlLCBkZWw6IHRydWV9O1xuICAgICAgfVxuICAgICwgJ2EnOiBvbkJpbmRBXG4gICAgLCAnZm9ybSc6IG9uQmluZEZvcm1cbiAgICB9XG5cbiAgLCAneC1hcyc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oZXZlbnRzLCBhdHRycywgbmFtZSkge1xuICAgICAgICBldmVudHMucHVzaChmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICBjdHguJGVsZW1lbnRzW25hbWVdID0gYXR0cnMuX2lkIHx8IGF0dHJzLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHthZGRJZDogdHJ1ZSwgZGVsOiB0cnVlfVxuICAgICAgfVxuICB9XG5cbiAgLCAnY2hlY2tlZCc6IHtcbiAgICAgICcqJzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7Ym9vbDogdHJ1ZX07XG4gICAgICB9XG4gICAgfVxuXG4gICwgJ3NlbGVjdGVkJzoge1xuICAgICAgJyonOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtib29sOiB0cnVlfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLCAnZGlzYWJsZWQnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge2Jvb2w6IHRydWV9O1xuICAgICAgfVxuICAgIH1cblxuICAsICdhdXRvZm9jdXMnOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge2Jvb2w6IHRydWV9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4sIFRFWFRfRVZFTlRTOiBURVhUX0VWRU5UU1xuLCBBVVRPQ09NUExFVEVfT0ZGOiBBVVRPQ09NUExFVEVfT0ZGXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCdyYWNlcicpLnV0aWxcbiAgLCB2aWV3UGF0aCA9IHJlcXVpcmUoJy4vdmlld1BhdGgnKVxuICAsIGV4dHJhY3RQbGFjZWhvbGRlciA9IHZpZXdQYXRoLmV4dHJhY3RQbGFjZWhvbGRlclxuICAsIGRhdGFWYWx1ZSA9IHZpZXdQYXRoLmRhdGFWYWx1ZVxuICAsIGN0eFBhdGggPSB2aWV3UGF0aC5jdHhQYXRoXG4gICwgcGF0aEZuQXJncyA9IHZpZXdQYXRoLnBhdGhGbkFyZ3NcbiAgLCBzZXRCb3VuZEZuID0gdmlld1BhdGguc2V0Qm91bmRGblxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZVxuXG5leHBvcnRzLnNwbGl0RXZlbnRzID0gc3BsaXRFdmVudHM7XG5leHBvcnRzLmZuTGlzdGVuZXIgPSBmbkxpc3RlbmVyO1xuZXhwb3J0cy5jb250YWluc0V2ZW50ID0gY29udGFpbnNFdmVudDtcbmV4cG9ydHMuYWRkRG9tRXZlbnQgPSB1dGlsLmlzU2VydmVyID8gZW1wdHkgOiBhZGREb21FdmVudDtcblxuZnVuY3Rpb24gc3BsaXRFdmVudHMoZXZlbnROYW1lcykge1xuICB2YXIgcGFpcnMgPSBldmVudE5hbWVzLnNwbGl0KCcsJylcbiAgICAsIGV2ZW50TGlzdCA9IFtdXG4gICAgLCBpLCBqLCBwYWlyLCBzZWdtZW50cywgbmFtZSwgZXZlbnROYW1lLCBkZWxheSwgZm5zLCBmbjtcbiAgZm9yIChpID0gcGFpcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHNlZ21lbnRzID0gcGFpci5zcGxpdCgnOicpO1xuICAgIG5hbWUgPSBzZWdtZW50c1swXS5zcGxpdCgnLycpO1xuICAgIGV2ZW50TmFtZSA9IG5hbWVbMF0udHJpbSgpO1xuICAgIGRlbGF5ID0gbmFtZVsxXTtcbiAgICBmbnMgPSAoc2VnbWVudHNbMV0gfHwgJycpLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgIGZvciAoaiA9IGZucy5sZW5ndGg7IGotLTspIHtcbiAgICAgIGZuID0gZm5zW2pdO1xuICAgICAgZm5zW2pdID0gZXh0cmFjdFBsYWNlaG9sZGVyKGZuKSB8fCBmbjtcbiAgICB9XG4gICAgZXZlbnRMaXN0LnB1c2goW2V2ZW50TmFtZSwgZGVsYXksIGZuc10pO1xuICB9XG4gIHJldHVybiBldmVudExpc3Q7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zRXZlbnQoZXZlbnROYW1lcywgZXhwZWN0ZWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkgZXhwZWN0ZWQgPSBbZXhwZWN0ZWRdO1xuICB2YXIgZXZlbnRMaXN0ID0gc3BsaXRFdmVudHMoZXZlbnROYW1lcylcbiAgICAsIGksIGosIGV2ZW50TmFtZVxuICBmb3IgKGkgPSBldmVudExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgZXZlbnROYW1lID0gZXZlbnRMaXN0W2ldWzBdO1xuICAgIGZvciAoaiA9IGV4cGVjdGVkLmxlbmd0aDsgai0tOykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXhwZWN0ZWRbal0pIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZERvbUV2ZW50KGV2ZW50cywgYXR0cnMsIGV2ZW50TmFtZXMsIG1hdGNoLCBvcHRpb25zKSB7XG4gIHZhciBldmVudExpc3QgPSBzcGxpdEV2ZW50cyhldmVudE5hbWVzKVxuICAgICwgYXJncywgbmFtZTtcblxuICBpZiAobWF0Y2gpIHtcbiAgICBuYW1lID0gbWF0Y2gubmFtZTtcblxuICAgIGlmICh+bmFtZS5pbmRleE9mKCcoJykpIHtcbiAgICAgIGFyZ3MgPSBwYXRoRm5BcmdzKG5hbWUpO1xuICAgICAgaWYgKCFhcmdzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICBldmVudHMucHVzaChmdW5jdGlvbihjdHgsIG1vZGVsRXZlbnRzLCBkb20sIHBhdGhNYXAsIHZpZXcpIHtcbiAgICAgICAgdmFyIGlkID0gYXR0cnMuX2lkIHx8IGF0dHJzLmlkXG4gICAgICAgICAgLCBwYXRocyA9IFtdXG4gICAgICAgICAgLCBhcmcsIHBhdGgsIHBhdGhJZCwgZXZlbnQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zLCBpLCBqO1xuICAgICAgICBvcHRpb25zLnNldFZhbHVlID0gZnVuY3Rpb24obW9kZWwsIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEJvdW5kRm4odmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICBwYXRoID0gY3R4UGF0aCh2aWV3LCBjdHgsIGFyZyk7XG4gICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICBwYXRoSWQgPSBwYXRoTWFwLmlkKHBhdGgpO1xuICAgICAgICAgIGZvciAoaiA9IGV2ZW50TGlzdC5sZW5ndGg7IGotLTspIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRMaXN0W2pdO1xuICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnRbMF07XG4gICAgICAgICAgICBldmVudE9wdGlvbnMgPSB1dGlsLm1lcmdlSW50byh7dmlldzogdmlldywgY3R4OiBjdHgsIHBhdGhJZDogcGF0aElkLCBkZWxheTogZXZlbnRbMV19LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRvbS5iaW5kKGV2ZW50TmFtZSwgaWQsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudHMucHVzaChmdW5jdGlvbihjdHgsIG1vZGVsRXZlbnRzLCBkb20sIHBhdGhNYXAsIHZpZXcpIHtcbiAgICAgIHZhciBpZCA9IGF0dHJzLl9pZCB8fCBhdHRycy5pZFxuICAgICAgICAsIHBhdGhJZCA9IHBhdGhNYXAuaWQoY3R4UGF0aCh2aWV3LCBjdHgsIG5hbWUpKVxuICAgICAgICAsIGV2ZW50LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucywgaTtcbiAgICAgIGZvciAoaSA9IGV2ZW50TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudExpc3RbaV07XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50WzBdO1xuICAgICAgICBldmVudE9wdGlvbnMgPSB1dGlsLm1lcmdlSW50byh7dmlldzogdmlldywgY3R4OiBjdHgsIHBhdGhJZDogcGF0aElkLCBkZWxheTogZXZlbnRbMV19LCBvcHRpb25zKTtcbiAgICAgICAgZG9tLmJpbmQoZXZlbnROYW1lLCBpZCwgZXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBldmVudHMucHVzaChmdW5jdGlvbihjdHgsIG1vZGVsRXZlbnRzLCBkb20sIHBhdGhNYXAsIHZpZXcpIHtcbiAgICB2YXIgaWQgPSBhdHRycy5faWQgfHwgYXR0cnMuaWRcbiAgICAgICwgcGF0aElkID0gcGF0aE1hcC5pZChjdHhQYXRoKHZpZXcsIGN0eCwgJy4nKSlcbiAgICAgICwgZXZlbnQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zLCBpO1xuICAgIGZvciAoaSA9IGV2ZW50TGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgIGV2ZW50ID0gZXZlbnRMaXN0W2ldO1xuICAgICAgZXZlbnROYW1lID0gZXZlbnRbMF07XG4gICAgICBldmVudE9wdGlvbnMgPSBmbkxpc3RlbmVyKHZpZXcsIGN0eCwgZXZlbnRbMl0sIGRvbSk7XG4gICAgICBldmVudE9wdGlvbnMuZGVsYXkgPSBldmVudFsxXTtcbiAgICAgIHV0aWwubWVyZ2VJbnRvKGV2ZW50T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB1dGlsLm1lcmdlSW50byhldmVudE9wdGlvbnMsIHt2aWV3OiB2aWV3LCBjdHg6IGN0eCwgcGF0aElkOiBwYXRoSWR9KTtcbiAgICAgIGRvbS5iaW5kKGV2ZW50TmFtZSwgaWQsIGV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZWFjaEZuTGlzdGVuZXIodmlldywgY3R4LCBmbk9iaiwgZG9tKSB7XG4gIHZhciBmbk5hbWUsIGZuLCBmbkN0eHMsIGksIGZuQ3R4O1xuXG4gIGZuTmFtZSA9IHR5cGVvZiBmbk9iaiA9PT0gJ29iamVjdCdcbiAgICA/IGRhdGFWYWx1ZSh2aWV3LCBjdHgsIHZpZXcubW9kZWwsIGZuT2JqLm5hbWUpXG4gICAgOiBmbk5hbWUgPSBmbk9iajtcblxuICAvLyBJZiBhIHBsYWNlaG9sZGVyIGZvciBhbiBldmVudCBuYW1lIGRvZXMgbm90IGhhdmUgYSB2YWx1ZSwgZG8gbm90aGluZ1xuICBpZiAoIWZuTmFtZSkgcmV0dXJuIGVtcHR5O1xuXG4gIC8vIFNlZSBpZiBpdCBpcyBhIGJ1aWx0LWluIGZ1bmN0aW9uXG4gIGZuID0gZG9tICYmIGRvbS5mbnNbZm5OYW1lXTtcblxuICAvLyBMb29rdXAgdGhlIGZ1bmN0aW9uIG5hbWUgb24gdGhlIGNvbXBvbmVudCBzY3JpcHQgb3IgYXBwXG5cbiAgLy8gVE9ETzogVGhpcyBzaW1wbHkgbG9va3MgaW4gdGhlIGxvY2FsIHNjb3BlIGZvciB0aGUgZnVuY3Rpb25cbiAgLy8gYW5kIHRoZW4gZ29lcyB1cCB0aGUgc2NvcGUgaWYgYSBmdW5jdGlvbiBuYW1lIGlzIG5vdCBmb3VuZC5cbiAgLy8gQmV0dGVyIHdvdWxkIGJlIHRvIGFjdHVhbGx5IGZpZ3VyZSBvdXQgdGhlIHNjb3BlIG9mIHdoZXJlIHRoZVxuICAvLyBmdW5jdGlvbiBuYW1lIGlzIHNwZWNmaWVkLCBzaW5jZSB0aGVyZSBjb3VsZCBlYXNpbHkgYmUgbmFtZXNwYWNlXG4gIC8vIGNvbmZsaWN0cyBiZXR3ZWVuIGZ1bmN0aW9ucyBpbiBhIGNvbXBvbmVudCBhbmQgZnVuY3Rpb25zIGluIGFuXG4gIC8vIGFwcCB1c2luZyB0aGF0IGNvbXBvbmVudC4gSG93IHRvIGltcGxlbWVudCB0aGlzIGNvcnJlY3RseSBpcyBub3RcbiAgLy8gb2J2aW91cyBhdCB0aGUgbW9tZW50LlxuICBpZiAoIWZuKSB7XG4gICAgZm5DdHhzID0gY3R4LiRmbkN0eDtcbiAgICBmb3IgKGkgPSBmbkN0eHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBmbkN0eCA9IGZuQ3R4c1tpXTtcbiAgICAgIGZuID0gZm5DdHhbZm5OYW1lXSB8fCB2aWV3UGF0aC5sb29rdXAoZm5OYW1lLCBmbkN0eCk7XG4gICAgICBpZiAoZm4pIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWZuKSB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kIGZ1bmN0aW9uIG5vdCBmb3VuZDogJyArIGZuTmFtZSk7XG5cbiAgLy8gQmluZCB0aGUgbGlzdGVuZXIgdG8gdGhlIGFwcCBvciBjb21wb25lbnQgb2JqZWN0IG9uIHdoaWNoIGl0XG4gIC8vIHdhcyBkZWZpbmVkIHNvIHRoYXQgdGhlIGB0aGlzYCBjb250ZXh0IHdpbGwgYmUgdGhlIGluc3RhbmNlXG4gIHJldHVybiBmbi5iaW5kKGZuQ3R4KTtcbn1cblxuZnVuY3Rpb24gZm5MaXN0ZW5lcih2aWV3LCBjdHgsIGZuTmFtZXMsIGRvbSkge1xuICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgZm46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbiA9IGZuTmFtZXMubGVuZ3RoXG4gICAgICAgICwgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICwgaSwgZm4sIGJvdW5kRm5zXG5cbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgbm8gaGFuZGxlciBmdW5jdGlvbnMgd2VyZSBzcGVjaWZpZWRcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmZuID0gZW1wdHk7XG5cbiAgICAgIH0gZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgICAgIGZuID0gZWFjaEZuTGlzdGVuZXIodmlldywgY3R4LCBmbk5hbWVzWzBdLCBkb20pO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZEZucyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSBsZW47IGktLTspIHtcbiAgICAgICAgICBib3VuZEZucy5wdXNoKGVhY2hGbkxpc3RlbmVyKHZpZXcsIGN0eCwgZm5OYW1lc1tpXSwgZG9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGJvdW5kRm5zLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgYm91bmRGbnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVyLmZuID0gZm47XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuIiwidmFyIHJvdXRlciA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yb3V0ZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvblxufVxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFkZCAoZS5nLiwgYXBwLmdldCwgYXBwLnBvc3QsIGV0Yy4pXG4gKiBAcGFyYW0ge0FycmF5fSB0cmFuc2l0aW9uQ2FsbHMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB0aGF0IGxvb2sgXG4gKiAgIGxpa2Uge2Zyb20sIHRvLCBmb3J3YXJkLCBiYWNrfVxuICogQHBhcmFtIHtTdHJpbmd9IGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm9yd2FyZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFja1xuICovXG5mdW5jdGlvbiB0cmFuc2l0aW9uKGFkZCwgY2FsbHMsIGZyb20sIHRvLCBmb3J3YXJkLCBiYWNrKSB7XG4gIGlmIChmcm9tID09PSB0bykgcmV0dXJuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjYWxsID0gY2FsbHNbaV1cbiAgICBpZiAoY2FsbC5mcm9tID09PSB0bykge1xuICAgICAgaWYgKGhhc1RyYW5zaXRpb24oY2FsbHMsIGZyb20sIGNhbGwudG8pKSBjb250aW51ZVxuICAgICAgdmFyIGNvbXBvc2VkRm9yd2FyZCA9IGNvbXBvc2VDYWxsYmFja3MoZm9yd2FyZCwgY2FsbC5mb3J3YXJkLCB0bylcbiAgICAgIGlmIChiYWNrICYmIGNhbGwuYmFjaykge1xuICAgICAgICB2YXIgY29tcG9zZWRCYWNrID0gY29tcG9zZUNhbGxiYWNrcyhjYWxsLmJhY2ssIGJhY2ssIHRvKVxuICAgICAgfVxuICAgICAgYWRkKHtcbiAgICAgICAgZnJvbTogZnJvbVxuICAgICAgLCB0bzogY2FsbC50b1xuICAgICAgLCBmb3J3YXJkOiBjb21wb3NlZEZvcndhcmRcbiAgICAgICwgYmFjazogY29tcG9zZWRCYWNrXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoY2FsbC50byA9PT0gZnJvbSkge1xuICAgICAgaWYgKGhhc1RyYW5zaXRpb24oY2FsbHMsIGNhbGwuZnJvbSwgdG8pKSBjb250aW51ZVxuICAgICAgdmFyIGNvbXBvc2VkRm9yd2FyZCA9IGNvbXBvc2VDYWxsYmFja3MoY2FsbC5mb3J3YXJkLCBmb3J3YXJkLCBmcm9tKVxuICAgICAgaWYgKGJhY2sgJiYgY2FsbC5iYWNrKSB7XG4gICAgICAgIHZhciBjb21wb3NlZEJhY2sgPSBjb21wb3NlQ2FsbGJhY2tzKGJhY2ssIGNhbGwuYmFjaywgZnJvbSlcbiAgICAgIH1cbiAgICAgIGFkZCh7XG4gICAgICAgIGZyb206IGNhbGwuZnJvbVxuICAgICAgLCB0bzogdG9cbiAgICAgICwgZm9yd2FyZDogY29tcG9zZWRGb3J3YXJkXG4gICAgICAsIGJhY2s6IGNvbXBvc2VkQmFja1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzVHJhbnNpdGlvbihjYWxscywgZnJvbSwgdG8pIHtcbiAgZm9yICh2YXIgaSA9IGNhbGxzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBjYWxsID0gY2FsbHNbaV07XG4gICAgaWYgKGNhbGwuZnJvbSA9PT0gZnJvbSAmJiBjYWxsLnRvID09PSB0bykgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gVE9ETzogQXN5bmMgc3VwcG9ydFxuZnVuY3Rpb24gY29tcG9zZUNhbGxiYWNrcyhmaXJzdCwgc2Vjb25kLCBpbnRlcm1lZGlhdGVQYXRoKSB7XG4gIGZ1bmN0aW9uIGNvbXBvc2VkKHNlbGYsIG1vZGVsLCBwYXJhbXMsIG5leHQsIGRvbmUpIHtcbiAgICB2YXIgaW50ZXJtZWRpYXRlVXJsID0gcm91dGVyLm1hcFJvdXRlKGludGVybWVkaWF0ZVBhdGgsIHBhcmFtcylcbiAgICB2YXIgdXJsID0gcGFyYW1zLnVybFxuICAgIHZhciBza2lwcGVkID0gZmFsc2VcbiAgICBmdW5jdGlvbiB3cmFwTmV4dChlcnIpIHtcbiAgICAgIHNraXBwZWQgPSB0cnVlXG4gICAgICBuZXh0KGVycilcbiAgICB9XG4gICAgcGFyYW1zLnVybCA9IGludGVybWVkaWF0ZVVybFxuICAgIGlmIChmaXJzdC5sZW5ndGggPT09IDQpIHtcbiAgICAgIGZpcnN0LmNhbGwoc2VsZiwgbW9kZWwsIHBhcmFtcywgd3JhcE5leHQsIGRvbmVGaXJzdClcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3QuY2FsbChzZWxmLCBtb2RlbCwgcGFyYW1zLCB3cmFwTmV4dClcbiAgICAgIGRvbmVGaXJzdCgpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvbmVGaXJzdCgpIHtcbiAgICAgIGlmIChza2lwcGVkKSByZXR1cm5cbiAgICAgIHBhcmFtcy5wcmV2aW91cyA9IGludGVybWVkaWF0ZVVybFxuICAgICAgcGFyYW1zLnVybCA9IHVybFxuICAgICAgaWYgKHNlY29uZC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgc2Vjb25kLmNhbGwoc2VsZiwgbW9kZWwsIHBhcmFtcywgbmV4dCwgZG9uZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlY29uZC5jYWxsKHNlbGYsIG1vZGVsLCBwYXJhbXMsIG5leHQpXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBpbmRpdmlkdWFsbHksIHNpbmNlIHRoZWlyXG4gIC8vIGFyZ3VtZW50IGxlbmd0aCB3aWxsIGJlIGNoZWNrZWRcbiAgZnVuY3Rpb24gYXN5bmNDb21wb3NlZENhbGxiYWNrKG1vZGVsLCBwYXJhbXMsIG5leHQsIGRvbmUpIHtcbiAgICBjb21wb3NlZCh0aGlzLCBtb2RlbCwgcGFyYW1zLCBuZXh0LCBkb25lKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wb3NlZENhbGxiYWNrKG1vZGVsLCBwYXJhbXMsIG5leHQpIHtcbiAgICBjb21wb3NlZCh0aGlzLCBtb2RlbCwgcGFyYW1zLCBuZXh0KTtcbiAgfVxuICByZXR1cm4gKGZpcnN0Lmxlbmd0aCA9PT0gNCB8fCBzZWNvbmQubGVuZ3RoID09PSA0KSA/XG4gICAgYXN5bmNDb21wb3NlZENhbGxiYWNrIDogY29tcG9zZWRDYWxsYmFjaztcbn1cbiIsInZhciB0cmltTGVhZGluZyA9IHJlcXVpcmUoJ2h0bWwtdXRpbCcpLnRyaW1MZWFkaW5nO1xuXG5leHBvcnRzLndyYXBSZW1haW5kZXIgPSB3cmFwUmVtYWluZGVyO1xuZXhwb3J0cy5leHRyYWN0UGxhY2Vob2xkZXIgPSBleHRyYWN0UGxhY2Vob2xkZXI7XG5leHBvcnRzLnBhdGhGbkFyZ3MgPSBwYXRoRm5BcmdzO1xuZXhwb3J0cy5zcXVhcmVCcmFja2V0c0FyZ3MgPSBzcXVhcmVCcmFja2V0c0FyZ3M7XG5leHBvcnRzLmN0eFBhdGggPSBjdHhQYXRoO1xuZXhwb3J0cy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuZXhwb3J0cy5kYXRhVmFsdWUgPSBkYXRhVmFsdWU7XG5leHBvcnRzLnNldEJvdW5kRm4gPSBzZXRCb3VuZEZuO1xuZXhwb3J0cy5sb29rdXAgPSBsb29rdXA7XG5leHBvcnRzLnJlcGxhY2VTcXVhcmVCcmFja2V0cyA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cztcblxuZnVuY3Rpb24gd3JhcFJlbWFpbmRlcih0YWdOYW1lLCByZW1haW5kZXIpIHtcbiAgaWYgKCFyZW1haW5kZXIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICEobmV3IFJlZ0V4cCgnXjxcXC8nICsgdGFnTmFtZSwgJ2knKSkudGVzdChyZW1haW5kZXIpO1xufVxuXG52YXIgb3BlblBsYWNlaG9sZGVyID0gL14oW1xcc1xcU10qPykoXFx7ezEsM30pXFxzKihbXFxzXFxTXSopL1xuICAsIGFsaWFzQ29udGVudCA9IC9eKFtcXHNcXFNdKilcXHMrYXNcXHMrOihcXFMrKVxccyokL1xuICAsIGJsb2NrQ29udGVudCA9IC9eKFtcXCNcXC9dPykoZWxzZVxcc2lmfGlmfGVsc2V8dW5sZXNzfGVhY2h8d2l0aHx1bmVzY2FwZWQpP1xccyooW1xcc1xcU10qPylcXHMqJC9cbiAgLCBjbG9zZU1hcCA9IHsgMTogJ30nLCAyOiAnfX0nIH1cbmZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlcih0ZXh0KSB7XG4gIHZhciBtYXRjaCA9IG9wZW5QbGFjZWhvbGRlci5leGVjKHRleHQpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBwcmUgPSBtYXRjaFsxXVxuICAgICwgb3BlbiA9IG1hdGNoWzJdXG4gICAgLCByZW1haW5kZXIgPSBtYXRjaFszXVxuICAgICwgb3BlbkxlbiA9IG9wZW4ubGVuZ3RoXG4gICAgLCBib3VuZCA9IG9wZW5MZW4gPT09IDFcbiAgICAsIGVuZCA9IG1hdGNoQnJhY2VzKHJlbWFpbmRlciwgb3BlbkxlbiwgMCwgJ3snLCAnfScpXG4gICAgLCBlbmRJbm5lciA9IGVuZCAtIG9wZW5MZW5cbiAgICAsIGlubmVyID0gcmVtYWluZGVyLnNsaWNlKDAsIGVuZElubmVyKVxuICAgICwgcG9zdCA9IHJlbWFpbmRlci5zbGljZShlbmQpXG4gICAgLCBhbGlhcywgaGFzaCwgdHlwZSwgbmFtZSwgZXNjYXBlZDtcblxuICBpZiAoL1tcIntbXS8udGVzdChpbm5lcikpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkaWRuJ3QgYWNjaWRlbnRhbGx5IG1hdGNoIGEgSlNPTiBsaXRlcmFsXG4gICAgdHJ5IHtcbiAgICAgIEpTT04ucGFyc2Uob3BlbiArIGlubmVyICsgY2xvc2VNYXBbb3Blbkxlbl0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cblxuICBtYXRjaCA9IGFsaWFzQ29udGVudC5leGVjKGlubmVyKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgaW5uZXIgPSBtYXRjaFsxXTtcbiAgICBhbGlhcyA9IG1hdGNoWzJdO1xuICB9XG5cbiAgbWF0Y2ggPSBibG9ja0NvbnRlbnQuZXhlYyhpbm5lcilcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICBoYXNoID0gbWF0Y2hbMV07XG4gIHR5cGUgPSBtYXRjaFsyXTtcbiAgbmFtZSA9IG1hdGNoWzNdO1xuXG4gIGVzY2FwZWQgPSB0cnVlO1xuICBpZiAodHlwZSA9PT0gJ3VuZXNjYXBlZCcpIHtcbiAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgdHlwZSA9ICcnO1xuICB9XG4gIGlmIChib3VuZCkgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxidGhpc1xcYi8sICcuJyk7XG4gIHJldHVybiB7XG4gICAgcHJlOiBwcmVcbiAgLCBwb3N0OiBwb3N0XG4gICwgYm91bmQ6IGJvdW5kXG4gICwgYWxpYXM6IGFsaWFzXG4gICwgaGFzaDogaGFzaFxuICAsIHR5cGU6IHR5cGVcbiAgLCBuYW1lOiBuYW1lXG4gICwgZXNjYXBlZDogZXNjYXBlZFxuICAsIHNvdXJjZTogdGV4dFxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXRjaEJyYWNlcyh0ZXh0LCBudW0sIGksIG9wZW5DaGFyLCBjbG9zZUNoYXIpIHtcbiAgdmFyIGNsb3NlLCBoYXNDbG9zZSwgaGFzT3Blbiwgb3BlbjtcbiAgaSsrO1xuICB3aGlsZSAobnVtKSB7XG4gICAgY2xvc2UgPSB0ZXh0LmluZGV4T2YoY2xvc2VDaGFyLCBpKTtcbiAgICBvcGVuID0gdGV4dC5pbmRleE9mKG9wZW5DaGFyLCBpKTtcbiAgICBoYXNDbG9zZSA9IH5jbG9zZTtcbiAgICBoYXNPcGVuID0gfm9wZW47XG4gICAgaWYgKGhhc0Nsb3NlICYmICghaGFzT3BlbiB8fCAoY2xvc2UgPCBvcGVuKSkpIHtcbiAgICAgIGkgPSBjbG9zZSArIDE7XG4gICAgICBudW0tLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzT3Blbikge1xuICAgICAgaSA9IG9wZW4gKyAxO1xuICAgICAgbnVtKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaTtcbn1cblxudmFyIGZuQ2FsbCA9IC9eKFteKF0rKVxccypcXChcXHMqKFtcXHNcXFNdKj8pXFxzKlxcKVxccyokL1xuICAsIGFyZ1NlcGFyYXRvciA9IC9cXHMqKFssKF0pXFxzKi9nXG4gICwgbm90U2VwYXJhdG9yID0gL1teLFxcc10vZ1xuICAsIG5vdFBhdGhBcmcgPSAvKD86XlsnXCJcXGRcXC1be10pfCg/Ol5udWxsJCl8KD86XnRydWUkKXwoPzpeZmFsc2UkKS87XG5cbmZ1bmN0aW9uIGZuQXJncyhpbm5lcikge1xuICB2YXIgYXJncyA9IFtdXG4gICAgLCBsYXN0SW5kZXggPSAwXG4gICAgLCBtYXRjaCwgZW5kLCBsYXN0O1xuICB3aGlsZSAobWF0Y2ggPSBhcmdTZXBhcmF0b3IuZXhlYyhpbm5lcikpIHtcbiAgICBpZiAobWF0Y2hbMV0gPT09ICcoJykge1xuICAgICAgZW5kID0gbWF0Y2hCcmFjZXMoaW5uZXIsIDEsIGFyZ1NlcGFyYXRvci5sYXN0SW5kZXgsICcoJywgJyknKTtcbiAgICAgIGFyZ3MucHVzaChpbm5lci5zbGljZShsYXN0SW5kZXgsIGVuZCkpO1xuICAgICAgbm90U2VwYXJhdG9yLmxhc3RJbmRleCA9IGVuZDtcbiAgICAgIGxhc3RJbmRleCA9IGFyZ1NlcGFyYXRvci5sYXN0SW5kZXggPVxuICAgICAgICBub3RTZXBhcmF0b3IudGVzdChpbm5lcikgPyBub3RTZXBhcmF0b3IubGFzdEluZGV4IC0gMSA6IGVuZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBhcmdzLnB1c2goaW5uZXIuc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgIGxhc3RJbmRleCA9IGFyZ1NlcGFyYXRvci5sYXN0SW5kZXg7XG4gIH1cbiAgbGFzdCA9IGlubmVyLnNsaWNlKGxhc3RJbmRleCk7XG4gIGlmIChsYXN0KSBhcmdzLnB1c2gobGFzdCk7XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBmbkNhbGxFcnJvcihuYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHZpZXcgZnVuY3Rpb24gY2FsbDogJyArIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBmbkFyZ1ZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGFyZykge1xuICB2YXIgbGl0ZXJhbCA9IGxpdGVyYWxWYWx1ZShhcmcpO1xuICBpZiAobGl0ZXJhbCAhPT0gdm9pZCAwKSByZXR1cm4gbGl0ZXJhbDtcblxuICB2YXIgcGF0aE1hcCA9IG1vZGVsLl9fcGF0aE1hcDtcbiAgaWYgKCFwYXRoTWFwKSByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIGFyZyk7XG5cbiAgdmFyIGFyZ0lkcyA9IGN0eC5oYXNPd25Qcm9wZXJ0eSgnJGZuQXJnSWRzJykgP1xuICAgIGN0eC4kZm5BcmdJZHMgOiAoY3R4LiRmbkFyZ0lkcyA9IHt9KTtcbiAgdmFyIHBhdGhJZCA9IGFyZ0lkc1thcmddO1xuICB2YXIgcGF0aDtcbiAgaWYgKHBhdGhJZCkge1xuICAgIHBhdGggPSBwYXRoTWFwLnBhdGhzW3BhdGhJZF07XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IGN0eFBhdGgodmlldywgY3R4LCBhcmcpO1xuICAgIGFyZ0lkc1thcmddID0gcGF0aE1hcC5pZChwYXRoKTtcbiAgfVxuICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBmblZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gZm5DYWxsLmV4ZWMobmFtZSkgfHwgZm5DYWxsRXJyb3IobmFtZSlcbiAgICAsIGZuTmFtZSA9IG1hdGNoWzFdXG4gICAgLCBhcmdzID0gZm5BcmdzKG1hdGNoWzJdKVxuICAgICwgZm4sIGZuTmFtZSwgaTtcbiAgZm9yIChpID0gYXJncy5sZW5ndGg7IGktLTspIHtcbiAgICBhcmdzW2ldID0gZm5BcmdWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBhcmdzW2ldKTtcbiAgfVxuICBpZiAoIShmbiA9IHZpZXcuZ2V0Rm5zW2ZuTmFtZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2aWV3IGZ1bmN0aW9uIFwiJyArIGZuTmFtZSArICdcIiBub3QgZm91bmQgZm9yIGNhbGw6ICcgKyBuYW1lKTtcbiAgfVxuICByZXR1cm4gZm4uYXBwbHkoe3ZpZXc6IHZpZXcsIGN0eDogY3R4LCBtb2RlbDogbW9kZWx9LCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gcGF0aEZuQXJncyhuYW1lLCBwYXRocykge1xuICB2YXIgbWF0Y2ggPSBmbkNhbGwuZXhlYyhuYW1lKSB8fCBmbkNhbGxFcnJvcihuYW1lKVxuICAgICwgYXJncyA9IGZuQXJncyhtYXRjaFsyXSlcbiAgICAsIGksIGFyZztcbiAgaWYgKHBhdGhzID09IG51bGwpIHBhdGhzID0gW107XG4gIGZvciAoaSA9IGFyZ3MubGVuZ3RoOyBpLS07KSB7XG4gICAgYXJnID0gYXJnc1tpXTtcbiAgICBpZiAobm90UGF0aEFyZy50ZXN0KGFyZykpIGNvbnRpbnVlO1xuICAgIGlmICh+YXJnLmluZGV4T2YoJygnKSkge1xuICAgICAgcGF0aEZuQXJncyhhcmcsIHBhdGhzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXRocy5wdXNoKGFyZyk7XG4gIH1cbiAgcmV0dXJuIHBhdGhzO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpIHtcbiAgdmFyIG5hbWUgPSBjdHguJHBhdGhzW2kgLSAxXSArIHJlbWFpbmRlcjtcblxuICAvLyBwYXRoTWFwIGlzIG9ubHkgY3JlYXRlZCBpbiB0aGUgYnJvd3NlclxuICB2YXIgcGF0aE1hcCA9IHZpZXcubW9kZWwuX19wYXRoTWFwO1xuICBpZiAoIXBhdGhNYXApIHJldHVybiBuYW1lO1xuICB2YXIgcGF0aElkID0gY3R4LiRwYXRoSWRzW25hbWVdIHx8IChjdHguJHBhdGhJZHNbbmFtZV0gPSBwYXRoTWFwLmlkKG5hbWUpKTtcbiAgcmV0dXJuIHBhdGhNYXAucGF0aHNbcGF0aElkXTtcbn1cblxuZnVuY3Rpb24gbWFjcm9OYW1lKHZpZXcsIGN0eCwgbmFtZSkge1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICdAJykgcmV0dXJuO1xuXG4gIHZhciBzZWdtZW50cyA9IG5hbWUuc2xpY2UoMSkuc3BsaXQoJy4nKTtcbiAgdmFyIGJhc2UgPSBzZWdtZW50cy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciB2YWx1ZSA9IGxvb2t1cChiYXNlLCBjdHguJG1hY3JvQ3R4KTtcbiAgdmFyIG1hdGNoTmFtZSA9IHZhbHVlICYmIHZhbHVlLiRtYXRjaE5hbWU7XG4gIHZhciByZW1haW5kZXIgPSBzZWdtZW50cy5qb2luKCcuJyk7XG5cbiAgaWYgKG1hdGNoTmFtZSkge1xuICAgIGlmICghcmVtYWluZGVyKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIHskbWF0Y2hOYW1lOiBtYXRjaE5hbWUgKyAnLicgKyByZW1haW5kZXJ9O1xuICB9XG4gIHJldHVybiAocmVtYWluZGVyKSA/IGJhc2UgKyAnLicgKyByZW1haW5kZXIgOiBiYXNlO1xufVxuXG5mdW5jdGlvbiBjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSkge1xuICB2YXIgaXNXaWxkY2FyZCA9IG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSkgPT09ICcqJztcbiAgaWYgKGlzV2lsZGNhcmQpIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKTtcblxuICB2YXIgbWFjcm9QYXRoID0gbWFjcm9OYW1lKHZpZXcsIGN0eCwgbmFtZSk7XG4gIGlmIChtYWNyb1BhdGggJiYgbWFjcm9QYXRoLiRtYXRjaE5hbWUpIG5hbWUgPSBtYWNyb1BhdGguJG1hdGNoTmFtZTtcblxuICB2YXIgZmlyc3RDaGFyID0gbmFtZS5jaGFyQXQoMClcbiAgICAsIGksIGFsaWFzTmFtZSwgcmVtYWluZGVyXG5cbiAgLy8gUmVzb2x2ZSBwYXRoIGFsaWFzZXNcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJzonKSB7XG4gICAgaWYgKH4oaSA9IG5hbWUuc2VhcmNoKC9bLltdLykpKSB7XG4gICAgICBhbGlhc05hbWUgPSBuYW1lLnNsaWNlKDEsIGkpO1xuICAgICAgcmVtYWluZGVyID0gbmFtZS5zbGljZShpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpYXNOYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgIHJlbWFpbmRlciA9ICcnO1xuICAgIH1cbiAgICBhbGlhc05hbWUgPSBhbGlhc05hbWU7XG4gICAgaSA9IGN0eC4kcGF0aHMubGVuZ3RoIC0gY3R4LiRhbGlhc2VzW2FsaWFzTmFtZV07XG4gICAgaWYgKGkgIT09IGkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYWxpYXM6ICcgKyBuYW1lKTtcblxuICAgIG5hbWUgPSByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpO1xuXG4gIC8vIFJlc29sdmUgcmVsYXRpdmUgcGF0aHNcbiAgfSBlbHNlIGlmIChmaXJzdENoYXIgPT09ICcuJykge1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChuYW1lLmNoYXJBdChpKSA9PT0gJy4nKSB7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJlbWFpbmRlciA9IGkgPT09IG5hbWUubGVuZ3RoID8gJycgOiBuYW1lLnNsaWNlKGkgLSAxKTtcblxuICAgIG5hbWUgPSByZWxhdGl2ZVBhdGgodmlldywgY3R4LCBpLCByZW1haW5kZXIpO1xuICB9XG5cbiAgbmFtZSA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cyh2aWV3LCBjdHgsIG5hbWUpO1xuICBpZiAoaXNXaWxkY2FyZCkgbmFtZSArPSAnKic7XG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBuYW1lKSB7XG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZignWycpO1xuICBpZiAoaSA9PT0gLTEpIHJldHVybiBuYW1lO1xuXG4gIHZhciBlbmQgPSBtYXRjaEJyYWNlcyhuYW1lLCAxLCBpLCAnWycsICddJyk7XG4gIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGp1c3QgaW4gY2FzZSByZXR1cm5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybjtcbiAgdmFyIGJlZm9yZSA9IG5hbWUuc2xpY2UoMCwgaSk7XG4gIHZhciBpbnNpZGUgPSBuYW1lLnNsaWNlKGkgKyAxLCBlbmQgLSAxKTtcbiAgdmFyIGFmdGVyID0gbmFtZS5zbGljZShlbmQpO1xuXG4gIG5hbWUgPSByZXBsYWNlU3F1YXJlQnJhY2tldHModmlldywgY3R4LCBpbnNpZGUpO1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZSh2aWV3LCBjdHgsIHZpZXcubW9kZWwsIG5hbWUpO1xuICBuYW1lID0gKHZhbHVlID09IG51bGwpID8gJyRudWxsJyA6IHZhbHVlO1xuICB2YXIgb3V0ID0gKGJlZm9yZSkgPyBiZWZvcmUgKyAnLicgKyBuYW1lIDogbmFtZTtcblxuICB3aGlsZSAoYWZ0ZXIpIHtcbiAgICBpID0gYWZ0ZXIuaW5kZXhPZignWycpO1xuICAgIGlmIChpID09PSAtMSkgcmV0dXJuIG91dCArIGFmdGVyO1xuXG4gICAgbmFtZSA9IGFmdGVyO1xuICAgIGVuZCA9IG1hdGNoQnJhY2VzKG5hbWUsIDEsIGksICdbJywgJ10nKTtcbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuO1xuICAgIGJlZm9yZSA9IG5hbWUuc2xpY2UoMCwgaSk7XG4gICAgaW5zaWRlID0gbmFtZS5zbGljZShpICsgMSwgZW5kIC0gMSk7XG4gICAgYWZ0ZXIgPSBuYW1lLnNsaWNlKGVuZCk7XG5cbiAgICBpZiAoYmVmb3JlKSBvdXQgKz0gYmVmb3JlO1xuXG4gICAgbmFtZSA9IHJlcGxhY2VTcXVhcmVCcmFja2V0cyh2aWV3LCBjdHgsIGluc2lkZSk7XG4gICAgdmFsdWUgPSBnZXRWYWx1ZSh2aWV3LCBjdHgsIHZpZXcubW9kZWwsIG5hbWUpO1xuICAgIHZhbHVlID0gKHZhbHVlID09IG51bGwpID8gJyRudWxsJyA6IHZhbHVlO1xuICAgIG91dCArPSAnLicgKyB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBzcXVhcmVCcmFja2V0c0FyZ3MobmFtZSwgcGF0aHMpIHtcbiAgcGF0aHMgfHwgKHBhdGhzID0gW10pO1xuXG4gIHdoaWxlIChuYW1lKSB7XG4gICAgaSA9IG5hbWUuaW5kZXhPZignWycpO1xuICAgIGlmIChpID09PSAtMSkgcmV0dXJuIHBhdGhzO1xuXG4gICAgZW5kID0gbWF0Y2hCcmFjZXMobmFtZSwgMSwgaSwgJ1snLCAnXScpO1xuICAgIGlmIChlbmQgPT09IC0xKSByZXR1cm4gcGF0aHM7XG4gICAgaW5zaWRlID0gbmFtZS5zbGljZShpICsgMSwgZW5kIC0gMSk7XG4gICAgbmFtZSA9IG5hbWUuc2xpY2UoZW5kKTtcblxuICAgIGlmIChpbnNpZGUuaW5kZXhPZignWycpID09PSAtMSkge1xuICAgICAgcGF0aHMucHVzaChpbnNpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcXVhcmVCcmFja2V0c0FyZ3MoaW5zaWRlLCBwYXRocyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRocztcbn1cblxuZnVuY3Rpb24gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSkge1xuICByZXR1cm4gZXNjYXBlID8gZXNjYXBlKHZhbHVlKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBsaXRlcmFsVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSAnbnVsbCcpIHJldHVybiBudWxsO1xuICBpZiAodmFsdWUgPT09ICd0cnVlJykgcmV0dXJuIHRydWU7XG4gIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuICB2YXIgZmlyc3RDaGFyID0gdmFsdWUuY2hhckF0KDApXG4gICAgLCBtYXRjaDtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gXCInXCIpIHtcbiAgICBtYXRjaCA9IC9eJyguKiknJC8uZXhlYyh2YWx1ZSkgfHwgZm5DYWxsRXJyb3IodmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoZmlyc3RDaGFyID09PSAnXCInKSB7XG4gICAgbWF0Y2ggPSAvXlwiKC4qKVwiJC8uZXhlYyh2YWx1ZSkgfHwgZm5DYWxsRXJyb3IodmFsdWUpO1xuICAgIHJldHVybiBtYXRjaFsxXTtcbiAgfVxuICBpZiAoL15bXFxkXFwtXS8udGVzdChmaXJzdENoYXIpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICByZXR1cm4gK3ZhbHVlO1xuICB9XG4gIGlmIChmaXJzdENoYXIgPT09ICdbJyB8fCBmaXJzdENoYXIgPT09ICd7Jykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh2aWV3LCBjdHgsIG1vZGVsLCBuYW1lLCBlc2NhcGUsIGZvcmNlRXNjYXBlKSB7XG4gIHZhciBsaXRlcmFsID0gbGl0ZXJhbFZhbHVlKG5hbWUpXG4gIGlmIChsaXRlcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGF0YVZhbHVlKHZpZXcsIGN0eCwgbW9kZWwsIG5hbWUsIGVzY2FwZSwgZm9yY2VFc2NhcGUpO1xuICB9XG4gIHJldHVybiBsaXRlcmFsO1xufVxuXG5mdW5jdGlvbiBkYXRhVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgZXNjYXBlLCBmb3JjZUVzY2FwZSkge1xuICB2YXIgbWFjcm9QYXRoLCBwYXRoLCB2YWx1ZTtcbiAgaWYgKCFuYW1lKSByZXR1cm47XG4gIGlmICh+bmFtZS5pbmRleE9mKCcoJykpIHtcbiAgICB2YWx1ZSA9IGZuVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSk7XG4gICAgcmV0dXJuIGVzY2FwZVZhbHVlKHZhbHVlLCBlc2NhcGUpO1xuICB9XG4gIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgbmFtZSk7XG4gIG1hY3JvUGF0aCA9IG1hY3JvTmFtZSh2aWV3LCBjdHgsIHBhdGgpO1xuICBpZiAobWFjcm9QYXRoKSB7XG4gICAgaWYgKG1hY3JvUGF0aC4kbWF0Y2hOYW1lKSB7XG4gICAgICBwYXRoID0gbWFjcm9QYXRoLiRtYXRjaE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gbG9va3VwKG1hY3JvUGF0aCwgY3R4LiRtYWNyb0N0eCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh2YWx1ZS51bmVzY2FwZWQgJiYgIWZvcmNlRXNjYXBlKSByZXR1cm4gdmFsdWUoY3R4LCBtb2RlbCk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoY3R4LCBtb2RlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSk7XG4gICAgfVxuICB9XG4gIHZhbHVlID0gbG9va3VwKHBhdGgsIGN0eCk7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB2YWx1ZSA9IG1vZGVsLmdldChwYXRoKVxuICByZXR1cm4gZXNjYXBlVmFsdWUodmFsdWUsIGVzY2FwZSk7XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kRm4odmlldywgY3R4LCBtb2RlbCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoID0gZm5DYWxsLmV4ZWMobmFtZSkgfHwgZm5DYWxsRXJyb3IobmFtZSlcbiAgICAsIGZuTmFtZSA9IG1hdGNoWzFdXG4gICAgLCBhcmdzID0gZm5BcmdzKG1hdGNoWzJdKVxuICAgICwgZ2V0ID0gdmlldy5nZXRGbnNbZm5OYW1lXVxuICAgICwgc2V0ID0gdmlldy5zZXRGbnNbZm5OYW1lXVxuICAgICwgbnVtSW5wdXRzID0gc2V0ICYmIHNldC5sZW5ndGggLSAxXG4gICAgLCBhcmcsIGksIGlucHV0cywgb3V0LCBrZXksIHBhdGgsIGxlbjtcblxuICBpZiAoIShnZXQgJiYgc2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmlldyBmdW5jdGlvbiBcIicgKyBmbk5hbWUgKyAnXCIgc2V0dGVyIG5vdCBmb3VuZCBmb3IgYmluZGluZyB0bzogJyArIG5hbWUpO1xuICB9XG5cbiAgaWYgKG51bUlucHV0cykge1xuICAgIGlucHV0cyA9IFt2YWx1ZV07XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBudW1JbnB1dHMpIHtcbiAgICAgIGlucHV0cy5wdXNoKGZuQXJnVmFsdWUodmlldywgY3R4LCBtb2RlbCwgbmFtZSwgYXJnc1tpKytdKSk7XG4gICAgfVxuICAgIG91dCA9IHNldC5hcHBseShudWxsLCBpbnB1dHMpO1xuICB9IGVsc2Uge1xuICAgIG91dCA9IHNldCh2YWx1ZSk7XG4gIH1cbiAgaWYgKCFvdXQpIHJldHVybjtcblxuICBmb3IgKGtleSBpbiBvdXQpIHtcbiAgICB2YWx1ZSA9IG91dFtrZXldO1xuICAgIGFyZyA9IGFyZ3Nba2V5XTtcbiAgICBpZiAofmFyZy5pbmRleE9mKCcoJykpIHtcbiAgICAgIHNldEJvdW5kRm4odmlldywgY3R4LCBtb2RlbCwgYXJnLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgbm90UGF0aEFyZy50ZXN0KGFyZykpIGNvbnRpbnVlO1xuICAgIHBhdGggPSBjdHhQYXRoKHZpZXcsIGN0eCwgYXJnKTtcbiAgICBpZiAobW9kZWwuZ2V0KHBhdGgpID09PSB2YWx1ZSkgY29udGludWU7XG4gICAgbW9kZWwuc2V0KHBhdGgsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rdXAocGF0aCwgb2JqKSB7XG4gIGlmICghcGF0aCB8fCAhb2JqKSByZXR1cm47XG4gIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHJldHVybiBvYmpbcGF0aF07XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgdmFyIHByb3AgPSBwYXJ0c1tpXTtcbiAgICBvYmogPSBvYmpbcHJvcF07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbiIsInZhciBlbnRpdHlDb2RlID0gcmVxdWlyZSgnLi9lbnRpdHlDb2RlJylcbiAgLCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IHBhcnNlXG4sIGVzY2FwZUh0bWw6IGVzY2FwZUh0bWxcbiwgZXNjYXBlQXR0cmlidXRlOiBlc2NhcGVBdHRyaWJ1dGVcbiwgdW5lc2NhcGVFbnRpdGllczogdW5lc2NhcGVFbnRpdGllc1xuLCBpc1ZvaWQ6IGlzVm9pZFxuLCBjb25kaXRpb25hbENvbW1lbnQ6IGNvbmRpdGlvbmFsQ29tbWVudFxuLCB0cmltTGVhZGluZzogdHJpbUxlYWRpbmdcbiwgdHJpbVRleHQ6IHRyaW1UZXh0XG4sIHRyaW1UYWc6IHRyaW1UYWdcbiwgbWluaWZ5OiBtaW5pZnlcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuICcnXG5cbiAgcmV0dXJuIHZhbHVlXG4gICAgLnRvU3RyaW5nKClcbiAgICAucmVwbGFjZSgvJig/IVxccyl8PC9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoID09PSAnJicgPyAnJmFtcDsnIDogJyZsdDsnXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSAnJykgcmV0dXJuICdcIlwiJ1xuXG4gIHZhbHVlID0gdmFsdWVcbiAgICAudG9TdHJpbmcoKVxuICAgIC5yZXBsYWNlKC8mKD8hXFxzKXxcIi9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoID09PSAnJicgPyAnJmFtcDsnIDogJyZxdW90OydcbiAgICB9KVxuICByZXR1cm4gL1sgPTw+J10vLnRlc3QodmFsdWUpID8gJ1wiJyArIHZhbHVlICsgJ1wiJyA6IHZhbHVlXG59XG5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2pzbGlicy93aWtpL0phdmFzY3JpcHRUaXBzI0VzY2FwZV9hbmRfdW5lc2NhcGVfSFRNTF9lbnRpdGllc1xuZnVuY3Rpb24gdW5lc2NhcGVFbnRpdGllcyhodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLyYoW147XSspOy9nLCBmdW5jdGlvbihtYXRjaCwgZW50aXR5KSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnXG4gICAgICAgICAgPyBlbnRpdHkuY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgID8gZW50aXR5LnNsaWNlKDIsIDE3KVxuICAgICAgICAgICAgOiBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgICA6IGVudGl0eUNvZGVbZW50aXR5XVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKVxuICB9KVxufVxuXG52YXIgdm9pZEVsZW1lbnQgPSB7XG4gIGFyZWE6IDFcbiwgYmFzZTogMVxuLCBicjogMVxuLCBjb2w6IDFcbiwgY29tbWFuZDogMVxuLCBlbWJlZDogMVxuLCBocjogMVxuLCBpbWc6IDFcbiwgaW5wdXQ6IDFcbiwga2V5Z2VuOiAxXG4sIGxpbms6IDFcbiwgbWV0YTogMVxuLCBwYXJhbTogMVxuLCBzb3VyY2U6IDFcbiwgdHJhY2s6IDFcbiwgd2JyOiAxXG59XG5mdW5jdGlvbiBpc1ZvaWQobmFtZSkge1xuICByZXR1cm4gbmFtZSBpbiB2b2lkRWxlbWVudFxufVxuXG4vLyBBc3N1bWUgYW55IEhUTUwgY29tbWVudCB0aGF0IHN0YXJ0cyB3aXRoIGA8IS0tW2Agb3IgZW5kcyB3aXRoIGBdLS0+YFxuLy8gaXMgYSBjb25kaXRpb25hbCBjb21tZW50LiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8ga2VlcCBjb21tZW50cyBpblxuLy8gbWluaWZpZWQgSFRNTCwgc3VjaCBhcyBgPCEtLVsgQ29weXJpZ2h0IEpvaG4gRG9lLCBNSVQgTGljZW5zZWQgXS0tPmBcbmZ1bmN0aW9uIGNvbmRpdGlvbmFsQ29tbWVudCh0YWcpIHtcbiAgcmV0dXJuIC8oPzpePCEtLVxcWyl8KD86XFxdLS0+JCkvLnRlc3QodGFnKVxufVxuXG4vLyBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCBuZXdsaW5lcyBmcm9tIGEgc3RyaW5nLiBXaGl0ZXNwYWNlIGF0IHRoZSBlbmRcbi8vIG9mIGEgbGluZSB3aWxsIGJlIG1haW50YWluZWRcbmZ1bmN0aW9uIHRyaW1MZWFkaW5nKHRleHQpIHtcbiAgcmV0dXJuIHRleHQgPyB0ZXh0LnJlcGxhY2UoL1xccj9cXG5cXHMqL2csICcnKSA6ICcnXG59XG5cbi8vIFJlbW92ZSBsZWFkaW5nICYgdHJhaWxpbmcgd2hpdGVzcGFjZSBhbmQgbmV3bGluZXMgZnJvbSBhIHN0cmluZ1xuZnVuY3Rpb24gdHJpbVRleHQodGV4dCkge1xuICByZXR1cm4gdGV4dCA/IHRleHQucmVwbGFjZSgvXFxzKlxccj9cXG5cXHMqL2csICcnKSA6ICcnXG59XG5cbi8vIFdpdGhpbiBhIHRhZywgcmVtb3ZlIGxlYWRpbmcgJiB0cmFpbGluZyB3aGl0ZXNwYWNlLiBLZWVwIGEgbGluZWJyZWFrLCBzaW5jZVxuLy8gdGhpcyBjb3VsZCBiZSB0aGUgc2VwYXJhdG9yIGJldHdlZW4gYXR0cmlidXRlc1xuZnVuY3Rpb24gdHJpbVRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZy5yZXBsYWNlKC8oPzpcXHMqXFxyP1xcblxccyopKy9nLCAnXFxuJylcbn1cblxuLy8gUmVtb3ZlIGxpbmVicmVha3MsIGxlYWRpbmcgJiB0cmFpbGluZyBzcGFjZSwgYW5kIGNvbW1lbnRzLiBNYWludGFpbiBhXG4vLyBsaW5lYnJlYWsgYmV0d2VlbiBIVE1MIHRhZyBhdHRyaWJ1dGVzIGFuZCBtYWludGFpbiBjb25kaXRpb25hbCBjb21tZW50cy5cbmZ1bmN0aW9uIG1pbmlmeShodG1sKSB7XG4gIHZhciBtaW5pZmllZCA9ICcnXG4gICAgLCBtaW5pZnlDb250ZW50ID0gdHJ1ZVxuXG4gIHBhcnNlKGh0bWwsIHtcbiAgICBzdGFydDogZnVuY3Rpb24odGFnLCB0YWdOYW1lLCBhdHRycykge1xuICAgICAgbWluaWZ5Q29udGVudCA9ICEoJ3gtbm8tbWluaWZ5JyBpbiBhdHRycylcbiAgICAgIG1pbmlmaWVkICs9IHRyaW1UYWcodGFnKVxuICAgIH1cbiAgLCBlbmQ6IGZ1bmN0aW9uKHRhZykge1xuICAgICAgbWluaWZpZWQgKz0gdHJpbVRhZyh0YWcpXG4gICAgfVxuICAsIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIG1pbmlmaWVkICs9IG1pbmlmeUNvbnRlbnQgPyB0cmltVGV4dCh0ZXh0KSA6IHRleHRcbiAgICB9XG4gICwgY29tbWVudDogZnVuY3Rpb24odGFnKSB7XG4gICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50KHRhZykpIG1pbmlmaWVkICs9IHRhZ1xuICAgIH1cbiAgLCBvdGhlcjogZnVuY3Rpb24odGFnKSB7XG4gICAgICBtaW5pZmllZCArPSB0YWdcbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW5pZmllZFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXBwKSB7XG4gIGFwcC5vbignbW9kZWwnLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICBtb2RlbC5mbignbG9jYWxlcycsIGZ1bmN0aW9uICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpO1xuICAgIH0pO1xuICB9KTtcblxuICBhcHAuZ2V0KCcqJywgZnVuY3Rpb24gKHBhZ2UsIG1vZGVsLCBwYXJhbXMsIG5leHQpIHtcbiAgICBtb2RlbC5zdGFydCgnbG9jYWxlcycsICckbGFuZy5sb2NhbGVzJywgJyRsYW5nLnRyYW5zbGF0aW9ucycpO1xuICAgIG5leHQoKTtcbiAgfSk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBhcHAudmlldy5mbignX18nLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApXG4gICAgICAsIGxhbmd1YWdlID0gdGhpcy5tb2RlbC5nZXQoJyRsYW5nLmRlZmF1bHRMb2NhbGUnKSB8fCAnZW4nXG4gICAgICAsIHRyYW5zbGF0aW9uSW5wdXQgPSB7fVxuICAgICAgLCB0cmFuc2xhdGlvblBhdGggPSAnJztcblxuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0cmFuc2xhdGlvblBhdGggPSBhcmdzWzBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRyYW5zbGF0aW9uUGF0aCA9IGFyZ3NbMF07XG4gICAgICAgICAgdHJhbnNsYXRpb25JbnB1dCA9IGFyZ3NbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFuZ3VhZ2UgPSBhcmdzWzBdO1xuICAgICAgICAgIHRyYW5zbGF0aW9uUGF0aCA9IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsYW5ndWFnZSA9IGFyZ3NbMF07XG4gICAgICAgICAgdHJhbnNsYXRpb25JbnB1dCA9IGFyZ3NbMl07XG4gICAgICAgICAgdHJhbnNsYXRpb25QYXRoID0gYXJnc1sxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklucHV0W2FyZ3NbMV1dID0gYXJnc1syXTtcbiAgICAgICAgICB0cmFuc2xhdGlvblBhdGggPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICUgMikge1xuICAgICAgICAgIHRyYW5zbGF0aW9uUGF0aCA9IGFyZ3NbMF07XG4gICAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhbmd1YWdlID0gYXJnc1swXTtcbiAgICAgICAgICB0cmFuc2xhdGlvblBhdGggPSBhcmdzWzFdO1xuICAgICAgICAgIHZhciBpID0gMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGk7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkrPTIpIHtcbiAgICAgICAgICB0cmFuc2xhdGlvbklucHV0W2FyZ3NbaV1dID0gYXJnc1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHZpZXdQYXRoID0gJ19fJyArIGxhbmd1YWdlICsgJ18nICsgdHJhbnNsYXRpb25QYXRoLnJlcGxhY2UoL1xcLi9nLCAnXycpO1xuICAgIHZhciB2aWV3Rm4gPSBhcHAudmlldy5nZXRGbnNbdmlld1BhdGhdO1xuICAgIGlmICh2aWV3Rm4pIHJldHVybiB2aWV3Rm4odHJhbnNsYXRpb25JbnB1dCk7XG4gICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5tb2RlbC5hdCgnJGxhbmcudHJhbnNsYXRpb25zJykuYXQobGFuZ3VhZ2UpLmdldCh0cmFuc2xhdGlvblBhdGgpO1xuICAgIHZpZXdGbiA9IEZ1bmN0aW9uKCdNZXNzYWdlRm9ybWF0JywgJ3JldHVybiAnICsgdHJhbnNsYXRpb24pKHtsb2NhbGU6IHtlbjogZnVuY3Rpb24oKXt9IH19KTtcbiAgICBhcHAudmlldy5mbih2aWV3UGF0aCwgdmlld0ZuKTtcbiAgICByZXR1cm4gdmlld0ZuKHRyYW5zbGF0aW9uSW5wdXQpO1xuICB9KTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJvdXRlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYFJvdXRlYCB3aXRoIHRoZSBnaXZlbiBIVFRQIGBtZXRob2RgLCBgcGF0aGAsXG4gKiBhbmQgYW4gYXJyYXkgb2YgYGNhbGxiYWNrc2AgYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAgLSBgc2Vuc2l0aXZlYCAgICBlbmFibGUgY2FzZS1zZW5zaXRpdmUgcm91dGVzXG4gKiAgIC0gYHN0cmljdGAgICAgICAgZW5hYmxlIHN0cmljdCBtYXRjaGluZyBmb3IgdHJhaWxpbmcgc2xhc2hlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUm91dGUobWV0aG9kLCBwYXRoLCBjYWxsYmFja3MsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgdGhpcy5yZWdleHAgPSB1dGlscy5wYXRoUmVnZXhwKHBhdGhcbiAgICAsIHRoaXMua2V5cyA9IFtdXG4gICAgLCBvcHRpb25zLnNlbnNpdGl2ZVxuICAgICwgb3B0aW9ucy5zdHJpY3QpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgcm91dGUgbWF0Y2hlcyBgcGF0aGAsIGlmIHNvXG4gKiBwb3B1bGF0ZSBgLnBhcmFtc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Sb3V0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbihwYXRoKXtcbiAgdmFyIGtleXMgPSB0aGlzLmtleXNcbiAgICAsIHBhcmFtcyA9IHRoaXMucGFyYW1zID0gW11cbiAgICAsIG0gPSB0aGlzLnJlZ2V4cC5leGVjKHBhdGgpO1xuXG4gIGlmICghbSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuXG4gICAgdmFyIHZhbCA9ICdzdHJpbmcnID09IHR5cGVvZiBtW2ldXG4gICAgICA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKVxuICAgICAgOiBtW2ldO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnB1c2godmFsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdDogMHgwMDIyXG4sIGFtcDogMHgwMDI2XG4sIGFwb3M6IDB4MDAyN1xuLCBscGFyOiAweDAwMjhcbiwgcnBhcjogMHgwMDI5XG4sIGx0OiAweDAwM0NcbiwgZ3Q6IDB4MDAzRVxuLCBuYnNwOiAweDAwQTBcbiwgaWV4Y2w6IDB4MDBBMVxuLCBjZW50OiAweDAwQTJcbiwgcG91bmQ6IDB4MDBBM1xuLCBjdXJyZW46IDB4MDBBNFxuLCB5ZW46IDB4MDBBNVxuLCBicnZiYXI6IDB4MDBBNlxuLCBzZWN0OiAweDAwQTdcbiwgdW1sOiAweDAwQThcbiwgY29weTogMHgwMEE5XG4sIG9yZGY6IDB4MDBBQVxuLCBsYXF1bzogMHgwMEFCXG4sIG5vdDogMHgwMEFDXG4sIHNoeTogMHgwMEFEXG4sIHJlZzogMHgwMEFFXG4sIG1hY3I6IDB4MDBBRlxuLCBkZWc6IDB4MDBCMFxuLCBwbHVzbW46IDB4MDBCMVxuLCBzdXAyOiAweDAwQjJcbiwgc3VwMzogMHgwMEIzXG4sIGFjdXRlOiAweDAwQjRcbiwgbWljcm86IDB4MDBCNVxuLCBwYXJhOiAweDAwQjZcbiwgbWlkZG90OiAweDAwQjdcbiwgY2VkaWw6IDB4MDBCOFxuLCBzdXAxOiAweDAwQjlcbiwgb3JkbTogMHgwMEJBXG4sIHJhcXVvOiAweDAwQkJcbiwgZnJhYzE0OiAweDAwQkNcbiwgZnJhYzEyOiAweDAwQkRcbiwgZnJhYzM0OiAweDAwQkVcbiwgaXF1ZXN0OiAweDAwQkZcbiwgQWdyYXZlOiAweDAwQzBcbiwgQWFjdXRlOiAweDAwQzFcbiwgQWNpcmM6IDB4MDBDMlxuLCBBdGlsZGU6IDB4MDBDM1xuLCBBdW1sOiAweDAwQzRcbiwgQXJpbmc6IDB4MDBDNVxuLCBBRWxpZzogMHgwMEM2XG4sIENjZWRpbDogMHgwMEM3XG4sIEVncmF2ZTogMHgwMEM4XG4sIEVhY3V0ZTogMHgwMEM5XG4sIEVjaXJjOiAweDAwQ0FcbiwgRXVtbDogMHgwMENCXG4sIElncmF2ZTogMHgwMENDXG4sIElhY3V0ZTogMHgwMENEXG4sIEljaXJjOiAweDAwQ0VcbiwgSXVtbDogMHgwMENGXG4sIEVUSDogMHgwMEQwXG4sIE50aWxkZTogMHgwMEQxXG4sIE9ncmF2ZTogMHgwMEQyXG4sIE9hY3V0ZTogMHgwMEQzXG4sIE9jaXJjOiAweDAwRDRcbiwgT3RpbGRlOiAweDAwRDVcbiwgT3VtbDogMHgwMEQ2XG4sIHRpbWVzOiAweDAwRDdcbiwgT3NsYXNoOiAweDAwRDhcbiwgVWdyYXZlOiAweDAwRDlcbiwgVWFjdXRlOiAweDAwREFcbiwgVWNpcmM6IDB4MDBEQlxuLCBVdW1sOiAweDAwRENcbiwgWWFjdXRlOiAweDAwRERcbiwgVEhPUk46IDB4MDBERVxuLCBzemxpZzogMHgwMERGXG4sIGFncmF2ZTogMHgwMEUwXG4sIGFhY3V0ZTogMHgwMEUxXG4sIGFjaXJjOiAweDAwRTJcbiwgYXRpbGRlOiAweDAwRTNcbiwgYXVtbDogMHgwMEU0XG4sIGFyaW5nOiAweDAwRTVcbiwgYWVsaWc6IDB4MDBFNlxuLCBjY2VkaWw6IDB4MDBFN1xuLCBlZ3JhdmU6IDB4MDBFOFxuLCBlYWN1dGU6IDB4MDBFOVxuLCBlY2lyYzogMHgwMEVBXG4sIGV1bWw6IDB4MDBFQlxuLCBpZ3JhdmU6IDB4MDBFQ1xuLCBpYWN1dGU6IDB4MDBFRFxuLCBpY2lyYzogMHgwMEVFXG4sIGl1bWw6IDB4MDBFRlxuLCBldGg6IDB4MDBGMFxuLCBudGlsZGU6IDB4MDBGMVxuLCBvZ3JhdmU6IDB4MDBGMlxuLCBvYWN1dGU6IDB4MDBGM1xuLCBvY2lyYzogMHgwMEY0XG4sIG90aWxkZTogMHgwMEY1XG4sIG91bWw6IDB4MDBGNlxuLCBkaXZpZGU6IDB4MDBGN1xuLCBvc2xhc2g6IDB4MDBGOFxuLCB1Z3JhdmU6IDB4MDBGOVxuLCB1YWN1dGU6IDB4MDBGQVxuLCB1Y2lyYzogMHgwMEZCXG4sIHV1bWw6IDB4MDBGQ1xuLCB5YWN1dGU6IDB4MDBGRFxuLCB0aG9ybjogMHgwMEZFXG4sIHl1bWw6IDB4MDBGRlxuLCBPRWxpZzogMHgwMTUyXG4sIG9lbGlnOiAweDAxNTNcbiwgU2Nhcm9uOiAweDAxNjBcbiwgc2Nhcm9uOiAweDAxNjFcbiwgWXVtbDogMHgwMTc4XG4sIGZub2Y6IDB4MDE5MlxuLCBjaXJjOiAweDAyQzZcbiwgdGlsZGU6IDB4MDJEQ1xuLCBBbHBoYTogMHgwMzkxXG4sIEJldGE6IDB4MDM5MlxuLCBHYW1tYTogMHgwMzkzXG4sIERlbHRhOiAweDAzOTRcbiwgRXBzaWxvbjogMHgwMzk1XG4sIFpldGE6IDB4MDM5NlxuLCBFdGE6IDB4MDM5N1xuLCBUaGV0YTogMHgwMzk4XG4sIElvdGE6IDB4MDM5OVxuLCBLYXBwYTogMHgwMzlBXG4sIExhbWJkYTogMHgwMzlCXG4sIE11OiAweDAzOUNcbiwgTnU6IDB4MDM5RFxuLCBYaTogMHgwMzlFXG4sIE9taWNyb246IDB4MDM5RlxuLCBQaTogMHgwM0EwXG4sIFJobzogMHgwM0ExXG4sIFNpZ21hOiAweDAzQTNcbiwgVGF1OiAweDAzQTRcbiwgVXBzaWxvbjogMHgwM0E1XG4sIFBoaTogMHgwM0E2XG4sIENoaTogMHgwM0E3XG4sIFBzaTogMHgwM0E4XG4sIE9tZWdhOiAweDAzQTlcbiwgYWxwaGE6IDB4MDNCMVxuLCBiZXRhOiAweDAzQjJcbiwgZ2FtbWE6IDB4MDNCM1xuLCBkZWx0YTogMHgwM0I0XG4sIGVwc2lsb246IDB4MDNCNVxuLCB6ZXRhOiAweDAzQjZcbiwgZXRhOiAweDAzQjdcbiwgdGhldGE6IDB4MDNCOFxuLCBpb3RhOiAweDAzQjlcbiwga2FwcGE6IDB4MDNCQVxuLCBsYW1iZGE6IDB4MDNCQlxuLCBtdTogMHgwM0JDXG4sIG51OiAweDAzQkRcbiwgeGk6IDB4MDNCRVxuLCBvbWljcm9uOiAweDAzQkZcbiwgcGk6IDB4MDNDMFxuLCByaG86IDB4MDNDMVxuLCBzaWdtYWY6IDB4MDNDMlxuLCBzaWdtYTogMHgwM0MzXG4sIHRhdTogMHgwM0M0XG4sIHVwc2lsb246IDB4MDNDNVxuLCBwaGk6IDB4MDNDNlxuLCBjaGk6IDB4MDNDN1xuLCBwc2k6IDB4MDNDOFxuLCBvbWVnYTogMHgwM0M5XG4sIHRoZXRhc3ltOiAweDAzRDFcbiwgdXBzaWg6IDB4MDNEMlxuLCBwaXY6IDB4MDNENlxuLCBlbnNwOiAweDIwMDJcbiwgZW1zcDogMHgyMDAzXG4sIHRoaW5zcDogMHgyMDA5XG4sIHp3bmo6IDB4MjAwQ1xuLCB6d2o6IDB4MjAwRFxuLCBscm06IDB4MjAwRVxuLCBybG06IDB4MjAwRlxuLCBuZGFzaDogMHgyMDEzXG4sIG1kYXNoOiAweDIwMTRcbiwgbHNxdW86IDB4MjAxOFxuLCByc3F1bzogMHgyMDE5XG4sIHNicXVvOiAweDIwMUFcbiwgbGRxdW86IDB4MjAxQ1xuLCByZHF1bzogMHgyMDFEXG4sIGJkcXVvOiAweDIwMUVcbiwgZGFnZ2VyOiAweDIwMjBcbiwgRGFnZ2VyOiAweDIwMjFcbiwgYnVsbDogMHgyMDIyXG4sIGhlbGxpcDogMHgyMDI2XG4sIHBlcm1pbDogMHgyMDMwXG4sIHByaW1lOiAweDIwMzJcbiwgUHJpbWU6IDB4MjAzM1xuLCBsc2FxdW86IDB4MjAzOVxuLCByc2FxdW86IDB4MjAzQVxuLCBvbGluZTogMHgyMDNFXG4sIGZyYXNsOiAweDIwNDRcbiwgZXVybzogMHgyMEFDXG4sIGltYWdlOiAweDIxMTFcbiwgd2VpZXJwOiAweDIxMThcbiwgcmVhbDogMHgyMTFDXG4sIHRyYWRlOiAweDIxMjJcbiwgYWxlZnN5bTogMHgyMTM1XG4sIGxhcnI6IDB4MjE5MFxuLCB1YXJyOiAweDIxOTFcbiwgcmFycjogMHgyMTkyXG4sIGRhcnI6IDB4MjE5M1xuLCBoYXJyOiAweDIxOTRcbiwgY3JhcnI6IDB4MjFCNVxuLCBsQXJyOiAweDIxRDBcbiwgdUFycjogMHgyMUQxXG4sIHJBcnI6IDB4MjFEMlxuLCBkQXJyOiAweDIxRDNcbiwgaEFycjogMHgyMUQ0XG4sIGZvcmFsbDogMHgyMjAwXG4sIHBhcnQ6IDB4MjIwMlxuLCBleGlzdDogMHgyMjAzXG4sIGVtcHR5OiAweDIyMDVcbiwgbmFibGE6IDB4MjIwN1xuLCBpc2luOiAweDIyMDhcbiwgbm90aW46IDB4MjIwOVxuLCBuaTogMHgyMjBCXG4sIHByb2Q6IDB4MjIwRlxuLCBzdW06IDB4MjIxMVxuLCBtaW51czogMHgyMjEyXG4sIGxvd2FzdDogMHgyMjE3XG4sIHJhZGljOiAweDIyMUFcbiwgcHJvcDogMHgyMjFEXG4sIGluZmluOiAweDIyMUVcbiwgYW5nOiAweDIyMjBcbiwgYW5kOiAweDIyMjdcbiwgb3I6IDB4MjIyOFxuLCBjYXA6IDB4MjIyOVxuLCBjdXA6IDB4MjIyQVxuLCBpbnQ6IDB4MjIyQlxuLCB0aGVyZTQ6IDB4MjIzNFxuLCBzaW06IDB4MjIzQ1xuLCBjb25nOiAweDIyNDVcbiwgYXN5bXA6IDB4MjI0OFxuLCBuZTogMHgyMjYwXG4sIGVxdWl2OiAweDIyNjFcbiwgbGU6IDB4MjI2NFxuLCBnZTogMHgyMjY1XG4sIHN1YjogMHgyMjgyXG4sIHN1cDogMHgyMjgzXG4sIG5zdWI6IDB4MjI4NFxuLCBzdWJlOiAweDIyODZcbiwgc3VwZTogMHgyMjg3XG4sIG9wbHVzOiAweDIyOTVcbiwgb3RpbWVzOiAweDIyOTdcbiwgcGVycDogMHgyMkE1XG4sIHNkb3Q6IDB4MjJDNVxuLCBsY2VpbDogMHgyMzA4XG4sIHJjZWlsOiAweDIzMDlcbiwgbGZsb29yOiAweDIzMEFcbiwgcmZsb29yOiAweDIzMEJcbiwgbGFuZzogMHgyMzI5XG4sIHJhbmc6IDB4MjMyQVxuLCBsb3o6IDB4MjVDQVxuLCBzcGFkZXM6IDB4MjY2MFxuLCBjbHViczogMHgyNjYzXG4sIGhlYXJ0czogMHgyNjY1XG4sIGRpYW1zOiAweDI2NjZcbn1cbiIsInZhciBzdGFydFRhZyA9IC9ePChbXlxccz1cXC8hPl0rKSgoPzpcXHMrW15cXHM9XFwvPl0rKD86XFxzKj1cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspPyk/KSopXFxzKihcXC8/KVxccyo+L1xuICAsIGVuZFRhZyA9IC9ePFxcLyhbXlxccz1cXC8hPl0rKVtePl0qPi9cbiAgLCBjb21tZW50ID0gL148IS0tKFtcXHNcXFNdKj8pLS0+L1xuICAsIGNvbW1lbnRJbnNpZGUgPSAvPCEtLVtcXHNcXFNdKj8tLT4vXG4gICwgb3RoZXIgPSAvXjwoW1xcc1xcU10qPyk+L1xuICAsIGF0dHIgPSAvKFteXFxzPV0rKSg/OlxccyooPSlcXHMqKD86KD86XCIoKD86XFxcXC58W15cIl0pKilcIil8KD86JygoPzpcXFxcLnxbXiddKSopJyl8KFtePlxcc10rKSk/KT8vZ1xuICAsIHJhd1RhZ3NEZWZhdWx0ID0gL14oc3R5bGV8c2NyaXB0KSQvaVxuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIG1hdGNoRW5kRGVmYXVsdCh0YWdOYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCc8LycgKyB0YWdOYW1lLCAnaScpXG59XG5cbmZ1bmN0aW9uIG9uU3RhcnRUYWcoaHRtbCwgbWF0Y2gsIGhhbmRsZXIpIHtcbiAgdmFyIGF0dHJzID0ge31cbiAgICAsIHRhZyA9IG1hdGNoWzBdXG4gICAgLCB0YWdOYW1lID0gbWF0Y2hbMV1cbiAgICAsIHJlbWFpbmRlciA9IG1hdGNoWzJdXG4gIGh0bWwgPSBodG1sLnNsaWNlKHRhZy5sZW5ndGgpXG5cbiAgcmVtYWluZGVyLnJlcGxhY2UoYXR0ciwgZnVuY3Rpb24obWF0Y2gsIG5hbWUsIGVxdWFscywgYXR0cjAsIGF0dHIxLCBhdHRyMikge1xuICAgIGF0dHJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBhdHRyMCB8fCBhdHRyMSB8fCBhdHRyMiB8fCAoZXF1YWxzID8gJycgOiBudWxsKVxuICB9KVxuICBoYW5kbGVyKHRhZywgdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRycywgaHRtbClcblxuICByZXR1cm4gaHRtbFxufVxuXG5mdW5jdGlvbiBvblRhZyhodG1sLCBtYXRjaCwgaGFuZGxlcikge1xuICB2YXIgdGFnID0gbWF0Y2hbMF1cbiAgICAsIGRhdGEgPSBtYXRjaFsxXVxuICBodG1sID0gaHRtbC5zbGljZSh0YWcubGVuZ3RoKVxuXG4gIGhhbmRsZXIodGFnLCBkYXRhLCBodG1sKVxuXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIG9uVGV4dChodG1sLCBpbmRleCwgaXNSYXdUZXh0LCBoYW5kbGVyKSB7XG4gIHZhciB0ZXh0XG4gIGlmICh+aW5kZXgpIHtcbiAgICB0ZXh0ID0gaHRtbC5zbGljZSgwLCBpbmRleClcbiAgICBodG1sID0gaHRtbC5zbGljZShpbmRleClcbiAgfSBlbHNlIHtcbiAgICB0ZXh0ID0gaHRtbFxuICAgIGh0bWwgPSAnJ1xuICB9XG5cbiAgaWYgKHRleHQpIGhhbmRsZXIodGV4dCwgaXNSYXdUZXh0LCBodG1sKVxuXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIHJhd0VuZChodG1sLCBlbmRpbmcsIG9mZnNldCkge1xuICBvZmZzZXQgfHwgKG9mZnNldCA9IDApXG4gIHZhciBpbmRleCA9IGh0bWwuc2VhcmNoKGVuZGluZylcbiAgICAsIGNvbW1lbnRNYXRjaCA9IGh0bWwubWF0Y2goY29tbWVudEluc2lkZSlcbiAgICAsIGNvbW1lbnRFbmRcbiAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGVuZGluZyBjb25kaXRpb24gaXNuJ3QgaW5zaWRlIG9mIGFuIEhUTUwgY29tbWVudFxuICBpZiAoY29tbWVudE1hdGNoICYmIGNvbW1lbnRNYXRjaC5pbmRleCA8IGluZGV4KSB7XG4gICAgY29tbWVudEVuZCA9IGNvbW1lbnRNYXRjaC5pbmRleCArIGNvbW1lbnRNYXRjaFswXS5sZW5ndGhcbiAgICBvZmZzZXQgKz0gY29tbWVudEVuZFxuICAgIGh0bWwgPSBodG1sLnNsaWNlKGNvbW1lbnRFbmQpXG4gICAgcmV0dXJuIHJhd0VuZChodG1sLCBlbmRpbmcsIG9mZnNldClcbiAgfVxuICByZXR1cm4gaW5kZXggKyBvZmZzZXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwpIG9wdGlvbnMgPSB7fVxuXG4gIGlmICghaHRtbCkgcmV0dXJuXG5cbiAgdmFyIHN0YXJ0SGFuZGxlciA9IG9wdGlvbnMuc3RhcnQgfHwgZW1wdHlcbiAgICAsIGVuZEhhbmRsZXIgPSBvcHRpb25zLmVuZCB8fCBlbXB0eVxuICAgICwgdGV4dEhhbmRsZXIgPSBvcHRpb25zLnRleHQgfHwgZW1wdHlcbiAgICAsIGNvbW1lbnRIYW5kbGVyID0gb3B0aW9ucy5jb21tZW50IHx8IGVtcHR5XG4gICAgLCBvdGhlckhhbmRsZXIgPSBvcHRpb25zLm90aGVyIHx8IGVtcHR5XG4gICAgLCBtYXRjaEVuZCA9IG9wdGlvbnMubWF0Y2hFbmQgfHwgbWF0Y2hFbmREZWZhdWx0XG4gICAgLCBlcnJvckhhbmRsZXIgPSBvcHRpb25zLmVycm9yXG4gICAgLCByYXdUYWdzID0gb3B0aW9ucy5yYXdUYWdzIHx8IHJhd1RhZ3NEZWZhdWx0XG4gICAgLCBpbmRleCwgbGFzdCwgbWF0Y2gsIHRhZ05hbWUsIGVyclxuXG4gIHdoaWxlIChodG1sKSB7XG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignSFRNTCBwYXJzZSBlcnJvcjogJyArIGh0bWwpXG4gICAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdCA9IGh0bWxcblxuICAgIGlmIChodG1sWzBdID09PSAnPCcpIHtcbiAgICAgIGlmIChtYXRjaCA9IGh0bWwubWF0Y2goc3RhcnRUYWcpKSB7XG4gICAgICAgIGh0bWwgPSBvblN0YXJ0VGFnKGh0bWwsIG1hdGNoLCBzdGFydEhhbmRsZXIpXG5cbiAgICAgICAgdGFnTmFtZSA9IG1hdGNoWzFdXG4gICAgICAgIGlmIChyYXdUYWdzLnRlc3QodGFnTmFtZSkpIHtcbiAgICAgICAgICBpbmRleCA9IHJhd0VuZChodG1sLCBtYXRjaEVuZCh0YWdOYW1lKSlcbiAgICAgICAgICBodG1sID0gb25UZXh0KGh0bWwsIGluZGV4LCB0cnVlLCB0ZXh0SGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZykpIHtcbiAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpICAvLyB0YWdOYW1lXG4gICAgICAgIGh0bWwgPSBvblRhZyhodG1sLCBtYXRjaCwgZW5kSGFuZGxlcilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID0gaHRtbC5tYXRjaChjb21tZW50KSkge1xuICAgICAgICBodG1sID0gb25UYWcoaHRtbCwgbWF0Y2gsIGNvbW1lbnRIYW5kbGVyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPSBodG1sLm1hdGNoKG90aGVyKSkge1xuICAgICAgICBodG1sID0gb25UYWcoaHRtbCwgbWF0Y2gsIG90aGVySGFuZGxlcilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbmRleCA9IGh0bWwuaW5kZXhPZignPCcpXG4gICAgaHRtbCA9IG9uVGV4dChodG1sLCBpbmRleCwgZmFsc2UsIHRleHRIYW5kbGVyKVxuICB9XG59XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuXG5mdW5jdGlvbiBDaGFubmVsKHNvY2tldCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlcztcblxuICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gIHZhciBvbm1lc3NhZ2UgPSBzb2NrZXQub25tZXNzYWdlO1xuICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEucmFjZXIpIHJldHVybiBjaGFubmVsLl9vbk1lc3NhZ2UoZGF0YSk7XG4gICAgb25tZXNzYWdlICYmIG9ubWVzc2FnZS5jYWxsKHNvY2tldCwgZGF0YSk7XG4gIH07XG59XG5cbnV0aWwubWVyZ2VJbnRvKENoYW5uZWwucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIGNiKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tZXNzYWdlcy5hZGQobmFtZSwgZGF0YSwgY2IpO1xuICAvLyBQcm9hY3RpdmVseSBjYWxsIHRoZSB0b0pTT04gZnVuY3Rpb24sIHNpbmNlIHRoZSBHb29nbGUgQ2xvc3VyZSBKU09OXG4gIC8vIHNlcmlhbGl6ZXIgZG9lc24ndCBjaGVjayBmb3IgaXRcbiAgdGhpcy5zb2NrZXQuc2VuZChtZXNzYWdlLnRvSlNPTigpKTtcbn07XG5cbkNoYW5uZWwucHJvdG90eXBlLl9yZXBseSA9IGZ1bmN0aW9uKGlkLCBuYW1lLCBkYXRhKSB7XG4gIHZhciBtZXNzYWdlID0gbmV3IE1lc3NhZ2UoaWQsIHRydWUsIG5hbWUsIGRhdGEpO1xuICB0aGlzLnNvY2tldC5zZW5kKG1lc3NhZ2UudG9KU09OKCkpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKGRhdGEuYWNrKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLnJlbW92ZShkYXRhLmlkKTtcbiAgICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLmNiKSBtZXNzYWdlLmNiLmFwcGx5KGRhdGEuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gZGF0YS5yYWNlcjtcbiAgaWYgKGRhdGEuY2IpIHtcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXM7XG4gICAgdmFyIGhhc0xpc3RlbmVycyA9IHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgY2hhbm5lbC5fcmVwbHkoZGF0YS5pZCwgbmFtZSwgYXJncyk7XG4gICAgfSk7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdChuYW1lLCBkYXRhLmRhdGEpO1xuICAgIHRoaXMuX3JlcGx5KGRhdGEuaWQsIG5hbWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNZXNzYWdlc01hcCgpIHt9XG5cbmZ1bmN0aW9uIE1lc3NhZ2VzKCkge1xuICB0aGlzLm1hcCA9IG5ldyBNZXNzYWdlc01hcCgpO1xuICB0aGlzLmlkQ291bnQgPSAwO1xufVxuTWVzc2FnZXMucHJvdG90eXBlLmlkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoKyt0aGlzLmlkQ291bnQpLnRvU3RyaW5nKDM2KTtcbn07XG5NZXNzYWdlcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgY2IpIHtcbiAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZSh0aGlzLmlkKCksIGZhbHNlLCBuYW1lLCBkYXRhLCBjYik7XG4gIHRoaXMubWFwW21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuTWVzc2FnZXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBtZXNzYWdlID0gdGhpcy5tYXBbaWRdO1xuICBkZWxldGUgdGhpcy5tYXBbaWRdO1xuICByZXR1cm4gbWVzc2FnZTtcbn07XG5cbmZ1bmN0aW9uIE1lc3NhZ2UoaWQsIGFjaywgbmFtZSwgZGF0YSwgY2IpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmFjayA9IGFjaztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5jYiA9IGNiO1xufVxuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmFjZXI6IHRoaXMubmFtZVxuICAsIGlkOiB0aGlzLmlkXG4gICwgZGF0YTogdGhpcy5kYXRhXG4gICwgYWNrOiArdGhpcy5hY2tcbiAgLCBjYjogKHRoaXMuY2IpID8gMSA6IDBcbiAgfTtcbn07XG4iLCJ2YXIgRG9jID0gcmVxdWlyZSgnLi9Eb2MnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRG9jO1xuXG5mdW5jdGlvbiBMb2NhbERvYyhtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkLCBzbmFwc2hvdCkge1xuICBEb2MuY2FsbCh0aGlzLCBtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xufVxuXG5Mb2NhbERvYy5wcm90b3R5cGUgPSBuZXcgRG9jO1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGFbdGhpcy5pZF0gPSB0aGlzLnNuYXBzaG90O1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgZnVuY3Rpb24gc2V0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FwcGx5KHNlZ21lbnRzLCBzZXQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgdW5kZWZpbmVkLCBzaW5jZVxuICAvLyBhcHBseSBjcmVhdGVzIG9iamVjdHMgYXMgaXQgdHJhdmVyc2VzLCBhbmQgdGhlIGRlbCBtZXRob2RcbiAgLy8gc2hvdWxkIG5vdCBjcmVhdGUgYW55dGhpbmdcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgPT09IHZvaWQgMCkge1xuICAgIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIGRlbChub2RlLCBrZXkpIHtcbiAgICBkZWxldGUgbm9kZVtrZXldO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXBwbHkoc2VnbWVudHMsIGRlbCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihzZWxmLl9lcnJvck1lc3NhZ2UoXG4gICAgICAnaW5jcmVtZW50IG9uIG5vbi1udW1iZXInLCBzZWdtZW50cywgdmFsdWVcbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnQobm9kZSwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gKG5vZGVba2V5XSB8fCAwKSArIGJ5TnVtYmVyO1xuICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBpbmNyZW1lbnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiBwdXNoKGFycikge1xuICAgIHJldHVybiBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHB1c2gsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiB1bnNoaWZ0KGFycikge1xuICAgIHJldHVybiBhcnIudW5zaGlmdCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHVuc2hpZnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlcywgY2IpIHtcbiAgZnVuY3Rpb24gaW5zZXJ0KGFycikge1xuICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBbaW5kZXgsIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIGZ1bmN0aW9uIHBvcChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnBvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwb3AsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICBmdW5jdGlvbiBzaGlmdChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHNoaWZ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiByZW1vdmUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIGhvd01hbnkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiBtb3ZlKGFycikge1xuICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBsb2NhdGlvblxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc3BsaWNlKGZyb20sIGhvd01hbnkpO1xuICAgIC8vIEluc2VydCBpbiBuZXcgbG9jYXRpb25cbiAgICBhcnIuc3BsaWNlLmFwcGx5KGFyciwgW3RvLCAwXS5jb25jYXQodmFsdWVzKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnN0cmluZ0luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ0luc2VydCBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgbm9kZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICAgIG5vZGVba2V5XSA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgcHJldmlvdXMuc2xpY2UoaW5kZXgpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ1JlbW92ZSBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nUmVtb3ZlKG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIHByZXZpb3VzO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHByZXZpb3VzLmxlbmd0aDtcbiAgICBub2RlW2tleV0gPSBwcmV2aW91cy5zbGljZSgwLCBpbmRleCkgKyBwcmV2aW91cy5zbGljZShpbmRleCArIGhvd01hbnkpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdSZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzZWdtZW50cykge1xuICByZXR1cm4gdXRpbC5sb29rdXAoc2VnbWVudHMsIHRoaXMuc25hcHNob3QpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBzZWdtZW50cyBpcyB0aGUgYXJyYXkgcmVwcmVzZW50aW5nIGEgcGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4obm9kZSwga2V5KSBhcHBsaWVzIGEgbXV0YXRpb24gb24gbm9kZVtrZXldXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBvZiBmbihub2RlLCBrZXkpXG4gKi9cbkxvY2FsRG9jLnByb3RvdHlwZS5fY3JlYXRlSW1wbGllZCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbikge1xuICB2YXIgbm9kZSA9IHRoaXM7XG4gIHZhciBrZXkgPSAnc25hcHNob3QnO1xuICB2YXIgaSA9IDA7XG4gIHZhciBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgd2hpbGUgKG5leHRLZXkgIT0gbnVsbCkge1xuICAgIC8vIEdldCBvciBjcmVhdGUgaW1wbGllZCBvYmplY3Qgb3IgYXJyYXlcbiAgICBub2RlID0gbm9kZVtrZXldIHx8IChub2RlW2tleV0gPSAvXlxcZCskLy50ZXN0KG5leHRLZXkpID8gW10gOiB7fSk7XG4gICAga2V5ID0gbmV4dEtleTtcbiAgICBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgfVxuICByZXR1cm4gZm4obm9kZSwga2V5KTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fYXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIHZhciBvdXQgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzLCBmbik7XG4gIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gIGNiKCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuX3ZhbGlkYXRlZEFwcGx5ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbGlkYXRlLCBmbiwgY2IpIHtcbiAgdmFyIG91dCA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMsIGZ1bmN0aW9uKG5vZGUsIGtleSkge1xuICAgIHZhciBlcnIgPSB2YWxpZGF0ZShub2RlW2tleV0pO1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIHJldHVybiBmbihub2RlLCBrZXkpO1xuICB9KTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgY2IoKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5fYXJyYXlBcHBseSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmbiwgY2IpIHtcbiAgLy8gTG9va3VwIGEgcG9pbnRlciB0byB0aGUgcHJvcGVydHkgb3IgbmVzdGVkIHByb3BlcnR5ICZcbiAgLy8gcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlIG9yIGNyZWF0ZSBhIG5ldyBhcnJheVxuICB2YXIgYXJyID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cywgbm9kZUNyZWF0ZUFycmF5KTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5fZXJyb3JNZXNzYWdlKGZuLm5hbWUgKyAnIG9uIG5vbi1hcnJheScsIHNlZ21lbnRzLCBhcnIpO1xuICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBjYihlcnIpO1xuICB9XG4gIHZhciBvdXQgPSBmbihhcnIpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICBjYigpO1xuICByZXR1cm4gb3V0O1xufTtcblxuZnVuY3Rpb24gbm9kZUNyZWF0ZUFycmF5KG5vZGUsIGtleSkge1xuICByZXR1cm4gbm9kZVtrZXldIHx8IChub2RlW2tleV0gPSBbXSk7XG59XG4iLCIvKipcbiAqIFJlbW90ZURvYyBhZGFwdHMgdGhlIFNoYXJlSlMgb3BlcmF0aW9uIHByb3RvY29sIHRvIFJhY2VyJ3MgbXV0YXRvclxuICogaW50ZXJmYWNlLlxuICpcbiAqIDEuIEl0IG1hcHMgUmFjZXIncyBtdXRhdG9yIG1ldGhvZHMgdG8gb3V0Z29pbmcgU2hhcmVKUyBvcGVyYXRpb25zLlxuICogMi4gSXQgbWFwcyBpbmNvbWluZyBTaGFyZUpTIG9wZXJhdGlvbnMgdG8gUmFjZXIgZXZlbnRzLlxuICovXG5cbnZhciBEb2MgPSByZXF1aXJlKCcuL0RvYycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRG9jO1xuXG5mdW5jdGlvbiBSZW1vdGVEb2MobW9kZWwsIGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICBEb2MuY2FsbCh0aGlzLCBtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYyA9IG1vZGVsLl9nZXRPckNyZWF0ZVNoYXJlRG9jKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSk7XG4gIHRoaXMuY3JlYXRlZExvY2FsbHkgPSBmYWxzZTtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsID0gbW9kZWwucGFzcyh7JHJlbW90ZTogdHJ1ZX0pO1xuICB0aGlzLl9wYXNzU3RyaW5nSW5zZXJ0ID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nSW5zZXJ0J30pLl9wYXNzO1xuICB0aGlzLl9wYXNzU3RyaW5nUmVtb3ZlID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuXG4gIHZhciBkb2MgPSB0aGlzO1xuICBzaGFyZURvYy5vbignb3AnLCBmdW5jdGlvbihvcCwgaXNMb2NhbCkge1xuICAgIC8vIERvbid0IGVtaXQgb24gbG9jYWwgb3BlcmF0aW9ucywgc2luY2UgdGhleSBhcmUgZW1pdHRlZCBpbiB0aGUgbXV0YXRvclxuICAgIGlmIChpc0xvY2FsKSByZXR1cm47XG4gICAgZG9jLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIGRvYy5fb25PcChvcCk7XG4gIH0pO1xuICBzaGFyZURvYy5vbignZGVsJywgZnVuY3Rpb24oaXNMb2NhbCwgcHJldmlvdXMpIHtcbiAgICAvLyBDYWxsaW5nIHRoZSBzaGFyZURvYy5kZWwgbWV0aG9kIGRvZXMgbm90IGVtaXQgYW4gb3BlcmF0aW9uIGV2ZW50LFxuICAgIC8vIHNvIHdlIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgaGVyZS5cbiAgICBpZiAoaXNMb2NhbCkgcmV0dXJuO1xuICAgIGRvYy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ZvaWQgMCwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gIH0pO1xuICBzaGFyZURvYy5vbignY3JlYXRlJywgZnVuY3Rpb24oaXNMb2NhbCkge1xuICAgIC8vIExvY2FsIGNyZWF0ZXMgc2hvdWxkIG5vdCBlbWl0IGFuIGV2ZW50LCBzaW5jZSB0aGV5IG9ubHkgaGFwcGVuXG4gICAgLy8gaW1wbGljaXRseSBhcyBhIHJlc3VsdCBvZiBhbm90aGVyIG11dGF0aW9uLCBhbmQgdGhhdCBvcGVyYXRpb24gd2lsbFxuICAgIC8vIGVtaXQgdGhlIGFwcHJvcHJpYXRlIGV2ZW50LiBSZW1vdGUgY3JlYXRlcyBjYW4gc2V0IHRoZSBzbmFwc2hvdCBkYXRhXG4gICAgLy8gd2l0aG91dCBlbWl0dGluZyBhbiBvcGVyYXRpb24gZXZlbnQsIHNvIGFuIGV2ZW50IG5lZWRzIHRvIGJlIGVtaXR0ZWRcbiAgICAvLyBmb3IgdGhlbS5cbiAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgLy8gVHJhY2sgd2hlbiBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJ5IHRoaXMgY2xpZW50LCBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAvLyBlbWl0IGEgbG9hZCBldmVudCB3aGVuIHN1YnNlcXVlbnRseSBzdWJzY3JpYmVkXG4gICAgICBkb2MuY3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2MuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgdmFyIHZhbHVlID0gc2hhcmVEb2Muc25hcHNob3Q7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFt2YWx1ZSwgdm9pZCAwLCBtb2RlbC5fcGFzc10pO1xuICB9KTtcbn1cblxuUmVtb3RlRG9jLnByb3RvdHlwZSA9IG5ldyBEb2M7XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGFbdGhpcy5pZF0gPSB0aGlzLnNoYXJlRG9jLnNuYXBzaG90O1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXRoaXMuc2hhcmVEb2MudHlwZSkge1xuICAgIHRoaXMuc2hhcmVEb2MuY3JlYXRlKCdqc29uMCcsIHZhbHVlLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cyk7XG4gIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbXBsaWVkT3ApIHtcbiAgICBwcmV2aW91cy52YWx1ZVtsYXN0U2VnbWVudF0gPSB2YWx1ZTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKHByZXZpb3VzLm9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAocHJldmlvdXMgPT0gbnVsbCkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgdmFsdWUpXSA6XG4gICAgICBbbmV3IExpc3RSZXBsYWNlT3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgcHJldmlvdXMsIHZhbHVlKV0gOlxuICAgIChwcmV2aW91cyA9PSBudWxsKSA/XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCB2YWx1ZSldIDpcbiAgICAgIFtuZXcgT2JqZWN0UmVwbGFjZU9wKHNlZ21lbnRzLCBwcmV2aW91cywgdmFsdWUpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLnNoYXJlRG9jLmRlbChjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgdW5kZWZpbmVkLCBzaW5jZVxuICAvLyB0aGUgZGVsIG1ldGhvZCBzaG91bGQgbm90IGNyZWF0ZSBhbnl0aGluZ1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyA9PT0gdm9pZCAwKSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9wID0gW25ldyBPYmplY3REZWxldGVPcChzZWdtZW50cywgcHJldmlvdXMpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cyk7XG4gIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEltcGxpZWRPcCkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHByZXZpb3VzLnZhbHVlW2xhc3RTZWdtZW50XSA9IGJ5TnVtYmVyO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3AocHJldmlvdXMub3AsIGNiKTtcbiAgICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICAgIHJldHVybiBieU51bWJlcjtcbiAgfVxuICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBvcCA9IChpc0FycmF5SW5kZXgobGFzdFNlZ21lbnQpKSA/XG4gICAgICBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCAtMSksIGxhc3RTZWdtZW50LCBieU51bWJlcildIDpcbiAgICAgIFtuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKV07XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgcmV0dXJuIGJ5TnVtYmVyO1xuICB9XG4gIHZhciBvcCA9IFtuZXcgSW5jcmVtZW50T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgcmV0dXJuIHByZXZpb3VzICsgYnlOdW1iZXI7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHB1c2goYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIGFyci5sZW5ndGgsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwdXNoLCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHVuc2hpZnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIDAsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiBhcnIubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCB1bnNoaWZ0LCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiBpbnNlcnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIG9wID0gY3JlYXRlSW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybiBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlcyldO1xuICB9XG4gIHZhciBvcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3AucHVzaChuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCsrLCB2YWx1ZXNbaV0pKTtcbiAgfVxuICByZXR1cm4gb3A7XG59XG5cblJlbW90ZURvYy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIHBvcChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgdmFsdWUgPSBhcnJbaW5kZXhdO1xuICAgIHZhciBvcCA9IFtuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwb3AsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gc2hpZnQoYXJyLCBmbkNiKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyWzBdO1xuICAgIHZhciBvcCA9IFtuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCAwLCB2YWx1ZSldO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHNoaWZ0LCBjYik7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcmVtb3ZlKGFyciwgZm5DYikge1xuICAgIHZhciB2YWx1ZXMgPSBhcnIuc2xpY2UoaW5kZXgsIGluZGV4ICsgaG93TWFueSk7XG4gICAgdmFyIG9wID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3AucHVzaChuZXcgTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzW2ldKSk7XG4gICAgfVxuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gbW92ZShhcnIsIGZuQ2IpIHtcbiAgICAvLyBHZXQgdGhlIHJldHVybiB2YWx1ZVxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc2xpY2UoZnJvbSwgZnJvbSArIGhvd01hbnkpO1xuXG4gICAgLy8gQnVpbGQgYW4gb3AgdGhhdCBtb3ZlcyBlYWNoIGl0ZW0gaW5kaXZpZHVhbGx5XG4gICAgdmFyIG9wID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICAgIG9wLnB1c2gobmV3IExpc3RNb3ZlT3Aoc2VnbWVudHMsIChmcm9tIDwgdG8pID8gZnJvbSA6IGZyb20gKyBob3dNYW55IC0gMSwgKGZyb20gPCB0bykgPyB0byArIGhvd01hbnkgLSAxIDogdG8pKTtcbiAgICB9XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdJbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlLCBjYikge1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgSW1wbGllZE9wKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgcHJldmlvdXMudmFsdWVbbGFzdFNlZ21lbnRdID0gdmFsdWU7XG4gICAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChwcmV2aW91cy5vcCwgY2IpO1xuICAgIHRoaXMuX3VwZGF0ZUNvbGxlY3Rpb25EYXRhKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAgIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIHZhbHVlKV0gOlxuICAgICAgW25ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpXTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gICAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgdmFyIG9wID0gW25ldyBTdHJpbmdJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgdGhpcy5fdXBkYXRlQ29sbGVjdGlvbkRhdGEoKTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBwcmV2aW91cyA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBJbXBsaWVkT3ApIHJldHVybjtcbiAgaWYgKHByZXZpb3VzID09IG51bGwpIHJldHVybiBwcmV2aW91cztcbiAgdmFyIHJlbW92ZWQgPSBwcmV2aW91cy5zbGljZShpbmRleCwgaW5kZXggKyBob3dNYW55KTtcbiAgdmFyIG9wID0gW25ldyBTdHJpbmdSZW1vdmVPcChzZWdtZW50cywgaW5kZXgsIHJlbW92ZWQpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gIHJldHVybiB1dGlsLmxvb2t1cChzZWdtZW50cywgdGhpcy5zaGFyZURvYy5zbmFwc2hvdCk7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLl9jcmVhdGVJbXBsaWVkID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgaWYgKCF0aGlzLnNoYXJlRG9jLnR5cGUpIHtcbiAgICB0aGlzLnNoYXJlRG9jLmNyZWF0ZSgnanNvbjAnKTtcbiAgfVxuICB2YXIgcGFyZW50ID0gdGhpcy5zaGFyZURvYztcbiAgdmFyIGtleSA9ICdzbmFwc2hvdCc7XG4gIHZhciBub2RlID0gcGFyZW50W2tleV07XG4gIHZhciBpID0gMDtcbiAgdmFyIG5leHRLZXkgPSBzZWdtZW50c1tpKytdO1xuICB2YXIgb3AsIHZhbHVlO1xuICB3aGlsZSAobmV4dEtleSAhPSBudWxsKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBpZiAob3ApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXldID0gaXNBcnJheUluZGV4KG5leHRLZXkpID8gW10gOiB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaXNBcnJheUluZGV4KG5leHRLZXkpID8gW10gOiB7fTtcbiAgICAgICAgb3AgPSAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSA/XG4gICAgICAgICAgbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cy5zbGljZSgwLCBpIC0gMiksIGtleSwgdmFsdWUpIDpcbiAgICAgICAgICBuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgaSAtIDEpLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBub2RlID0gdmFsdWU7XG4gICAgfVxuICAgIHBhcmVudCA9IG5vZGU7XG4gICAga2V5ID0gbmV4dEtleTtcbiAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgbmV4dEtleSA9IHNlZ21lbnRzW2krK107XG4gIH1cbiAgaWYgKG9wKSByZXR1cm4gbmV3IEltcGxpZWRPcChvcCwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIEltcGxpZWRPcChvcCwgdmFsdWUpIHtcbiAgdGhpcy5vcCA9IG9wO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX2FycmF5QXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKGFyciBpbnN0YW5jZW9mIEltcGxpZWRPcCkge1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3AoYXJyLm9wKTtcbiAgICBhcnIgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIH0gZWxzZSBpZiAoYXJyID09IG51bGwpIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgW10pXSA6XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCBbXSldO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3ApO1xuICAgIGFyciA9IHRoaXMuZ2V0KHNlZ21lbnRzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9lcnJvck1lc3NhZ2UoZm4ubmFtZSArICcgb24gbm9uLWFycmF5Jywgc2VnbWVudHMsIGFycik7XG4gICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cbiAgdmFyIG91dCA9IGZuKGFyciwgY2IpO1xuICB0aGlzLl91cGRhdGVDb2xsZWN0aW9uRGF0YSgpO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5fb25PcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBpdGVtID0gb3BbMF07XG4gIHZhciBzZWdtZW50cyA9IFt0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLmlkXS5jb25jYXQoaXRlbS5wKTtcbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcblxuICAvLyBPYmplY3RSZXBsYWNlT3AsIE9iamVjdEluc2VydE9wLCBvciBPYmplY3REZWxldGVPcFxuICBpZiAoZGVmaW5lZChpdGVtLm9pKSB8fCBkZWZpbmVkKGl0ZW0ub2QpKSB7XG4gICAgdmFyIHZhbHVlID0gaXRlbS5vaTtcbiAgICB2YXIgcHJldmlvdXMgPSBpdGVtLm9kO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIExpc3RSZXBsYWNlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubGkpICYmIGRlZmluZWQoaXRlbS5sZCkpIHtcbiAgICB2YXIgdmFsdWUgPSBpdGVtLmxpO1xuICAgIHZhciBwcmV2aW91cyA9IGl0ZW0ubGQ7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdEluc2VydE9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLmxpKSkge1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB2YWx1ZXMgPSBbaXRlbS5saV07XG4gICAgbW9kZWwuZW1pdCgnaW5zZXJ0Jywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbaW5kZXgsIHZhbHVlcywgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBMaXN0UmVtb3ZlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubGQpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJlbW92ZWQgPSBbaXRlbS5sZF07XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbaW5kZXgsIHJlbW92ZWQsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdE1vdmVPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5sbSkpIHtcbiAgICB2YXIgZnJvbSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0byA9IGl0ZW0ubG0gLSAxO1xuICAgIHZhciBob3dNYW55ID0gMTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBbZnJvbSwgdG8sIGhvd01hbnksIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gU3RyaW5nSW5zZXJ0T3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0uc2kpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRleHQgPSBpdGVtLnNpO1xuICAgIHNlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMCwgLTEpO1xuICAgIG1vZGVsLmVtaXQoJ3N0cmluZ0luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIHRleHQsIG1vZGVsLl9wYXNzXSk7XG4gICAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cyk7XG4gICAgdmFyIHByZXZpb3VzID0gdmFsdWUuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUuc2xpY2UoaW5kZXggKyB0ZXh0Lmxlbmd0aCk7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIHRoaXMuX3Bhc3NTdHJpbmdJbnNlcnRdKTtcblxuICAvLyBTdHJpbmdSZW1vdmVPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5zZCkpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgdGV4dCA9IGl0ZW0uc2Q7XG4gICAgdmFyIGhvd01hbnkgPSB0ZXh0Lmxlbmd0aDtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDAsIC0xKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQoc2VnbWVudHMpO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlLnNsaWNlKDAsIGluZGV4KSArIHRleHQgKyB2YWx1ZS5zbGljZShpbmRleCk7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIHRoaXMuX3Bhc3NTdHJpbmdSZW1vdmVdKTtcblxuICAvLyBJbmNyZW1lbnRPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5uYSkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChpdGVtLnApO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlIC0gaXRlbS5uYTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gT2JqZWN0UmVwbGFjZU9wKHNlZ21lbnRzLCBiZWZvcmUsIGFmdGVyKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMub2QgPSBiZWZvcmU7XG4gIHRoaXMub2kgPSAoYWZ0ZXIgPT09IHZvaWQgMCkgPyBudWxsIDogYWZ0ZXI7XG59XG5mdW5jdGlvbiBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5vaSA9ICh2YWx1ZSA9PT0gdm9pZCAwKSA/IG51bGwgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIE9iamVjdERlbGV0ZU9wKHNlZ21lbnRzLCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMpO1xuICB0aGlzLm9kID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdFJlcGxhY2VPcChzZWdtZW50cywgaW5kZXgsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxkID0gYmVmb3JlO1xuICB0aGlzLmxpID0gKGFmdGVyID09PSB2b2lkIDApID8gbnVsbCA6IGFmdGVyO1xufVxuZnVuY3Rpb24gTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxpID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdFJlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxkID0gKHZhbHVlID09PSB2b2lkIDApID8gbnVsbCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gTGlzdE1vdmVPcChzZWdtZW50cywgZnJvbSwgdG8pIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChmcm9tKSk7XG4gIHRoaXMubG0gPSB0bztcbn1cbmZ1bmN0aW9uIFN0cmluZ0luc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLnNpID0gdmFsdWU7XG59XG5mdW5jdGlvbiBTdHJpbmdSZW1vdmVPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdGhpcy5zZCA9IHZhbHVlO1xufVxuZnVuY3Rpb24gSW5jcmVtZW50T3Aoc2VnbWVudHMsIGJ5TnVtYmVyKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMubmEgPSBieU51bWJlcjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKSB7XG4gIC8vIENhc3QgbnVtYmVyIHBhdGggc2VnbWVudHMgZnJvbSBzdHJpbmdzIHRvIG51bWJlcnNcbiAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJyAmJiBpc0FycmF5SW5kZXgoc2VnbWVudCkpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gK3NlZ21lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxuZnVuY3Rpb24gaXNBcnJheUluZGV4KHNlZ21lbnQpIHtcbiAgcmV0dXJuICgvXlswLTldKyQvKS50ZXN0KHNlZ21lbnQpO1xufVxuIiwiLy8gbm90aGluZyB0byBzZWUgaGVyZS4uLiBubyBmaWxlIG1ldGhvZHMgZm9yIHRoZSBicm93c2VyXG4iLCJ2YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5Jbk5ld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IHt9O1xuICAgIFxuICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZiAoIWlmcmFtZS5zdHlsZSkgaWZyYW1lLnN0eWxlID0ge307XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICBcbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGNvbnRleHQpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgIH0pO1xuICAgICBcbiAgICBpZiAoIXdpbi5ldmFsICYmIHdpbi5leGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi5ldmFsKCkgbWFnaWNhbGx5IGFwcGVhcnMgd2hlbiB0aGlzIGlzIGNhbGxlZCBpbiBJRTpcbiAgICAgICAgd2luLmV4ZWNTY3JpcHQoJ251bGwnKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlcyA9IHdpbi5ldmFsKHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbnRleHRba2V5XSA9IHdpbltrZXldO1xuICAgIH0pO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICByZXR1cm4gcmVzO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JblRoaXNDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBldmFsKHRoaXMuY29kZSk7IC8vIG1heWJlLi4uXG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgLy8gc2VlbXMgdG8gYmUganVzdCBydW5Jbk5ld0NvbnRleHQgb24gbWFnaWNhbCBjb250ZXh0IG9iamVjdHMgd2hpY2ggYXJlXG4gICAgLy8gb3RoZXJ3aXNlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gb2JqZWN0cyBleGNlcHQgcGxhaW4gb2xkIG9iamVjdHNcbiAgICAvLyBmb3IgdGhlIHBhcmFtZXRlciBzZWdmYXVsdHMgbm9kZVxuICAgIHJldHVybiB0aGlzLnJ1bkluTmV3Q29udGV4dChjb250ZXh0KTtcbn07XG5cbmZvckVhY2goT2JqZWN0X2tleXMoU2NyaXB0LnByb3RvdHlwZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZXhwb3J0c1tuYW1lXSA9IFNjcmlwdFtuYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHZhciBzID0gU2NyaXB0KGNvZGUpO1xuICAgICAgICByZXR1cm4gc1tuYW1lXS5hcHBseShzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH07XG59KTtcblxuZXhwb3J0cy5jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBleHBvcnRzLlNjcmlwdChjb2RlKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAvLyBub3QgcmVhbGx5IHN1cmUgd2hhdCB0aGlzIG9uZSBkb2VzXG4gICAgLy8gc2VlbXMgdG8ganVzdCBtYWtlIGEgc2hhbGxvdyBjb3B5XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuIiwiKGZ1bmN0aW9uKCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIEVUYWcgZm9yIGBib2R5YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGJvZHlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXRhZyA9IGZ1bmN0aW9uKGJvZHkpe1xuICByZXR1cm4gJ1wiJyArIGNyYzMyLnNpZ25lZChib2R5KSArICdcIic7XG59O1xuXG4vKipcbiAqIE1ha2UgYGxvY2FscygpYCBib3VuZCB0byB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogVGhpcyBpcyB1c2VkIGZvciBgYXBwLmxvY2Fsc2AgYW5kIGByZXMubG9jYWxzYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubG9jYWxzID0gZnVuY3Rpb24ob2JqKXtcbiAgZnVuY3Rpb24gbG9jYWxzKG9iail7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgbG9jYWxzW2tleV0gPSBvYmpba2V5XTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHJldHVybiBsb2NhbHM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBwYXRoYCBsb29rcyBhYnNvbHV0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpe1xuICBpZiAoJy8nID09IHBhdGhbMF0pIHJldHVybiB0cnVlO1xuICBpZiAoJzonID09IHBhdGhbMV0gJiYgJ1xcXFwnID09IHBhdGhbMl0pIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBGbGF0dGVuIHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyLCByZXQpe1xuICB2YXIgcmV0ID0gcmV0IHx8IFtdXG4gICAgLCBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuICAgICAgZXhwb3J0cy5mbGF0dGVuKGFycltpXSwgcmV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBgdHlwZWAsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5ub3JtYWxpemVUeXBlID0gZnVuY3Rpb24odHlwZSl7XG4gIHJldHVybiB+dHlwZS5pbmRleE9mKCcvJylcbiAgICA/IGFjY2VwdFBhcmFtcyh0eXBlKVxuICAgIDogeyB2YWx1ZTogbWltZS5sb29rdXAodHlwZSksIHBhcmFtczoge30gfTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGB0eXBlc2AsIGZvciBleGFtcGxlIFwiaHRtbFwiIGJlY29tZXMgXCJ0ZXh0L2h0bWxcIi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0eXBlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm5vcm1hbGl6ZVR5cGVzID0gZnVuY3Rpb24odHlwZXMpe1xuICB2YXIgcmV0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHJldC5wdXNoKGV4cG9ydHMubm9ybWFsaXplVHlwZSh0eXBlc1tpXSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhY2NlcHRhYmxlIHR5cGUgaW4gYHR5cGVzYCwgaWYgYW55LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmFjY2VwdHNBcnJheSA9IGZ1bmN0aW9uKHR5cGVzLCBzdHIpe1xuICAvLyBhY2NlcHQgYW55dGhpbmcgd2hlbiBBY2NlcHQgaXMgbm90IHByZXNlbnRcbiAgaWYgKCFzdHIpIHJldHVybiB0eXBlc1swXTtcblxuICAvLyBwYXJzZVxuICB2YXIgYWNjZXB0ZWQgPSBleHBvcnRzLnBhcnNlQWNjZXB0KHN0cilcbiAgICAsIG5vcm1hbGl6ZWQgPSBleHBvcnRzLm5vcm1hbGl6ZVR5cGVzKHR5cGVzKVxuICAgICwgbGVuID0gYWNjZXB0ZWQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IHR5cGVzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgaWYgKGV4cG9ydHMuYWNjZXB0KG5vcm1hbGl6ZWRbal0sIGFjY2VwdGVkW2ldKSkge1xuICAgICAgICByZXR1cm4gdHlwZXNbal07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGB0eXBlKHMpYCBhcmUgYWNjZXB0YWJsZSBiYXNlZCBvblxuICogdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlKHMpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtCb29sZWFufFN0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYWNjZXB0cyA9IGZ1bmN0aW9uKHR5cGUsIHN0cil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdHlwZSkgdHlwZSA9IHR5cGUuc3BsaXQoLyAqLCAqLyk7XG4gIHJldHVybiBleHBvcnRzLmFjY2VwdHNBcnJheSh0eXBlLCBzdHIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgdHlwZWAgYXJyYXkgaXMgYWNjZXB0YWJsZSBmb3IgYG90aGVyYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hY2NlcHQgPSBmdW5jdGlvbih0eXBlLCBvdGhlcil7XG4gIHZhciB0ID0gdHlwZS52YWx1ZS5zcGxpdCgnLycpO1xuICByZXR1cm4gKHRbMF0gPT0gb3RoZXIudHlwZSB8fCAnKicgPT0gb3RoZXIudHlwZSlcbiAgICAmJiAodFsxXSA9PSBvdGhlci5zdWJ0eXBlIHx8ICcqJyA9PSBvdGhlci5zdWJ0eXBlKVxuICAgICYmIHBhcmFtc0VxdWFsKHR5cGUucGFyYW1zLCBvdGhlci5wYXJhbXMpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhY2NlcHQgcGFyYW1zIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJhbXNFcXVhbChhLCBiKXtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhhKS5zb21lKGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gYVtrXSAhPSBiW2tdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhY2NlcHQgYHN0cmAsIHJldHVybmluZ1xuICogYW4gYXJyYXkgb2JqZWN0cyBjb250YWluaW5nXG4gKiBgLnR5cGVgIGFuZCBgLnN1YnR5cGVgIGFsb25nXG4gKiB3aXRoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYnlcbiAqIGBwYXJzZVF1YWxpdHkoKWAuXG4gKlxuICogQHBhcmFtIHtUeXBlfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUFjY2VwdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBleHBvcnRzXG4gICAgLnBhcnNlUGFyYW1zKHN0cilcbiAgICAubWFwKGZ1bmN0aW9uKG9iail7XG4gICAgICB2YXIgcGFydHMgPSBvYmoudmFsdWUuc3BsaXQoJy8nKTtcbiAgICAgIG9iai50eXBlID0gcGFydHNbMF07XG4gICAgICBvYmouc3VidHlwZSA9IHBhcnRzWzFdO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFyc2UgcXVhbGl0eSBgc3RyYCwgcmV0dXJuaW5nIGFuXG4gKiBhcnJheSBvZiBvYmplY3RzIHdpdGggYC52YWx1ZWAsXG4gKiBgLnF1YWxpdHlgIGFuZCBvcHRpb25hbCBgLnBhcmFtc2BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyXG4gICAgLnNwbGl0KC8gKiwgKi8pXG4gICAgLm1hcChhY2NlcHRQYXJhbXMpXG4gICAgLmZpbHRlcihmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iai5xdWFsaXR5O1xuICAgIH0pXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICBpZiAoYS5xdWFsaXR5ID09PSBiLnF1YWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIGEub3JpZ2luYWxJbmRleCAtIGIub3JpZ2luYWxJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiLnF1YWxpdHkgLSBhLnF1YWxpdHk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFjY2VwdCBwYXJhbXMgYHN0cmAgcmV0dXJuaW5nIGFuXG4gKiBvYmplY3Qgd2l0aCBgLnZhbHVlYCwgYC5xdWFsaXR5YCBhbmQgYC5wYXJhbXNgLlxuICogYWxzbyBpbmNsdWRlcyBgLm9yaWdpbmFsSW5kZXhgIGZvciBzdGFibGUgc29ydGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFjY2VwdFBhcmFtcyhzdHIsIGluZGV4KSB7XG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgdmFyIHJldCA9IHsgdmFsdWU6IHBhcnRzWzBdLCBxdWFsaXR5OiAxLCBwYXJhbXM6IHt9LCBvcmlnaW5hbEluZGV4OiBpbmRleCB9O1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcG1zID0gcGFydHNbaV0uc3BsaXQoLyAqPSAqLyk7XG4gICAgaWYgKCdxJyA9PSBwbXNbMF0pIHtcbiAgICAgIHJldC5xdWFsaXR5ID0gcGFyc2VGbG9hdChwbXNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucGFyYW1zW3Btc1swXV0gPSBwbXNbMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcgb2YgaHRtbC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24oaHRtbCkge1xuICByZXR1cm4gU3RyaW5nKGh0bWwpXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsXG4gKiByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgc2hvdWxkIGJlIHBhc3NlZCxcbiAqIHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGxhY2Vob2xkZXJcbiAqIGtleSBuYW1lcy4gRm9yIGV4YW1wbGUgXCIvdXNlci86aWRcIiB3aWxsXG4gKiB0aGVuIGNvbnRhaW4gW1wiaWRcIl0uXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfFJlZ0V4cHxBcnJheX0gcGF0aFxuICogQHBhcmFtICB7QXJyYXl9IGtleXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59IHNlbnNpdGl2ZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhdGhSZWdleHAgPSBmdW5jdGlvbihwYXRoLCBrZXlzLCBzZW5zaXRpdmUsIHN0cmljdCkge1xuICBpZiAodG9TdHJpbmcuY2FsbChwYXRoKSA9PSAnW29iamVjdCBSZWdFeHBdJykgcmV0dXJuIHBhdGg7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSBwYXRoID0gJygnICsgcGF0aC5qb2luKCd8JykgKyAnKSc7XG4gIHBhdGggPSBwYXRoXG4gICAgLmNvbmNhdChzdHJpY3QgPyAnJyA6ICcvPycpXG4gICAgLnJlcGxhY2UoL1xcL1xcKC9nLCAnKD86LycpXG4gICAgLnJlcGxhY2UoLyhcXC8pPyhcXC4pPzooXFx3KykoPzooXFwoLio/XFwpKSk/KFxcPyk/KFxcKik/L2csIGZ1bmN0aW9uKF8sIHNsYXNoLCBmb3JtYXQsIGtleSwgY2FwdHVyZSwgb3B0aW9uYWwsIHN0YXIpe1xuICAgICAga2V5cy5wdXNoKHsgbmFtZToga2V5LCBvcHRpb25hbDogISEgb3B0aW9uYWwgfSk7XG4gICAgICBzbGFzaCA9IHNsYXNoIHx8ICcnO1xuICAgICAgcmV0dXJuICcnXG4gICAgICAgICsgKG9wdGlvbmFsID8gJycgOiBzbGFzaClcbiAgICAgICAgKyAnKD86J1xuICAgICAgICArIChvcHRpb25hbCA/IHNsYXNoIDogJycpXG4gICAgICAgICsgKGZvcm1hdCB8fCAnJykgKyAoY2FwdHVyZSB8fCAoZm9ybWF0ICYmICcoW14vLl0rPyknIHx8ICcoW14vXSs/KScpKSArICcpJ1xuICAgICAgICArIChvcHRpb25hbCB8fCAnJylcbiAgICAgICAgKyAoc3RhciA/ICcoLyopPycgOiAnJyk7XG4gICAgfSlcbiAgICAucmVwbGFjZSgvKFtcXC8uXSkvZywgJ1xcXFwkMScpXG4gICAgLnJlcGxhY2UoL1xcKi9nLCAnKC4qKScpO1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwYXRoICsgJyQnLCBzZW5zaXRpdmUgPyAnJyA6ICdpJyk7XG59XG5cbn0pKCkiLCJ2YXIgc2hhcmUgPSByZXF1aXJlKCdzaGFyZS9saWIvY2xpZW50Jyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciBMb2NhbERvYyA9IHJlcXVpcmUoJy4vTG9jYWxEb2MnKTtcbnZhciBSZW1vdGVEb2MgPSByZXF1aXJlKCcuL1JlbW90ZURvYycpO1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihidW5kbGUpIHtcbiAgLy8gTW9kZWw6Ol9jcmVhdGVTb2NrZXQgc2hvdWxkIGJlIGRlZmluZWQgYnkgdGhlIHNvY2tldCBwbHVnaW5cbiAgdGhpcy5yb290LnNvY2tldCA9IHRoaXMuX2NyZWF0ZVNvY2tldChidW5kbGUpO1xuXG4gIC8vIFRoZSBTaGFyZSBjb25uZWN0aW9uIHdpbGwgYmluZCB0byB0aGUgc29ja2V0IGJ5IGRlZmluaW5nIHRoZSBvbm9wZW4sXG4gIC8vIG9ubWVzc2FnZSwgZXRjLiBtZXRob2RzXG4gIHZhciBzaGFyZUNvbm5lY3Rpb24gPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uID0gbmV3IHNoYXJlLkNvbm5lY3Rpb24odGhpcy5yb290LnNvY2tldCk7XG4gIHZhciBzZWdtZW50cyA9IFsnJGNvbm5lY3Rpb24nLCAnc3RhdGUnXTtcbiAgdmFyIHN0YXRlcyA9IFsnY29ubmVjdGluZycsICdjb25uZWN0ZWQnLCAnZGlzY29ubmVjdGVkJywgJ3N0b3BwZWQnXTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzaGFyZUNvbm5lY3Rpb24ub24oc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuX3NldChzZWdtZW50cywgc3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc2V0KHNlZ21lbnRzLCAnY29ubmVjdGVkJyk7XG5cbiAgLy8gV3JhcCB0aGUgc29ja2V0IG1ldGhvZHMgb24gdG9wIG9mIFNoYXJlJ3MgbWV0aG9kc1xuICB0aGlzLl9jcmVhdGVDaGFubmVsKCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0Lm9wZW4oKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJvb3Quc29ja2V0LmNsb3NlKCk7XG59O1xuTW9kZWwucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgdGhpcy5jb25uZWN0KCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2NyZWF0ZUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yb290LmNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLnJvb3Quc29ja2V0KTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVTaGFyZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnJvb3Quc2hhcmVDb25uZWN0aW9uLmdldChjb2xsZWN0aW9uTmFtZSwgaWQsIGRhdGEpO1xuICBzaGFyZURvYy5pbmNyZW1lbnRhbCA9IHRydWU7XG4gIHJldHVybiBzaGFyZURvYztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fZ2V0RG9jQ29uc3RydWN0b3IgPSBmdW5jdGlvbihuYW1lKSB7XG4gIC8vIFdoZXRoZXIgdGhlIGNvbGxlY3Rpb24gaXMgbG9jYWwgb3IgcmVtb3RlIGlzIGRldGVybWluZWQgYnkgaXRzIG5hbWUuXG4gIC8vIENvbGxlY3Rpb25zIHN0YXJ0aW5nIHdpdGggYW4gdW5kZXJzY29yZSAoJ18nKSBhcmUgZm9yIHVzZXItZGVmaW5lZCBsb2NhbFxuICAvLyBjb2xsZWN0aW9ucywgdGhvc2Ugc3RhcnRpbmcgd2l0aCBhIGRvbGxhciBzaWduICgnJCcnKSBhcmUgZm9yXG4gIC8vIGZyYW1ld29yay1kZWZpbmVkIGxvY2FsIGNvbGxlY3Rpb25zLCBhbmQgYWxsIG90aGVycyBhcmUgcmVtb3RlLlxuICB2YXIgZmlyc3RDaGFyY3RlciA9IG5hbWUuY2hhckF0KDApO1xuICB2YXIgaXNMb2NhbCA9IChmaXJzdENoYXJjdGVyID09PSAnXycgfHwgZmlyc3RDaGFyY3RlciA9PT0gJyQnKTtcbiAgcmV0dXJuIChpc0xvY2FsKSA/IExvY2FsRG9jIDogUmVtb3RlRG9jO1xufTtcbiIsInZhciB1dWlkID0gcmVxdWlyZSgnbm9kZS11dWlkJyk7XG5cbk1vZGVsLklOSVRTID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG5cbmZ1bmN0aW9uIE1vZGVsKG9wdGlvbnMpIHtcbiAgdGhpcy5yb290ID0gdGhpcztcblxuICB2YXIgaW5pdHMgPSBNb2RlbC5JTklUUztcbiAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0cy5sZW5ndGg7IGkrKykge1xuICAgIGluaXRzW2ldKHRoaXMsIG9wdGlvbnMpO1xuICB9XG59XG5cbk1vZGVsLnByb3RvdHlwZS5pZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdXVpZC52NCgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLl9jaGlsZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IENoaWxkTW9kZWwodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBDaGlsZE1vZGVsKG1vZGVsKSB7XG4gIC8vIFNoYXJlZCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBhY2Nlc3NlZCB2aWEgdGhlIHJvb3QuIFRoaXMgbWFrZXMgaW5oZXJpdGFuY2VcbiAgLy8gY2hlYXAgYW5kIGVhc2lseSBleHRlbnNpYmxlXG4gIHRoaXMucm9vdCA9IG1vZGVsLnJvb3Q7XG5cbiAgLy8gRXZlbnRFbWl0dGVyIG1ldGhvZHMgYWNjZXNzIHRoZXNlIHByb3BlcnRpZXMgZGlyZWN0bHksIHNvIHRoZXkgbXVzdCBiZVxuICAvLyBpbmhlcml0ZWQgbWFudWFsbHkgaW5zdGVhZCBvZiB2aWEgdGhlIHJvb3RcbiAgdGhpcy5fZXZlbnRzID0gbW9kZWwuX2V2ZW50cztcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbW9kZWwuX21heExpc3RlbmVycztcblxuICAvLyBQcm9wZXJ0aWVzIHNwZWNpZmljIHRvIGEgY2hpbGQgaW5zdGFuY2VcbiAgdGhpcy5fY29udGV4dCA9IG1vZGVsLl9jb250ZXh0O1xuICB0aGlzLl9hdCA9IG1vZGVsLl9hdDtcbiAgdGhpcy5fcGFzcyA9IG1vZGVsLl9wYXNzO1xuICB0aGlzLl9zaWxlbnQgPSBtb2RlbC5fc2lsZW50O1xufVxuQ2hpbGRNb2RlbC5wcm90b3R5cGUgPSBuZXcgTW9kZWw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERvYztcblxuZnVuY3Rpb24gRG9jKG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgaWQpIHtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29sbGVjdGlvbkRhdGEgPSBtb2RlbCAmJiBtb2RlbC5kYXRhW2NvbGxlY3Rpb25OYW1lXTtcbn1cblxuRG9jLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbk5hbWUgKyAnLicgKyB0aGlzLmlkICsgJy4nICsgc2VnbWVudHMuam9pbignLicpO1xufTtcblxuRG9jLnByb3RvdHlwZS5fZXJyb3JNZXNzYWdlID0gZnVuY3Rpb24oZGVzY3JpcHRpb24sIHNlZ21lbnRzLCB2YWx1ZSkge1xuICByZXR1cm4gZGVzY3JpcHRpb24gKyAnIGF0ICcgKyB0aGlzLnBhdGgoc2VnbWVudHMpICsgJzogJyArXG4gICAgSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIDIpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ2FycmF5ZGlmZicpO1xuXG5Nb2RlbC5wcm90b3R5cGUuc2V0RGlmZiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgdmFsdWUsIG9wdGlvbnMsIGNiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldERpZmYoc2VnbWVudHMsIHZhbHVlLCBvcHRpb25zLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXREaWZmID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBvcHRpb25zLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIGVxdWFsRm4gPSAob3B0aW9ucyAmJiBvcHRpb25zLmVxdWFsKSB8fCB1dGlsLmVxdWFsO1xuICB2YXIgaXNFYWNoID0gb3B0aW9ucyAmJiBvcHRpb25zLmVhY2g7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHNldERpZmYoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBiZWZvcmUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICBpZiAoZXF1YWxGbihiZWZvcmUsIHZhbHVlKSkgcmV0dXJuIGZuQ2IoKTtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoZm5DYik7XG4gICAgZG9EaWZmKG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBiZWZvcmUsIHZhbHVlLCBlcXVhbEZuLCBncm91cCwgaXNFYWNoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXREaWZmLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXRBcnJheURpZmYgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzZXRBcnJheURpZmYoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBiZWZvcmUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICBpZiAoYmVmb3JlID09PSB2YWx1ZSkgcmV0dXJuIGZuQ2IoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYmVmb3JlKSB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGFwcGx5U2V0KG1vZGVsLCBkb2MsIHNlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaWZmID0gYXJyYXlEaWZmKGJlZm9yZSwgdmFsdWUpO1xuICAgIGlmICghZGlmZi5sZW5ndGgpIHJldHVybiBmbkNiKCk7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGZuQ2IpO1xuICAgIGFwcGx5QXJyYXlEaWZmKG1vZGVsLCBkb2MsIHNlZ21lbnRzLCBkaWZmLCBncm91cCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2V0QXJyYXlEaWZmLCBjYik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb2MuY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb2MuaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2Muc25hcHNob3RcbiAqIEBwYXJhbSB7QXJyYXl9IHNlZ21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gYmVmb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gYWZ0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdyb3VwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzRWFjaFxuICovXG5mdW5jdGlvbiBkb0RpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGJlZm9yZSwgYWZ0ZXIsIGVxdWFsRm4sIGdyb3VwLCBpc0VhY2gpIHtcbiAgaWYgKHR5cGVvZiBiZWZvcmUgIT09ICdvYmplY3QnIHx8ICFiZWZvcmUgfHxcbiAgICAgIHR5cGVvZiBhZnRlciAhPT0gJ29iamVjdCcgfHwgIWFmdGVyKSB7XG4gICAgLy8gU2V0IHRoZSBlbnRpcmUgdmFsdWUgaWYgbm90IGRpZmZhYmxlXG4gICAgYXBwbHlTZXQobW9kZWwsIGRvYywgc2VnbWVudHMsIGFmdGVyLCBncm91cCgpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYmVmb3JlKSAmJiBBcnJheS5pc0FycmF5KGFmdGVyKSkge1xuICAgIHZhciBkaWZmID0gYXJyYXlEaWZmKGJlZm9yZSwgYWZ0ZXIsIGVxdWFsRm4pO1xuICAgIGlmICghZGlmZi5sZW5ndGgpIHJldHVybiBncm91cCgpKCk7XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhbmdlIGlzIGEgc2luZ2xlIGl0ZW0gcmVwbGFjZW1lbnQsIGRpZmYgdGhlIGl0ZW0gaW5zdGVhZFxuICAgIGlmIChcbiAgICAgIGRpZmYubGVuZ3RoID09PSAyICYmXG4gICAgICBkaWZmWzBdLmluZGV4ID09PSBkaWZmWzFdLmluZGV4ICYmXG4gICAgICBkaWZmWzBdIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYgJiZcbiAgICAgIGRpZmZbMF0uaG93TWFueSA9PT0gMSAmJlxuICAgICAgZGlmZlsxXSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmICYmXG4gICAgICBkaWZmWzFdLnZhbHVlcy5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIHZhciBpbmRleCA9IGRpZmZbMF0uaW5kZXg7XG4gICAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgICAgIGRvRGlmZihtb2RlbCwgZG9jLCBpdGVtU2VnbWVudHMsIGJlZm9yZVtpbmRleF0sIGFmdGVyW2luZGV4XSwgZXF1YWxGbiwgZ3JvdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHBseUFycmF5RGlmZihtb2RlbCwgZG9jLCBzZWdtZW50cywgZGlmZiwgZ3JvdXApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWlzRWFjaCkge1xuICAgIC8vIERlbGV0ZSBrZXlzIHRoYXQgd2VyZSBpbiBiZWZvcmUgYnV0IG5vdCBhZnRlclxuICAgIGZvciAodmFyIGtleSBpbiBiZWZvcmUpIHtcbiAgICAgIGlmIChrZXkgaW4gYWZ0ZXIpIGNvbnRpbnVlO1xuICAgICAgdmFyIGl0ZW1TZWdtZW50cyA9IHNlZ21lbnRzLmNvbmNhdChrZXkpO1xuICAgICAgdmFyIGRvY1NlZ21lbnRzID0gaXRlbVNlZ21lbnRzLnNsaWNlKDIpO1xuICAgICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZ3JvdXAoKSk7XG4gICAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBpdGVtU2VnbWVudHMsIFt2b2lkIDAsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIH1cbiAgfVxuICAvLyBEaWZmIGVhY2ggcHJvcGVydHkgaW4gYWZ0ZXJcbiAgZm9yICh2YXIga2V5IGluIGFmdGVyKSB7XG4gICAgaWYgKGVxdWFsRm4oYmVmb3JlW2tleV0sIGFmdGVyW2tleV0pKSBjb250aW51ZTtcbiAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGtleSk7XG4gICAgZG9EaWZmKG1vZGVsLCBkb2MsIGl0ZW1TZWdtZW50cywgYmVmb3JlW2tleV0sIGFmdGVyW2tleV0sIGVxdWFsRm4sIGdyb3VwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVNldChtb2RlbCwgZG9jLCBzZWdtZW50cywgYWZ0ZXIsIGNiKSB7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCBhZnRlciwgY2IpO1xuICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW2FmdGVyLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBcnJheURpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGRpZmYsIGdyb3VwKSB7XG4gIHZhciBkb2NTZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDIpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlmZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBpdGVtID0gZGlmZltpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIGRvYy5pbnNlcnQoZG9jU2VnbWVudHMsIGl0ZW0uaW5kZXgsIGl0ZW0udmFsdWVzLCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaXRlbS5pbmRleCwgaXRlbS52YWx1ZXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYpIHtcbiAgICAgIC8vIFJlbW92ZVxuICAgICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpdGVtLmluZGV4LCBpdGVtLmhvd01hbnksIGdyb3VwKCkpO1xuICAgICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpdGVtLmluZGV4LCByZW1vdmVkLCBtb2RlbC5fcGFzc10pO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5Nb3ZlRGlmZikge1xuICAgICAgLy8gTW92ZVxuICAgICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGl0ZW0uZnJvbSwgaXRlbS50bywgaXRlbS5ob3dNYW55LCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ21vdmUnLCBzZWdtZW50cywgW2l0ZW0uZnJvbSwgaXRlbS50bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIH1cbiAgfVxufVxuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9Nb2RlbCcpO1xudmFyIGFycmF5RGlmZiA9IHJlcXVpcmUoJ2FycmF5ZGlmZicpO1xudmFyIGRlZXBFcXVhbHMgPSByZXF1aXJlKCdkZWVwLWlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwucm9vdC5fcXVlcmllcyA9IG5ldyBRdWVyaWVzO1xuICBpZiAobW9kZWwucm9vdC5mZXRjaE9ubHkpIHJldHVybjtcbiAgbW9kZWwub24oJ2FsbCcsIGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gICAgLy8gVXBkYXRlZCBhc3luYywgc2luY2UgdGhpcyBpcyBsaWtlbHkgdGhlIHJlc3VsdCBvZiBhbiBvcGVyYXRpb24gdGhhdFxuICAgIC8vIGluY2x1ZGVzIGNyZWF0aW5nIHRoZSBkb2MsIGFuZCB3ZSB3b3VsZCBsaWtlIHRoYXQgdG8gaGFwcGVuIGJlZm9yZVxuICAgIC8vIHNlbmRpbmcgdGhlIHN1YnNjcmliZSBtZXNzYWdlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXAgPSBtb2RlbC5yb290Ll9xdWVyaWVzLm1hcDtcbiAgICAgIGZvciAodmFyIGhhc2ggaW4gbWFwKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IG1hcFtoYXNoXTtcbiAgICAgICAgaWYgKHF1ZXJ5LmlzUGF0aFF1ZXJ5ICYmIHF1ZXJ5LnNoYXJlUXVlcnkgJiYgdXRpbC5tYXlJbXBhY3QocXVlcnkuZXhwcmVzc2lvbiwgc2VnbWVudHMpKSB7XG4gICAgICAgICAgdmFyIGlkcyA9IHBhdGhJZHMobW9kZWwsIHF1ZXJ5LmV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBwcmV2aW91c0lkcyA9IG1vZGVsLl9nZXQocXVlcnkuaWRTZWdtZW50cyk7XG4gICAgICAgICAgcXVlcnkuX29uQ2hhbmdlKGlkcywgcHJldmlvdXNJZHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9XG4gKi9cbk1vZGVsLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uLnBhdGggPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGV4cHJlc3Npb24gIT09ICdvYmplY3QnKSB7XG4gICAgZXhwcmVzc2lvbiA9IHRoaXMuX3NwbGl0UGF0aChleHByZXNzaW9uKTtcbiAgfVxuICB2YXIgcXVlcnkgPSB0aGlzLnJvb3QuX3F1ZXJpZXMuZ2V0KGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpO1xuICBpZiAocXVlcnkpIHJldHVybiBxdWVyeTtcbiAgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHRoaXMucm9vdC5fcXVlcmllcy5hZGQocXVlcnkpO1xuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGJ1bmRsZSBvbiBwYWdlIGxvYWQuXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNbKl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtc1sqXVswXSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW1zWypdWzFdIGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtc1sqXVsyXSBzb3VyY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtc1sqXVszXSBzdWJzY3JpYmVDb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IGl0ZW1zWypdWzRdIGZldGNoQ291bnRcbiAqIEBwYXJhbSB7QXJyYXl9ICBpdGVtc1sqXVs1XSBmZXRjaElkc1xuICovXG5Nb2RlbC5wcm90b3R5cGUuX2luaXRRdWVyaWVzID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10sIGl0ZW1bNF0sIGl0ZW1bNV0pO1xuICAgIHZhciBjb3VudCA9IHF1ZXJ5LmZldGNoQ291bnQ7XG4gICAgd2hpbGUgKGNvdW50LS0pIHRoaXMuZW1pdCgnZmV0Y2hRdWVyeScsIHF1ZXJ5LCB0aGlzLl9jb250ZXh0KTtcbiAgICB2YXIgY291bnQgPSBxdWVyeS5zdWJzY3JpYmVDb3VudDtcbiAgICBxdWVyeS5zdWJzY3JpYmVDb3VudCA9IDA7XG4gICAgd2hpbGUgKGNvdW50LS0pIHF1ZXJ5LnN1YnNjcmliZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBRdWVyaWVzTWFwKCkge31cblxuZnVuY3Rpb24gUXVlcmllcygpIHtcbiAgdGhpcy5tYXAgPSBuZXcgUXVlcmllc01hcDtcbn1cblF1ZXJpZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHRoaXMubWFwW3F1ZXJ5Lmhhc2hdID0gcXVlcnk7XG59O1xuUXVlcmllcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgZGVsZXRlIHRoaXMubWFwW3F1ZXJ5Lmhhc2hdO1xufTtcblF1ZXJpZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgdmFyIGhhc2ggPSBxdWVyeUhhc2goY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHJldHVybiB0aGlzLm1hcFtoYXNoXTtcbn07XG5RdWVyaWVzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdO1xuICBmb3IgKHZhciBoYXNoIGluIHRoaXMubWFwKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5tYXBbaGFzaF07XG4gICAgaWYgKHF1ZXJ5LnN1YnNjcmliZUNvdW50IHx8IHF1ZXJ5LmZldGNoQ291bnQpIHtcbiAgICAgIG91dC5wdXNoKHF1ZXJ5LnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgKGUuZy4sICdzb2xyJylcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdWJzY3JpYmVDb3VudFxuICogQHBhcmFtIHtOdW1iZXJ9IGZldGNoQ291bnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8U3RyaW5nPj59IGZldGNoSWRzXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5KG1vZGVsLCBjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlLCBzdWJzY3JpYmVDb3VudCwgZmV0Y2hDb3VudCwgZmV0Y2hJZHMpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsLnBhc3MoeyRxdWVyeTogdGhpc30pO1xuICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLmhhc2ggPSBxdWVyeUhhc2goY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHRoaXMuc2VnbWVudHMgPSBbJyRxdWVyaWVzJywgdGhpcy5oYXNoXTtcbiAgdGhpcy5pZFNlZ21lbnRzID0gWyckcXVlcmllcycsIHRoaXMuaGFzaCwgJ2lkcyddO1xuICB0aGlzLmV4dHJhU2VnbWVudHMgPSBbJyRxdWVyaWVzJywgdGhpcy5oYXNoLCAnZXh0cmEnXTtcbiAgdGhpcy5pc1BhdGhRdWVyeSA9IEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbik7XG5cbiAgdGhpcy5fcGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrcyA9IFtdO1xuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGhlbHAgY2xlYW51cCBhcHByb3ByaWF0ZWx5IHdoZW4gY2FsbGluZyB1bnN1YnNjcmliZSBhbmRcbiAgLy8gdW5mZXRjaC4gQSBxdWVyeSB3b24ndCBiZSBmdWxseSBjbGVhbmVkIHVwIHVudGlsIHVuZmV0Y2ggYW5kIHVuc3Vic2NyaWJlXG4gIC8vIGFyZSBjYWxsZWQgdGhlIHNhbWUgbnVtYmVyIG9mIHRpbWVzIHRoYXQgZmV0Y2ggYW5kIHN1YnNjcmliZSB3ZXJlIGNhbGxlZC5cbiAgdGhpcy5zdWJzY3JpYmVDb3VudCA9IHN1YnNjcmliZUNvdW50IHx8IDA7XG4gIHRoaXMuZmV0Y2hDb3VudCA9IGZldGNoQ291bnQgfHwgMDtcbiAgLy8gVGhlIGxpc3Qgb2YgaWRzIGF0IHRoZSB0aW1lIG9mIGVhY2ggZmV0Y2ggaXMgcHVzaGVkIG9udG8gZmV0Y2hJZHMsIHNvXG4gIC8vIHRoYXQgdW5mZXRjaERvYyBjYW4gYmUgY2FsbGVkIHRoZSBzYW1lIG51bWJlciBvZiB0aW1lcyBhcyBmZXRjaERvY1xuICB0aGlzLmZldGNoSWRzID0gZmV0Y2hJZHMgfHwgW107XG5cbiAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gIHRoaXMuc2hhcmVRdWVyeSA9IG51bGw7XG59XG5cblF1ZXJ5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jcmVhdGVkID0gdHJ1ZTtcbiAgdGhpcy5tb2RlbC5yb290Ll9xdWVyaWVzLmFkZCh0aGlzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlZCA9IGZhbHNlO1xuICBpZiAodGhpcy5zaGFyZVF1ZXJ5KSB7XG4gICAgdGhpcy5zaGFyZVF1ZXJ5LmRlc3Ryb3koKTtcbiAgICB0aGlzLnNoYXJlUXVlcnkgPSBudWxsO1xuICB9XG4gIHRoaXMubW9kZWwucm9vdC5fcXVlcmllcy5yZW1vdmUodGhpcyk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLnNlZ21lbnRzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5zb3VyY2VRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc1BhdGhRdWVyeSkge1xuICAgIHZhciBpZHMgPSBwYXRoSWRzKHRoaXMubW9kZWwsIHRoaXMuZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIHtfaWQ6IHskaW46IGlkc319O1xuICB9XG4gIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gY2IoZXJyKVxuICovXG5RdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMubW9kZWwucm9vdC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ2ZldGNoUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICB0aGlzLmZldGNoQ291bnQrKztcblxuICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGUoKTtcbiAgdmFyIHF1ZXJ5ID0gdGhpcztcblxuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB2YXIgc2hhcmVEb2NzID0gY29sbGVjdGlvblNoYXJlRG9jcyh0aGlzLm1vZGVsLCB0aGlzLmNvbGxlY3Rpb25OYW1lKTtcbiAgdmFyIG9wdGlvbnMgPSB7ZG9jTW9kZTogJ2ZldGNoJywga25vd25Eb2NzOiBzaGFyZURvY3N9O1xuICBpZiAodGhpcy5zb3VyY2UpIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uY3JlYXRlRmV0Y2hRdWVyeShcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLnNvdXJjZVF1ZXJ5KCksIG9wdGlvbnMsIGZldGNoUXVlcnlDYWxsYmFja1xuICApO1xuICBmdW5jdGlvbiBmZXRjaFF1ZXJ5Q2FsbGJhY2soZXJyLCByZXN1bHRzLCBleHRyYSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIHZhciBpZHMgPSByZXN1bHRzSWRzKHJlc3VsdHMpO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgaWRzIGF0IGZldGNoIHRpbWUgZm9yIHVzZSBpbiB1bmZldGNoXG4gICAgcXVlcnkuZmV0Y2hJZHMucHVzaChpZHMuc2xpY2UoKSk7XG4gICAgLy8gVXBkYXRlIHRoZSByZXN1bHRzIGlkcyBhbmQgZXh0cmFcbiAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5pZFNlZ21lbnRzLCBpZHMpO1xuICAgIGlmIChleHRyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgfVxuXG4gICAgaWYgKCFpZHMubGVuZ3RoKSByZXR1cm4gY2IoKTtcblxuICAgIC8vIENhbGwgZmV0Y2hEb2MgZm9yIGVhY2ggZG9jdW1lbnQgcmV0dXJuZWQgc28gdGhhdCB0aGUgcHJvcGVyIGxvYWQgZXZlbnRzXG4gICAgLy8gYW5kIGludGVybmFsIGNvdW50cyBhcmUgbWFpbnRhaW5lZC4gSG93ZXZlciwgc3BlY2lmeSB0aGF0IHdlIGFscmVhZHlcbiAgICAvLyBsb2FkZWQgdGhlIGRvY3VtZW50cyBhcyBwYXJ0IG9mIHRoZSBxdWVyeSwgc2luY2Ugd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIGFjdHVhbGx5IGZldGNoIHRoZSBkb2N1bWVudHMgYWdhaW5cbiAgICB2YXIgYWxyZWFkeUxvYWRlZCA9IHRydWU7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbW9kZWwuZmV0Y2hEb2MocXVlcnkuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSwgZ3JvdXAoKSwgYWxyZWFkeUxvYWRlZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIGEgc3Vic2NyaXB0aW9uIHRvIGB0aGlzYCBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqL1xuUXVlcnkucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5tb2RlbC5yb290Ll9kZWZhdWx0Q2FsbGJhY2s7XG4gIHRoaXMubW9kZWwuZW1pdCgnc3Vic2NyaWJlUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICB2YXIgcXVlcnkgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnN1YnNjcmliZUNvdW50KyspIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkubW9kZWwuX2dldChxdWVyeS5zZWdtZW50cyk7XG4gICAgICBpZiAoZGF0YSkgY2IoKTtcbiAgICAgIGVsc2UgcXVlcnkuX3BlbmRpbmdTdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGUoKTtcblxuICAvLyBXaGVuIGRvaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZywgd2UgYWN0dWFsbHkgZG8gYSBmZXRjaCB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGF0IHN1YnNjcmliZSBpcyBjYWxsZWQsIGJ1dCBrZWVwIHRyYWNrIG9mIHRoZSBzdGF0ZSBhcyBpZiBzdWJzY3JpYmVcbiAgLy8gd2VyZSBjYWxsZWQgZm9yIHByb3BlciBpbml0aWFsaXphdGlvbiBpbiB0aGUgY2xpZW50XG4gIHZhciBzaGFyZURvY3MgPSBjb2xsZWN0aW9uU2hhcmVEb2NzKHRoaXMubW9kZWwsIHRoaXMuY29sbGVjdGlvbk5hbWUpO1xuICB2YXIgb3B0aW9ucyA9IHtkb2NNb2RlOiAnc3ViJywga25vd25Eb2NzOiBzaGFyZURvY3N9O1xuICBpZiAodGhpcy5zb3VyY2UpIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgaWYgKCF0aGlzLm1vZGVsLnJvb3QuZmV0Y2hPbmx5KSB7XG4gICAgdGhpcy5fc2hhcmVTdWJzY3JpYmUob3B0aW9ucywgY2IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgb3B0aW9ucy5kb2NNb2RlID0gJ2ZldGNoJztcbiAgbW9kZWwucm9vdC5zaGFyZUNvbm5lY3Rpb24uY3JlYXRlRmV0Y2hRdWVyeShcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lLCB0aGlzLnNvdXJjZVF1ZXJ5KCksIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cywgZXh0cmEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG4gICAgICBpZiAoZXh0cmEgIT09IHZvaWQgMCkge1xuICAgICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgICB9XG4gICAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBudWxsLCBjYik7XG4gICAgICB3aGlsZSAoY2IgPSBxdWVyeS5fcGVuZGluZ1N1YnNjcmliZUNhbGxiYWNrcy5zaGlmdCgpKSB7XG4gICAgICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIG51bGwsIGNiKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvbGxdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvY01vZGUgPSBmZXRjaCBvciBzdWJzY3JpYmVdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIsIHJlc3VsdHMpXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fc2hhcmVTdWJzY3JpYmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICB2YXIgcXVlcnkgPSB0aGlzO1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICB0aGlzLnNoYXJlUXVlcnkgPSB0aGlzLm1vZGVsLnJvb3Quc2hhcmVDb25uZWN0aW9uLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cywgZXh0cmEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgaWYgKGV4dHJhICE9PSB2b2lkIDApIHtcbiAgICAgICAgbW9kZWwuX3NldERpZmYocXVlcnkuZXh0cmFTZWdtZW50cywgZXh0cmEsIHtlcXVhbDogZGVlcEVxdWFsc30pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdWx0cyBhcmUgbm90IHNldCBpbiB0aGUgY2FsbGJhY2ssIGJlY2F1c2UgdGhlIHNoYXJlUXVlcnkgc2hvdWxkXG4gICAgICAvLyBlbWl0IGEgJ2NoYW5nZScgZXZlbnQgYmVmb3JlIGNhbGxpbmcgYmFja1xuICAgICAgY2IoKTtcbiAgICB9XG4gICk7XG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignaW5zZXJ0JywgZnVuY3Rpb24oc2hhcmVEb2NzLCBpbmRleCkge1xuICAgIHF1ZXJ5Ll9vbkluc2VydChzaGFyZURvY3MsIGluZGV4KTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbigncmVtb3ZlJywgZnVuY3Rpb24oc2hhcmVEb2NzLCBpbmRleCkge1xuICAgIHF1ZXJ5Ll9vblJlbW92ZShzaGFyZURvY3MsIGluZGV4KTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignbW92ZScsIGZ1bmN0aW9uKHNoYXJlRG9jcywgZnJvbSwgdG8pIHtcbiAgICBxdWVyeS5fb25Nb3ZlKHNoYXJlRG9jcywgZnJvbSwgdG8pO1xuICB9KTtcbiAgdGhpcy5zaGFyZVF1ZXJ5Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihyZXN1bHRzLCBwcmV2aW91cykge1xuICAgIC8vIEdldCB0aGUgbmV3IGFuZCBwcmV2aW91cyBsaXN0IG9mIGlkcyB3aGVuIHRoZSBlbnRpcmUgcmVzdWx0cyBzZXQgY2hhbmdlc1xuICAgIHZhciBpZHMgPSByZXN1bHRzSWRzKHJlc3VsdHMpO1xuICAgIHZhciBwcmV2aW91c0lkcyA9IHByZXZpb3VzICYmIHJlc3VsdHNJZHMocHJldmlvdXMpO1xuICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIHByZXZpb3VzSWRzKTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignZXh0cmEnLCBmdW5jdGlvbiAoZXh0cmEpIHtcbiAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIsIG5ld0ZldGNoQ291bnQpXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS51bmZldGNoID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCd1bmZldGNoUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIHF1ZXJ5IGlzIG5vdCBjdXJyZW50bHkgZmV0Y2hlZFxuICBpZiAoIXRoaXMuZmV0Y2hDb3VudCkge1xuICAgIGNiKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgaWRzID0gdGhpcy5mZXRjaElkcy5zaGlmdCgpIHx8IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubW9kZWwudW5mZXRjaERvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZHNbaV0pO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcztcbiAgaWYgKHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5mZXRjaFF1ZXJ5LCB0aGlzLm1vZGVsLnJvb3QudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuZmV0Y2hRdWVyeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFVuZmV0Y2hRdWVyeSgpIHtcbiAgICB2YXIgY291bnQgPSAtLXF1ZXJ5LmZldGNoQ291bnQ7XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuICAgIC8vIENsZWFudXAgd2hlbiBubyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgcmVtYWluXG4gICAgaWYgKCFxdWVyeS5zdWJzY3JpYmVDb3VudCkgcXVlcnkuZGVzdHJveSgpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUXVlcnkucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLnJvb3QuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCd1bnN1YnNjcmliZVF1ZXJ5JywgdGhpcywgdGhpcy5tb2RlbC5fY29udGV4dCk7XG5cbiAgLy8gTm8gZWZmZWN0IGlmIHRoZSBxdWVyeSBpcyBub3QgY3VycmVudGx5IHN1YnNjcmliZWRcbiAgaWYgKCF0aGlzLnN1YnNjcmliZUNvdW50KSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIGlmICh0aGlzLm1vZGVsLnJvb3QudW5sb2FkRGVsYXkpIHtcbiAgICBzZXRUaW1lb3V0KGZpbmlzaFVuc3Vic2NyaWJlUXVlcnksIHRoaXMubW9kZWwucm9vdC51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVRdWVyeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFVuc3Vic2NyaWJlUXVlcnkoKSB7XG4gICAgdmFyIGNvdW50ID0gLS1xdWVyeS5zdWJzY3JpYmVDb3VudDtcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICBpZiAocXVlcnkuc2hhcmVRdWVyeSkge1xuICAgICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocXVlcnkuc2hhcmVRdWVyeS5yZXN1bHRzKTtcbiAgICAgIHF1ZXJ5LnNoYXJlUXVlcnkuZGVzdHJveSgpO1xuICAgICAgcXVlcnkuc2hhcmVRdWVyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFxdWVyeS5tb2RlbC5yb290LmZldGNoT25seSAmJiBpZHMgJiYgaWRzLmxlbmd0aCkge1xuICAgICAgLy8gVW5zdWJzY3JpYmUgYWxsIGRvY3VtZW50cyB0aGF0IHRoaXMgcXVlcnkgY3VycmVudGx5IGhhcyBpbiByZXN1bHRzXG4gICAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAodW5zdWJzY3JpYmVRdWVyeUNhbGxiYWNrKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXJ5Lm1vZGVsLnVuc3Vic2NyaWJlRG9jKHF1ZXJ5LmNvbGxlY3Rpb25OYW1lLCBpZHNbaV0sIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2soKTtcbiAgfVxuICBmdW5jdGlvbiB1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgLy8gQ2xlYW51cCB3aGVuIG5vIGZldGNoZXMgb3Igc3Vic2NyaWJlcyByZW1haW5cbiAgICBpZiAoIXF1ZXJ5LmZldGNoQ291bnQpIHF1ZXJ5LmRlc3Ryb3koKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fb25JbnNlcnQgPSBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFyZURvY3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaWQgPSBzaGFyZURvY3NbaV0ubmFtZTtcbiAgICBpZHMucHVzaChpZCk7XG4gICAgdGhpcy5tb2RlbC5zdWJzY3JpYmVEb2ModGhpcy5jb2xsZWN0aW9uTmFtZSwgaWQpO1xuICB9XG4gIHRoaXMubW9kZWwuX2luc2VydCh0aGlzLmlkU2VnbWVudHMsIGluZGV4LCBpZHMpO1xufTtcblF1ZXJ5LnByb3RvdHlwZS5fb25SZW1vdmUgPSBmdW5jdGlvbihzaGFyZURvY3MsIGluZGV4KSB7XG4gIHRoaXMubW9kZWwuX3JlbW92ZSh0aGlzLmlkU2VnbWVudHMsIGluZGV4LCBzaGFyZURvY3MubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFyZURvY3MubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLm1vZGVsLnVuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHNoYXJlRG9jc1tpXS5uYW1lKTtcbiAgfVxufTtcblF1ZXJ5LnByb3RvdHlwZS5fb25Nb3ZlID0gZnVuY3Rpb24oc2hhcmVEb2NzLCBmcm9tLCB0bykge1xuICB0aGlzLm1vZGVsLl9tb3ZlKHRoaXMuaWRTZWdtZW50cywgZnJvbSwgdG8sIHNoYXJlRG9jcy5sZW5ndGgpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9vbkNoYW5nZSA9IGZ1bmN0aW9uKGlkcywgcHJldmlvdXNJZHMsIGNiKSB7XG4gIC8vIERpZmYgdGhlIG5ldyBhbmQgcHJldmlvdXMgbGlzdCBvZiBpZHMsIHN1YnNjcmliaW5nIHRvIGRvY3VtZW50cyBmb3JcbiAgLy8gaW5zZXJ0ZWQgaWRzIGFuZCB1bnN1YnNjcmliaW5nIGZyb20gZG9jdW1lbnRzIGZvciByZW1vdmVkIGlkc1xuICB2YXIgZGlmZiA9IChwcmV2aW91c0lkcykgP1xuICAgIGFycmF5RGlmZihwcmV2aW91c0lkcywgaWRzKSA6XG4gICAgW25ldyBhcnJheURpZmYuSW5zZXJ0RGlmZigwLCBpZHMpXTtcbiAgdmFyIHByZXZpb3VzQ29weSA9IHByZXZpb3VzSWRzICYmIHByZXZpb3VzSWRzLnNsaWNlKCk7XG5cbiAgLy8gVGhlIHJlc3VsdHMgYXJlIHVwZGF0ZWQgdmlhIGEgZGlmZmVyZW50IGRpZmYsIHNpbmNlIHRoZXkgbWlnaHQgYWxyZWFkeVxuICAvLyBoYXZlIGEgdmFsdWUgZnJvbSBhIGZldGNoIG9yIHByZXZpb3VzIHNoYXJlUXVlcnkgaW5zdGFuY2VcbiAgdGhpcy5tb2RlbC5fc2V0RGlmZih0aGlzLmlkU2VnbWVudHMsIGlkcyk7XG5cbiAgaWYgKGNiKSB7XG4gICAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiKTtcbiAgICB2YXIgZmluaXNoZWQgPSBncm91cCgpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gZGlmZltpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmKSB7XG4gICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGRvY3VtZW50IGZvciBlYWNoIGluc2VydGVkIGlkXG4gICAgICB2YXIgdmFsdWVzID0gaXRlbS52YWx1ZXM7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzLm1vZGVsLnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCB2YWx1ZXNbal0sIGNiICYmIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIGFycmF5RGlmZi5SZW1vdmVEaWZmKSB7XG4gICAgICB2YXIgdmFsdWVzID0gcHJldmlvdXNDb3B5LnNwbGljZShpdGVtLmluZGV4LCBpdGVtLmhvd01hbnkpO1xuICAgICAgLy8gVW5zdWJzY3JpYmUgZnJvbSB0aGUgZG9jdW1lbnQgZm9yIGVhY2ggcmVtb3ZlZCBpZFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGhpcy5tb2RlbC51bnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCB2YWx1ZXNbal0sIGNiICYmIGdyb3VwKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZpbmcgZG9lc24ndCBjaGFuZ2UgZG9jdW1lbnQgc3Vic2NyaXB0aW9ucywgc28gdGhhdCBpcyBpZ25vcmVkLlxuICB9XG4gIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBjYWxsYmFjayBnZXRzIGNhbGxlZCBpZiB0aGUgZGlmZiBpcyBlbXB0eSBvciBpdFxuICAvLyBjb250YWlucyBubyBpbnNlcnRzIG9yIHJlbW92ZXNcbiAgZmluaXNoZWQgJiYgZmluaXNoZWQoKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGRhdGEgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5zZWdtZW50cyk7XG4gIGlmICghZGF0YSkge1xuICAgIGNvbnNvbGUud2FybignWW91IG11c3QgZmV0Y2ggb3Igc3Vic2NyaWJlIHRvIGEgcXVlcnkgYmVmb3JlIGdldHRpbmcgaXRzIHJlc3VsdHMuJyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgdmFyIGlkcyA9IGRhdGEuaWRzO1xuICBpZiAoIWlkcykgcmV0dXJuIHJlc3VsdHM7XG5cbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLm1vZGVsLmdldENvbGxlY3Rpb24odGhpcy5jb2xsZWN0aW9uTmFtZSk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaWRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICB2YXIgZG9jID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmRvY3NbaWRdO1xuICAgIHJlc3VsdHMucHVzaChkb2MgJiYgZG9jLmdldCgpKTtcbiAgfVxuICByZXR1cm4gKGRhdGEuZXh0cmEgPT09IHZvaWQgMCkgP1xuICAgIHJlc3VsdHMgOlxuICAgIHtyZXN1bHRzOiByZXN1bHRzLCBleHRyYTogZGF0YS5leHRyYX07XG59O1xuXG4vKipcbiAqIExhemlseSBjcmVhdGVzIG9yIGdldHMgYSByZWYgdG8gb3VyIHJlc3VsdHNldCdzIHJlc3VsdHMuXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbihmcm9tKSB7XG4gIHZhciBpZHNQYXRoID0gdGhpcy5pZFNlZ21lbnRzLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMubW9kZWwucmVmTGlzdChmcm9tLCB0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZHNQYXRoKTtcbn07XG5cbi8qKlxuICogTGF6aWx5IGNyZWF0ZXMgb3IgZ2V0cyBhIHJlZiB0byBvdXIgcmVzdWx0c2V0J3MgZXh0cmEgZGF0YS5cbiAqL1xuUXVlcnkucHJvdG90eXBlLmV4dHJhUmVmID0gZnVuY3Rpb24oZnJvbSwgcmVsUGF0aCkge1xuICB2YXIgZXh0cmFQYXRoID0gdGhpcy5leHRyYVNlZ21lbnRzLmpvaW4oJy4nKSArIChyZWxQYXRoID8gJy4nICsgcmVsUGF0aCA6ICcnKTtcbiAgcmV0dXJuIHRoaXMubW9kZWwucmVmKGZyb20sIGV4dHJhUGF0aCk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAgdGhpcy5jb2xsZWN0aW9uTmFtZVxuICAsIHRoaXMuZXhwcmVzc2lvblxuICAsIHRoaXMuc291cmNlXG4gICwgdGhpcy5zdWJzY3JpYmVDb3VudFxuICAsIHRoaXMuZmV0Y2hDb3VudFxuICAsIHRoaXMuZmV0Y2hJZHNcbiAgXTtcbn07XG5cbmZ1bmN0aW9uIHF1ZXJ5SGFzaChjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKSB7XG4gIHZhciBhcmdzID0gW2NvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2VdO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJncykucmVwbGFjZSgvXFwuL2csICd8Jyk7XG59XG5cbmZ1bmN0aW9uIHJlc3VsdHNJZHMocmVzdWx0cykge1xuICB2YXIgaWRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGFyZURvYyA9IHJlc3VsdHNbaV07XG4gICAgaWRzLnB1c2goc2hhcmVEb2MubmFtZSk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn1cblxuZnVuY3Rpb24gcGF0aElkcyhtb2RlbCwgc2VnbWVudHMpIHtcbiAgdmFyIHZhbHVlID0gbW9kZWwuX2dldChzZWdtZW50cyk7XG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBbdmFsdWVdIDpcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWUuc2xpY2UoKSA6IFtdO1xufVxuXG5mdW5jdGlvbiBjb2xsZWN0aW9uU2hhcmVEb2NzKG1vZGVsLCBjb2xsZWN0aW9uTmFtZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IG1vZGVsLmdldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybjtcblxuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIGNvbGxlY3Rpb24uZG9jcykge1xuICAgIHJlc3VsdHMucHVzaChjb2xsZWN0aW9uLmRvY3NbbmFtZV0uc2hhcmVEb2MpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG52YXIgcmVzb2x2ZVVybCA9IHJlcXVpcmUoJ3VybCcpLnJlc29sdmVcbnZhciByZW5kZXJSb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGVyJykucmVuZGVyXG52YXIgY3VycmVudFBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG5cbi8vIFJlcGxhY2UgdGhlIGluaXRpYWwgc3RhdGUgd2l0aCB0aGUgY3VycmVudCBVUkwgaW1tZWRpYXRlbHksXG4vLyBzbyB0aGF0IGl0IHdpbGwgYmUgcmVuZGVyZWQgaWYgdGhlIHN0YXRlIGlzIGxhdGVyIHBvcHBlZFxuaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICRyZW5kZXI6IHRydWUsXG4gICAgJG1ldGhvZDogJ2dldCdcbiAgfSwgbnVsbCwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGlzdG9yeVxuXG5mdW5jdGlvbiBIaXN0b3J5KGNyZWF0ZVBhZ2UsIHJvdXRlcykge1xuICB0aGlzLl9jcmVhdGVQYWdlID0gY3JlYXRlUGFnZVxuICB0aGlzLl9yb3V0ZXMgPSByb3V0ZXNcblxuICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgYWRkTGlzdGVuZXJzKHRoaXMpXG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5wdXNoID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpXG4gIH1cbiAgdGhpcy5yZXBsYWNlID0gZnVuY3Rpb24odXJsKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsKVxuICB9XG4gIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdwdXNoU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih1cmwsIHJlbmRlciwgc3RhdGUsIGUpIHtcbiAgdGhpcy5fdXBkYXRlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIHJlbmRlciwgc3RhdGUsIGUpXG59XG5cbi8vIFJlcmVuZGVyIHRoZSBjdXJyZW50IHVybCBsb2NhbGx5XG5IaXN0b3J5LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRoID0gcm91dGVQYXRoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICByZW5kZXJSb3V0ZSh0aGlzLnBhZ2UoKSwge3VybDogcGF0aCwgcHJldmlvdXM6IHBhdGgsIG1ldGhvZDogJ2dldCd9KVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmJhY2soKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKVxufVxuXG5IaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKGkpIHtcbiAgd2luZG93Lmhpc3RvcnkuZ28oaSlcbn1cblxuSGlzdG9yeS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKGhpc3RvcnlNZXRob2QsIHJlbGF0aXZlVXJsLCByZW5kZXIsIHN0YXRlLCBlKSB7XG4gIHZhciB1cmwgPSByZXNvbHZlVXJsKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCByZWxhdGl2ZVVybClcbiAgdmFyIHBhdGggPSByb3V0ZVBhdGgodXJsKVxuXG4gIC8vIFRPRE86IGhpc3RvcnkucHVzaCBzaG91bGQgc2V0IHRoZSB3aW5kb3cubG9jYXRpb24gd2l0aCBleHRlcm5hbCB1cmxzXG4gIGlmICghcGF0aCkgcmV0dXJuXG4gIGlmIChyZW5kZXIgPT0gbnVsbCkgcmVuZGVyID0gdHJ1ZVxuICBpZiAoc3RhdGUgPT0gbnVsbCkgc3RhdGUgPSB7fVxuXG4gIC8vIFVwZGF0ZSB0aGUgVVJMXG4gIHZhciBvcHRpb25zID0gcmVuZGVyT3B0aW9ucyhlLCBwYXRoKVxuICBzdGF0ZS4kcmVuZGVyID0gdHJ1ZVxuICBzdGF0ZS4kbWV0aG9kID0gb3B0aW9ucy5tZXRob2RcbiAgd2luZG93Lmhpc3RvcnlbaGlzdG9yeU1ldGhvZF0oc3RhdGUsIG51bGwsIG9wdGlvbnMudXJsKVxuICBjdXJyZW50UGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgaWYgKHJlbmRlcikgcmVuZGVyUm91dGUodGhpcy5wYWdlKCksIG9wdGlvbnMsIGUpXG59XG5cbkhpc3RvcnkucHJvdG90eXBlLnBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3BhZ2UpIHJldHVybiB0aGlzLl9wYWdlXG5cbiAgdmFyIHBhZ2UgPSB0aGlzLl9wYWdlID0gdGhpcy5fY3JlYXRlUGFnZSgpXG4gIHZhciBoaXN0b3J5ID0gdGhpc1xuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0KHVybCkge1xuICAgIGlmICh1cmwgPT09ICdiYWNrJykgcmV0dXJuIGhpc3RvcnkuYmFjaygpXG4gICAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIGBiYXNlcGF0aGAgb3B0aW9uIGxpa2UgRXhwcmVzc1xuICAgIGlmICh1cmwgPT09ICdob21lJykgdXJsID0gJ1xcXFwnXG4gICAgaGlzdG9yeS5yZXBsYWNlKHVybCwgdHJ1ZSlcbiAgfVxuXG4gIHBhZ2UucmVkaXJlY3QgPSByZWRpcmVjdFxuICBwYWdlLl9yb3V0ZXMgPSB0aGlzLl9yb3V0ZXNcbiAgcmV0dXJuIHBhZ2Vcbn1cblxuLy8gR2V0IHRoZSBwYXRobmFtZSBpZiBpdCBpcyBvbiB0aGUgc2FtZSBwcm90b2NvbCBhbmQgZG9tYWluXG5mdW5jdGlvbiByb3V0ZVBhdGgodXJsKSB7XG4gIHZhciBtYXRjaCA9IHBhcnNlVXJsKHVybClcbiAgcmV0dXJuIG1hdGNoICYmXG4gICAgbWF0Y2gucHJvdG9jb2wgPT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAmJlxuICAgIG1hdGNoLmhvc3QgPT09IHdpbmRvdy5sb2NhdGlvbi5ob3N0ICYmXG4gICAgbWF0Y2gucGF0aG5hbWUgKyAobWF0Y2guc2VhcmNoIHx8ICcnKVxufVxuXG5mdW5jdGlvbiByZW5kZXJPcHRpb25zKGUsIHBhdGgpIHtcbiAgLy8gSWYgdGhpcyBpcyBhIGZvcm0gc3VibWlzc2lvbiwgZXh0cmFjdCB0aGUgZm9ybSBkYXRhIGFuZFxuICAvLyBhcHBlbmQgaXQgdG8gdGhlIHVybCBmb3IgYSBnZXQgb3IgcGFyYW1zLmJvZHkgZm9yIGEgcG9zdFxuICBpZiAoZSAmJiBlLnR5cGUgPT09ICdzdWJtaXQnKSB7XG4gICAgdmFyIGZvcm0gPSBlLnRhcmdldFxuICAgIHZhciBlbGVtZW50cyA9IGZvcm0uZWxlbWVudHNcbiAgICB2YXIgcXVlcnkgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGgsIGVsOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGVsID0gZWxlbWVudHNbaV1cbiAgICAgIHZhciBuYW1lID0gZWwubmFtZVxuICAgICAgaWYgKCFuYW1lKSBjb250aW51ZVxuICAgICAgdmFyIHZhbHVlID0gZWwudmFsdWVcbiAgICAgIHF1ZXJ5LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIGlmIChuYW1lID09PSAnX21ldGhvZCcpIHtcbiAgICAgICAgdmFyIG92ZXJyaWRlID0gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICBpZiAob3ZlcnJpZGUgPT09ICdkZWxldGUnKSBvdmVycmlkZSA9ICdkZWwnXG4gICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5ID0gcXVlcnkuam9pbignJicpXG4gICAgaWYgKGZvcm0ubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdwb3N0Jykge1xuICAgICAgdmFyIG1ldGhvZCA9IG92ZXJyaWRlIHx8ICdwb3N0J1xuICAgICAgdmFyIGJvZHkgPSBxcy5wYXJzZShxdWVyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWV0aG9kID0gJ2dldCdcbiAgICAgIHBhdGggKz0gJz8nICsgcXVlcnlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gJ2dldCdcbiAgfVxuICByZXR1cm4ge1xuICAgIG1ldGhvZDogbWV0aG9kXG4gICwgdXJsOiBwYXRoXG4gICwgcHJldmlvdXM6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgLCBib2R5OiBib2R5XG4gICwgZm9ybTogZm9ybVxuICAsIGxpbms6IGUgJiYgZS5fdHJhY2tzTGlua1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhoaXN0b3J5KSB7XG5cbiAgLy8gRGV0ZWN0IGNsaWNrcyBvbiBsaW5rc1xuICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldFxuXG4gICAgLy8gSWdub3JlIGNvbW1hbmQgY2xpY2ssIGNvbnRyb2wgY2xpY2ssIGFuZCBub24tbGVmdCBjbGlja1xuICAgIGlmIChlLm1ldGFLZXkgfHwgZS53aGljaCAhPT0gMSkgcmV0dXJuXG5cbiAgICAvLyBJZ25vcmUgaWYgYWxyZWFkeSBwcmV2ZW50ZWRcbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkIHx8IGUucmV0dXJuVmFsdWUgPT09IGZhbHNlKSByZXR1cm5cblxuICAgIC8vIEFsc28gbG9vayB1cCBmb3IgcGFyZW50IGxpbmtzICg8YT48aW1nPjwvYT4pXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICB2YXIgdXJsID0gZWwuaHJlZlxuICAgICAgaWYgKHVybCkge1xuXG4gICAgICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlICYmIGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJykpIHJldHVyblxuXG4gICAgICAgIC8vIElnbm9yZSBsaW5rcyBtZWFudCB0byBvcGVuIGluIGEgZGlmZmVyZW50IHdpbmRvdyBvciBmcmFtZVxuICAgICAgICBpZiAoZWwudGFyZ2V0ICYmIGVsLnRhcmdldCAhPT0gJ19zZWxmJykgcmV0dXJuXG5cbiAgICAgICAgLy8gSWdub3JlIGhhc2ggbGlua3MgdG8gdGhlIHNhbWUgcGFnZVxuICAgICAgICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKVxuICAgICAgICBpZiAofmhhc2hJbmRleCAmJiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KSA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgvIy4qLywgJycpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBlLl90cmFja3NMaW5rID0gZWxcbiAgICAgICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3VibWl0KGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXRcblxuICAgIC8vIElnbm9yZSBpZiBhbHJlYWR5IHByZXZlbnRlZFxuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHJldHVyblxuXG4gICAgLy8gT25seSBoYW5kbGUgaWYgZW1pdHRlZCBvbiBhIGZvcm0gZWxlbWVudCB0aGF0IGlzbid0IG11bHRpcGFydFxuICAgIGlmICh0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZm9ybScpIHJldHVyblxuICAgIGlmICh0YXJnZXQuZW5jdHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSByZXR1cm5cblxuICAgIC8vIElnbm9yZSBpZiBjcmVhdGVkIGJ5IFRyYWNrc1xuICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcm91dGVyLWlnbm9yZScpKSByZXR1cm5cblxuICAgIC8vIFVzZSB0aGUgdXJsIGZyb20gdGhlIGZvcm0gYWN0aW9uLCBkZWZhdWx0aW5nIHRvIHRoZSBjdXJyZW50IHVybFxuICAgIHZhciB1cmwgPSB0YXJnZXQuYWN0aW9uIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgaGlzdG9yeS5wdXNoKHVybCwgdHJ1ZSwgbnVsbCwgZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9wU3RhdGUoZSkge1xuICAgIHZhciBwcmV2aW91cyA9IGN1cnJlbnRQYXRoXG4gICAgdmFyIHN0YXRlID0gZS5zdGF0ZVxuICAgIGN1cnJlbnRQYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaFxuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICAsIHVybDogY3VycmVudFBhdGhcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuJHJlbmRlcikgcmV0dXJuXG4gICAgICBvcHRpb25zLm1ldGhvZCA9IHN0YXRlLiRtZXRob2RcbiAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcG9zdCBib2R5IGlzIG9ubHkgc2VudCBvbiB0aGUgaW5pdGlhbCByZXFlc3RcbiAgICAgIC8vIGFuZCBpdCBpcyBlbXB0eSBpZiB0aGUgc3RhdGUgaXMgbGF0ZXIgcG9wcGVkXG4gICAgICByZXR1cm4gcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgLy8gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGJlIG51bGwgZm9yIHN0YXRlcyBjcmVhdGVkIGJ5IGp1bXAgbGlua3MuXG4gICAgLy8gd2luZG93LmxvY2F0aW9uLmhhc2ggY2Fubm90IGJlIHVzZWQsIGJlY2F1c2UgaXQgcmV0dXJucyBub3RoaW5nXG4gICAgLy8gaWYgdGhlIHVybCBlbmRzIGluIGp1c3QgYSBoYXNoIGNoYXJhY3RlclxuICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgLCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpXG4gICAgICAsIGVsLCBpZFxuICAgIGlmICh+aGFzaEluZGV4ICYmIGN1cnJlbnRQYXRoICE9PSBwcmV2aW91cykge1xuICAgICAgb3B0aW9ucy5tZXRob2QgPSAnZ2V0J1xuICAgICAgcmVuZGVyUm91dGUoaGlzdG9yeS5wYWdlKCksIG9wdGlvbnMpXG4gICAgICBpZCA9IHVybC5zbGljZShoYXNoSW5kZXggKyAxKVxuICAgICAgaWYgKGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGlkKVswXSkge1xuICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCBmYWxzZSlcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgb25TdWJtaXQsIGZhbHNlKVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlLCBmYWxzZSlcbn1cbiIsInZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBub2RlVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXI6IHJlbmRlclxuLCBpc1RyYW5zaXRpb25hbDogaXNUcmFuc2l0aW9uYWxcbiwgbWFwUm91dGU6IG1hcFJvdXRlXG59XG5cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbmFsKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4uaGFzT3duUHJvcGVydHkoJ2Zyb20nKSAmJiBwYXR0ZXJuLmhhc093blByb3BlcnR5KCd0bycpXG59XG5cbmZ1bmN0aW9uIG1hcFJvdXRlKGZyb20sIHBhcmFtcykge1xuICB2YXIgaSA9IHBhcmFtcy51cmwuaW5kZXhPZignPycpXG4gIHZhciBxdWVyeVN0cmluZyA9ICh+aSkgPyBwYXJhbXMudXJsLnNsaWNlKGkpIDogJydcbiAgLy8gSWYgdGhlIHJvdXRlIGxvb2tzIGxpa2UgLzphLzpiPy86Yy86ZD9cbiAgLy8gYW5kIDpiIGFuZCA6ZCBhcmUgbWlzc2luZywgcmV0dXJuIC9hL2NcbiAgLy8gVGh1cywgc2tpcCB0aGUgLyBpZiB0aGUgdmFsdWUgaXMgbWlzc2luZ1xuICB2YXIgaSA9IDBcbiAgdmFyIHBhdGggPSBmcm9tLnJlcGxhY2UoL1xcLyg/Oig/OlxcOihbXj9cXC86Kl0rKSl8XFwqKShcXD8pPy9nLCBvbk1hdGNoKVxuICBmdW5jdGlvbiBvbk1hdGNoKG1hdGNoLCBrZXksIG9wdGlvbmFsKSB7XG4gICAgdmFyIHZhbHVlID0ga2V5ID8gcGFyYW1zW2tleV0gOiBwYXJhbXNbaSsrXVxuICAgIHJldHVybiAob3B0aW9uYWwgJiYgdmFsdWUgPT09IHZvaWQgMCkgPyAnJyA6ICcvJyArIHZhbHVlXG4gIH1cbiAgcmV0dXJuIHBhdGggKyBxdWVyeVN0cmluZ1xufVxuXG5mdW5jdGlvbiByZW5kZXIocGFnZSwgb3B0aW9ucywgZSkge1xuICB2YXIgcmVxID0gbmV3IFJlbmRlclJlcShwYWdlLCBvcHRpb25zLCBlKVxuICByZXEucm91dGVUcmFuc2l0aW9uYWwoMCwgZnVuY3Rpb24oKSB7XG4gICAgcmVxLnJvdXRlUXVldWUoMCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXEucm91dGVBbmRUcmFuc2l0aW9uKDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDYW5jZWwgcmVuZGVyaW5nIGJ5IHRoaXMgYXBwIGlmIG5vIHJvdXRlcyBtYXRjaFxuICAgICAgICByZXEuY2FuY2VsKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gUmVuZGVyUmVxKHBhZ2UsIG9wdGlvbnMsIGUpIHtcbiAgdGhpcy5wYWdlID0gcGFnZVxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuZSA9IGVcbiAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwucmVwbGFjZSgvIy4qLywgJycpKVxuICB2YXIgcXVlcnlTdHJpbmcgPSBub2RlVXJsLnBhcnNlKHRoaXMudXJsKS5xdWVyeTtcbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5U3RyaW5nID8gcXMucGFyc2UocXVlcnlTdHJpbmcpIDoge31cbiAgdGhpcy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZFxuICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwge31cbiAgdGhpcy5wcmV2aW91cyA9IG9wdGlvbnMucHJldmlvdXNcbiAgdmFyIHJvdXRlcyA9IHBhZ2UuX3JvdXRlc1xuICB0aGlzLnRyYW5zaXRpb25hbCA9IHJvdXRlcy50cmFuc2l0aW9uYWxbdGhpcy5tZXRob2RdXG4gIHRoaXMucXVldWUgPSByb3V0ZXMucXVldWVbdGhpcy5tZXRob2RdXG4gIHRoaXMub25Sb3V0ZSA9IHJvdXRlcy5vblJvdXRlXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhbiBldmVudCwgc2luY2UgdGhlXG4gIC8vIGFwcHJvcHJpYXRlIGFjdGlvbiB3aWxsIGhhcHBlbiBieSBkZWZhdWx0XG4gIGlmICh0aGlzLmUgfHwgb3B0aW9ucy5ub05hdmlnYXRlKSByZXR1cm5cbiAgLy8gT3RoZXJ3aXNlLCBtYW51YWxseSBwZXJmb3JtIGFwcHJvcHJpYXRlIGFjdGlvblxuICBpZiAob3B0aW9ucy5mb3JtKSB7XG4gICAgb3B0aW9ucy5mb3JtLnNldEF0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJywgJycpXG4gICAgb3B0aW9ucy5mb3JtLnN1Ym1pdCgpXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5saW5rKSB7XG4gICAgb3B0aW9ucy5saW5rLnNldEF0dHJpYnV0ZSgnZGF0YS1yb3V0ZXItaWdub3JlJywgJycpXG4gICAgb3B0aW9ucy5saW5rLmNsaWNrKClcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKG9wdGlvbnMudXJsKVxuICB9XG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIHRoaXMudXJsID0gdXJsXG4gIHRoaXMucGF0aCA9IHRoaXMudXJsLnJlcGxhY2UoL1xcPy4qLywgJycpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVUcmFuc2l0aW9uYWwgPSBmdW5jdGlvbihpLCBuZXh0KSB7XG4gIGkgfHwgKGkgPSAwKVxuICB2YXIgaXRlbVxuICB3aGlsZSAoaXRlbSA9IHRoaXMudHJhbnNpdGlvbmFsW2krK10pIHtcbiAgICBpZiAoIWl0ZW0udG8ubWF0Y2godGhpcy5wYXRoKSB8fCAhaXRlbS5mcm9tLm1hdGNoKHRoaXMucHJldmlvdXMpKSBjb250aW51ZVxuICAgIHZhciByZXEgPSB0aGlzXG4gICAgdmFyIG90aGVyUGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhpdGVtLmZyb20pXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucm91dGVQYXJhbXMoaXRlbS50bywgb3RoZXJQYXJhbXMpXG4gICAgLy8gRXZlbiB0aG91Z2ggd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBhZnRlciBhIGRvbmUsIHBhc3MgYVxuICAgIC8vIG5vIG9wIGZ1bmN0aW9uLCBzbyB0aGF0IHJvdXRlcyBjYW4gZXhwZWN0IGl0IHRvIGJlIGRlZmluZWRcbiAgICBmdW5jdGlvbiBkb25lKCkge31cbiAgICB0aGlzLm9uTWF0Y2goaXRlbS50bywgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiByZXEuY2FuY2VsKClcbiAgICAgIHJlcS5yb3V0ZVRyYW5zaXRpb25hbChpLCBuZXh0KVxuICAgIH0sIGRvbmUpXG4gICAgcmV0dXJuXG4gIH1cbiAgbmV4dCgpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVRdWV1ZSA9IGZ1bmN0aW9uKGksIG5leHQpIHtcbiAgaSB8fCAoaSA9IDApXG4gIHZhciByb3V0ZVxuICB3aGlsZSAocm91dGUgPSB0aGlzLnF1ZXVlW2krK10pIHtcbiAgICBpZiAoIXJvdXRlLm1hdGNoKHRoaXMucGF0aCkpIGNvbnRpbnVlXG4gICAgdmFyIHJlcSA9IHRoaXNcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yb3V0ZVBhcmFtcyhyb3V0ZSlcbiAgICB0aGlzLm9uTWF0Y2gocm91dGUsIHBhcmFtcywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gcmVxLmNhbmNlbCgpXG4gICAgICByZXEucm91dGVRdWV1ZShpLCBuZXh0KVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgbmV4dCgpXG59XG5cblJlbmRlclJlcS5wcm90b3R5cGUucm91dGVBbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24oaSwgbmV4dCkge1xuICBpIHx8IChpID0gMClcbiAgdmFyIHJlbmRlciA9IHRoaXMucGFnZS5yZW5kZXJcbiAgdmFyIGl0ZW1cbiAgd2hpbGUgKGl0ZW0gPSB0aGlzLnRyYW5zaXRpb25hbFtpKytdKSB7XG4gICAgaWYgKCFpdGVtLnRvLm1hdGNoKHRoaXMucGF0aCkpIGNvbnRpbnVlXG4gICAgdmFyIHVybCA9IHRoaXMudXJsXG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucm91dGVQYXJhbXMoaXRlbS50bylcbiAgICB0aGlzLnNldFVybChtYXBSb3V0ZShpdGVtLmZyb20ucGF0aCwgcGFyYW1zKSlcbiAgICB2YXIgcmVxID0gdGhpc1xuICAgIHZhciBza2lwcGVkID0gZmFsc2VcbiAgICBmdW5jdGlvbiBjb250aW51ZU5leHQoKSB7XG4gICAgICBza2lwcGVkID0gdHJ1ZVxuICAgICAgcmVxLnNldFVybCh1cmwpXG4gICAgICByZXEucGFnZS5yZW5kZXIgPSByZW5kZXJcbiAgICAgIHJlcS5yb3V0ZUFuZFRyYW5zaXRpb24oaSwgbmV4dClcbiAgICB9XG4gICAgdGhpcy5wYWdlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlbmRlckFyZ3VtZW50cyA9IGFyZ3VtZW50c1xuICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgaWYgKHNraXBwZWQpIHJldHVyblxuICAgICAgICByZXEucGFnZS5yZW5kZXIgPSByZW5kZXJcbiAgICAgICAgcmVuZGVyLmFwcGx5KHJlcS5wYWdlLCByZW5kZXJBcmd1bWVudHMpXG4gICAgICB9XG4gICAgICByZXEuc2V0VXJsKHVybClcbiAgICAgIHZhciBpc0FzeW5jID0gcmVxLm9uTWF0Y2goaXRlbS50bywgcGFyYW1zLCBjb250aW51ZU5leHQsIGRvbmUpXG4gICAgICBpZiAoaXNBc3luYykgcmV0dXJuXG4gICAgICBkb25lKClcbiAgICB9XG4gICAgdGhpcy5yb3V0ZVF1ZXVlKDAsIGNvbnRpbnVlTmV4dClcbiAgICByZXR1cm5cbiAgfVxuICBuZXh0KClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5vbk1hdGNoID0gZnVuY3Rpb24ocm91dGUsIHBhcmFtcywgbmV4dCwgZG9uZSkge1xuICAvLyBTdG9wIHRoZSBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uLCBzdWNoIGFzIGNsaWNraW5nIGEgbGluayBvciBzdWJtaXR0aW5nIGEgZm9ybVxuICBpZiAodGhpcy5lKSB7XG4gICAgdGhpcy5lLnByZXZlbnREZWZhdWx0KClcbiAgICB0aGlzLmUgPSBudWxsXG4gIH1cbiAgdGhpcy5wYWdlLnBhcmFtcyA9IHBhcmFtc1xuICByZXR1cm4gdGhpcy5vblJvdXRlKFxuICAgIHJvdXRlLmNhbGxiYWNrc1xuICAsIHRoaXMucGFnZVxuICAsIHRoaXMucGFnZS5wYXJhbXNcbiAgLCBuZXh0XG4gICwgcm91dGUuaXNUcmFuc2l0aW9uYWxcbiAgLCBkb25lXG4gIClcbn1cblxuUmVuZGVyUmVxLnByb3RvdHlwZS5yb3V0ZVBhcmFtcyA9IGZ1bmN0aW9uKHJvdXRlLCBvdGhlclBhcmFtcykge1xuICB2YXIgcm91dGVQYXJhbXMgPSByb3V0ZS5wYXJhbXNcbiAgdmFyIHBhcmFtcyA9IHJvdXRlUGFyYW1zLnNsaWNlKClcbiAgaWYgKG90aGVyUGFyYW1zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG90aGVyUGFyYW1zKSB7XG4gICAgICBwYXJhbXNba2V5XSA9IG90aGVyUGFyYW1zW2tleV1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHJvdXRlUGFyYW1zKSB7XG4gICAgcGFyYW1zW2tleV0gPSByb3V0ZVBhcmFtc1trZXldXG4gIH1cbiAgcGFyYW1zLnByZXZpb3VzID0gdGhpcy5wcmV2aW91c1xuICBwYXJhbXMudXJsID0gdGhpcy51cmxcbiAgcGFyYW1zLmJvZHkgPSB0aGlzLmJvZHlcbiAgcGFyYW1zLnF1ZXJ5ID0gdGhpcy5xdWVyeVxuICBwYXJhbXMubWV0aG9kID0gdGhpcy5tZXRob2RcbiAgcmV0dXJuIHBhcmFtc1xufVxuIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIC8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4gIC8vIGRldGVjdCB0byBkZXRlcm1pbmUgdGhlIGJlc3QgUk5HIHNvdXJjZSwgbm9ybWFsaXppbmcgdG8gYSBmdW5jdGlvbiB0aGF0XG4gIC8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG4gIHZhciBfcm5nO1xuXG4gIC8vIE5vZGUuanMgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvdjAuNi4yL2FwaS9jcnlwdG8uaHRtbFxuICAvL1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICBpZiAodHlwZW9mKHJlcXVpcmUpID09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9yYiA9IHJlcXVpcmUoJ2NyeXB0bycpLnJhbmRvbUJ5dGVzO1xuICAgICAgX3JuZyA9IF9yYiAmJiBmdW5jdGlvbigpIHtyZXR1cm4gX3JiKDE2KTt9O1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmICghX3JuZyAmJiBfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gICAgLy9cbiAgICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICAgIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHM4KTtcbiAgICAgIHJldHVybiBfcm5kczg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghX3JuZykge1xuICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAvL1xuICAgIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gICAgLy8gcXVhbGl0eS5cbiAgICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JuZHM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciBjbGFzcyB0byB1c2VcbiAgdmFyIEJ1ZmZlckNsYXNzID0gdHlwZW9mKEJ1ZmZlcikgPT0gJ2Z1bmN0aW9uJyA/IEJ1ZmZlciA6IEFycmF5O1xuXG4gIC8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG4gIHZhciBfYnl0ZVRvSGV4ID0gW107XG4gIHZhciBfaGV4VG9CeXRlID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBfaGV4VG9CeXRlW19ieXRlVG9IZXhbaV1dID0gaTtcbiAgfVxuXG4gIC8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuICBmdW5jdGlvbiBwYXJzZShzLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICAgIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgICBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZywgZnVuY3Rpb24ob2N0KSB7XG4gICAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gICAgd2hpbGUgKGlpIDwgMTYpIHtcbiAgICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICAvLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbiAgZnVuY3Rpb24gdW5wYXJzZShidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gICAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbiAgfVxuXG4gIC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbiAgLy9cbiAgLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbiAgLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuICAvLyByYW5kb20gIydzIHdlIG5lZWQgdG8gaW5pdCBub2RlIGFuZCBjbG9ja3NlcVxuICB2YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgdmFyIF9ub2RlSWQgPSBbXG4gICAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuICBdO1xuXG4gIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gIHZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbiAgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG4gIHZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICAgIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9IG51bGwgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gICAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAgIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAgIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gICAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPSBudWxsID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPSBudWxsID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gICAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICAgIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gICAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gICAgLy8gdGltZSBpbnRlcnZhbFxuICAgIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PSBudWxsKSB7XG4gICAgICBuc2VjcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICAgIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gICAgfVxuXG4gICAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICAgIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAgIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICAgIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gICAgLy8gYHRpbWVfbG93YFxuICAgIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX21pZGBcbiAgICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gICAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gICAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgICAvLyBgbm9kZWBcbiAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG4gIH1cblxuICAvLyAqKmB2NCgpYCAtIEdlbmVyYXRlIHJhbmRvbSBVVUlEKipcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgLy8gRGVwcmVjYXRlZCAtICdmb3JtYXQnIGFyZ3VtZW50LCBhcyBzdXBwb3J0ZWQgaW4gdjEuMlxuICAgIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gICAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gb3B0aW9ucyA9PSAnYmluYXJ5JyA/IG5ldyBCdWZmZXJDbGFzcygxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuICB9XG5cbiAgLy8gRXhwb3J0IHB1YmxpYyBBUElcbiAgdmFyIHV1aWQgPSB2NDtcbiAgdXVpZC52MSA9IHYxO1xuICB1dWlkLnY0ID0gdjQ7XG4gIHV1aWQucGFyc2UgPSBwYXJzZTtcbiAgdXVpZC51bnBhcnNlID0gdW5wYXJzZTtcbiAgdXVpZC5CdWZmZXJDbGFzcyA9IEJ1ZmZlckNsYXNzO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBQdWJsaXNoIGFzIEFNRCBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQ7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2Uge1xuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZ2xvYmFsLnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF9nbG9iYWwudXVpZCA9IHV1aWQ7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cyA9IGFycmF5RGlmZjtcblxuLy8gQmFzZWQgb24gc29tZSByb3VnaCBiZW5jaG1hcmtpbmcsIHRoaXMgYWxnb3JpdGhtIGlzIGFib3V0IE8oMm4pIHdvcnN0IGNhc2UsXG4vLyBhbmQgaXQgY2FuIGNvbXB1dGUgZGlmZnMgb24gcmFuZG9tIGFycmF5cyBvZiBsZW5ndGggMTAyNCBpbiBhYm91dCAzNG1zLFxuLy8gdGhvdWdoIGp1c3QgYSBmZXcgY2hhbmdlcyBvbiBhbiBhcnJheSBvZiBsZW5ndGggMTAyNCB0YWtlcyBhYm91dCAwLjVtc1xuXG5hcnJheURpZmYuSW5zZXJ0RGlmZiA9IEluc2VydERpZmY7XG5hcnJheURpZmYuUmVtb3ZlRGlmZiA9IFJlbW92ZURpZmY7XG5hcnJheURpZmYuTW92ZURpZmYgPSBNb3ZlRGlmZjtcblxuZnVuY3Rpb24gSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG59XG5JbnNlcnREaWZmLnByb3RvdHlwZS50eXBlID0gJ2luc2VydCc7XG5JbnNlcnREaWZmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0aGlzLnR5cGVcbiAgLCBpbmRleDogdGhpcy5pbmRleFxuICAsIHZhbHVlczogdGhpcy52YWx1ZXNcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFJlbW92ZURpZmYoaW5kZXgsIGhvd01hbnkpIHtcbiAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB0aGlzLmhvd01hbnkgPSBob3dNYW55O1xufVxuUmVtb3ZlRGlmZi5wcm90b3R5cGUudHlwZSA9ICdyZW1vdmUnO1xuUmVtb3ZlRGlmZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdGhpcy50eXBlXG4gICwgaW5kZXg6IHRoaXMuaW5kZXhcbiAgLCBob3dNYW55OiB0aGlzLmhvd01hbnlcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSB7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMudG8gPSB0bztcbiAgdGhpcy5ob3dNYW55ID0gaG93TWFueTtcbn1cbk1vdmVEaWZmLnByb3RvdHlwZS50eXBlID0gJ21vdmUnO1xuTW92ZURpZmYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHRoaXMudHlwZVxuICAsIGZyb206IHRoaXMuZnJvbVxuICAsIHRvOiB0aGlzLnRvXG4gICwgaG93TWFueTogdGhpcy5ob3dNYW55XG4gIH07XG59O1xuXG5mdW5jdGlvbiBzdHJpY3RFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheURpZmYoYmVmb3JlLCBhZnRlciwgZXF1YWxGbikge1xuICBpZiAoIWVxdWFsRm4pIGVxdWFsRm4gPSBzdHJpY3RFcXVhbDtcblxuICAvLyBGaW5kIGFsbCBpdGVtcyBpbiBib3RoIHRoZSBiZWZvcmUgYW5kIGFmdGVyIGFycmF5LCBhbmQgcmVwcmVzZW50IHRoZW1cbiAgLy8gYXMgbW92ZXMuIE1hbnkgb2YgdGhlc2UgXCJtb3Zlc1wiIG1heSBlbmQgdXAgYmVpbmcgZGlzY2FyZGVkIGluIHRoZSBsYXN0XG4gIC8vIHBhc3MgaWYgdGhleSBhcmUgZnJvbSBhbiBpbmRleCB0byB0aGUgc2FtZSBpbmRleCwgYnV0IHdlIGRvbid0IGtub3cgdGhpc1xuICAvLyB1cCBmcm9udCwgc2luY2Ugd2UgaGF2ZW4ndCB5ZXQgb2Zmc2V0IHRoZSBpbmRpY2VzLlxuICAvLyBcbiAgLy8gQWxzbyBrZWVwIGEgbWFwIG9mIGFsbCB0aGUgaW5kaWNpZXMgYWNjb3VudGVkIGZvciBpbiB0aGUgYmVmb3JlIGFuZCBhZnRlclxuICAvLyBhcnJheXMuIFRoZXNlIG1hcHMgYXJlIHVzZWQgbmV4dCB0byBjcmVhdGUgaW5zZXJ0IGFuZCByZW1vdmUgZGlmZnMuXG4gIHZhciBiZWZvcmVMZW5ndGggPSBiZWZvcmUubGVuZ3RoO1xuICB2YXIgYWZ0ZXJMZW5ndGggPSBhZnRlci5sZW5ndGg7XG4gIHZhciBtb3ZlcyA9IFtdO1xuICB2YXIgYmVmb3JlTWFya2VkID0ge307XG4gIHZhciBhZnRlck1hcmtlZCA9IHt9O1xuICBmb3IgKHZhciBiZWZvcmVJbmRleCA9IDA7IGJlZm9yZUluZGV4IDwgYmVmb3JlTGVuZ3RoOyBiZWZvcmVJbmRleCsrKSB7XG4gICAgdmFyIGJlZm9yZUl0ZW0gPSBiZWZvcmVbYmVmb3JlSW5kZXhdO1xuICAgIGZvciAodmFyIGFmdGVySW5kZXggPSAwOyBhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGg7IGFmdGVySW5kZXgrKykge1xuICAgICAgaWYgKGFmdGVyTWFya2VkW2FmdGVySW5kZXhdKSBjb250aW51ZTtcbiAgICAgIGlmICghZXF1YWxGbihiZWZvcmVJdGVtLCBhZnRlclthZnRlckluZGV4XSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGZyb20gPSBiZWZvcmVJbmRleDtcbiAgICAgIHZhciB0byA9IGFmdGVySW5kZXg7XG4gICAgICB2YXIgaG93TWFueSA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleCsrXSA9IGFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10gPSB0cnVlO1xuICAgICAgICBob3dNYW55Kys7XG4gICAgICB9IHdoaWxlIChcbiAgICAgICAgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGggJiZcbiAgICAgICAgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoICYmXG4gICAgICAgIGVxdWFsRm4oYmVmb3JlW2JlZm9yZUluZGV4XSwgYWZ0ZXJbYWZ0ZXJJbmRleF0pICYmXG4gICAgICAgICFhZnRlck1hcmtlZFthZnRlckluZGV4XVxuICAgICAgKTtcbiAgICAgIG1vdmVzLnB1c2gobmV3IE1vdmVEaWZmKGZyb20sIHRvLCBob3dNYW55KSk7XG4gICAgICBiZWZvcmVJbmRleC0tO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgcmVtb3ZlIGZvciBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBiZWZvcmUgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYWZ0ZXIgYXJyYXkgYXMgd2VsbFxuICB2YXIgcmVtb3ZlcyA9IFtdO1xuICBmb3IgKGJlZm9yZUluZGV4ID0gMDsgYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGg7KSB7XG4gICAgaWYgKGJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleF0pIHtcbiAgICAgIGJlZm9yZUluZGV4Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gYmVmb3JlSW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChiZWZvcmVJbmRleCA8IGJlZm9yZUxlbmd0aCAmJiAhYmVmb3JlTWFya2VkW2JlZm9yZUluZGV4KytdKSB7XG4gICAgICBob3dNYW55Kys7XG4gICAgfVxuICAgIHJlbW92ZXMucHVzaChuZXcgUmVtb3ZlRGlmZihpbmRleCwgaG93TWFueSkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGluc2VydCBmb3IgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYWZ0ZXIgYXJyYXkgdGhhdCB3ZXJlXG4gIC8vIG5vdCBtYXJrZWQgYXMgYmVpbmcgbWF0Y2hlZCBpbiB0aGUgYmVmb3JlIGFycmF5IGFzIHdlbGxcbiAgdmFyIGluc2VydHMgPSBbXTtcbiAgZm9yIChhZnRlckluZGV4ID0gMDsgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoOykge1xuICAgIGlmIChhZnRlck1hcmtlZFthZnRlckluZGV4XSkge1xuICAgICAgYWZ0ZXJJbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGFmdGVySW5kZXg7XG4gICAgdmFyIGhvd01hbnkgPSAwO1xuICAgIHdoaWxlIChhZnRlckluZGV4IDwgYWZ0ZXJMZW5ndGggJiYgIWFmdGVyTWFya2VkW2FmdGVySW5kZXgrK10pIHtcbiAgICAgIGhvd01hbnkrKztcbiAgICB9XG4gICAgdmFyIHZhbHVlcyA9IGFmdGVyLnNsaWNlKGluZGV4LCBpbmRleCArIGhvd01hbnkpO1xuICAgIGluc2VydHMucHVzaChuZXcgSW5zZXJ0RGlmZihpbmRleCwgdmFsdWVzKSk7XG4gIH1cblxuICB2YXIgaW5zZXJ0c0xlbmd0aCA9IGluc2VydHMubGVuZ3RoO1xuICB2YXIgcmVtb3Zlc0xlbmd0aCA9IHJlbW92ZXMubGVuZ3RoO1xuICB2YXIgbW92ZXNMZW5ndGggPSBtb3Zlcy5sZW5ndGg7XG4gIHZhciBpLCBqO1xuXG4gIC8vIE9mZnNldCBzdWJzZXF1ZW50IHJlbW92ZXMgYW5kIG1vdmVzIGJ5IHJlbW92ZXNcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IHJlbW92ZXNMZW5ndGg7IGkrKykge1xuICAgIHZhciByZW1vdmUgPSByZW1vdmVzW2ldO1xuICAgIHJlbW92ZS5pbmRleCAtPSBjb3VudDtcbiAgICBjb3VudCArPSByZW1vdmUuaG93TWFueTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW92ZXNMZW5ndGg7IGorKykge1xuICAgICAgdmFyIG1vdmUgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChtb3ZlLmZyb20gPj0gcmVtb3ZlLmluZGV4KSBtb3ZlLmZyb20gLT0gcmVtb3ZlLmhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgLy8gT2Zmc2V0IG1vdmVzIGJ5IGluc2VydHNcbiAgZm9yIChpID0gaW5zZXJ0c0xlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnNlcnQgPSBpbnNlcnRzW2ldO1xuICAgIHZhciBob3dNYW55ID0gaW5zZXJ0LnZhbHVlcy5sZW5ndGg7XG4gICAgZm9yIChqID0gbW92ZXNMZW5ndGg7IGotLTspIHtcbiAgICAgIHZhciBtb3ZlID0gbW92ZXNbal07XG4gICAgICBpZiAobW92ZS50byA+PSBpbnNlcnQuaW5kZXgpIG1vdmUudG8gLT0gaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPZmZzZXQgdGhlIHRvIG9mIG1vdmVzIGJ5IGxhdGVyIG1vdmVzXG4gIGZvciAoaSA9IG1vdmVzTGVuZ3RoOyBpLS0gPiAxOykge1xuICAgIHZhciBtb3ZlID0gbW92ZXNbaV07XG4gICAgaWYgKG1vdmUudG8gPT09IG1vdmUuZnJvbSkgY29udGludWU7XG4gICAgZm9yIChqID0gaTsgai0tOykge1xuICAgICAgdmFyIGVhcmxpZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChlYXJsaWVyLnRvID49IG1vdmUudG8pIGVhcmxpZXIudG8gLT0gbW92ZS5ob3dNYW55O1xuICAgICAgaWYgKGVhcmxpZXIudG8gPj0gbW92ZS5mcm9tKSBlYXJsaWVyLnRvICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICAvLyBPbmx5IG91dHB1dCBtb3ZlcyB0aGF0IGVuZCB1cCBoYXZpbmcgYW4gZWZmZWN0IGFmdGVyIG9mZnNldHRpbmdcbiAgdmFyIG91dHB1dE1vdmVzID0gW107XG5cbiAgLy8gT2Zmc2V0IHRoZSBmcm9tIG9mIG1vdmVzIGJ5IGVhcmxpZXIgbW92ZXNcbiAgZm9yIChpID0gMDsgaSA8IG1vdmVzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbW92ZSA9IG1vdmVzW2ldO1xuICAgIGlmIChtb3ZlLnRvID09PSBtb3ZlLmZyb20pIGNvbnRpbnVlO1xuICAgIG91dHB1dE1vdmVzLnB1c2gobW92ZSk7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBtb3Zlc0xlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbGF0ZXIgPSBtb3Zlc1tqXTtcbiAgICAgIGlmIChsYXRlci5mcm9tID49IG1vdmUuZnJvbSkgbGF0ZXIuZnJvbSAtPSBtb3ZlLmhvd01hbnk7XG4gICAgICBpZiAobGF0ZXIuZnJvbSA+PSBtb3ZlLnRvKSBsYXRlci5mcm9tICs9IG1vdmUuaG93TWFueTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVtb3Zlcy5jb25jYXQob3V0cHV0TW92ZXMsIGluc2VydHMpO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKVxuICAsIGNvbXBpbGVyID0gcmVxdWlyZSgnLi9jb21waWxlcicpXG4gICwgbWVtb3J5Q2FjaGUgPSByZXF1aXJlKCdtZW1vcnktY2FjaGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgY2FjaGU6IHtleHBpcmF0aW9uOiAwfSxcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyYW5zbGF0aW9ucyA9IG1lbW9yeUNhY2hlLmdldCgndHJhbnNsYXRpb25zJyk7XG4gICAgaWYgKHRyYW5zbGF0aW9ucykgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRyYW5zbGF0aW9ucyk7XG4gICAgY29tcGlsZXIuY29tcGlsZShvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2xhdGlvbnMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgbWVtb3J5Q2FjaGUucHV0KCd0cmFuc2xhdGlvbnMnLCB0cmFuc2xhdGlvbnMsIG9wdGlvbnMuY2FjaGUuZXhwaXJhdGlvbik7XG4gICAgICBjYWxsYmFjayhudWxsLCB0cmFuc2xhdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xuICAgIHZhciBtb2RlbCA9IHJlcS5nZXRNb2RlbCgpO1xuICAgIGdldFRyYW5zbGF0aW9ucyhmdW5jdGlvbiAoZXJyLCB0cmFuc2xhdGlvbnMpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7XG4gICAgICBtb2RlbC5zZXQoJyRsYW5nLmRlZmF1bHRMb2NhbGUnLCAnZW4nKTtcbiAgICAgIG1vZGVsLnNldCgnJGxhbmcudHJhbnNsYXRpb25zJywgdHJhbnNsYXRpb25zKTtcbiAgICAgIG5leHQoKTtcbiAgICB9KTtcbiAgfTtcbn07IiwiKGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGNyeXB0ID0gcmVxdWlyZSgnY3J5cHQnKSxcclxuICAgICAgdXRmOCA9IHJlcXVpcmUoJ2NoYXJlbmMnKS51dGY4LFxyXG4gICAgICBiaW4gPSByZXF1aXJlKCdjaGFyZW5jJykuYmluLFxyXG5cclxuICAvLyBUaGUgY29yZVxyXG4gIG1kNSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGUgYXJyYXlcclxuICAgIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09IFN0cmluZylcclxuICAgICAgbWVzc2FnZSA9IHV0Zjguc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKVxyXG4gICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygpO1xyXG4gICAgLy8gZWxzZSwgYXNzdW1lIGJ5dGUgYXJyYXkgYWxyZWFkeVxyXG5cclxuICAgIHZhciBtID0gY3J5cHQuYnl0ZXNUb1dvcmRzKG1lc3NhZ2UpLFxyXG4gICAgICAgIGwgPSBtZXNzYWdlLmxlbmd0aCAqIDgsXHJcbiAgICAgICAgYSA9ICAxNzMyNTg0MTkzLFxyXG4gICAgICAgIGIgPSAtMjcxNzMzODc5LFxyXG4gICAgICAgIGMgPSAtMTczMjU4NDE5NCxcclxuICAgICAgICBkID0gIDI3MTczMzg3ODtcclxuXHJcbiAgICAvLyBTd2FwIGVuZGlhblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG1baV0gPSAoKG1baV0gPDwgIDgpIHwgKG1baV0gPj4+IDI0KSkgJiAweDAwRkYwMEZGIHxcclxuICAgICAgICAgICAgICgobVtpXSA8PCAyNCkgfCAobVtpXSA+Pj4gIDgpKSAmIDB4RkYwMEZGMDA7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFkZGluZ1xyXG4gICAgbVtsID4+PiA1XSB8PSAweDgwIDw8IChsICUgMzIpO1xyXG4gICAgbVsoKChsICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGw7XHJcblxyXG4gICAgLy8gTWV0aG9kIHNob3J0Y3V0c1xyXG4gICAgdmFyIEZGID0gbWQ1Ll9mZixcclxuICAgICAgICBHRyA9IG1kNS5fZ2csXHJcbiAgICAgICAgSEggPSBtZDUuX2hoLFxyXG4gICAgICAgIElJID0gbWQ1Ll9paTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XHJcblxyXG4gICAgICB2YXIgYWEgPSBhLFxyXG4gICAgICAgICAgYmIgPSBiLFxyXG4gICAgICAgICAgY2MgPSBjLFxyXG4gICAgICAgICAgZGQgPSBkO1xyXG5cclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgMF0sICA3LCAtNjgwODc2OTM2KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDRdLCAgNywgLTE3NjQxODg5Nyk7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsgN10sIDIyLCAtNDU3MDU5ODMpO1xyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyA4XSwgIDcsICAxNzcwMDM1NDE2KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krMTBdLCAxNywgLTQyMDYzKTtcclxuICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIG1baSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krMTJdLCAgNywgIDE4MDQ2MDM2ODIpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcclxuXHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDFdLCAgNSwgLTE2NTc5NjUxMCk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krIDZdLCAgOSwgLTEwNjk1MDE2MzIpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKyA1XSwgIDUsIC03MDE1NTg2OTEpO1xyXG4gICAgICBkID0gR0coZCwgYSwgYiwgYywgbVtpKzEwXSwgIDksICAzODAxNjA4Myk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDldLCAgNSwgIDU2ODQ0NjQzOCk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krMTRdLCAgOSwgLTEwMTk4MDM2OTApO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xyXG4gICAgICBiID0gR0coYiwgYywgZCwgYSwgbVtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsxM10sICA1LCAtMTQ0NDY4MTQ2Nyk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krIDJdLCAgOSwgLTUxNDAzNzg0KTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xyXG5cclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgNV0sICA0LCAtMzc4NTU4KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krIDFdLCAgNCwgLTE1MzA5OTIwNjApO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XHJcbiAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBtW2krMTNdLCAgNCwgIDY4MTI3OTE3NCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XHJcbiAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBtW2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krIDZdLCAyMywgIDc2MDI5MTg5KTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgOV0sICA0LCAtNjQwMzY0NDg3KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsxMl0sIDExLCAtNDIxODE1ODM1KTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcclxuXHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDBdLCAgNiwgLTE5ODYzMDg0NCk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKzEyXSwgIDYsICAxNzAwNDg1NTcxKTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krMTBdLCAxNSwgLTEwNTE1MjMpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgOF0sICA2LCAgMTg3MzMxMzM1OSk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyA0XSwgIDYsIC0xNDU1MjMwNzApO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcclxuXHJcbiAgICAgIGEgPSAoYSArIGFhKSA+Pj4gMDtcclxuICAgICAgYiA9IChiICsgYmIpID4+PiAwO1xyXG4gICAgICBjID0gKGMgKyBjYykgPj4+IDA7XHJcbiAgICAgIGQgPSAoZCArIGRkKSA+Pj4gMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY3J5cHQuZW5kaWFuKFthLCBiLCBjLCBkXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQXV4aWxpYXJ5IGZ1bmN0aW9uc1xyXG4gIG1kNS5fZmYgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChiICYgYyB8IH5iICYgZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5fZ2cgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChiICYgZCB8IGMgJiB+ZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5faGggID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuICBtZDUuX2lpICA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcblxyXG4gIC8vIFBhY2thZ2UgcHJpdmF0ZSBibG9ja3NpemVcclxuICBtZDUuX2Jsb2Nrc2l6ZSA9IDE2O1xyXG4gIG1kNS5fZGlnZXN0c2l6ZSA9IDE2O1xyXG5cclxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgZGlnZXN0Ynl0ZXMgPSBjcnlwdC53b3Jkc1RvQnl0ZXMobWQ1KG1lc3NhZ2UpKTtcclxuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNCeXRlcyA/IGRpZ2VzdGJ5dGVzIDpcclxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPyBiaW4uYnl0ZXNUb1N0cmluZyhkaWdlc3RieXRlcykgOlxyXG4gICAgICAgIGNyeXB0LmJ5dGVzVG9IZXgoZGlnZXN0Ynl0ZXMpO1xyXG4gIH07XHJcblxyXG59KSgpO1xyXG4iLCIvKipcbiAqIE9iamVjdCN0b1N0cmluZygpIHJlZiBmb3Igc3RyaW5naWZ5KCkuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBPYmplY3QjaGFzT3duUHJvcGVydHkgcmVmXG4gKi9cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBcnJheSNpbmRleE9mIHNoaW0uXG4gKi9cblxudmFyIGluZGV4T2YgPSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbidcbiAgPyBmdW5jdGlvbihhcnIsIGVsKSB7IHJldHVybiBhcnIuaW5kZXhPZihlbCk7IH1cbiAgOiBmdW5jdGlvbihhcnIsIGVsKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJyW2ldID09PSBlbCkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheS5pc0FycmF5IHNoaW0uXG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIE9iamVjdC5rZXlzIHNoaW0uXG4gKi9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJldCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXQucHVzaChrZXkpO1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBBcnJheSNmb3JFYWNoIHNoaW0uXG4gKi9cblxudmFyIGZvckVhY2ggPSB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggPT09ICdmdW5jdGlvbidcbiAgPyBmdW5jdGlvbihhcnIsIGZuKSB7IHJldHVybiBhcnIuZm9yRWFjaChmbik7IH1cbiAgOiBmdW5jdGlvbihhcnIsIGZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZm4oYXJyW2ldKTtcbiAgICB9O1xuXG4vKipcbiAqIEFycmF5I3JlZHVjZSBzaGltLlxuICovXG5cbnZhciByZWR1Y2UgPSBmdW5jdGlvbihhcnIsIGZuLCBpbml0aWFsKSB7XG4gIGlmICh0eXBlb2YgYXJyLnJlZHVjZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGFyci5yZWR1Y2UoZm4sIGluaXRpYWwpO1xuICB2YXIgcmVzID0gaW5pdGlhbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHJlcyA9IGZuKHJlcywgYXJyW2ldKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbnVsbGFyeSBvYmplY3QgaWYgcG9zc2libGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlXG4gICAgPyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBDYWNoZSBub24taW50ZWdlciB0ZXN0IHJlZ2V4cC5cbiAqL1xuXG52YXIgaXNpbnQgPSAvXlswLTldKyQvO1xuXG5mdW5jdGlvbiBwcm9tb3RlKHBhcmVudCwga2V5KSB7XG4gIGlmIChwYXJlbnRba2V5XS5sZW5ndGggPT0gMCkgcmV0dXJuIHBhcmVudFtrZXldID0gY3JlYXRlT2JqZWN0KCk7XG4gIHZhciB0ID0gY3JlYXRlT2JqZWN0KCk7XG4gIGZvciAodmFyIGkgaW4gcGFyZW50W2tleV0pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwYXJlbnRba2V5XSwgaSkpIHtcbiAgICAgIHRbaV0gPSBwYXJlbnRba2V5XVtpXTtcbiAgICB9XG4gIH1cbiAgcGFyZW50W2tleV0gPSB0O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gcGFyc2UocGFydHMsIHBhcmVudCwga2V5LCB2YWwpIHtcbiAgdmFyIHBhcnQgPSBwYXJ0cy5zaGlmdCgpO1xuICAvLyBlbmRcbiAgaWYgKCFwYXJ0KSB7XG4gICAgaWYgKGlzQXJyYXkocGFyZW50W2tleV0pKSB7XG4gICAgICBwYXJlbnRba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHBhcmVudFtrZXldKSB7XG4gICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50W2tleV0gPSBbcGFyZW50W2tleV0sIHZhbF07XG4gICAgfVxuICAgIC8vIGFycmF5XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9iaiA9IHBhcmVudFtrZXldID0gcGFyZW50W2tleV0gfHwgW107XG4gICAgaWYgKCddJyA9PSBwYXJ0KSB7XG4gICAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICAgIGlmICgnJyAhPSB2YWwpIG9iai5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgICAgb2JqW29iamVjdEtleXMob2JqKS5sZW5ndGhdID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gcGFyZW50W2tleV0gPSBbcGFyZW50W2tleV0sIHZhbF07XG4gICAgICB9XG4gICAgICAvLyBwcm9wXG4gICAgfSBlbHNlIGlmICh+aW5kZXhPZihwYXJ0LCAnXScpKSB7XG4gICAgICBwYXJ0ID0gcGFydC5zdWJzdHIoMCwgcGFydC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICAgIC8vIGtleVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzaW50LnRlc3QocGFydCkgJiYgaXNBcnJheShvYmopKSBvYmogPSBwcm9tb3RlKHBhcmVudCwga2V5KTtcbiAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQsIHZhbCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgcGFyZW50IGtleS92YWwgcGFpci5cbiAqL1xuXG5mdW5jdGlvbiBtZXJnZShwYXJlbnQsIGtleSwgdmFsKXtcbiAgaWYgKH5pbmRleE9mKGtleSwgJ10nKSkge1xuICAgIHZhciBwYXJ0cyA9IGtleS5zcGxpdCgnWycpXG4gICAgICAsIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgLCBsYXN0ID0gbGVuIC0gMTtcbiAgICBwYXJzZShwYXJ0cywgcGFyZW50LCAnYmFzZScsIHZhbCk7XG4gICAgLy8gb3B0aW1pemVcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzaW50LnRlc3Qoa2V5KSAmJiBpc0FycmF5KHBhcmVudC5iYXNlKSkge1xuICAgICAgdmFyIHQgPSBjcmVhdGVPYmplY3QoKTtcbiAgICAgIGZvciAodmFyIGsgaW4gcGFyZW50LmJhc2UpIHRba10gPSBwYXJlbnQuYmFzZVtrXTtcbiAgICAgIHBhcmVudC5iYXNlID0gdDtcbiAgICB9XG4gICAgc2V0KHBhcmVudC5iYXNlLCBrZXksIHZhbCk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50O1xufVxuXG4vKipcbiAqIENvbXBhY3Qgc3BhcnNlIGFycmF5cy5cbiAqL1xuXG5mdW5jdGlvbiBjb21wYWN0KG9iaikge1xuICBpZiAoJ29iamVjdCcgIT0gdHlwZW9mIG9iaikgcmV0dXJuIG9iajtcblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIHtcbiAgICAgICAgcmV0LnB1c2gob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIG9ialtrZXldID0gY29tcGFjdChvYmpba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFJlc3RvcmUgT2JqZWN0LnByb3RvdHlwZS5cbiAqIHNlZSBwdWxsLXJlcXVlc3QgIzU4XG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVByb3RvKG9iaikge1xuICBpZiAoIU9iamVjdC5jcmVhdGUpIHJldHVybiBvYmo7XG4gIGlmIChpc0FycmF5KG9iaikpIHJldHVybiBvYmo7XG4gIGlmIChvYmogJiYgJ29iamVjdCcgIT0gdHlwZW9mIG9iaikgcmV0dXJuIG9iajtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBvYmpba2V5XSA9IHJlc3RvcmVQcm90byhvYmpba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgb2JqLl9fcHJvdG9fXyA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuXG4gIGZvckVhY2gob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICBtZXJnZShyZXQsIG5hbWUsIG9ialtuYW1lXSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb21wYWN0KHJldC5iYXNlKTtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gc3RyLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cil7XG4gIHZhciByZXQgPSByZWR1Y2UoU3RyaW5nKHN0cikuc3BsaXQoJyYnKSwgZnVuY3Rpb24ocmV0LCBwYWlyKXtcbiAgICB2YXIgZXFsID0gaW5kZXhPZihwYWlyLCAnPScpXG4gICAgICAsIGJyYWNlID0gbGFzdEJyYWNlSW5LZXkocGFpcilcbiAgICAgICwga2V5ID0gcGFpci5zdWJzdHIoMCwgYnJhY2UgfHwgZXFsKVxuICAgICAgLCB2YWwgPSBwYWlyLnN1YnN0cihicmFjZSB8fCBlcWwsIHBhaXIubGVuZ3RoKVxuICAgICAgLCB2YWwgPSB2YWwuc3Vic3RyKGluZGV4T2YodmFsLCAnPScpICsgMSwgdmFsLmxlbmd0aCk7XG5cbiAgICAvLyA/Zm9vXG4gICAgaWYgKCcnID09IGtleSkga2V5ID0gcGFpciwgdmFsID0gJyc7XG4gICAgaWYgKCcnID09IGtleSkgcmV0dXJuIHJldDtcblxuICAgIHJldHVybiBtZXJnZShyZXQsIGRlY29kZShrZXkpLCBkZWNvZGUodmFsKSk7XG4gIH0sIHsgYmFzZTogY3JlYXRlT2JqZWN0KCkgfSkuYmFzZTtcblxuICByZXR1cm4gcmVzdG9yZVByb3RvKGNvbXBhY3QocmV0KSk7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHF1ZXJ5IGBzdHJgIG9yIGBvYmpgLCByZXR1cm5pbmcgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgfCB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHN0cil7XG4gIGlmIChudWxsID09IHN0ciB8fCAnJyA9PSBzdHIpIHJldHVybiB7fTtcbiAgcmV0dXJuICdvYmplY3QnID09IHR5cGVvZiBzdHJcbiAgICA/IHBhcnNlT2JqZWN0KHN0cilcbiAgICA6IHBhcnNlU3RyaW5nKHN0cik7XG59O1xuXG4vKipcbiAqIFR1cm4gdGhlIGdpdmVuIGBvYmpgIGludG8gYSBxdWVyeSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iaiwgcHJlZml4KSB7XG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkob2JqLCBwcmVmaXgpO1xuICB9IGVsc2UgaWYgKCdbb2JqZWN0IE9iamVjdF0nID09IHRvU3RyaW5nLmNhbGwob2JqKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3Qob2JqLCBwcmVmaXgpO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5U3RyaW5nKG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhvYmopKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhzdHIsIHByZWZpeCkge1xuICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5naWZ5IGV4cGVjdHMgYW4gb2JqZWN0Jyk7XG4gIHJldHVybiBwcmVmaXggKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBhcnJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoYXJyLCBwcmVmaXgpIHtcbiAgdmFyIHJldCA9IFtdO1xuICBpZiAoIXByZWZpeCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5naWZ5IGV4cGVjdHMgYW4gb2JqZWN0Jyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0LnB1c2goc3RyaW5naWZ5KGFycltpXSwgcHJlZml4ICsgJ1snICsgaSArICddJykpO1xuICB9XG4gIHJldHVybiByZXQuam9pbignJicpO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmeSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXVxuICAgICwga2V5cyA9IG9iamVjdEtleXMob2JqKVxuICAgICwga2V5O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoJycgPT0ga2V5KSBjb250aW51ZTtcbiAgICBpZiAobnVsbCA9PSBvYmpba2V5XSkge1xuICAgICAgcmV0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChzdHJpbmdpZnkob2JqW2tleV0sIHByZWZpeFxuICAgICAgICA/IHByZWZpeCArICdbJyArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJ10nXG4gICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTZXQgYG9iamAncyBga2V5YCB0byBgdmFsYCByZXNwZWN0aW5nXG4gKiB0aGUgd2VpcmQgYW5kIHdvbmRlcmZ1bCBzeW50YXggb2YgYSBxcyxcbiAqIHdoZXJlIFwiZm9vPWJhciZmb289YmF6XCIgYmVjb21lcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXQob2JqLCBrZXksIHZhbCkge1xuICB2YXIgdiA9IG9ialtrZXldO1xuICBpZiAodW5kZWZpbmVkID09PSB2KSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh2KSkge1xuICAgIHYucHVzaCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gW3YsIHZhbF07XG4gIH1cbn1cblxuLyoqXG4gKiBMb2NhdGUgbGFzdCBicmFjZSBpbiBgc3RyYCB3aXRoaW4gdGhlIGtleS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsYXN0QnJhY2VJbktleShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIGJyYWNlXG4gICAgLCBjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYyA9IHN0cltpXTtcbiAgICBpZiAoJ10nID09IGMpIGJyYWNlID0gZmFsc2U7XG4gICAgaWYgKCdbJyA9PSBjKSBicmFjZSA9IHRydWU7XG4gICAgaWYgKCc9JyA9PSBjICYmICFicmFjZSkgcmV0dXJuIGk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiKGZ1bmN0aW9uKGdsb2JhbCl7LyoqXG4gKiBAbGljZW5zZVxuICogTG8tRGFzaCAyLjMuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cDovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIC1vIC4vZGlzdC9sb2Rhc2guanNgXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDEzIFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjUuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYW5kIHRlc3Qgd2hpdGVzcGFjZSAqL1xuICB2YXIgd2hpdGVzcGFjZSA9IChcbiAgICAvLyB3aGl0ZXNwYWNlXG4gICAgJyBcXHRcXHgwQlxcZlxceEEwXFx1ZmVmZicgK1xuXG4gICAgLy8gbGluZSB0ZXJtaW5hdG9yc1xuICAgICdcXG5cXHJcXHUyMDI4XFx1MjAyOScgK1xuXG4gICAgLy8gdW5pY29kZSBjYXRlZ29yeSBcIlpzXCIgc3BhY2Ugc2VwYXJhdG9yc1xuICAgICdcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwJ1xuICApO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UgKi9cbiAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy03LjguNlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdGVkIG5hbWVkIGZ1bmN0aW9ucyAqL1xuICB2YXIgcmVGdW5jTmFtZSA9IC9eXFxzKmZ1bmN0aW9uWyBcXG5cXHJcXHRdK1xcdy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgZnVuY3Rpb25zIGNvbnRhaW5pbmcgYSBgdGhpc2AgcmVmZXJlbmNlICovXG4gIHZhciByZVRoaXMgPSAvXFxidGhpc1xcYi87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdFxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMgKi9cbiAgdmFyIGNvbnRleHRQcm9wcyA9IFtcbiAgICAnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Z1bmN0aW9uJywgJ01hdGgnLCAnTnVtYmVyJywgJ09iamVjdCcsXG4gICAgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnXycsICdhdHRhY2hFdmVudCcsICdjbGVhclRpbWVvdXQnLCAnaXNGaW5pdGUnLCAnaXNOYU4nLFxuICAgICdwYXJzZUludCcsICdzZXRJbW1lZGlhdGUnLCAnc2V0VGltZW91dCdcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5ICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCBhcyBhbiBpbnRlcm5hbCBgXy5kZWJvdW5jZWAgb3B0aW9ucyBvYmplY3QgKi9cbiAgdmFyIGRlYm91bmNlT3B0aW9ucyA9IHtcbiAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICdtYXhXYWl0JzogMCxcbiAgICAndHJhaWxpbmcnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciBgX19iaW5kRGF0YV9fYCAqL1xuICB2YXIgZGVzY3JpcHRvciA9IHtcbiAgICAnY29uZmlndXJhYmxlJzogZmFsc2UsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBudWxsLFxuICAgICd3cml0YWJsZSc6IGZhbHNlXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0ICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AgKi9cbiAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMgJiYgZnJlZUV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSBhbmQgdXNlIGl0IGFzIGByb290YCAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IChmcm9tSW5kZXggfHwgMCkgLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgYF8uY29udGFpbnNgIGZvciBjYWNoZSBvYmplY3RzIHRoYXQgbWltaWNzIHRoZSByZXR1cm5cbiAgICogc2lnbmF0dXJlIG9mIGBfLmluZGV4T2ZgIGJ5IHJldHVybmluZyBgMGAgaWYgdGhlIHZhbHVlIGlzIGZvdW5kLCBlbHNlIGAtMWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV0gPyAwIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gKGNhY2hlID0gY2FjaGVbdHlwZV0pICYmIGNhY2hlW2tleV07XG5cbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0J1xuICAgICAgPyAoY2FjaGUgJiYgYmFzZUluZGV4T2YoY2FjaGUsIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGUgPyAwIDogLTEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBnaXZlbiB2YWx1ZSB0byB0aGUgY29ycmVzcG9uZGluZyBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZCB0byB0aGUgY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZVB1c2godmFsdWUpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxuICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIGNhY2hlW3ZhbHVlXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlLFxuICAgICAgICAgIHR5cGVDYWNoZSA9IGNhY2hlW3R5cGVdIHx8IChjYWNoZVt0eXBlXSA9IHt9KTtcblxuICAgICAgaWYgKHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBjYWxsYmFjayB3aGVuIGEgZ2l2ZW5cbiAgICogY29sbGVjdGlvbiBpcyBhIHN0cmluZyB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBjaGFyYWN0ZXIgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29kZSB1bml0IG9mIGdpdmVuIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJBdENhbGxiYWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgc29ydEJ5YCB0byBjb21wYXJlIHRyYW5zZm9ybWVkIGBjb2xsZWN0aW9uYCBlbGVtZW50cywgc3RhYmxlIHNvcnRpbmdcbiAgICogdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYmAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29tcGFyZSB0byBgYWAuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIG9mIGAxYCBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyhhLCBiKSB7XG4gICAgdmFyIGFjID0gYS5jcml0ZXJpYSxcbiAgICAgICAgYmMgPSBiLmNyaXRlcmlhO1xuXG4gICAgLy8gZW5zdXJlIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXNcbiAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MFxuICAgIGlmIChhYyAhPT0gYmMpIHtcbiAgICAgIGlmIChhYyA+IGJjIHx8IHR5cGVvZiBhYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChhYyA8IGJjIHx8IHR5cGVvZiBiYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zIGxpa2UgSW5EZXNpZ24gaGFzIGEgYnVnZ3lcbiAgICAvLyBgQXJyYXkjc29ydGAgaW1wbGVtZW50YXRpb24gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcyxcbiAgICAvLyB0byByZXR1cm4gdGhlIHNhbWUgdmFsdWUgZm9yIGBhYCBhbmQgYGJgLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYWNoZSBvYmplY3QgdG8gb3B0aW1pemUgbGluZWFyIHNlYXJjaGVzIG9mIGxhcmdlIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCBvciBgbnVsbGAgaWYgY2FjaGluZyBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWNoZShhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGZpcnN0ID0gYXJyYXlbMF0sXG4gICAgICAgIG1pZCA9IGFycmF5WyhsZW5ndGggLyAyKSB8IDBdLFxuICAgICAgICBsYXN0ID0gYXJyYXlbbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZmlyc3QgJiYgdHlwZW9mIGZpcnN0ID09ICdvYmplY3QnICYmXG4gICAgICAgIG1pZCAmJiB0eXBlb2YgbWlkID09ICdvYmplY3QnICYmIGxhc3QgJiYgdHlwZW9mIGxhc3QgPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlID0gZ2V0T2JqZWN0KCk7XG4gICAgY2FjaGVbJ2ZhbHNlJ10gPSBjYWNoZVsnbnVsbCddID0gY2FjaGVbJ3RydWUnXSA9IGNhY2hlWyd1bmRlZmluZWQnXSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlc3VsdCA9IGdldE9iamVjdCgpO1xuICAgIHJlc3VsdC5hcnJheSA9IGFycmF5O1xuICAgIHJlc3VsdC5jYWNoZSA9IGNhY2hlO1xuICAgIHJlc3VsdC5wdXNoID0gY2FjaGVQdXNoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgZnJvbSB0aGUgYXJyYXkgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFycmF5KCkge1xuICAgIHJldHVybiBhcnJheVBvb2wucG9wKCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gb2JqZWN0UG9vbC5wb3AoKSB8fCB7XG4gICAgICAnYXJyYXknOiBudWxsLFxuICAgICAgJ2NhY2hlJzogbnVsbCxcbiAgICAgICdjcml0ZXJpYSc6IG51bGwsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICdpbmRleCc6IDAsXG4gICAgICAnbnVsbCc6IGZhbHNlLFxuICAgICAgJ251bWJlcic6IG51bGwsXG4gICAgICAnb2JqZWN0JzogbnVsbCxcbiAgICAgICdwdXNoJzogbnVsbCxcbiAgICAgICdzdHJpbmcnOiBudWxsLFxuICAgICAgJ3RydWUnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBhcnJheSBiYWNrIHRvIHRoZSBhcnJheSBwb29sLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byByZWxlYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsZWFzZUFycmF5KGFycmF5KSB7XG4gICAgYXJyYXkubGVuZ3RoID0gMDtcbiAgICBpZiAoYXJyYXlQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBhcnJheVBvb2wucHVzaChhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIHRoZSBnaXZlbiBvYmplY3QgYmFjayB0byB0aGUgb2JqZWN0IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBjYWNoZSA9IG9iamVjdC5jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgIH1cbiAgICBvYmplY3QuYXJyYXkgPSBvYmplY3QuY2FjaGUgPSBvYmplY3QuY3JpdGVyaWEgPSBvYmplY3Qub2JqZWN0ID0gb2JqZWN0Lm51bWJlciA9IG9iamVjdC5zdHJpbmcgPSBvYmplY3QudmFsdWUgPSBudWxsO1xuICAgIGlmIChvYmplY3RQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBvYmplY3RQb29sLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpY2VzIHRoZSBgY29sbGVjdGlvbmAgZnJvbSB0aGUgYHN0YXJ0YCBpbmRleCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG4gICAqIHRoZSBgZW5kYCBpbmRleC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluc3RlYWQgb2YgYEFycmF5I3NsaWNlYCB0byBzdXBwb3J0IG5vZGUgbGlzdHNcbiAgICogaW4gSUUgPCA5IGFuZCB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgaW5kZXguXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQgfHwgMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGdpdmVuIGNvbnRleHQgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDExLjEuNS5cbiAgICBjb250ZXh0ID0gY29udGV4dCA/IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpIDogcm9vdDtcblxuICAgIC8qKiBOYXRpdmUgY29uc3RydWN0b3IgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIEJvb2xlYW4gPSBjb250ZXh0LkJvb2xlYW4sXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEZ1bmN0aW9uID0gY29udGV4dC5GdW5jdGlvbixcbiAgICAgICAgTWF0aCA9IGNvbnRleHQuTWF0aCxcbiAgICAgICAgTnVtYmVyID0gY29udGV4dC5OdW1iZXIsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgYEFycmF5YCBtZXRob2QgcmVmZXJlbmNlcy5cbiAgICAgKlxuICAgICAqIE5vcm1hbGx5IGBBcnJheS5wcm90b3R5cGVgIHdvdWxkIHN1ZmZpY2UsIGhvd2V2ZXIsIHVzaW5nIGFuIGFycmF5IGxpdGVyYWxcbiAgICAgKiBhdm9pZHMgaXNzdWVzIGluIE5hcndoYWwuXG4gICAgICovXG4gICAgdmFyIGFycmF5UmVmID0gW107XG5cbiAgICAvKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzICovXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gICAgdmFyIG9sZERhc2ggPSBjb250ZXh0Ll87XG5cbiAgICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBpbnRlcm5hbCBbW0NsYXNzXV0gb2YgdmFsdWVzICovXG4gICAgdmFyIHRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcodG9TdHJpbmcpXG4gICAgICAgIC5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAgIC5yZXBsYWNlKC90b1N0cmluZ3wgZm9yIFteXFxdXSsvZywgJy4qPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICBnZXRQcm90b3R5cGVPZiA9IHJlTmF0aXZlLnRlc3QoZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YpICYmIGdldFByb3RvdHlwZU9mLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5LFxuICAgICAgICBub3cgPSByZU5hdGl2ZS50ZXN0KG5vdyA9IERhdGUubm93KSAmJiBub3cgfHwgZnVuY3Rpb24oKSB7IHJldHVybiArbmV3IERhdGU7IH0sXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBzZXRUaW1lb3V0ID0gY29udGV4dC5zZXRUaW1lb3V0LFxuICAgICAgICBzcGxpY2UgPSBhcnJheVJlZi5zcGxpY2U7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgYHNldEltbWVkaWF0ZWAgaW4gTm9kZS5qcyAqL1xuICAgIHZhciBzZXRJbW1lZGlhdGUgPSB0eXBlb2YgKHNldEltbWVkaWF0ZSA9IGZyZWVHbG9iYWwgJiYgbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnNldEltbWVkaWF0ZSkgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgIXJlTmF0aXZlLnRlc3Qoc2V0SW1tZWRpYXRlKSAmJiBzZXRJbW1lZGlhdGU7XG5cbiAgICAvKiogVXNlZCB0byBzZXQgbWV0YSBkYXRhIG9uIGZ1bmN0aW9ucyAqL1xuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIC8vIElFIDggb25seSBhY2NlcHRzIERPTSBlbGVtZW50c1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG8gPSB7fSxcbiAgICAgICAgICAgIGZ1bmMgPSByZU5hdGl2ZS50ZXN0KGZ1bmMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGZ1bmMsXG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jKG8sIG8sIG8pICYmIGZ1bmM7XG4gICAgICB9IGNhdGNoKGUpIHsgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KCkpO1xuXG4gICAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgICB2YXIgbmF0aXZlQ3JlYXRlID0gcmVOYXRpdmUudGVzdChuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUlzTmFOID0gY29udGV4dC5pc05hTixcbiAgICAgICAgbmF0aXZlS2V5cyA9IHJlTmF0aXZlLnRlc3QobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgICB2YXIgY3RvckJ5Q2xhc3MgPSB7fTtcbiAgICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICAgIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICAgIGN0b3JCeUNsYXNzW2RhdGVDbGFzc10gPSBEYXRlO1xuICAgIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gICAgY3RvckJ5Q2xhc3NbbnVtYmVyQ2xhc3NdID0gTnVtYmVyO1xuICAgIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3Qgd2hpY2ggd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHRvIGVuYWJsZSBpbnR1aXRpdmVcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVgLCBgY3JlYXRlQ2FsbGJhY2tgLCBgY3VycnlgLFxuICAgICAqIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsIGBkZWZlcmAsIGBkZWxheWAsIGBkaWZmZXJlbmNlYCwgYGZpbHRlcmAsIGBmbGF0dGVuYCxcbiAgICAgKiBgZm9yRWFjaGAsIGBmb3JFYWNoUmlnaHRgLCBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLFxuICAgICAqIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbmRleEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludmVydGAsXG4gICAgICogYGludm9rZWAsIGBrZXlzYCwgYG1hcGAsIGBtYXhgLCBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtaW5gLCBgb2JqZWN0YCwgYG9taXRgLFxuICAgICAqIGBvbmNlYCwgYHBhaXJzYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBpY2tgLCBgcGx1Y2tgLCBgcHVsbGAsIGBwdXNoYCxcbiAgICAgKiBgcmFuZ2VgLCBgcmVqZWN0YCwgYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2h1ZmZsZWAsIGBzbGljZWAsIGBzb3J0YCxcbiAgICAgKiBgc29ydEJ5YCwgYHNwbGljZWAsIGB0YXBgLCBgdGhyb3R0bGVgLCBgdGltZXNgLCBgdG9BcnJheWAsIGB0cmFuc2Zvcm1gLFxuICAgICAqIGB1bmlvbmAsIGB1bmlxYCwgYHVuc2hpZnRgLCBgdW56aXBgLCBgdmFsdWVzYCwgYHdoZXJlYCwgYHdpdGhvdXRgLCBgd3JhcGAsXG4gICAgICogYW5kIGB6aXBgXG4gICAgICpcbiAgICAgKiBUaGUgbm9uLWNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGNsb25lYCwgYGNsb25lRGVlcGAsIGBjb250YWluc2AsIGBlc2NhcGVgLCBgZXZlcnlgLCBgZmluZGAsIGBmaW5kSW5kZXhgLFxuICAgICAqIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCwgYGZpbmRMYXN0SW5kZXhgLCBgZmluZExhc3RLZXlgLCBgaGFzYCwgYGlkZW50aXR5YCxcbiAgICAgKiBgaW5kZXhPZmAsIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQm9vbGVhbmAsIGBpc0RhdGVgLCBgaXNFbGVtZW50YCxcbiAgICAgKiBgaXNFbXB0eWAsIGBpc0VxdWFsYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNOYU5gLCBgaXNOdWxsYCwgYGlzTnVtYmVyYCxcbiAgICAgKiBgaXNPYmplY3RgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsIGBpc1N0cmluZ2AsIGBpc1VuZGVmaW5lZGAsIGBqb2luYCxcbiAgICAgKiBgbGFzdEluZGV4T2ZgLCBgbWl4aW5gLCBgbm9Db25mbGljdGAsIGBwYXJzZUludGAsIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsXG4gICAgICogYHJlZHVjZVJpZ2h0YCwgYHJlc3VsdGAsIGBzaGlmdGAsIGBzaXplYCwgYHNvbWVgLCBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdW5lc2NhcGVgLCBgdW5pcXVlSWRgLCBhbmQgYHZhbHVlYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgZnVuY3Rpb25zIGBmaXJzdGAgYW5kIGBsYXN0YCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgd2hlbiBgbmAgaXNcbiAgICAgKiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZXkgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbmluZyBjYW4gYmUgZW5hYmxlZCBieSB1c2luZyB0aGUgYF8uY2hhaW5gIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDIsIDNdKTtcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYW4gdW53cmFwcGVkIHZhbHVlXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gcmV0dXJucyBhIHdyYXBwZWQgdmFsdWVcbiAgICAgKiB2YXIgc3F1YXJlcyA9IHdyYXBwZWQubWFwKGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAqIG51bTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgLy8gZG9uJ3Qgd3JhcCBpZiBhbHJlYWR5IHdyYXBwZWQsIGV2ZW4gaWYgd3JhcHBlZCBieSBhIGRpZmZlcmVudCBgbG9kYXNoYCBjb25zdHJ1Y3RvclxuICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdfX3dyYXBwZWRfXycpKVxuICAgICAgID8gdmFsdWVcbiAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZhc3QgcGF0aCBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjaGFpbkFsbCBBIGZsYWcgdG8gZW5hYmxlIGNoYWluaW5nIGZvciBhbGwgbWV0aG9kc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGZ1bmN0aW9ucyBjYW4gYmUgZGVjb21waWxlZCBieSBgRnVuY3Rpb24jdG9TdHJpbmdgXG4gICAgICogKGFsbCBidXQgUFMzIGFuZCBvbGRlciBPcGVyYSBtb2JpbGUgYnJvd3NlcnMgJiBhdm9pZGVkIGluIFdpbmRvd3MgOCBhcHBzKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnN1cHBvcnRcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgc3VwcG9ydC5mdW5jRGVjb21wID0gIXJlTmF0aXZlLnRlc3QoY29udGV4dC5XaW5SVEVycm9yKSAmJiByZVRoaXMudGVzdChydW5JbkNvbnRleHQpO1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNuYW1lYCBpcyBzdXBwb3J0ZWQgKGFsbCBidXQgSUUpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZ1bmNOYW1lcyA9IHR5cGVvZiBGdW5jdGlvbi5uYW1lID09ICdzdHJpbmcnO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBMby1EYXNoIGFyZSBzaW1pbGFyIHRvIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAgICogZGVsaW1pdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdldmFsdWF0ZSc6IC88JShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgUmVnRXhwXG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICdpbXBvcnRzJzoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5iaW5kYCB0aGF0IGNyZWF0ZXMgdGhlIGJvdW5kIGZ1bmN0aW9uIGFuZFxuICAgICAqIHNldHMgaXRzIG1ldGEgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYmluZERhdGEgVGhlIGJpbmQgZGF0YSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQmluZChiaW5kRGF0YSkge1xuICAgICAgdmFyIGZ1bmMgPSBiaW5kRGF0YVswXSxcbiAgICAgICAgICBwYXJ0aWFsQXJncyA9IGJpbmREYXRhWzJdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XTtcblxuICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgIC8vIGBGdW5jdGlvbiNiaW5kYCBzcGVjXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjVcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBwYXJ0aWFsQXJncy5zbGljZSgpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDEzLjIuMlxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGBuZXcgYm91bmRgIGlzIGFuIGluc3RhbmNlIG9mIGBmdW5jYFxuICAgICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoZnVuYy5wcm90b3R5cGUpLFxuICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzIHx8IGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBzZXRCaW5kRGF0YShib3VuZCwgYmluZERhdGEpO1xuICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgYHRoaXNBcmdgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyBjbG9uZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaW5zcGVjdCBbW0NsYXNzXV1cbiAgICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmIChpc09iaikge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgICBjYXNlIHN0cmluZ0NsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgICAgIGNhc2UgcmVnZXhwQ2xhc3M6XG4gICAgICAgICAgICByZXN1bHQgPSBjdG9yKHZhbHVlLnNvdXJjZSwgcmVGbGFncy5leGVjKHZhbHVlKSk7XG4gICAgICAgICAgICByZXN1bHQubGFzdEluZGV4ID0gdmFsdWUubGFzdEluZGV4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgICBzdGFja0EgfHwgKHN0YWNrQSA9IGdldEFycmF5KCkpO1xuICAgICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHZhbHVlLmxlbmd0aCkgOiB7fTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBpc0FyciA/IHNsaWNlKHZhbHVlKSA6IGFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIGFycmF5IHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYFxuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5kZXgnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbmRleCA9IHZhbHVlLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnaW5wdXQnKSkge1xuICAgICAgICAgIHJlc3VsdC5pbnB1dCA9IHZhbHVlLmlucHV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGJhc2VDbG9uZShvYmpWYWx1ZSwgaXNEZWVwLCBjYWxsYmFjaywgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuICAgIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGBPYmplY3QuY3JlYXRlYFxuICAgIGlmICghbmF0aXZlQ3JlYXRlKSB7XG4gICAgICBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBPYmplY3QoKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE9iamVjdDtcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGNvbnRleHQuT2JqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICB9KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZUNhbGxiYWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGNyZWF0aW5nXG4gICAgICogXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ0NvdW50XSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICAgIH1cbiAgICAgIC8vIGV4aXQgZWFybHkgZm9yIG5vIGB0aGlzQXJnYCBvciBhbHJlYWR5IGJvdW5kIGJ5IGBGdW5jdGlvbiNiaW5kYFxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8ICEoJ3Byb3RvdHlwZScgaW4gZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICB2YXIgYmluZERhdGEgPSBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmICh0eXBlb2YgYmluZERhdGEgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuZnVuY05hbWVzKSB7XG4gICAgICAgICAgYmluZERhdGEgPSAhZnVuYy5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGJpbmREYXRhID0gYmluZERhdGEgfHwgIXN1cHBvcnQuZnVuY0RlY29tcDtcbiAgICAgICAgaWYgKCFiaW5kRGF0YSkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBmblRvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgaWYgKCFzdXBwb3J0LmZ1bmNOYW1lcykge1xuICAgICAgICAgICAgYmluZERhdGEgPSAhcmVGdW5jTmFtZS50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYmluZERhdGEpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiBgZnVuY2AgcmVmZXJlbmNlcyB0aGUgYHRoaXNgIGtleXdvcmQgYW5kIHN0b3JlcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICBiaW5kRGF0YSA9IHJlVGhpcy50ZXN0KHNvdXJjZSk7XG4gICAgICAgICAgICBzZXRCaW5kRGF0YShmdW5jLCBiaW5kRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyBgdGhpc2AgcmVmZXJlbmNlcyBvciBgZnVuY2AgaXMgYm91bmRcbiAgICAgIGlmIChiaW5kRGF0YSA9PT0gZmFsc2UgfHwgKGJpbmREYXRhICE9PSB0cnVlICYmIGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGEsIGIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbmQoZnVuYywgdGhpc0FyZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZVdyYXBwZXJgIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBlciBhbmRcbiAgICAgKiBzZXRzIGl0cyBtZXRhIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJpbmREYXRhIFRoZSBiaW5kIGRhdGEgYXJyYXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNyZWF0ZVdyYXBwZXIoYmluZERhdGEpIHtcbiAgICAgIHZhciBmdW5jID0gYmluZERhdGFbMF0sXG4gICAgICAgICAgYml0bWFzayA9IGJpbmREYXRhWzFdLFxuICAgICAgICAgIHBhcnRpYWxBcmdzID0gYmluZERhdGFbMl0sXG4gICAgICAgICAgcGFydGlhbFJpZ2h0QXJncyA9IGJpbmREYXRhWzNdLFxuICAgICAgICAgIHRoaXNBcmcgPSBiaW5kRGF0YVs0XSxcbiAgICAgICAgICBhcml0eSA9IGJpbmREYXRhWzVdO1xuXG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGtleSA9IGZ1bmM7XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcztcbiAgICAgICAgaWYgKHBhcnRpYWxBcmdzKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBwYXJ0aWFsQXJncy5zbGljZSgpO1xuICAgICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbFJpZ2h0QXJncyB8fCBpc0N1cnJ5KSB7XG4gICAgICAgICAgYXJncyB8fCAoYXJncyA9IHNsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICAgIGlmIChwYXJ0aWFsUmlnaHRBcmdzKSB7XG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNDdXJyeSAmJiBhcmdzLmxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IDE2ICYgfjMyO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVXcmFwcGVyKFtmdW5jLCAoaXNDdXJyeUJvdW5kID8gYml0bWFzayA6IGJpdG1hc2sgJiB+MyksIGFyZ3MsIG51bGwsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3MgfHwgKGFyZ3MgPSBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoaXNCaW5kS2V5KSB7XG4gICAgICAgICAgZnVuYyA9IHRoaXNCaW5kaW5nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIHRoaXNCaW5kaW5nID0gYmFzZUNyZWF0ZShmdW5jLnByb3RvdHlwZSk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgc2V0QmluZERhdGEoYm91bmQsIGJpbmREYXRhKTtcbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5kaWZmZXJlbmNlYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgYXJyYXlcbiAgICAgKiBvZiB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIGFycmF5IG9mIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgaXNMYXJnZSA9IGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICB2YWx1ZXMgPSBjYWNoZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0xhcmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGluZGV4T2YodmFsdWVzLCB2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICByZWxlYXNlT2JqZWN0KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2tcbiAgICAgKiBzaG9ydGhhbmRzIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NoYWxsb3c9ZmFsc2VdIEEgZmxhZyB0byByZXN0cmljdCBmbGF0dGVuaW5nIHRvIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0PWZhbHNlXSBBIGZsYWcgdG8gcmVzdHJpY3QgZmxhdHRlbmluZyB0byBhcnJheXMgYW5kIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHN0YXJ0IGZyb20uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBpc1N0cmljdCwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSAoZnJvbUluZGV4IHx8IDApIC0gMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcidcbiAgICAgICAgICAgICYmIChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICAgIGlmICghaXNTaGFsbG93KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VGbGF0dGVuKHZhbHVlLCBpc1NoYWxsb3csIGlzU3RyaWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbEluZGV4ID0gLTEsXG4gICAgICAgICAgICAgIHZhbExlbmd0aCA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmVzSW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgcmVzdWx0Lmxlbmd0aCArPSB2YWxMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsrdmFsSW5kZXggPCB2YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlW3ZhbEluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgLCB3aXRob3V0IHN1cHBvcnQgZm9yIGB0aGlzQXJnYCBiaW5kaW5nLFxuICAgICAqIHRoYXQgYWxsb3dzIHBhcnRpYWwgXCJfLndoZXJlXCIgc3R5bGUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gYSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2lzV2hlcmU9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSBwZXJmb3JtaW5nIHBhcnRpYWwgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQT1bXV0gVHJhY2tzIHRyYXZlcnNlZCBgYWAgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAvLyB1c2VkIHRvIGluZGljYXRlIHRoYXQgd2hlbiBjb21wYXJpbmcgb2JqZWN0cywgYGFgIGhhcyBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyBvZiBgYmBcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgICBvdGhlclR5cGUgPSB0eXBlb2YgYjtcblxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICAgIShhICYmIG9iamVjdFR5cGVzW3R5cGVdKSAmJlxuICAgICAgICAgICEoYiAmJiBvYmplY3RUeXBlc1tvdGhlclR5cGVdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGF2b2lkaW5nIEVTMydzIEZ1bmN0aW9uI2NhbGwgYmVoYXZpb3JcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMy40LjRcbiAgICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhID09PSBiO1xuICAgICAgfVxuICAgICAgLy8gY29tcGFyZSBbW0NsYXNzXV0gbmFtZXNcbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpLFxuICAgICAgICAgIG90aGVyQ2xhc3MgPSB0b1N0cmluZy5jYWxsKGIpO1xuXG4gICAgICBpZiAoY2xhc3NOYW1lID09IGFyZ3NDbGFzcykge1xuICAgICAgICBjbGFzc05hbWUgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChvdGhlckNsYXNzID09IGFyZ3NDbGFzcykge1xuICAgICAgICBvdGhlckNsYXNzID0gb2JqZWN0Q2xhc3M7XG4gICAgICB9XG4gICAgICBpZiAoY2xhc3NOYW1lICE9IG90aGVyQ2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSBib29sQ2xhc3M6XG4gICAgICAgIGNhc2UgZGF0ZUNsYXNzOlxuICAgICAgICAgIC8vIGNvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAgIC8vIHRvIGAxYCBvciBgMGAgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEwLjYuNClcbiAgICAgICAgICAvLyB0cmVhdCBzdHJpbmcgcHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3QgaW5zdGFuY2VzIGFzIGVxdWFsXG4gICAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgfVxuICAgICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3M7XG4gICAgICBpZiAoIWlzQXJyKSB7XG4gICAgICAgIC8vIHVud3JhcCBhbnkgYGxvZGFzaGAgd3JhcHBlZCB2YWx1ZXNcbiAgICAgICAgdmFyIGFXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgICAgIGJXcmFwcGVkID0gaGFzT3duUHJvcGVydHkuY2FsbChiLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAoYVdyYXBwZWQgfHwgYldyYXBwZWQpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUlzRXF1YWwoYVdyYXBwZWQgPyBhLl9fd3JhcHBlZF9fIDogYSwgYldyYXBwZWQgPyBiLl9fd3JhcHBlZF9fIDogYiwgY2FsbGJhY2ssIGlzV2hlcmUsIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgICBpZiAoY2xhc3NOYW1lICE9IG9iamVjdENsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIE9wZXJhLCBgYXJndW1lbnRzYCBvYmplY3RzIGhhdmUgYEFycmF5YCBjb25zdHJ1Y3RvcnNcbiAgICAgICAgdmFyIGN0b3JBID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIGN0b3JCID0gYi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBub24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbFxuICAgICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiZcbiAgICAgICAgICAgICAgIShpc0Z1bmN0aW9uKGN0b3JBKSAmJiBjdG9yQSBpbnN0YW5jZW9mIGN0b3JBICYmIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckIpICYmXG4gICAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgY3ljbGljIHN0cnVjdHVyZXMgYXJlIGVxdWFsXG4gICAgICAvLyB0aGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMVxuICAgICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS4xMi4zKVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gYSkge1xuICAgICAgICAgIHJldHVybiBzdGFja0JbbGVuZ3RoXSA9PSBiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc2l6ZSA9IDA7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgICAvLyBhZGQgYGFgIGFuZCBgYmAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICBzdGFja0EucHVzaChhKTtcbiAgICAgIHN0YWNrQi5wdXNoKGIpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIHNpemUgPSBiLmxlbmd0aDtcblxuICAgICAgICAvLyBjb21wYXJlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeVxuICAgICAgICByZXN1bHQgPSBzaXplID09IGEubGVuZ3RoO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICBpZiAoaXNXaGVyZSkge1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgaWYgKChyZXN1bHQgPSBiYXNlSXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEocmVzdWx0ID0gYmFzZUlzRXF1YWwoYVtzaXplXSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIGRlZXAgY29tcGFyZSBvYmplY3RzIHVzaW5nIGBmb3JJbmAsIGluc3RlYWQgb2YgYGZvck93bmAsIHRvIGF2b2lkIGBPYmplY3Qua2V5c2BcbiAgICAgIC8vIHdoaWNoLCBpbiB0aGlzIGNhc2UsIGlzIG1vcmUgY29zdGx5XG4gICAgICBmb3JJbihiLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkpIHtcbiAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIC8vIGRlZXAgY29tcGFyZSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmIGJhc2VJc0VxdWFsKGFba2V5XSwgdmFsdWUsIGNhbGxiYWNrLCBpc1doZXJlLCBzdGFja0EsIHN0YWNrQikpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHJlc3VsdCAmJiAhaXNXaGVyZSkge1xuICAgICAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICAgICAgZm9ySW4oYSwgZnVuY3Rpb24odmFsdWUsIGtleSwgYSkge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIGBzaXplYCB3aWxsIGJlIGAtMWAgaWYgYGFgIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBgYmBcbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0ID0gLS1zaXplID4gLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5pdGVkU3RhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQSk7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBhcmd1bWVudCBqdWdnbGluZyBvciBzdXBwb3J0XG4gICAgICogZm9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2luZyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3N0YWNrQj1bXV0gQXNzb2NpYXRlcyB2YWx1ZXMgd2l0aCBzb3VyY2UgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKSB7XG4gICAgICAoaXNBcnJheShzb3VyY2UpID8gZm9yRWFjaCA6IGZvck93bikoc291cmNlLCBmdW5jdGlvbihzb3VyY2UsIGtleSkge1xuICAgICAgICB2YXIgZm91bmQsXG4gICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgLy8gYXZvaWQgbWVyZ2luZyBwcmV2aW91c2x5IG1lcmdlZCBjeWNsaWMgc291cmNlc1xuICAgICAgICAgIHZhciBzdGFja0xlbmd0aCA9IHN0YWNrQS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmICgoZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdGFja0Jbc3RhY2tMZW5ndGhdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIGlzU2hhbGxvdztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKChpc1NoYWxsb3cgPSB0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgPyAoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdKVxuICAgICAgICAgICAgICAgIDogKGlzUGxhaW5PYmplY3QodmFsdWUpID8gdmFsdWUgOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgYHNvdXJjZWAgYW5kIGFzc29jaWF0ZWQgYHZhbHVlYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgICAgICAgIHN0YWNrQS5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBpZiAoIWlzU2hhbGxvdykge1xuICAgICAgICAgICAgICBiYXNlTWVyZ2UodmFsdWUsIHNvdXJjZSwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IGFyZ3VtZW50IGp1Z2dsaW5nIG9yIHN1cHBvcnRcbiAgICAgKiBmb3IgcmV0dXJuaW5nIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGEgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gbWluICsgZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIG9yIGB0aGlzQXJnYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+PSBsYXJnZUFycmF5U2l6ZSAmJiBpbmRleE9mID09PSBiYXNlSW5kZXhPZixcbiAgICAgICAgICBzZWVuID0gKGNhbGxiYWNrIHx8IGlzTGFyZ2UpID8gZ2V0QXJyYXkoKSA6IHJlc3VsdDtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3JlYXRlQ2FjaGUoc2Vlbik7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIGluZGV4T2YgPSBjYWNoZUluZGV4T2Y7XG4gICAgICAgICAgc2VlbiA9IGNhY2hlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTGFyZ2UgPSBmYWxzZTtcbiAgICAgICAgICBzZWVuID0gY2FsbGJhY2sgPyBzZWVuIDogKHJlbGVhc2VBcnJheShzZWVuKSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBjYWxsYmFjayA/IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgYXJyYXkpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzU29ydGVkXG4gICAgICAgICAgICAgID8gIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gY29tcHV0ZWRcbiAgICAgICAgICAgICAgOiBpbmRleE9mKHNlZW4sIGNvbXB1dGVkKSA8IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayB8fCBpc0xhcmdlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzZWVuLmFycmF5KTtcbiAgICAgICAgcmVsZWFzZU9iamVjdChzZWVuKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhZ2dyZWdhdGVzIGEgY29sbGVjdGlvbiwgY3JlYXRpbmcgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgY29sbGVjdGlvblxuICAgICAqIHRocm91Z2ggYSBjYWxsYmFjay4gVGhlIGdpdmVuIGBzZXR0ZXJgIGZ1bmN0aW9uIHNldHMgdGhlIGtleXMgYW5kIHZhbHVlc1xuICAgICAqIG9mIHRoZSBjb21wb3NlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgc2V0dGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSwgY29sbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBzZXR0ZXIocmVzdWx0LCB2YWx1ZSwgY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGNvbGxlY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2BcbiAgICAgKiB3aXRoIGFuIG9wdGlvbmFsIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgbWV0aG9kIGZsYWdzIHRvIGNvbXBvc2UuXG4gICAgICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICAgICAqICAxIC0gYF8uYmluZGBcbiAgICAgKiAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogIDQgLSBgXy5jdXJyeWBcbiAgICAgKiAgOCAtIGBfLmN1cnJ5YCAoYm91bmQpXG4gICAgICogIDE2IC0gYF8ucGFydGlhbGBcbiAgICAgKiAgMzIgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZVxuICAgICAqICBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsUmlnaHRBcmdzXSBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlXG4gICAgICogIHByb3ZpZGVkIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIDEsXG4gICAgICAgICAgaXNCaW5kS2V5ID0gYml0bWFzayAmIDIsXG4gICAgICAgICAgaXNDdXJyeSA9IGJpdG1hc2sgJiA0LFxuICAgICAgICAgIGlzQ3VycnlCb3VuZCA9IGJpdG1hc2sgJiA4LFxuICAgICAgICAgIGlzUGFydGlhbCA9IGJpdG1hc2sgJiAxNixcbiAgICAgICAgICBpc1BhcnRpYWxSaWdodCA9IGJpdG1hc2sgJiAzMjtcblxuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWwgJiYgIXBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4xNjtcbiAgICAgICAgaXNQYXJ0aWFsID0gcGFydGlhbEFyZ3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcnRpYWxSaWdodCAmJiAhcGFydGlhbFJpZ2h0QXJncy5sZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+MzI7XG4gICAgICAgIGlzUGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0QXJncyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGJpbmREYXRhID0gZnVuYyAmJiBmdW5jLl9fYmluZERhdGFfXztcbiAgICAgIGlmIChiaW5kRGF0YSAmJiBiaW5kRGF0YSAhPT0gdHJ1ZSkge1xuICAgICAgICBiaW5kRGF0YSA9IGJpbmREYXRhLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gc2V0IGB0aGlzQmluZGluZ2AgaXMgbm90IHByZXZpb3VzbHkgYm91bmRcbiAgICAgICAgaWYgKGlzQmluZCAmJiAhKGJpbmREYXRhWzFdICYgMSkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs0XSA9IHRoaXNBcmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGlmIHByZXZpb3VzbHkgYm91bmQgYnV0IG5vdCBjdXJyZW50bHkgKHN1YnNlcXVlbnQgY3VycmllZCBmdW5jdGlvbnMpXG4gICAgICAgIGlmICghaXNCaW5kICYmIGJpbmREYXRhWzFdICYgMSkge1xuICAgICAgICAgIGJpdG1hc2sgfD0gODtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3VycmllZCBhcml0eSBpZiBub3QgeWV0IHNldFxuICAgICAgICBpZiAoaXNDdXJyeSAmJiAhKGJpbmREYXRhWzFdICYgNCkpIHtcbiAgICAgICAgICBiaW5kRGF0YVs1XSA9IGFyaXR5O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIGxlZnQgYXJndW1lbnRzXG4gICAgICAgIGlmIChpc1BhcnRpYWwpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzJdIHx8IChiaW5kRGF0YVsyXSA9IFtdKSwgcGFydGlhbEFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50c1xuICAgICAgICBpZiAoaXNQYXJ0aWFsUmlnaHQpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KGJpbmREYXRhWzNdIHx8IChiaW5kRGF0YVszXSA9IFtdKSwgcGFydGlhbFJpZ2h0QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgZmxhZ3NcbiAgICAgICAgYmluZERhdGFbMV0gfD0gYml0bWFzaztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIuYXBwbHkobnVsbCwgYmluZERhdGEpO1xuICAgICAgfVxuICAgICAgLy8gZmFzdCBwYXRoIGZvciBgXy5iaW5kYFxuICAgICAgdmFyIGNyZWF0ZXIgPSAoYml0bWFzayA9PSAxIHx8IGJpdG1hc2sgPT09IDE3KSA/IGJhc2VCaW5kIDogYmFzZUNyZWF0ZVdyYXBwZXI7XG4gICAgICByZXR1cm4gY3JlYXRlcihbZnVuYywgYml0bWFzaywgcGFydGlhbEFyZ3MsIHBhcnRpYWxSaWdodEFyZ3MsIHRoaXNBcmcsIGFyaXR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzZUluZGV4T2ZgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIFwiaW5kZXhPZlwiIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluZGV4T2YoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2VJbmRleE9mIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGB0aGlzYCBiaW5kaW5nIGRhdGEgb24gYSBnaXZlbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc2V0IGRhdGEgb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWUgVGhlIGRhdGEgYXJyYXkgdG8gc2V0LlxuICAgICAqL1xuICAgIHZhciBzZXRCaW5kRGF0YSA9ICFkZWZpbmVQcm9wZXJ0eSA/IG5vb3AgOiBmdW5jdGlvbihmdW5jLCB2YWx1ZSkge1xuICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgICAgZGVmaW5lUHJvcGVydHkoZnVuYywgJ19fYmluZERhdGFfXycsIGRlc2NyaXB0b3IpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB3aGljaCBjaGVja3MgaWYgYSBnaXZlbiB2YWx1ZVxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGltSXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIGN0b3IsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICAvLyBhdm9pZCBub24gT2JqZWN0IG9iamVjdHMsIGBhcmd1bWVudHNgIG9iamVjdHMsIGFuZCBET00gZWxlbWVudHNcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSB8fFxuICAgICAgICAgIChjdG9yID0gdmFsdWUuY29uc3RydWN0b3IsIGlzRnVuY3Rpb24oY3RvcikgJiYgIShjdG9yIGluc3RhbmNlb2YgY3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PSAndW5kZWZpbmVkJyB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyk7IH0pKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzIHx8IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLmlzQXJyYXkoYXJndW1lbnRzKTsgfSkoKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MgfHwgZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBwcm9kdWNlcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgdmFyIHNoaW1LZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpdGVyYWJsZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtleXMoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSk7XG4gICAgICogLy8gPT4gWydvbmUnLCAndHdvJywgJ3RocmVlJ10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzICovXG4gICAgdmFyIHJlRXNjYXBlZEh0bWwgPSBSZWdFeHAoJygnICsga2V5cyhodG1sVW5lc2NhcGVzKS5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cCgnWycgKyBrZXlzKGh0bWxFc2NhcGVzKS5qb2luKCcnKSArICddJywgJ2cnKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLiBJZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM7IChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnZnJlZCcgfSwgeyAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ24sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiB0eXBlb2YgYSA9PSAndW5kZWZpbmVkJyA/IGIgOiBhO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIGRlZmF1bHRzKG9iamVjdCwgeyAnbmFtZSc6ICdmcmVkJywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdlbXBsb3llcic6ICdzbGF0ZScgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayA/IGNhbGxiYWNrKHJlc3VsdFtpbmRleF0sIGl0ZXJhYmxlW2luZGV4XSkgOiBpdGVyYWJsZVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGlzRGVlcGAgaXMgYHRydWVgIG5lc3RlZCBvYmplY3RzIHdpbGwgYWxzb1xuICAgICAqIGJlIGNsb25lZCwgb3RoZXJ3aXNlIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBieSByZWZlcmVuY2UuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIHRoZVxuICAgICAqIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAgY2xvbmluZyB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcD1mYWxzZV0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKGNoYXJhY3RlcnMpO1xuICAgICAqIHNoYWxsb3dbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lKGNoYXJhY3RlcnMsIHRydWUpO1xuICAgICAqIGRlZXBbMF0gPT09IGNoYXJhY3RlcnNbMF07XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ2Nsb25lJzogXy5wYXJ0aWFsUmlnaHQoXy5jbG9uZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICAgcmV0dXJuIF8uaXNFbGVtZW50KHZhbHVlKSA/IHZhbHVlLmNsb25lTm9kZShmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICogICB9KVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZShkb2N1bWVudC5ib2R5KTtcbiAgICAgKiBjbG9uZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGlzRGVlcCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMgd2l0aG91dCB1c2luZyB0aGVpciBgaW5kZXhgXG4gICAgICAvLyBhbmQgYGNvbGxlY3Rpb25gIGFyZ3VtZW50cyBmb3IgYGlzRGVlcGAgYW5kIGBjYWxsYmFja2BcbiAgICAgIGlmICh0eXBlb2YgaXNEZWVwICE9ICdib29sZWFuJyAmJiBpc0RlZXAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gaXNEZWVwO1xuICAgICAgICBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgdHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicgJiYgYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlXG4gICAgICogZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlcy4gSWYgdGhlIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0b1xuICAgICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlIHN0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtLiBGdW5jdGlvbnNcbiAgICAgKiBhbmQgRE9NIG5vZGVzIGFyZSAqKm5vdCoqIGNsb25lZC4gVGhlIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFuZFxuICAgICAqIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhbiBgT2JqZWN0YCBhcmUgY2xvbmVkIHRvIHBsYWluIGBPYmplY3RgIG9iamVjdHMuXG4gICAgICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjaW50ZXJuYWwtc3RydWN0dXJlZC1jbG9uaW5nLWFsZ29yaXRobS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoY2hhcmFjdGVycyk7XG4gICAgICogZGVlcFswXSA9PT0gY2hhcmFjdGVyc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIHRydWUsIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nICYmIGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcbiAgICAgKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwgeyAnY29uc3RydWN0b3InOiBDaXJjbGUgfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA/IGFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZV0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgYGtleWAgYW5kIGBvYmplY3RgIGFyZ3VtZW50cyBhcyBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnYmFybmV5JyB9O1xuICAgICAqIF8uZGVmYXVsdHMob2JqZWN0LCB7ICduYW1lJzogJ2ZyZWQnLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmFybmV5JywgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkge1xuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2luZGV4XSA9PSAndW5kZWZpbmVkJykgcmVzdWx0W2luZGV4XSA9IGl0ZXJhYmxlW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudCB0aGF0IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG9cbiAgICAgKiAgY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiB7ICAnYWdlJzogMzYsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgICdmcmVkJzogeyAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgKiAgIHJldHVybiBjaHIuYWdlIDwgNDA7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRLZXkoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZEtleShjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIGZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxzdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0b1xuICAgICAqICBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6IHsgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6IHsgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zIGBwZWJibGVzYCwgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyBgYmFybmV5YFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEtleShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmluZExhc3RLZXkoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgZm9yT3duUmlnaHQob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0LFxuICAgICAqIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaGFwZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHRoaXMueCArPSB4O1xuICAgICAqICAgdGhpcy55ICs9IHk7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ3gnLCAneScsIGFuZCAnbW92ZScgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBjb2xsZWN0aW9uLCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIW9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0pIHJldHVybiByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2hhcGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICB0aGlzLnggKz0geDtcbiAgICAgKiAgIHRoaXMueSArPSB5O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IFNoYXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ21vdmUnLCAneScsIGFuZCAneCcgYXNzdW1pbmcgYF8uZm9ySW4gYCBsb2dzICd4JywgJ3knLCBhbmQgJ21vdmUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcblxuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHBhaXJzLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcbiAgICAgIGNhbGxiYWNrID0gYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoY2FsbGJhY2socGFpcnNbbGVuZ3RoLS1dLCBwYWlyc1tsZW5ndGhdLCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QsIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2tcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBsb2dzICcwJywgJzEnLCBhbmQgJ2xlbmd0aCcgKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogYmFzZUNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQoeyAnMCc6ICd6ZXJvJywgJzEnOiAnb25lJywgJ2xlbmd0aCc6IDIgfSwgZnVuY3Rpb24obnVtLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gbG9ncyAnbGVuZ3RoJywgJzEnLCBhbmQgJzAnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnMCcsICcxJywgYW5kICdsZW5ndGgnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdO1xuICAgICAgICBpZiAoY2FsbGJhY2sob2JqZWN0W2tleV0sIGtleSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQsIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBgcHJvcGVydHlgIGV4aXN0cyBhbmQgaXMgYSBkaXJlY3QgcHJvcGVydHksXG4gICAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICBfLmludmVydCh7ICdmaXJzdCc6ICdmcmVkJywgJ3NlY29uZCc6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiAnZmlyc3QnLCAnYmFybmV5JzogJ3NlY29uZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmVydChvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W29iamVjdFtrZXldXSA9IGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBkYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBkYXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGRhdGVDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZW1wdHkuIEFycmF5cywgc3RyaW5ncywgb3IgYGFyZ3VtZW50c2Agb2JqZWN0cyB3aXRoIGFcbiAgICAgKiBsZW5ndGggb2YgYDBgIGFuZCBvYmplY3RzIHdpdGggbm8gb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgY29uc2lkZXJlZFxuICAgICAqIFwiZW1wdHlcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KCcnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICBpZiAoKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzIHx8IGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gYXJnc0NsYXNzICkgfHxcbiAgICAgICAgICAoY2xhc3NOYW1lID09IG9iamVjdENsYXNzICYmIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgaXNGdW5jdGlvbih2YWx1ZS5zcGxpY2UpKSkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvck93bih2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXIuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZFxuICAgICAqIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgdW5kZWZpbmVkYCBjb21wYXJpc29ucyB3aWxsXG4gICAgICogYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM7IChhLCBiKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gYiBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaW5nIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqIHZhciBjb3B5ID0geyAnbmFtZSc6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogb2JqZWN0ID09IGNvcHk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIGNvcHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB3b3JkcyA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlcldvcmRzID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwod29yZHMsIG90aGVyV29yZHMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHZhciByZUdyZWV0ID0gL14oPzpoZWxsb3xoaSkkL2ksXG4gICAgICogICAgICAgYUdyZWV0ID0gXy5pc1N0cmluZyhhKSAmJiByZUdyZWV0LnRlc3QoYSksXG4gICAgICogICAgICAgYkdyZWV0ID0gXy5pc1N0cmluZyhiKSAmJiByZUdyZWV0LnRlc3QoYik7XG4gICAgICpcbiAgICAgKiAgIHJldHVybiAoYUdyZWV0IHx8IGJHcmVldCkgPyAoYUdyZWV0ID09IGJHcmVldCkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbChhLCBiLCB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcywgb3IgY2FuIGJlIGNvZXJjZWQgdG8sIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNGaW5pdGVgIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi41LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZmluaXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBsYW5ndWFnZSB0eXBlIG9mIE9iamVjdC5cbiAgICAgKiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCgxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGUgdmFsdWUgaXMgdGhlIEVDTUFTY3JpcHQgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3RcbiAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4OFxuICAgICAgLy8gYW5kIGF2b2lkIGEgVjggYnVnXG4gICAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxXG4gICAgICByZXR1cm4gISEodmFsdWUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzTmFOYCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1lcmljIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBgTmFOYCBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLiBTZWUgaHR0cDovL2VzNS5naXRodWIuaW8vI3g4LjUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgU2hhcGUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSB0eXBlb2YgdmFsdWVPZiA9PSAnZnVuY3Rpb24nICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2ZyZWQvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gcmVnZXhwQ2xhc3MgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdDbGFzcyB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzXG4gICAgICogd2lsbCBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy4gSWYgYSBjYWxsYmFjayBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBhbmQgc291cmNlIHByb3BlcnRpZXMuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgIG1lcmdpbmcgd2lsbFxuICAgICAqIGJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBuYW1lcyA9IHtcbiAgICAgKiAgICdjaGFyYWN0ZXJzJzogW1xuICAgICAqICAgICB7ICduYW1lJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBhZ2VzID0ge1xuICAgICAqICAgJ2NoYXJhY3RlcnMnOiBbXG4gICAgICogICAgIHsgJ2FnZSc6IDM2IH0sXG4gICAgICogICAgIHsgJ2FnZSc6IDQwIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShuYW1lcywgYWdlcyk7XG4gICAgICogLy8gPT4geyAnY2hhcmFjdGVycyc6IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LCB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV0gfVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydhcHBsZSddLFxuICAgICAqICAgJ3ZlZ2V0YWJsZXMnOiBbJ2JlZXQnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXJGb29kID0ge1xuICAgICAqICAgJ2ZydWl0cyc6IFsnYmFuYW5hJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnY2Fycm90J11cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShmb29kLCBvdGhlckZvb2QsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzQXJyYXkoYSkgPyBhLmNvbmNhdChiKSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcnVpdHMnOiBbJ2FwcGxlJywgJ2JhbmFuYSddLCAndmVnZXRhYmxlcyc6IFsnYmVldCcsICdjYXJyb3RdIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZShvYmplY3QpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IDI7XG5cbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFuZCBgY29sbGVjdGlvbmAgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gIT0gJ251bWJlcicpIHtcbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGJhc2VDcmVhdGVDYWxsYmFjayhhcmdzWy0tbGVuZ3RoIC0gMV0sIGFyZ3NbbGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1stLWxlbmd0aF07XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlcyA9IHNsaWNlKGFyZ3VtZW50cywgMSwgbGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCksXG4gICAgICAgICAgc3RhY2tCID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlc1tpbmRleF0sIGNhbGxiYWNrLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgIHJlbGVhc2VBcnJheShzdGFja0IpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIG9taXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5XG4gICAgICogZm9yLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258Li4uc3RyaW5nfHN0cmluZ1tdfSBbY2FsbGJhY2tdIFRoZSBwcm9wZXJ0aWVzIHRvIG9taXQgb3IgdGhlXG4gICAgICogIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJyB9XG4gICAgICpcbiAgICAgKiBfLm9taXQoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXQob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9wcyA9IGJhc2VEaWZmZXJlbmNlKHByb3BzLCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBhbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAgICogaS5lLiBgW1trZXkxLCB2YWx1ZTFdLCBba2V5MiwgdmFsdWUyXV1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgbmV3IGFycmF5IG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWlycyh7ICdiYXJuZXknOiAzNiwgJ2ZyZWQnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFpcnMob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgY29tcG9zZWQgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mXG4gICAgICogcHJvcGVydHkgbmFtZXMuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaFxuICAgICAqIHByb3BlcnR5IG9mIGBvYmplY3RgIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXlcbiAgICAgKiBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnwuLi5zdHJpbmd8c3RyaW5nW119IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWVzIHRvIHBpY2ssIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIHByb3BlcnR5XG4gICAgICogIG5hbWVzIG9yIGFycmF5cyBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2ZyZWQnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ2ZyZWQnLCAnX3VzZXJpZCc6ICdmcmVkMScgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleS5jaGFyQXQoMCkgIT0gJ18nO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnZnJlZCcgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGlzT2JqZWN0KG9iamVjdCkgPyBwcm9wcy5sZW5ndGggOiAwO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSwgb2JqZWN0KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgIHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgZWxlbWVudHNcbiAgICAgKiB0aHJvdWdoIGEgY2FsbGJhY2ssIHdpdGggZWFjaCBjYWxsYmFjayBleGVjdXRpb24gcG90ZW50aWFsbHkgbXV0YXRpbmdcbiAgICAgKiB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuIENhbGxiYWNrcyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNxdWFyZXMgPSBfLnRyYW5zZm9ybShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLCBmdW5jdGlvbihyZXN1bHQsIG51bSkge1xuICAgICAqICAgbnVtICo9IG51bTtcbiAgICAgKiAgIGlmIChudW0gJSAyKSB7XG4gICAgICogICAgIHJldHVybiByZXN1bHQucHVzaChudW0pIDwgMztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgOSwgMjVdXG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICAgIHByb3RvID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZTtcblxuICAgICAgICAgIGFjY3VtdWxhdG9yID0gYmFzZUNyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBvYmplY3RbcHJvcHNbaW5kZXhdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleGVzLCBvciBrZXlzLCBvZiB0aGVcbiAgICAgKiBgY29sbGVjdGlvbmAuIEluZGV4ZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW118c3RyaW5nfHN0cmluZ1tdKX0gW2luZGV4XSBUaGUgaW5kZXhlcyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiAgIHRvIHJldHJpZXZlLCBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBpbmRleGVzIG9yIGFycmF5cyBvZiBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddLCAwLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXQoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGJhc2VGbGF0dGVuKGFyZ3MsIHRydWUsIGZhbHNlLCAxKSxcbiAgICAgICAgICBsZW5ndGggPSAoYXJnc1syXSAmJiBhcmdzWzJdW2FyZ3NbMV1dID09PSBjb2xsZWN0aW9uKSA/IDEgOiBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIGEgY29sbGVjdGlvbiB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH0sICdmcmVkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygncGViYmxlcycsICdlYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uLmluZGV4T2YodGFyZ2V0LCBmcm9tSW5kZXgpIDogaW5kZXhPZihjb2xsZWN0aW9uLCB0YXJnZXQsIGZyb21JbmRleCkpID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoKytpbmRleCA+PSBmcm9tSW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IHZhbHVlID09PSB0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgICogb2YgZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suXG4gICAgICogVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50cztcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgcmV0dXJucyB0cnVleSB2YWx1ZSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzZWQgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSAhIWNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5IGZvci4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBzZWxlY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGV2ZW5zID0gXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDM2IH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50IHRoYXRcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3IuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZGV0ZWN0LCBmaW5kV2hlcmVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYmxvY2tlZCc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCA0MDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoY2hhcmFjdGVycywgeyAnYWdlJzogMSB9KTtcbiAgICAgKiAvLyA9PiAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2FnZSc6IDEsICdibG9ja2VkJzogZmFsc2UgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBhIGNvbGxlY3Rpb24sIGV4ZWN1dGluZyB0aGUgY2FsbGJhY2sgZm9yIGVhY2hcbiAgICAgKiBlbGVtZW50LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzO1xuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieVxuICAgICAqIGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBgbGVuZ3RoYCBwcm9wZXJ0eVxuICAgICAqIGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciBgXy5mb3JJbmAgb3IgYF8uZm9yT3duYFxuICAgICAqIG1heSBiZSB1c2VkIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R8c3RyaW5nfSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLmZvckVhY2goZnVuY3Rpb24obnVtKSB7IGNvbnNvbGUubG9nKG51bSk7IH0pLmpvaW4oJywnKTtcbiAgICAgKiAvLyA9PiBsb2dzIGVhY2ggbnVtYmVyIGFuZCByZXR1cm5zICcxLDIsMydcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgY29uc29sZS5sb2cobnVtKTsgfSk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyB0aGUgb2JqZWN0IChwcm9wZXJ0eSBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZW52aXJvbm1lbnRzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGJhc2VDcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYSBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxzdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaFJpZ2h0KGZ1bmN0aW9uKG51bSkgeyBjb25zb2xlLmxvZyhudW0pOyB9KS5qb2luKCcsJyk7XG4gICAgICogLy8gPT4gbG9ncyBlYWNoIG51bWJlciBmcm9tIHJpZ2h0IHRvIGxlZnQgYW5kIHJldHVybnMgJzMsMiwxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnID8gY2FsbGJhY2sgOiBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25bbGVuZ3RoXSwgbGVuZ3RoLCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGtleSA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICAqIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIHRoZSBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuNF0gfVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogcmVzdWx0W2tleV0gPSBbXSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgZ2l2ZW4gY2FsbGJhY2suIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LlxuICAgICAqIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGtleXMgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5pbmRleEJ5KGtleXMsIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXkuY29kZSk7IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8uaW5kZXhCeShjaGFyYWN0ZXJzLCBmdW5jdGlvbihrZXkpIHsgdGhpcy5mcm9tQ2hhckNvZGUoa2V5LmNvZGUpOyB9LCBTdHJpbmcpO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIgaW5kZXhCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIG5hbWVkIGJ5IGBtZXRob2ROYW1lYCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYFxuICAgICAqIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIHdpbGwgYmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXRcbiAgICAgKiB3aWxsIGJlIGludm9rZWQgZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gdGhlIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZShbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW52b2tlKGNvbGxlY3Rpb24sIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBtZXRob2ROYW1lID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gKGlzRnVuYyA/IG1ldGhvZE5hbWUgOiB2YWx1ZVttZXRob2ROYW1lXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICogdGhyb3VnaCB0aGUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgY29sbGVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgNiwgOV0gKHByb3BlcnR5IG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkIGFjcm9zcyBlbnZpcm9ubWVudHMpXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWFwKGNoYXJhY3RlcnMsICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eSBvclxuICAgICAqIGZhbHNleSBgLUluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWF4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChjaGFyYWN0ZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGEgY29sbGVjdGlvbi4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgb3JcbiAgICAgKiBmYWxzZXkgYEluZmluaXR5YCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGNvbGxlY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWVcbiAgICAgKiBpcyByYW5rZWQuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubWluKGNoYXJhY3RlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZWQ7XG5cbiAgICAgIC8vIGFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nXG4gICAgICAvLyB0aGVpciBgaW5kZXhgIGFyZ3VtZW50IGFzIGEgY2FsbGJhY2tcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJyAmJiB0aGlzQXJnICYmIHRoaXNBcmdbY2FsbGJhY2tdID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IChjYWxsYmFjayA9PSBudWxsICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGFsbCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIHBsdWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wbHVjayhjaGFyYWN0ZXJzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBsdWNrKGNvbGxlY3Rpb24sIHByb3BlcnR5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltpbmRleF1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0IHx8IG1hcChjb2xsZWN0aW9uLCBwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBhIGNvbGxlY3Rpb24gdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGNhbGxiYWNrIGV4ZWN1dGlvbiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBleGVjdXRpb24uIElmXG4gICAgICogYGFjY3VtdWxhdG9yYCBpcyBub3QgcHJvdmlkZWQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvbGxlY3Rpb24gd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIGluaXRpYWwgYGFjY3VtdWxhdG9yYCB2YWx1ZS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgICAqIGFuZCBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM7IChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZGwsIGluamVjdFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIEluaXRpYWwgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24oc3VtLCBudW0pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBudW07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogdmFyIG1hcHBlZCA9IF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCBmdW5jdGlvbihyZXN1bHQsIG51bSwga2V5KSB7XG4gICAgICogICByZXN1bHRba2V5XSA9IG51bSAqIDM7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBjYWxsYmFjaywgYWNjdW11bGF0b3IsIHRoaXNBcmcpIHtcbiAgICAgIGlmICghY29sbGVjdGlvbikgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChub2FjY3VtKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjb2xsZWN0aW9uWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBhIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgZm9sZHJcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsaXN0ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCA0KTtcbiAgICAgIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBub2FjY3VtXG4gICAgICAgICAgPyAobm9hY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYVxuICAgICAqIGNvbGxlY3Rpb24gdGhhdCB0aGUgY2FsbGJhY2sgZG9lcyAqKm5vdCoqIHJldHVybiB0cnVleSBmb3IuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBmYWlsZWQgdGhlIGNhbGxiYWNrIGNoZWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2RkcyA9IF8ucmVqZWN0KFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdibG9ja2VkJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnJlamVjdChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHJldHVybiBmaWx0ZXIoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHJhbmRvbSBlbGVtZW50IG9yIGBuYCByYW5kb20gZWxlbWVudHMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEFsbG93cyB3b3JraW5nIHdpdGggZnVuY3Rpb25zIGxpa2UgYF8ubWFwYFxuICAgICAqICB3aXRob3V0IHVzaW5nIHRoZWlyIGBpbmRleGAgYXJndW1lbnRzIGFzIGBuYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBzYW1wbGUocykgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggIT0gJ251bWJlcicpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uW2Jhc2VSYW5kb20oMCwgY29sbGVjdGlvbi5sZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2h1ZmZsZShjb2xsZWN0aW9uKTtcbiAgICAgIHJlc3VsdC5sZW5ndGggPSBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIG4pLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGUgRmlzaGVyLVlhdGVzXG4gICAgICogc2h1ZmZsZS4gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgc2h1ZmZsZWQgY29sbGVjdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0LCA1LCA2XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiAwKTtcblxuICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oMCwgKytpbmRleCk7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSByZXN1bHRbcmFuZF07XG4gICAgICAgIHJlc3VsdFtyYW5kXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgdGhlIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgYGNvbGxlY3Rpb24ubGVuZ3RoYCBmb3IgYXJyYXlzXG4gICAgICogYW5kIGFycmF5LWxpa2Ugb2JqZWN0cyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGBjb2xsZWN0aW9uLmxlbmd0aGAgb3IgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1ZXkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogY29sbGVjdGlvbi4gVGhlIGZ1bmN0aW9uIHJldHVybnMgYXMgc29vbiBhcyBpdCBmaW5kcyBhIHBhc3NpbmcgdmFsdWUgYW5kXG4gICAgICogZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgY29sbGVjdGlvbi4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvXG4gICAgICogYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkXG4gICAgICogIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYmxvY2tlZCc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb21lKGNoYXJhY3RlcnMsIHsgJ2FnZSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICgocmVzdWx0ID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yT3duKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiAhKHJlc3VsdCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocm91Z2ggdGhlIGNhbGxiYWNrLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHdpbGwgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBlcXVhbCBlbGVtZW50cy4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2Ygc29ydGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gTWF0aC5zaW4obnVtKTsgfSk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeShbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5zaW4obnVtKTsgfSwgTWF0aCk7XG4gICAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRCeShbJ2JhbmFuYScsICdzdHJhd2JlcnJ5JywgJ2FwcGxlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiBbJ2FwcGxlJywgJ2JhbmFuYScsICdzdHJhd2JlcnJ5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0QnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHJlc3VsdFsrK2luZGV4XSA9IGdldE9iamVjdCgpO1xuICAgICAgICBvYmplY3QuY3JpdGVyaWEgPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgb2JqZWN0LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG5cbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQuc29ydChjb21wYXJlQXNjZW5kaW5nKTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICByZWxlYXNlT2JqZWN0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBgY29sbGVjdGlvbmAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDEpOyB9KSgxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uICYmIHR5cGVvZiBjb2xsZWN0aW9uLmxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gc2xpY2UoY29sbGVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIG9mIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAncGV0cyc6IFsnaG9wcHknXSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAnYWdlJzogNDAsICdwZXRzJzogWydiYWJ5IHB1c3MnLCAnZGlubyddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYsICdwZXRzJzogWydob3BweSddIH1dXG4gICAgICpcbiAgICAgKiBfLndoZXJlKGNoYXJhY3RlcnMsIHsgJ3BldHMnOiBbJ2Rpbm8nXSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwLCAncGV0cyc6IFsnYmFieSBwdXNzJywgJ2Rpbm8nXSB9XVxuICAgICAqL1xuICAgIHZhciB3aGVyZSA9IGZpbHRlcjtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBhbGwgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBhcnJheXMgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSBhcnJheXMgb2YgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYmxvY2tlZCc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPCAyMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCB7ICdhZ2UnOiAzNiB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRJbmRleChjaGFyYWN0ZXJzLCAnYmxvY2tlZCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGEgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2Jsb2NrZWQnOiB0cnVlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdibG9ja2VkJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2Jsb2NrZWQnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsIGZ1bmN0aW9uKGNocikge1xuICAgICAqICAgcmV0dXJuIGNoci5hZ2UgPiAzMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgoY2hhcmFjdGVycywgeyAnYWdlJzogMzYgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kTGFzdEluZGV4KGNoYXJhY3RlcnMsICdibG9ja2VkJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9yIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFja1xuICAgICAqIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSByZXR1cm5lZCBhcyBsb25nXG4gICAgICogYXMgdGhlIGNhbGxiYWNrIHJldHVybnMgdHJ1ZXkuIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgaGVhZCwgdGFrZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpcnN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICdzbGF0ZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5maXJzdChjaGFyYWN0ZXJzLCB7ICdlbXBsb3llcic6ICdzbGF0ZScgfSksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gY2FsbGJhY2s7XG4gICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgIHJldHVybiBhcnJheSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnVleSwgdGhlIGFycmF5IHdpbGwgb25seSBiZSBmbGF0dGVuZWQgYSBzaW5nbGUgbGV2ZWwuIElmIGEgY2FsbGJhY2tcbiAgICAgKiBpcyBwcm92aWRlZCBlYWNoIGVsZW1lbnQgb2YgdGhlIGFycmF5IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmVcbiAgICAgKiBmbGF0dGVuaW5nLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU2hhbGxvdz1mYWxzZV0gQSBmbGFnIHRvIHJlc3RyaWN0IGZsYXR0ZW5pbmcgdG8gYSBzaW5nbGUgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFtbNF1dXTtcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzAsICdwZXRzJzogWydob3BweSddIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ3BldHMnOiBbJ2JhYnkgcHVzcycsICdkaW5vJ10gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZsYXR0ZW4oY2hhcmFjdGVycywgJ3BldHMnKTtcbiAgICAgKiAvLyA9PiBbJ2hvcHB5JywgJ2JhYnkgcHVzcycsICdkaW5vJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBpc1NoYWxsb3csIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGlzU2hhbGxvdyAhPSAnYm9vbGVhbicgJiYgaXNTaGFsbG93ICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgaXNTaGFsbG93ICE9ICdmdW5jdGlvbicgJiYgdGhpc0FyZyAmJiB0aGlzQXJnW2lzU2hhbGxvd10gPT09IGFycmF5KSA/IG51bGwgOiBpc1NoYWxsb3c7XG4gICAgICAgIGlzU2hhbGxvdyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXkgPSBtYXAoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgaXNTaGFsbG93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIGFscmVhZHkgc29ydGVkXG4gICAgICogcHJvdmlkaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtib29sZWFufG51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgXG4gICAgICogIHRvIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4IHx8IDApO1xuICAgICAgfSBlbHNlIGlmIChmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2luZGV4XSA9PT0gdmFsdWUgPyBpbmRleCA6IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvciBsYXN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYVxuICAgICAqIGNhbGxiYWNrIGlzIHByb3ZpZGVkIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tXG4gICAgICogdGhlIHJlc3VsdCBhcyBsb25nIGFzIHRoZSBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmRcbiAgICAgKiB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxudW1iZXJ8c3RyaW5nfSBbY2FsbGJhY2s9MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgICdibG9ja2VkJzogZmFsc2UsICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgICdlbXBsb3llcic6ICduYScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiBmYWxzZSwgJ2VtcGxveWVyJzogJ3NsYXRlJyB9XVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmluaXRpYWwoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pLCAnbmFtZScpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdudW1iZXInICYmIGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IChjYWxsYmFjayA9PSBudWxsIHx8IHRoaXNBcmcpID8gMSA6IGNhbGxiYWNrIHx8IG47XG4gICAgICB9XG4gICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbiksIGxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyBwcmVzZW50IGluIGFsbCBwcm92aWRlZCBhcnJheXMgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheV0gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBjb21wb3NpdGUgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFsxMDEsIDIsIDEsIDEwXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBjYWNoZXMgPSBnZXRBcnJheSgpLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IGdldEFycmF5KCk7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBjYWNoZXNbYXJnc0luZGV4XSA9IGluZGV4T2YgPT09IGJhc2VJbmRleE9mICYmXG4gICAgICAgICAgKHZhbHVlID8gdmFsdWUubGVuZ3RoIDogMCkgPj0gbGFyZ2VBcnJheVNpemUgJiZcbiAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9yIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGFuIGFycmF5LiBJZiBhIGNhbGxiYWNrIGlzXG4gICAgICogcHJvdmlkZWQgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogY2FsbGJhY2sgcmV0dXJucyB0cnVleS4gVGhlIGNhbGxiYWNrIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQgZm9yIGBjYWxsYmFja2AgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8bnVtYmVyfHN0cmluZ30gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPiAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogdmFyIGNoYXJhY3RlcnMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2Jhcm5leScsICAnYmxvY2tlZCc6IGZhbHNlLCAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnc2xhdGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICAnZW1wbG95ZXInOiAnbmEnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5wbHVjayhfLmxhc3QoY2hhcmFjdGVycywgJ2Jsb2NrZWQnKSwgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoY2hhcmFjdGVycywgeyAnZW1wbG95ZXInOiAnbmEnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ3BlYmJsZXMnLCAnYmxvY2tlZCc6IHRydWUsICdlbXBsb3llcic6ICduYScgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDMpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG4gPT0gbnVsbCB8fCB0aGlzQXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBwcm92aWRlZCB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgdXNpbmcgc3RyaWN0IGVxdWFsaXR5IGZvclxuICAgICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgMSwgMiwgM107XG4gICAgICogXy5wdWxsKGFycmF5LCAyLCAzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbChhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0luZGV4ID0gMCxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleC0tLCAxKTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgZW5kYC4gSWYgYHN0YXJ0YCBpcyBsZXNzIHRoYW4gYHN0b3BgIGFcbiAgICAgKiB6ZXJvLWxlbmd0aCByYW5nZSBpcyBjcmVhdGVkIHVubGVzcyBhIG5lZ2F0aXZlIGBzdGVwYCBpcyBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9IHR5cGVvZiBzdGVwID09ICdudW1iZXInID8gc3RlcCA6ICgrc3RlcCB8fCAxKTtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICAvLyB1c2UgYEFycmF5KGxlbmd0aClgIHNvIGVuZ2luZXMgbGlrZSBDaGFrcmEgYW5kIFY4IGF2b2lkIHNsb3dlciBtb2Rlc1xuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgdGhhdCB0aGUgY2FsbGJhY2sgcmV0dXJucyB0cnVleSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDQsIDZdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgtLSwgMSk7XG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgIHRoaXMgbWV0aG9kIGdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvclxuICAgICAqIGZpcnN0IGBuYCBlbGVtZW50cyBvZiBhbiBhcnJheS4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZCBlbGVtZW50c1xuICAgICAqIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGVcbiAgICAgKiBjYWxsYmFjayByZXR1cm5zIHRydWV5LiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fG51bWJlcnxzdHJpbmd9IFtjYWxsYmFjaz0xXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXhjbHVkZS4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtIDwgMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2Jsb2NrZWQnOiB0cnVlLCAgJ2VtcGxveWVyJzogJ3NsYXRlJyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdmcmVkJywgICAgJ2Jsb2NrZWQnOiBmYWxzZSwgICdlbXBsb3llcic6ICdzbGF0ZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdibG9ja2VkJzogdHJ1ZSwgJ2VtcGxveWVyJzogJ25hJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucGx1Y2soXy5yZXN0KGNoYXJhY3RlcnMsICdibG9ja2VkJyksICduYW1lJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGNoYXJhY3RlcnMsIHsgJ2VtcGxveWVyJzogJ3NsYXRlJyB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdwZWJibGVzJywgJ2Jsb2NrZWQnOiB0cnVlLCAnZW1wbG95ZXInOiAnbmEnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCBhIHZhbHVlXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYSBnaXZlbiBzb3J0ZWQgYXJyYXkgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnRcbiAgICAgKiBvcmRlciBvZiB0aGUgYXJyYXkuIElmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQgaXQgd2lsbCBiZSBleGVjdXRlZCBmb3JcbiAgICAgKiBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlXG4gICAgICogY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGZvciBgY2FsbGJhY2tgIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBkaWN0ID0ge1xuICAgICAqICAgJ3dvcmRUb051bWJlcic6IHsgJ3R3ZW50eSc6IDIwLCAndGhpcnR5JzogMzAsICdmb3VydHknOiA0MCwgJ2ZpZnR5JzogNTAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFsndHdlbnR5JywgJ3RoaXJ0eScsICdmaWZ0eSddLCAnZm91cnR5JywgZnVuY3Rpb24od29yZCkge1xuICAgICAqICAgcmV0dXJuIGRpY3Qud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gdGhpcy53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSwgZGljdCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IGxvdztcblxuICAgICAgLy8gZXhwbGljaXRseSByZWZlcmVuY2UgYGlkZW50aXR5YCBmb3IgYmV0dGVyIGlubGluaW5nIGluIEZpcmVmb3hcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpIDogaWRlbnRpdHk7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlKTtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcbiAgICAgICAgKGNhbGxiYWNrKGFycmF5W21pZF0pIDwgdmFsdWUpXG4gICAgICAgICAgPyBsb3cgPSBtaWQgKyAxXG4gICAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiB0aGUgcHJvdmlkZWQgYXJyYXlzIHVzaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXldIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgY29tcG9zaXRlIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMSwgMiwgM10sIFsxMDEsIDIsIDEsIDEwXSwgWzIsIDFdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgMTAxLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlvbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5IHVzaW5nIHN0cmljdCBlcXVhbGl0eVxuICAgICAqIGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgdGhlIGFycmF5IGlzIHNvcnRlZCwgcHJvdmlkaW5nXG4gICAgICogYHRydWVgIGZvciBgaXNTb3J0ZWRgIHdpbGwgdXNlIGEgZmFzdGVyIGFsZ29yaXRobS4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZFxuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBiZWZvcmUgdW5pcXVlbmVzc1xuICAgICAqIGlzIGNvbXB1dGVkLiBUaGUgY2FsbGJhY2sgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCBmb3IgYGNhbGxiYWNrYCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgYGFycmF5YCBpcyBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8c3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWRcbiAgICAgKiAgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCAhPSAnYm9vbGVhbicgJiYgaXNTb3J0ZWQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gKHR5cGVvZiBpc1NvcnRlZCAhPSAnZnVuY3Rpb24nICYmIHRoaXNBcmcgJiYgdGhpc0FyZ1tpc1NvcnRlZF0gPT09IGFycmF5KSA/IG51bGwgOiBpc1NvcnRlZDtcbiAgICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnLCAzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShhcnJheSwgaXNTb3J0ZWQsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgcHJvdmlkZWQgdmFsdWVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3JcbiAgICAgKiBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAgICogLy8gPT4gWzIsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VEaWZmZXJlbmNlKGFycmF5LCBzbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdW56aXBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5XSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snZnJlZCcsIDMwLCB0cnVlXSwgWydiYXJuZXknLCA0MCwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcCgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzIDogYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBtYXgocGx1Y2soYXJyYXksICdsZW5ndGgnKSkgOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIGZyb20gYXJyYXlzIG9mIGBrZXlzYCBhbmQgYHZhbHVlc2AuIFByb3ZpZGVcbiAgICAgKiBlaXRoZXIgYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LCBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWBcbiAgICAgKiBvciB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydmcmVkJywgJ2Jhcm5leSddLCBbMzAsIDQwXSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDMwLCAnYmFybmV5JzogNDAgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChrZXlzLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkpIHtcbiAgICAgICAgICByZXN1bHRba2V5WzBdXSA9IGtleVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGBmdW5jYCwgd2l0aCAgdGhlIGB0aGlzYCBiaW5kaW5nIGFuZFxuICAgICAqIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgb25seSBhZnRlciBiZWluZyBjYWxsZWQgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGJlZm9yZVxuICAgICAqICBgZnVuY2AgaXMgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdEb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGxvZ3MgJ0RvbmUgc2F2aW5nIScsIGFmdGVyIGFsbCBzYXZlcyBoYXZlIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZVxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBib3VuZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogZnVuYyA9IF8uYmluZChmdW5jLCB7ICduYW1lJzogJ2ZyZWQnIH0sICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMlxuICAgICAgICA/IGNyZWF0ZVdyYXBwZXIoZnVuYywgMTcsIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIHRoaXNBcmcpXG4gICAgICAgIDogY3JlYXRlV3JhcHBlcihmdW5jLCAxLCBudWxsLCBudWxsLCB0aGlzQXJnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLiBNZXRob2QgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXNcbiAgICAgKiBvZiBtZXRob2QgbmFtZXMuIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQgYWxsIHRoZSBmdW5jdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAgd2lsbCBiZSBib3VuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbbWV0aG9kTmFtZV0gVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG9cbiAgICAgKiAgYmluZCwgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgbWV0aG9kIG5hbWVzIG9yIGFycmF5cyBvZiBtZXRob2QgbmFtZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgJ29uQ2xpY2snOiBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpOyB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3KTtcbiAgICAgKiBqUXVlcnkoJyNkb2NzJykub24oJ2NsaWNrJywgdmlldy5vbkNsaWNrKTtcbiAgICAgKiAvLyA9PiBsb2dzICdjbGlja2VkIGRvY3MnLCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGJhc2VGbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgZmFsc2UsIDEpIDogZnVuY3Rpb25zKG9iamVjdCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICAgIG9iamVjdFtrZXldID0gY3JlYXRlV3JhcHBlcihvYmplY3Rba2V5XSwgMSwgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYFxuICAgICAqIGFuZCBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgYmluZEtleWAgYXJndW1lbnRzIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnbmFtZSc6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZykge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLm5hbWUgKyAnISc7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kS2V5KG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDJcbiAgICAgICAgPyBjcmVhdGVXcmFwcGVyKGtleSwgMTksIHNsaWNlKGFyZ3VtZW50cywgMiksIG51bGwsIG9iamVjdClcbiAgICAgICAgOiBjcmVhdGVXcmFwcGVyKGtleSwgMywgbnVsbCwgbnVsbCwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gW2Z1bmNdIEZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhbE5hbWVNYXAgPSB7XG4gICAgICogICAncGViYmxlcyc6ICdwZW5lbG9wZSdcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgKiAgIG5hbWUgPSByZWFsTmFtZU1hcFtuYW1lLnRvTG93ZXJDYXNlKCldIHx8IG5hbWU7XG4gICAgICogICByZXR1cm4gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZm9ybWF0dGVkKSB7XG4gICAgICogICByZXR1cm4gJ0hpeWEgJyArIGZvcm1hdHRlZCArICchJztcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZ3JlZXQsIGZvcm1hdCk7XG4gICAgICogd2VsY29tZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdIaXlhIFBlbmVsb3BlISdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlKCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jc1tsZW5ndGhdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBsZW5ndGggPSBmdW5jcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJncyA9IFtmdW5jc1tsZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3MpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1swXTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSBjYWxsYmFjayBib3VuZCB0byBhbiBvcHRpb25hbCBgdGhpc0FyZ2AuIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5XG4gICAgICogbmFtZSB0aGUgY3JlYXRlZCBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBJZiBgZnVuY2AgaXMgYW4gb2JqZWN0IHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9aWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBjYWxsYmFjayBhY2NlcHRzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY2hhcmFjdGVycyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGNhbGxiYWNrKTtcbiAgICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihjaGFyYWN0ZXJzLCAnYWdlX19ndDM4Jyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBmdW5jO1xuICAgICAgaWYgKGZ1bmMgPT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnLCBhcmdDb3VudCk7XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgXCJfLnBsdWNrXCIgc3R5bGUgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3RbZnVuY107XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGZ1bmMpLFxuICAgICAgICAgIGtleSA9IHByb3BzWzBdLFxuICAgICAgICAgIGEgPSBmdW5jW2tleV07XG5cbiAgICAgIC8vIGhhbmRsZSBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09IDEgJiYgYSA9PT0gYSAmJiAhaXNPYmplY3QoYSkpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIHRoZSBjb21tb24gY2FzZSBvZiBwcm92aWRpbmcgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGVcbiAgICAgICAgLy8gcHJvcGVydHkgY29udGFpbmluZyBhIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIGIgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiAmJiAoYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGJhc2VJc0VxdWFsKG9iamVjdFtwcm9wc1tsZW5ndGhdXSwgZnVuY1twcm9wc1tsZW5ndGhdXSwgbnVsbCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgb25lIG9yIG1vcmUgYXJndW1lbnRzIG9mIGBmdW5jYCB0aGF0IHdoZW5cbiAgICAgKiBpbnZva2VkIGVpdGhlciBleGVjdXRlcyBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGFsbCBgZnVuY2AgYXJndW1lbnRzXG4gICAgICogaGF2ZSBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBvciBtb3JlIG9mIHRoZVxuICAgICAqIHJlbWFpbmluZyBgZnVuY2AgYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgY2FuIGJlIHNwZWNpZmllZFxuICAgICAqIGlmIGBmdW5jLmxlbmd0aGAgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgY29uc29sZS5sb2coYSArIGIgKyBjKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiA2XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSkge1xuICAgICAgYXJpdHkgPSB0eXBlb2YgYXJpdHkgPT0gJ251bWJlcicgPyBhcml0eSA6ICgrYXJpdHkgfHwgZnVuYy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgNCwgbnVsbCwgbnVsbCwgbnVsbCwgYXJpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICAgKiBgd2FpdGAgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLlxuICAgICAqIFByb3ZpZGUgYW4gb3B0aW9ucyBvYmplY3QgdG8gaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb25cbiAgICAgKiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHNcbiAgICAgKiB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXSBTcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XSBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgY2FsbGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBhdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4XG4gICAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKTtcbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgbGF6eUxheW91dCk7XG4gICAgICpcbiAgICAgKiAvLyBleGVjdXRlIGBzZW5kTWFpbGAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxsc1xuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBlbnN1cmUgYGJhdGNoTG9nYCBpcyBleGVjdXRlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxsc1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwge1xuICAgICAqICAgJ21heFdhaXQnOiAxMDAwXG4gICAgICogfSwgZmFsc2UpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKG5hdGl2ZU1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5vdygpO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzdGFtcCA9IG5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGV4ZWN1dGluZyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuXG4gICAgICogQWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ10gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ2RlZmVycmVkJyk7IH0pO1xuICAgICAqIC8vIHJldHVybnMgZnJvbSB0aGUgZnVuY3Rpb24gYmVmb3JlICdkZWZlcnJlZCcgaXMgbG9nZ2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmZXIoZnVuYykge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCAxKTtcbiAgICB9XG4gICAgLy8gdXNlIGBzZXRJbW1lZGlhdGVgIGlmIGF2YWlsYWJsZSBpbiBOb2RlLmpzXG4gICAgaWYgKHNldEltbWVkaWF0ZSkge1xuICAgICAgZGVmZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZS5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmddIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2cgPSBfLmJpbmQoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICAgICAqIF8uZGVsYXkobG9nLCAxMDAwLCAnbG9nZ2VkIGxhdGVyJyk7XG4gICAgICogLy8gPT4gJ2xvZ2dlZCBsYXRlcicgKEFwcGVhcnMgYWZ0ZXIgb25lIHNlY29uZC4pXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZVxuICAgICAqIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuXG4gICAgICogVGhlIGBmdW5jYCBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogVGhlIHJlc3VsdCBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBBIGZ1bmN0aW9uIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiA8IDIgPyBuIDogZmlib25hY2NpKG4gLSAxKSArIGZpYm9uYWNjaShuIC0gMik7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmaWJvbmFjY2koOSlcbiAgICAgKiAvLyA9PiAzNFxuICAgICAqXG4gICAgICogdmFyIGRhdGEgPSB7XG4gICAgICogICAnZnJlZCc6IHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIC8vIG1vZGlmeWluZyB0aGUgcmVzdWx0IGNhY2hlXG4gICAgICogdmFyIGdldCA9IF8ubWVtb2l6ZShmdW5jdGlvbihuYW1lKSB7IHJldHVybiBkYXRhW25hbWVdOyB9LCBfLmlkZW50aXR5KTtcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICpcbiAgICAgKiBnZXQuY2FjaGUucGViYmxlcy5uYW1lID0gJ3BlbmVsb3BlJztcbiAgICAgKiBnZXQoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ3BlbmVsb3BlJywgJ2FnZSc6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkLmNhY2hlLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5UHJlZml4ICsgYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgICAgOiAoY2FjaGVba2V5XSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IHt9O1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0ZSBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzIHRvXG4gICAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vIGBpbml0aWFsaXplYCBleGVjdXRlcyBgY3JlYXRlQXBwbGljYXRpb25gIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHZhciByYW4sXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJhbikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBgZnVuY2AgdmFyaWFibGUgc28gdGhlIGZ1bmN0aW9uIG1heSBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICBmdW5jID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIGFueSBhZGRpdGlvbmFsXG4gICAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KiogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7IH07XG4gICAgICogdmFyIGhpID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGknKTtcbiAgICAgKiBoaSgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMTYsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0c0RlZXAgPSBfLnBhcnRpYWxSaWdodChfLm1lcmdlLCBfLmRlZmF1bHRzKTtcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0ge1xuICAgICAqICAgJ3ZhcmlhYmxlJzogJ2RhdGEnLFxuICAgICAqICAgJ2ltcG9ydHMnOiB7ICdqcSc6ICQgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBkZWZhdWx0c0RlZXAob3B0aW9ucywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcbiAgICAgKlxuICAgICAqIG9wdGlvbnMudmFyaWFibGVcbiAgICAgKiAvLyA9PiAnZGF0YSdcbiAgICAgKlxuICAgICAqIG9wdGlvbnMuaW1wb3J0c1xuICAgICAqIC8vID0+IHsgJ18nOiBfLCAnanEnOiAkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJ0aWFsUmlnaHQoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXBwZXIoZnVuYywgMzIsIG51bGwsIHNsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvXG4gICAgICogaW5kaWNhdGUgdGhhdCBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2VcbiAgICAgKiBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsXG4gICAgICogcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV0gU3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdIFNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gYXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZ1xuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gZXhlY3V0ZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzXG4gICAgICogalF1ZXJ5KCcuaW50ZXJhY3RpdmUnKS5vbignY2xpY2snLCBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwge1xuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlT3B0aW9ucy5sZWFkaW5nID0gbGVhZGluZztcbiAgICAgIGRlYm91bmNlT3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIGRlYm91bmNlT3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwgZGVib3VuY2VPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIHRoZSB3cmFwcGVyIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+RnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVyKHdyYXBwZXIsIDE2LCBbdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIGAmYCwgYDxgLCBgPmAsIGBcImAsIGFuZCBgJ2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ0ZyZWQsIFdpbG1hLCAmIFBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCwgV2lsbWEsICZhbXA7IFBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICduYW1lJzogJ2ZyZWQnIH07XG4gICAgICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBmdW5jdGlvbiBwcm9wZXJ0aWVzIG9mIGEgc291cmNlIG9iamVjdCB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24gYW5kXG4gICAgICogY2hhaW5hYmxlIHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9uIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBsb2Rhc2hgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIGFkZCB0byBgbG9kYXNoYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2FwaXRhbGl6ZSc6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS5jYXBpdGFsaXplKCk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHZhciBjdG9yID0gb2JqZWN0LFxuICAgICAgICAgIGlzRnVuYyA9ICFzb3VyY2UgfHwgaXNGdW5jdGlvbihjdG9yKTtcblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY3RvciA9IGxvZGFzaFdyYXBwZXI7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gbG9kYXNoO1xuICAgICAgfVxuICAgICAgZm9yRWFjaChmdW5jdGlvbnMoc291cmNlKSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IG9iamVjdFttZXRob2ROYW1lXSA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIGN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbdmFsdWVdO1xuXG4gICAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShvYmplY3QsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGN0b3IocmVzdWx0KTtcbiAgICAgICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG5vLW9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ25hbWUnOiAnZnJlZCcgfTtcbiAgICAgKiBfLm5vb3Aob2JqZWN0KSA9PT0gdW5kZWZpbmVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gbm8gb3BlcmF0aW9uIHBlcmZvcm1lZFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBJZiBgcmFkaXhgIGlzIGB1bmRlZmluZWRgIG9yIGAwYCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyB0aGVcbiAgICAgKiBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGF2b2lkcyBkaWZmZXJlbmNlcyBpbiBuYXRpdmUgRVMzIGFuZCBFUzUgYHBhcnNlSW50YFxuICAgICAqIGltcGxlbWVudGF0aW9ucy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmlvLyNFLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeF0gVGhlIHJhZGl4IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB2YWx1ZSB0byBwYXJzZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBuZXcgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICovXG4gICAgdmFyIHBhcnNlSW50ID0gbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZSArICcwOCcpID09IDggPyBuYXRpdmVQYXJzZUludCA6IGZ1bmN0aW9uKHZhbHVlLCByYWRpeCkge1xuICAgICAgLy8gRmlyZWZveCA8IDIxIGFuZCBPcGVyYSA8IDE1IGZvbGxvdyB0aGUgRVMzIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZUxlYWRpbmdTcGFjZXNBbmRaZXJvcywgJycpIDogdmFsdWUsIHJhZGl4IHx8IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIHRydWV5IG9yIGVpdGhlciBgbWluYCBvciBgbWF4YCBhcmUgZmxvYXRzIGFcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXIgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmc9ZmFsc2VdIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCwgZmxvYXRpbmcpIHtcbiAgICAgIHZhciBub01pbiA9IG1pbiA9PSBudWxsLFxuICAgICAgICAgIG5vTWF4ID0gbWF4ID09IG51bGw7XG5cbiAgICAgIGlmIChmbG9hdGluZyA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluID09ICdib29sZWFuJyAmJiBub01heCkge1xuICAgICAgICAgIGZsb2F0aW5nID0gbWluO1xuICAgICAgICAgIG1pbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5vTWF4ICYmIHR5cGVvZiBtYXggPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBtYXg7XG4gICAgICAgICAgbm9NYXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9NaW4gJiYgbm9NYXgpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChub01heCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbWluICUgMSB8fCBtYXggJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obWluICsgKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSkpLCBtYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obWluLCBtYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSB2YWx1ZSBvZiBgcHJvcGVydHlgIG9uIGBvYmplY3RgLiBJZiBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb25cbiAgICAgKiBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYG9iamVjdGAgYW5kIGl0cyByZXN1bHQgcmV0dXJuZWQsXG4gICAgICogZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXMgcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgICAqICAgJ3N0dWZmJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiAnbm9uc2Vuc2UnO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICAgKiAvLyA9PiAnY3J1bXBldHMnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgICAqIC8vID0+ICdub25zZW5zZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3RbcHJvcGVydHldKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWU6XG4gICAgICogaHR0cDovL2RldmVsb3Blci5jaHJvbWUuY29tL3N0YWJsZS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsLmh0bWxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlXSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlXSBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0c10gQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBsb2NhbCB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlXSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVVSTF0gVGhlIHNvdXJjZVVSTCBvZiB0aGUgdGVtcGxhdGUncyBjb21waWxlZCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YXJpYWJsZV0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufHN0cmluZ30gUmV0dXJucyBhIGNvbXBpbGVkIGZ1bmN0aW9uIHdoZW4gbm8gYGRhdGFgIG9iamVjdFxuICAgICAqICBpcyBnaXZlbiwgZWxzZSBpdCByZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIEhUTUwgaW4gZGF0YSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+JywgeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBnZW5lcmF0ZSBIVE1MXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JS0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICAgKiBfLnRlbXBsYXRlKCdoZWxsbyAkeyBuYW1lIH0nLCB7ICduYW1lJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgbmFtZSk7ICU+IScsIHsgJ25hbWUnOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnNcbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgICogICAnaW50ZXJwb2xhdGUnOiAve3soW1xcc1xcU10rPyl9fS9nXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvIHt7IG5hbWUgfX0hJywgeyAnbmFtZSc6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBqUXVlcnlcbiAgICAgKiB2YXIgbGlzdCA9ICc8JSAkLmVhY2gocGVvcGxlLCBmdW5jdGlvbihuYW1lKSB7ICU+PGxpPjwlLSBuYW1lICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIF8udGVtcGxhdGUobGlzdCwgeyAncGVvcGxlJzogWydmcmVkJywgJ2Jhcm5leSddIH0sIHsgJ2ltcG9ydHMnOiB7ICckJzogalF1ZXJ5IH0gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicsIG51bGwsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAgICogICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS5uYW1lICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogICByZXR1cm4gX19wO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4oY3dkLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHRleHQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIC8vIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcbiAgICAgIHRleHQgPSBTdHJpbmcodGV4dCB8fCAnJyk7XG5cbiAgICAgIC8vIGF2b2lkIG1pc3NpbmcgZGVwZW5kZW5jaWVzIHdoZW4gYGl0ZXJhdG9yVGVtcGxhdGVgIGlzIG5vdCBkZWZpbmVkXG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMoe30sIG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IHZhbHVlcyhpbXBvcnRzKTtcblxuICAgICAgdmFyIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIGNvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgdGV4dC5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBlc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHNcbiAgICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyByZXF1aXJlcyByZXR1cm5pbmcgdGhlIGBtYXRjaGBcbiAgICAgICAgLy8gc3RyaW5nIGluIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWVcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIGlmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCwgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICAgIHZhciB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUsXG4gICAgICAgICAgaGFzVmFyaWFibGUgPSB2YXJpYWJsZTtcblxuICAgICAgaWYgKCFoYXNWYXJpYWJsZSkge1xuICAgICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3NcbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gZnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keVxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgICAgKGhhc1ZhcmlhYmxlID8gJycgOiB2YXJpYWJsZSArICcgfHwgKCcgKyB2YXJpYWJsZSArICcgPSB7fSk7XFxuJykgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnLCBfX2UgPSBfLmVzY2FwZVwiICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnXFxuLypcXG4vLyMgc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKSArICdcXG4qLyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBGdW5jdGlvbihpbXBvcnRzS2V5cywgJ3JldHVybiAnICsgc291cmNlICsgc291cmNlVVJMKS5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAgIC8vIHN1cHBvcnRlZCBlbnZpcm9ubWVudHMsIG9yIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgLy8gaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNhbGxiYWNrIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAgICogb2YgZWFjaCBjYWxsYmFjayBleGVjdXRpb24uIFRoZSBjYWxsYmFjayBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBiYXNlQ3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdGcmVkLCBCYXJuZXkgJmFtcDsgUGViYmxlcycpO1xuICAgICAqIC8vID0+ICdGcmVkLCBCYXJuZXkgJiBQZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgcHJvdmlkZWQgdGhlIElEIHdpbGwgYmUgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gU3RyaW5nKHByZWZpeCA9PSBudWxsID8gJycgOiBwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHRoYXQgd3JhcHMgdGhlIGdpdmVuIHZhbHVlIHdpdGggZXhwbGljaXRcbiAgICAgKiBtZXRob2QgY2hhaW5pbmcgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICduYW1lJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihjaGFyYWN0ZXJzKVxuICAgICAqICAgICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgICAubWFwKGZ1bmN0aW9uKGNocikgeyByZXR1cm4gY2hyLm5hbWUgKyAnIGlzICcgKyBjaHIuYWdlOyB9KVxuICAgICAqICAgICAuZmlyc3QoKVxuICAgICAqICAgICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVuXG4gICAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2RcbiAgICAgKiBjaGFpbiBpbiBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluXG4gICAgICogdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgMywgNF0pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHsgYXJyYXkucG9wKCk7IH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgZXhwbGljaXQgbWV0aG9kIGNoYWluaW5nIG9uIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBjaGFyYWN0ZXJzID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZ1xuICAgICAqIF8oY2hhcmFjdGVycykuZmlyc3QoKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGV4cGxpY2l0IGNoYWluaW5nXG4gICAgICogXyhjaGFyYWN0ZXJzKS5jaGFpbigpXG4gICAgICogICAuZmlyc3QoKVxuICAgICAqICAgLnBpY2soJ2FnZScpXG4gICAgICogICAudmFsdWUoKVxuICAgICAqIC8vID0+IHsgJ2FnZSc6IDM2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyB0aGUgYHRvU3RyaW5nYCByZXN1bHQgb2YgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nIHJlc3VsdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnRvU3RyaW5nKCk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb1N0cmluZygpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZU9mXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgdmFsdWVcbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlT2YoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWVPZigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fd3JhcHBlZF9fO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbXBvc2UgPSBjb21wb3NlO1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5kZXhCeSA9IGluZGV4Qnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gucGFpcnMgPSBwYWlycztcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBsdWNrID0gcGx1Y2s7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gud2hlcmUgPSB3aGVyZTtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcblxuICAgIC8vIGFkZCBhbGlhc2VzXG4gICAgbG9kYXNoLmNvbGxlY3QgPSBtYXA7XG4gICAgbG9kYXNoLmRyb3AgPSByZXN0O1xuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB6aXA7XG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRvIGBsb2Rhc2gucHJvdG90eXBlYFxuICAgIG1peGluKGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyB3aGVuIGNoYWluaW5nXG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY29udGFpbnMgPSBjb250YWlucztcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guYWxsID0gZXZlcnk7XG4gICAgbG9kYXNoLmFueSA9IHNvbWU7XG4gICAgbG9kYXNoLmRldGVjdCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRXaGVyZSA9IGZpbmQ7XG4gICAgbG9kYXNoLmZvbGRsID0gcmVkdWNlO1xuICAgIGxvZGFzaC5mb2xkciA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmluamVjdCA9IHJlZHVjZTtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fX3dyYXBwZWRfX10sXG4gICAgICAgICAgICAgIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX187XG5cbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkobG9kYXNoLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgICAgID8gbmV3IGxvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbClcbiAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIGNhcGFibGUgb2YgcmV0dXJuaW5nIHdyYXBwZWQgYW5kIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2gudGFrZSA9IGZpcnN0O1xuICAgIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG5cbiAgICBmb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2FsbGJhY2thYmxlID0gbWV0aG9kTmFtZSAhPT0gJ3NhbXBsZSc7XG4gICAgICBpZiAoIWxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXT0gZnVuY3Rpb24obiwgZ3VhcmQpIHtcbiAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYyh0aGlzLl9fd3JhcHBlZF9fLCBuLCBndWFyZCk7XG5cbiAgICAgICAgICByZXR1cm4gIWNoYWluQWxsICYmIChuID09IG51bGwgfHwgKGd1YXJkICYmICEoY2FsbGJhY2thYmxlICYmIHR5cGVvZiBuID09ICdmdW5jdGlvbicpKSlcbiAgICAgICAgICAgID8gcmVzdWx0XG4gICAgICAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9ICcyLjMuMCc7XG5cbiAgICAvLyBhZGQgXCJDaGFpbmluZ1wiIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlclxuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlT2Y7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gd3JhcHBlclZhbHVlT2Y7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydqb2luJywgJ3BvcCcsICdzaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gY2hhaW5BbGxcbiAgICAgICAgICA/IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpXG4gICAgICAgICAgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRoZSB3cmFwcGVkIHZhbHVlXG4gICAgZm9yRWFjaChbJ3B1c2gnLCAncmV2ZXJzZScsICdzb3J0JywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gbmV3IHdyYXBwZWQgdmFsdWVzXG4gICAgZm9yRWFjaChbJ2NvbmNhdCcsICdzbGljZScsICdzcGxpY2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVJlZlttZXRob2ROYW1lXTtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2Rhc2hXcmFwcGVyKGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKSwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMgbGlrZSByLmpzIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIHdhcyBpbmplY3RlZCBieSBhIHRoaXJkLXBhcnR5IHNjcmlwdCBhbmQgbm90IGludGVuZGVkIHRvIGJlXG4gICAgLy8gbG9hZGVkIGFzIGEgbW9kdWxlLiBUaGUgZ2xvYmFsIGFzc2lnbm1lbnQgY2FuIGJlIHJldmVydGVkIGluIHRoZSBMby1EYXNoXG4gICAgLy8gbW9kdWxlIGJ5IGl0cyBgbm9Db25mbGljdCgpYCBtZXRob2QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gY2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgYW4gYGV4cG9ydHNgIG9iamVjdFxuICBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTXG4gICAgaWYgKG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaGlubyAtcmVxdWlyZVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGluIGEgYnJvd3NlciBvciBSaGlub1xuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cbn0pKHdpbmRvdykiLCJ2YXIgY2FjaGUgPSB7fVxuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gKG5ldyBEYXRlKS5nZXRUaW1lKCk7IH1cbnZhciBkZWJ1ZyA9IGZhbHNlO1xudmFyIGhpdENvdW50ID0gMDtcbnZhciBtaXNzQ291bnQgPSAwO1xuXG5leHBvcnRzLnB1dCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHRpbWUsIHRpbWVvdXRDYWxsYmFjaykge1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKCdjYWNoaW5nOiAnK2tleSsnID0gJyt2YWx1ZSsnIChAJyt0aW1lKycpJyk7XG4gIHZhciBvbGRSZWNvcmQgPSBjYWNoZVtrZXldO1xuXHRpZiAob2xkUmVjb3JkKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KG9sZFJlY29yZC50aW1lb3V0KTtcblx0fVxuXG5cdHZhciBleHBpcmUgPSB0aW1lICsgbm93KCk7XG5cdHZhciByZWNvcmQgPSB7dmFsdWU6IHZhbHVlLCBleHBpcmU6IGV4cGlyZX07XG5cblx0aWYgKCFpc05hTihleHBpcmUpKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHQgICAgZXhwb3J0cy5kZWwoa2V5KTtcblx0ICAgIGlmICh0eXBlb2YgdGltZW91dENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICBcdHRpbWVvdXRDYWxsYmFjayhrZXkpO1xuXHQgICAgfVxuXHQgIH0sIHRpbWUpO1xuXHRcdHJlY29yZC50aW1lb3V0ID0gdGltZW91dDtcblx0fVxuXG5cdGNhY2hlW2tleV0gPSByZWNvcmQ7XG59XG5cbmV4cG9ydHMuZGVsID0gZnVuY3Rpb24oa2V5KSB7XG4gIGRlbGV0ZSBjYWNoZVtrZXldO1xufVxuXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGNhY2hlID0ge307XG59XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBkYXRhID0gY2FjaGVba2V5XTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAoaXNOYU4oZGF0YS5leHBpcmUpIHx8IGRhdGEuZXhwaXJlID49IG5vdygpKSB7XG5cdCAgaWYgKGRlYnVnKSBoaXRDb3VudCsrO1xuICAgICAgcmV0dXJuIGRhdGEudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZyZWUgc29tZSBzcGFjZVxuICAgICAgaWYgKGRlYnVnKSBtaXNzQ291bnQrKztcbiAgICAgIGV4cG9ydHMuZGVsKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLnNpemUgPSBmdW5jdGlvbigpIHsgXG4gIHZhciBzaXplID0gMCwga2V5O1xuICBmb3IgKGtleSBpbiBjYWNoZSkge1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBcbiAgICAgIGlmIChleHBvcnRzLmdldChrZXkpICE9PSBudWxsKVxuICAgICAgICBzaXplKys7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbmV4cG9ydHMubWVtc2l6ZSA9IGZ1bmN0aW9uKCkgeyBcbiAgdmFyIHNpemUgPSAwLCBrZXk7XG4gIGZvciAoa2V5IGluIGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIFxuICAgICAgc2l6ZSsrO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oYm9vbCkge1xuICBkZWJ1ZyA9IGJvb2w7XG59XG5cbmV4cG9ydHMuaGl0cyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gaGl0Q291bnQ7XG59XG5cbmV4cG9ydHMubWlzc2VzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBtaXNzQ291bnQ7XG59XG4iLCJcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpLkNvbm5lY3Rpb247XG5leHBvcnRzLkRvYyA9IHJlcXVpcmUoJy4vZG9jJykuRG9jO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG4iLCJ2YXIgY2hhcmVuYyA9IHtcbiAgLy8gVVRGLTggZW5jb2RpbmdcbiAgdXRmODoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gY2hhcmVuYy5iaW4uc3RyaW5nVG9CeXRlcyh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShjaGFyZW5jLmJpbi5ieXRlc1RvU3RyaW5nKGJ5dGVzKSkpO1xuICAgIH1cbiAgfSxcblxuICAvLyBCaW5hcnkgZW5jb2RpbmdcbiAgYmluOiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGZvciAodmFyIHN0ciA9IFtdLCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBzdHIucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKSk7XG4gICAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFyZW5jO1xuIiwidmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMToge1xuICAgIGhleDogc2hhLmhleF9zaGExLFxuICAgIGJpbmFyeTogc2hhLmI2NF9zaGExLFxuICAgIGFzY2lpOiBzaGEuc3RyX3NoYTFcbiAgfSxcbiAgbWQ1OiB7XG4gICAgaGV4OiBtZDUuaGV4X21kNSxcbiAgICBiaW5hcnk6IG1kNS5iNjRfbWQ1LFxuICAgIGFzY2lpOiBtZDUuYW55X21kNVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgaWYoIWFsZ29yaXRobXNbYWxnXSlcbiAgICBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgdmFyIHMgPSAnJ1xuICB2YXIgX2FsZyA9IGFsZ29yaXRobXNbYWxnXVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHMgKz0gZGF0YVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gICAgICB2YXIgZm5cbiAgICAgIGlmKCEoZm4gPSBfYWxnW2VuY10pKVxuICAgICAgICBlcnJvcignZW5jb2Rpbmc6JywgZW5jICwgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBhbGdvcml0aG0nLCBhbGcpXG4gICAgICB2YXIgciA9IGZuKHMpXG4gICAgICBzID0gbnVsbCAvL25vdCBtZWFudCB0byB1c2UgdGhlIGhhc2ggYWZ0ZXIgeW91J3ZlIGNhbGxlZCBkaWdlc3QuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIHJuZyhzaXplKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycik7IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm5nKHNpemUpO1xuICB9XG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuO1snY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVIbWFjJ1xuLCAnY3JlYXRlQ3lwaGVyJ1xuLCAnY3JlYXRlQ3lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGVmZmllSGVsbG1hbidcbiwgJ3Bia2RmMiddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuIiwidmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKVxuICAsIGZpbmRpdCA9IHJlcXVpcmUoJ2ZpbmRpdCcpXG4gICwgZnMgPSByZXF1aXJlKCdmcycpXG4gICwgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKVxuICAsIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0JylcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gICwgdHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpXG4gICwgdm0gPSByZXF1aXJlKCd2bScpO1xuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmxvYWQpIG9wdGlvbnMubG9hZCA9IGxvYWRlci5maWxlc3lzdGVtKG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIGdldEZvcm1hdHMoY2FsbGJhY2spIHtcbiAgICB2YXIgZGlyID0gcGF0aC5yZXNvbHZlKHJlcXVpcmUucmVzb2x2ZSgnbWVzc2FnZWZvcm1hdCcpLCAnLi4vbG9jYWxlJylcbiAgICAgICwgZmluZCA9IGZpbmRpdChkaXIpXG4gICAgICAsIHNhbmRib3ggPSB7TWVzc2FnZUZvcm1hdDoge2xvY2FsZToge319fVxuICAgICAgLCBjb250ZXh0ID0gdm0uY3JlYXRlQ29udGV4dChzYW5kYm94KTtcblxuICAgIGZpbmQub24oJ2ZpbGUnLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgaWYgKHBhdGguZXh0bmFtZShmaWxlKSAhPT0gJy5qcycpIHJldHVybjtcbiAgICAgIHZhciBjb2RlID0gZnMucmVhZEZpbGVTeW5jKGZpbGUsIHtlbmNvZGluZzogJ3V0ZjgnfSk7XG4gICAgICB2bS5ydW5JbkNvbnRleHQoY29kZSwgY29udGV4dCk7XG4gICAgfSk7XG5cbiAgICBmaW5kLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhjb250ZXh0Lk1lc3NhZ2VGb3JtYXQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Rm9ybWF0cyhmdW5jdGlvbiAoZGVmYXVsdEZvcm1hdHMpIHtcbiAgICB2YXIgZmluZCA9IGZpbmRpdChvcHRpb25zLmRpcmVjdG9yeSk7XG5cbiAgICBvcHRpb25zLmxvYWQoZnVuY3Rpb24gKGVyciwgZm9ybWF0cywgdHJhbnNsYXRpb25zKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIGZvcm1hdHMgPSBfLm1lcmdlKGRlZmF1bHRGb3JtYXRzLCBmb3JtYXRzIHx8IHt9KTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRyYXZlcnNlKHRyYW5zbGF0aW9ucykubWFwKGZ1bmN0aW9uICh0cmFuc2xhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5sZXZlbCA8IDIpIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLmlzTGVhZikgcmV0dXJuO1xuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5wYXRoWzBdO1xuICAgICAgICB2YXIgbWVzc2FnZWZvcm1hdCA9IG5ldyBNZXNzYWdlRm9ybWF0KGxvY2FsZSwgZm9ybWF0cy5sb2NhbGVbbG9jYWxlXSk7XG4gICAgICAgIHRoaXMudXBkYXRlKG1lc3NhZ2Vmb3JtYXQucHJlY29tcGlsZShtZXNzYWdlZm9ybWF0LnBhcnNlKHRyYW5zbGF0aW9uKSksIHRydWUpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9KTtcbn07IiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxuZXhwb3J0cy5oZXhfc2hhMSA9IGhleF9zaGExO1xuZXhwb3J0cy5iNjRfc2hhMSA9IGI2NF9zaGExO1xuZXhwb3J0cy5zdHJfc2hhMSA9IHN0cl9zaGExO1xuZXhwb3J0cy5oZXhfaG1hY19zaGExID0gaGV4X2htYWNfc2hhMTtcbmV4cG9ydHMuYjY0X2htYWNfc2hhMSA9IGI2NF9obWFjX3NoYTE7XG5leHBvcnRzLnN0cl9obWFjX3NoYTEgPSBzdHJfaG1hY19zaGExO1xuXG4vKlxuICogQ29uZmlndXJhYmxlIHZhcmlhYmxlcy4gWW91IG1heSBuZWVkIHRvIHR3ZWFrIHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAqL1xudmFyIGhleGNhc2UgPSAwOyAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG52YXIgY2hyc3ogICA9IDg7ICAvKiBiaXRzIHBlciBpbnB1dCBjaGFyYWN0ZXIuIDggLSBBU0NJSTsgMTYgLSBVbmljb2RlICAgICAgKi9cblxuLypcbiAqIFRoZXNlIGFyZSB0aGUgZnVuY3Rpb25zIHlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gY2FsbFxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGhleF9zaGExKHMpe3JldHVybiBiaW5iMmhleChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGI2NF9zaGExKHMpe3JldHVybiBiaW5iMmI2NChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIHN0cl9zaGExKHMpe3JldHVybiBiaW5iMnN0cihjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGhleF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyaGV4KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIGI2NF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyYjY0KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIHN0cl9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyc3RyKGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cblxuLypcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xuICovXG5mdW5jdGlvbiBzaGExX3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X3NoYTEoXCJhYmNcIikgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcblxuICB2YXIgdyA9IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIHZhciBvbGRlID0gZTtcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdO1xuICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm9sKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7XG5cbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSBzdHIyYmluYihrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gY29yZV9zaGExKGJrZXksIGtleS5sZW5ndGggKiBjaHJzeik7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gY29yZV9zaGExKGlwYWQuY29uY2F0KHN0cjJiaW5iKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiBjb3JlX3NoYTEob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDE2MCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gOC1iaXQgb3IgMTYtYml0IHN0cmluZyB0byBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzXG4gKiBJbiA4LWJpdCBmdW5jdGlvbiwgY2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGktYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBzdHIyYmluYihzdHIpXG57XG4gIHZhciBiaW4gPSBBcnJheSgpO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICogY2hyc3o7IGkgKz0gY2hyc3opXG4gICAgYmluW2k+PjVdIHw9IChzdHIuY2hhckNvZGVBdChpIC8gY2hyc3opICYgbWFzaykgPDwgKDMyIC0gY2hyc3ogLSBpJTMyKTtcbiAgcmV0dXJuIGJpbjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMnN0cihiaW4pXG57XG4gIHZhciBzdHIgPSBcIlwiO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoICogMzI7IGkgKz0gY2hyc3opXG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGJpbltpPj41XSA+Pj4gKDMyIC0gY2hyc3ogLSBpJTMyKSkgJiBtYXNrKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJpbmIyaGV4KGJpbmFycmF5KVxue1xuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkrKylcbiAge1xuICAgIHN0ciArPSBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4KzQpKSAmIDB4RikgK1xuICAgICAgICAgICBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4ICApKSAmIDB4Rik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGJhc2UtNjQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmIyYjY0KGJpbmFycmF5KVxue1xuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoKChiaW5hcnJheVtpICAgPj4gMl0gPj4gOCAqICgzIC0gIGkgICAlNCkpICYgMHhGRikgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoKChiaW5hcnJheVtpKzEgPj4gMl0gPj4gOCAqICgzIC0gKGkrMSklNCkpICYgMHhGRikgPDwgOCApXG4gICAgICAgICAgICAgICAgfCAgKChiaW5hcnJheVtpKzIgPj4gMl0gPj4gOCAqICgzIC0gKGkrMiklNCkpICYgMHhGRik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gYmluYXJyYXkubGVuZ3RoICogMzIpIHN0ciArPSBiNjRwYWQ7XG4gICAgICBlbHNlIHN0ciArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbiIsIi8vIE9yaWdpbmFsIGNvZGUgYWRhcHRlZCBmcm9tIFJvYmVydCBLaWVmZmVyLlxuLy8gZGV0YWlscyBhdCBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgdmFyIG1hdGhSTkcsIHdoYXR3Z1JORztcblxuICAvLyBOT1RFOiBNYXRoLnJhbmRvbSgpIGRvZXMgbm90IGd1YXJhbnRlZSBcImNyeXB0b2dyYXBoaWMgcXVhbGl0eVwiXG4gIG1hdGhSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciByO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmICgoaSAmIDB4MDMpID09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBieXRlc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICAvLyBjdXJyZW50bHkgb25seSBhdmFpbGFibGUgaW4gd2Via2l0LWJhc2VkIGJyb3dzZXJzLlxuICBpZiAoX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHZhciBfcm5kcyA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICB3aGF0d2dSTkcgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzKTtcblxuICAgICAgZm9yICh2YXIgYyA9IDAgOyBjIDwgc2l6ZTsgYysrKSB7XG4gICAgICAgIGJ5dGVzW2NdID0gX3JuZHNbYyA+PiAyXSA+Pj4gKChjICYgMHgwMykgKiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB3aGF0d2dSTkcgfHwgbWF0aFJORztcblxufSgpKSIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCJcIjsgIC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfbWQ1KHMpICAgIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpKTsgfVxuZnVuY3Rpb24gYjY0X21kNShzKSAgICB7IHJldHVybiByc3RyMmI2NChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGFueV9tZDUocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSksIGUpOyB9XG5mdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGI2NF9obWFjX21kNShrLCBkKVxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYW55X2htYWNfbWQ1KGssIGQsIGUpXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSksIGUpOyB9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X21kNShcImFiY1wiKS50b0xvd2VyQ2FzZSgpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGEgcmF3IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyX21kNShzKVxue1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtTUQ1LCBvZiBhIGtleSBhbmQgc29tZSBkYXRhIChyYXcgc3RyaW5ncylcbiAqL1xuZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gcnN0cjJiaW5sKGtleSk7XG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5sX21kNShia2V5LCBrZXkubGVuZ3RoICogOCk7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gYmlubF9tZDUoaXBhZC5jb25jYXQocnN0cjJiaW5sKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiA4KTtcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTI4KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJoZXgoaW5wdXQpXG57XG4gIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIHg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAge1xuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIG91dHB1dCArPSBoZXhfdGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBGKVxuICAgICAgICAgICArICBoZXhfdGFiLmNoYXJBdCggeCAgICAgICAgJiAweDBGKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmI2NChpbnB1dClcbntcbiAgdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcbiAgICAgICAgICAgICAgICB8IChpICsgMSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsxKSA8PCA4IDogMClcbiAgICAgICAgICAgICAgICB8IChpICsgMiA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsyKSAgICAgIDogMCk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gaW5wdXQubGVuZ3RoICogOCkgb3V0cHV0ICs9IGI2NHBhZDtcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcmJpdHJhcnkgc3RyaW5nIGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcbntcbiAgdmFyIGRpdmlzb3IgPSBlbmNvZGluZy5sZW5ndGg7XG4gIHZhciBpLCBqLCBxLCB4LCBxdW90aWVudDtcblxuICAvKiBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIDE2LWJpdCBiaWctZW5kaWFuIHZhbHVlcywgZm9ybWluZyB0aGUgZGl2aWRlbmQgKi9cbiAgdmFyIGRpdmlkZW5kID0gQXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDIpKTtcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICBkaXZpZGVuZFtpXSA9IChpbnB1dC5jaGFyQ29kZUF0KGkgKiAyKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBlbmNvZGluZyBpcyB0aGUgZGl2aXNvci4gT25jZSBjb21wdXRlZCwgdGhlIHF1b3RpZW50XG4gICAqIGZvcm1zIHRoZSBkaXZpZGVuZCBmb3IgdGhlIG5leHQgc3RlcC4gQWxsIHJlbWFpbmRlcnMgYXJlIHN0b3JlZCBmb3IgbGF0ZXJcbiAgICogdXNlLlxuICAgKi9cbiAgdmFyIGZ1bGxfbGVuZ3RoID0gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAqIDggL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpO1xuICB2YXIgcmVtYWluZGVycyA9IEFycmF5KGZ1bGxfbGVuZ3RoKTtcbiAgZm9yKGogPSAwOyBqIDwgZnVsbF9sZW5ndGg7IGorKylcbiAge1xuICAgIHF1b3RpZW50ID0gQXJyYXkoKTtcbiAgICB4ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XG4gICAgICBxID0gTWF0aC5mbG9vcih4IC8gZGl2aXNvcik7XG4gICAgICB4IC09IHEgKiBkaXZpc29yO1xuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcbiAgICAgICAgcXVvdGllbnRbcXVvdGllbnQubGVuZ3RoXSA9IHE7XG4gICAgfVxuICAgIHJlbWFpbmRlcnNbal0gPSB4O1xuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XG4gIH1cblxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IoaSA9IHJlbWFpbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04LlxuICogRm9yIGVmZmljaWVuY3ksIHRoaXMgYXNzdW1lcyB0aGUgaW5wdXQgaXMgdmFsaWQgdXRmLTE2LlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGY4KGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHgsIHk7XG5cbiAgd2hpbGUoKytpIDwgaW5wdXQubGVuZ3RoKVxuICB7XG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICB5ID0gaSArIDEgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKSA6IDA7XG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXG4gICAge1xuICAgICAgeCA9IDB4MTAwMDAgKyAoKHggJiAweDAzRkYpIDw8IDEwKSArICh5ICYgMHgwM0ZGKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXG4gICAgaWYoeCA8PSAweDdGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoeCA+Pj4gNiApICYgMHgxRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKHggPj4+IDEyKSAmIDB4MEYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4MUZGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGMCB8ICgoeCA+Pj4gMTgpICYgMHgwNyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTE2XG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2bGUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZiZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IEFycmF5KGlucHV0Lmxlbmd0aCA+PiAyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXRbaV0gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KVxuICAgIG91dHB1dFtpPj41XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoaSUzMik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGJpbmxfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cblxuZXhwb3J0cy5oZXhfbWQ1ID0gaGV4X21kNTtcbmV4cG9ydHMuYjY0X21kNSA9IGI2NF9tZDU7XG5leHBvcnRzLmFueV9tZDUgPSBhbnlfbWQ1O1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3YWxrIChkaXIsIG9wdHMsIGVtaXR0ZXIsIGRzdGF0KSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgdmFyIGZkaXIgPSBvcHRzLl9vcmlnaW5hbCB8fCBkaXI7XG4gICAgb3B0cy5fb3JpZ2luYWwgPSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKCFlbWl0dGVyKSB7XG4gICAgICAgIGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlbWl0dGVyLl9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RvcCcpO1xuICAgICAgICB9O1xuICAgICAgICBlbWl0dGVyLl9wZW5kaW5nID0gMDtcbiAgICAgICAgZW1pdHRlci5fc2VlbiA9IHt9O1xuICAgIH1cbiAgICBlbWl0dGVyLl9wZW5kaW5nICsrO1xuICAgIFxuICAgIGlmIChkc3RhdCkge1xuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBlbWl0dGVyLmVtaXQoJ2RpcmVjdG9yeScsIGZkaXIsIGRzdGF0LCBmdW5jdGlvbiBzdG9wICgpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1pdHRlci5lbWl0KCdwYXRoJywgZmRpciwgZHN0YXQpO1xuICAgICAgICBpZiAoIXN0b3BwZWQpIGZzLnJlYWRkaXIoZGlyLCBvbnJlYWRkaXIpO1xuICAgICAgICBlbHNlIGNoZWNrKClcbiAgICB9XG4gICAgZWxzZSBmcy5sc3RhdChkaXIsIGZ1bmN0aW9uIG9uc3RhdCAoZXJyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlbWl0dGVyLl9zdG9wcGVkKSByZXR1cm47XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgZW1pdHRlci5fc2VlbltzdGF0LmlubyB8fCBkaXJdID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdGF0LmlzU3ltYm9saWNMaW5rKCkgJiYgb3B0cy5mb2xsb3dTeW1saW5rcykge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdsaW5rJywgZmRpciwgc3RhdCk7XG4gICAgICAgICAgICBmcy5yZWFkbGluayhkaXIsIGZ1bmN0aW9uIChlcnIsIHJmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIuX3N0b3BwZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVfID0gcGF0aC5yZXNvbHZlKGRpciwgcmZpbGUpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgncmVhZGxpbmsnLCBmZGlyLCBmaWxlXyk7XG4gICAgICAgICAgICAgICAgZnMubHN0YXQoZmlsZV8sIG9uc3RhdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbGluaycsIGZkaXIsIHN0YXQpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwYXRoJywgZmRpciwgc3RhdCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2RpcmVjdG9yeScsIGZkaXIsIHN0YXQsIGZ1bmN0aW9uIHN0b3AgKCkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BhdGgnLCBmZGlyLCBzdGF0KTtcbiAgICAgICAgICAgIGlmICghc3RvcHBlZCkgZnMucmVhZGRpcihkaXIsIG9ucmVhZGRpcik7XG4gICAgICAgICAgICBlbHNlIGNoZWNrKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnZmlsZScsIGZkaXIsIHN0YXQpO1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdwYXRoJywgZmRpciwgc3RhdCk7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBlbWl0dGVyO1xuICAgIFxuICAgIGZ1bmN0aW9uIGNoZWNrICgpIHtcbiAgICAgICAgaWYgKC0tIGVtaXR0ZXIuX3BlbmRpbmcgPT09IDApIGZpbmlzaCgpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgICAgICBlbWl0dGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICBlbWl0dGVyLl9zZWVuID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gb25yZWFkZGlyIChlcnIsIGZpbGVzKSB7XG4gICAgICAgIGlmIChlbWl0dGVyLl9zdG9wcGVkKSByZXR1cm47XG4gICAgICAgIGVtaXR0ZXIuX3BlbmRpbmcgLS07XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjaGVjaygpO1xuICAgICAgICBcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAocmZpbGUpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIuX3BlbmRpbmcgKys7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHBhdGguam9pbihmZGlyLCByZmlsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZzLmxzdGF0KGZpbGUsIGZ1bmN0aW9uIChlcnIsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW1pdHRlci5fc3RvcHBlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGNoZWNrKClcbiAgICAgICAgICAgICAgICBlbHNlIG9uc3RhdChmaWxlLCBzdGF0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBvbnN0YXQgKGZpbGUsIHN0YXQsIG9yaWdpbmFsKSB7XG4gICAgICAgIGlmIChlbWl0dGVyLl9zZWVuW3N0YXQuaW5vIHx8IGZpbGVdKSByZXR1cm4gY2hlY2soKTtcbiAgICAgICAgZW1pdHRlci5fc2VlbltzdGF0LmlubyB8fCBmaWxlXSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwpIG9wdHMuX29yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgICAgICAgICB3YWxrKGZpbGUsIG9wdHMsIGVtaXR0ZXIsIHN0YXQpO1xuICAgICAgICAgICAgY2hlY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0LmlzU3ltYm9saWNMaW5rKCkgJiYgb3B0cy5mb2xsb3dTeW1saW5rcykge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdsaW5rJywgZmlsZSwgc3RhdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZzLnJlYWRsaW5rKGZpbGUsIGZ1bmN0aW9uIChlcnIsIHJmaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIuX3N0b3BwZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2hlY2soKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZV8gPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGZpbGUpLCByZmlsZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdyZWFkbGluaycsIGZpbGUsIGZpbGVfKTtcbiAgICAgICAgICAgICAgICBmcy5sc3RhdChmaWxlXywgZnVuY3Rpb24gKGVyciwgc3RhdF8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVtaXR0ZXIuX3N0b3BwZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLl9wZW5kaW5nICsrO1xuICAgICAgICAgICAgICAgICAgICBvbnN0YXQoZmlsZV8sIHN0YXRfLCBmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdsaW5rJywgZmlsZSwgc3RhdCk7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3BhdGgnLCBmaWxlLCBzdGF0KTtcbiAgICAgICAgICAgIGNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ2ZpbGUnLCBmaWxlLCBzdGF0KTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgncGF0aCcsIGZpbGUsIHN0YXQpO1xuICAgICAgICAgICAgY2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCJ2YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gbmV3IFRyYXZlcnNlKG9iaik7XG59O1xuXG5mdW5jdGlvbiBUcmF2ZXJzZSAob2JqKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9iajtcbn1cblxuVHJhdmVyc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocHMsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoIC0gMTsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgbm9kZVtwc1tpXV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHdhbGsodGhpcy52YWx1ZSwgY2IsIHRydWUpO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLnZhbHVlID0gd2Fsayh0aGlzLnZhbHVlLCBjYiwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYiwgaW5pdCkge1xuICAgIHZhciBza2lwID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB2YXIgYWNjID0gc2tpcCA/IHRoaXMudmFsdWUgOiBpbml0O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290IHx8ICFza2lwKSB7XG4gICAgICAgICAgICBhY2MgPSBjYi5jYWxsKHRoaXMsIGFjYywgeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5wYXRoKTsgXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMubm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdLCBub2RlcyA9IFtdO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gY2xvbmUgKHNyYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldID09PSBzcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSBjb3B5KHNyYyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzcmMpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChkc3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKG9iamVjdEtleXMoc3JjKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gY2xvbmUoc3JjW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSkodGhpcy52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB3YWxrIChyb290LCBjYiwgaW1tdXRhYmxlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBhbGl2ZSA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiB3YWxrZXIgKG5vZGVfKSB7XG4gICAgICAgIHZhciBub2RlID0gaW1tdXRhYmxlID8gY29weShub2RlXykgOiBub2RlXztcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGtlZXBHb2luZyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBub2RlIDogbm9kZSxcbiAgICAgICAgICAgIG5vZGVfIDogbm9kZV8sXG4gICAgICAgICAgICBwYXRoIDogW10uY29uY2F0KHBhdGgpLFxuICAgICAgICAgICAgcGFyZW50IDogcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50cyA6IHBhcmVudHMsXG4gICAgICAgICAgICBrZXkgOiBwYXRoLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGlzUm9vdCA6IHBhdGgubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgbGV2ZWwgOiBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNpcmN1bGFyIDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uICh4LCBzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlID0geDtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEhlcmUpIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAoc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdGF0ZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGUuc3BsaWNlKHN0YXRlLmtleSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlzIDogbnVsbCxcbiAgICAgICAgICAgIGJlZm9yZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5iZWZvcmUgPSBmIH0sXG4gICAgICAgICAgICBhZnRlciA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5hZnRlciA9IGYgfSxcbiAgICAgICAgICAgIHByZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wcmUgPSBmIH0sXG4gICAgICAgICAgICBwb3N0IDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnBvc3QgPSBmIH0sXG4gICAgICAgICAgICBzdG9wIDogZnVuY3Rpb24gKCkgeyBhbGl2ZSA9IGZhbHNlIH0sXG4gICAgICAgICAgICBibG9jayA6IGZ1bmN0aW9uICgpIHsga2VlcEdvaW5nID0gZmFsc2UgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhbGl2ZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlLm5vZGUgPT09ICdvYmplY3QnICYmIHN0YXRlLm5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmtleXMgfHwgc3RhdGUubm9kZV8gIT09IHN0YXRlLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG9iamVjdEtleXMoc3RhdGUubm9kZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gc3RhdGUua2V5cy5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0ubm9kZV8gPT09IG5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaXJjdWxhciA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXRlLm5vdExlYWYgPSAhc3RhdGUuaXNMZWFmO1xuICAgICAgICAgICAgc3RhdGUubm90Um9vdCA9ICFzdGF0ZS5pc1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgcmV0dXJuIHZhbHVlcyB0byB1cGRhdGUgaWYgZGVmaW5lZFxuICAgICAgICB2YXIgcmV0ID0gY2IuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS51cGRhdGUpIHN0YXRlLnVwZGF0ZShyZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5iZWZvcmUpIG1vZGlmaWVycy5iZWZvcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWtlZXBHb2luZykgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09ICdvYmplY3QnXG4gICAgICAgICYmIHN0YXRlLm5vZGUgIT09IG51bGwgJiYgIXN0YXRlLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKHN0YXRlLmtleXMsIGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByZSkgbW9kaWZpZXJzLnByZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gd2Fsa2VyKHN0YXRlLm5vZGVba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLm5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubm9kZVtrZXldID0gY2hpbGQubm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQuaXNMYXN0ID0gaSA9PSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQuaXNGaXJzdCA9IGkgPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnBvc3QpIG1vZGlmaWVycy5wb3N0LmNhbGwoc3RhdGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobW9kaWZpZXJzLmFmdGVyKSBtb2RpZmllcnMuYWZ0ZXIuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSkocm9vdCkubm9kZTtcbn1cblxuZnVuY3Rpb24gY29weSAoc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZHN0O1xuICAgICAgICBcbiAgICAgICAgaWYgKGlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lID8gc3JjLmdldFRpbWUoKSA6IHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFJlZ0V4cChzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3Ioc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0geyBtZXNzYWdlOiBzcmMubWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgQm9vbGVhbihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBOdW1iZXIoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIGRzdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNyYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBkc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9XG4gICAgICAgICAgICAgICAgKHNyYy5jb25zdHJ1Y3RvciAmJiBzcmMuY29uc3RydWN0b3IucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHx8IHNyYy5fX3Byb3RvX19cbiAgICAgICAgICAgICAgICB8fCB7fVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIFQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIFQucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICBkc3QgPSBuZXcgVDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBzcmM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdG9TIChvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIH1cbmZ1bmN0aW9uIGlzRGF0ZSAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nIH1cbmZ1bmN0aW9uIGlzUmVnRXhwIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyB9XG5mdW5jdGlvbiBpc0Vycm9yIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBFcnJvcl0nIH1cbmZ1bmN0aW9uIGlzQm9vbGVhbiAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nIH1cbmZ1bmN0aW9uIGlzTnVtYmVyIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyB9XG5mdW5jdGlvbiBpc1N0cmluZyAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgfVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheSAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG5mb3JFYWNoKG9iamVjdEtleXMoVHJhdmVyc2UucHJvdG90eXBlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHRyYXZlcnNlW2tleV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgdCA9IG5ldyBUcmF2ZXJzZShvYmopO1xuICAgICAgICByZXR1cm4gdFtrZXldLmFwcGx5KHQsIGFyZ3MpO1xuICAgIH07XG59KTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufTtcbiIsIi8qKlxuICogbWVzc2FnZWZvcm1hdC5qc1xuICpcbiAqIElDVSBQbHVyYWxGb3JtYXQgKyBTZWxlY3RGb3JtYXQgZm9yIEphdmFTY3JpcHRcbiAqXG4gKiBAYXV0aG9yIEFsZXggU2V4dG9uIC0gQFNsZXhBeHRvblxuICogQHZlcnNpb24gMC4xLjVcbiAqIEBsaWNlbnNlIFdURlBMXG4gKiBAY29udHJpYnV0b3JfbGljZW5zZSBEb2pvIENMQVxuKi9cbihmdW5jdGlvbiAoIHJvb3QgKSB7XG5cbiAgLy8gQ3JlYXRlIHRoZSBjb250cnVjdG9yIGZ1bmN0aW9uXG4gIGZ1bmN0aW9uIE1lc3NhZ2VGb3JtYXQgKCBsb2NhbGUsIHBsdXJhbEZ1bmMgKSB7XG4gICAgdmFyIGZhbGxiYWNrTG9jYWxlO1xuXG4gICAgaWYgKCBsb2NhbGUgJiYgcGx1cmFsRnVuYyApIHtcbiAgICAgIE1lc3NhZ2VGb3JtYXQubG9jYWxlWyBsb2NhbGUgXSA9IHBsdXJhbEZ1bmM7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdHNcbiAgICBmYWxsYmFja0xvY2FsZSA9IGxvY2FsZSA9IGxvY2FsZSB8fCBcImVuXCI7XG4gICAgcGx1cmFsRnVuYyA9IHBsdXJhbEZ1bmMgfHwgTWVzc2FnZUZvcm1hdC5sb2NhbGVbIGZhbGxiYWNrTG9jYWxlID0gTWVzc2FnZUZvcm1hdC5VdGlscy5nZXRGYWxsYmFja0xvY2FsZSggbG9jYWxlICkgXTtcblxuICAgIGlmICggISBwbHVyYWxGdW5jICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCBcIlBsdXJhbCBGdW5jdGlvbiBub3QgZm91bmQgZm9yIGxvY2FsZTogXCIgKyBsb2NhbGUgKTtcbiAgICB9XG5cbiAgICAvLyBPd24gUHJvcGVydGllc1xuICAgIHRoaXMucGx1cmFsRnVuYyA9IHBsdXJhbEZ1bmM7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5mYWxsYmFja0xvY2FsZSA9IGZhbGxiYWNrTG9jYWxlO1xuICB9XG5cbiAgLy8gU2V0IHVwIHRoZSBsb2NhbGVzIG9iamVjdC4gQWRkIGluIGVuZ2xpc2ggYnkgZGVmYXVsdFxuICBNZXNzYWdlRm9ybWF0LmxvY2FsZSA9IHtcbiAgICBcImVuXCIgOiBmdW5jdGlvbiAoIG4gKSB7XG4gICAgICBpZiAoIG4gPT09IDEgKSB7XG4gICAgICAgIHJldHVybiBcIm9uZVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbiAgLy8gbW9yZSBvciBsZXNzIHN0b2xlbiBmcm9tIEhhbmRsZWJhcnMgYnkgQHd5Y2F0c1xuICBNZXNzYWdlRm9ybWF0LlNhZmVTdHJpbmcgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICB9O1xuXG4gIE1lc3NhZ2VGb3JtYXQuU2FmZVN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgTWVzc2FnZUZvcm1hdC5VdGlscyA9IHtcbiAgICBudW1TdWIgOiBmdW5jdGlvbiAoIHN0cmluZywga2V5LCBkZXB0aCApIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGl0J3Mgbm90IGFuIGVzY2FwZWQgb2N0b3Rob3JwZVxuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvXiN8W15cXFxcXSMvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IG0gJiYgbS5sZW5ndGggPT09IDIgPyBtLmNoYXJBdCgwKSA6ICcnO1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgJ1wiICsgKGZ1bmN0aW9uKCl7IHZhciB4ID0gJyArXG4gICAgICAgIGtleSsnO1xcbmlmKCBpc05hTih4KSApe1xcbnRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2VGb3JtYXQ6IGBcIitsYXN0a2V5XycrZGVwdGgrJytcImAgaXNudCBhIG51bWJlci5cIik7XFxufVxcbnJldHVybiB4O1xcbn0pKCkgKyBcIic7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVzY2FwZUV4cHJlc3Npb24gOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICB2YXIgZXNjYXBlID0ge1xuICAgICAgICAgICAgXCJcXG5cIjogXCJcXFxcblwiLFxuICAgICAgICAgICAgXCJcXFwiXCI6ICdcXFxcXCInXG4gICAgICAgICAgfSxcbiAgICAgICAgICBiYWRDaGFycyA9IC9bXFxuXCJdL2csXG4gICAgICAgICAgcG9zc2libGUgPSAvW1xcblwiXS8sXG4gICAgICAgICAgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKGNocikge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZVtjaHJdIHx8IFwiJmFtcDtcIjtcbiAgICAgICAgICB9O1xuXG4gICAgICAvLyBEb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gICAgICBpZiAoIHN0cmluZyBpbnN0YW5jZW9mIE1lc3NhZ2VGb3JtYXQuU2FmZVN0cmluZyApIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IGZhbHNlICkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAhIHBvc3NpYmxlLnRlc3QoIHN0cmluZyApICkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKCBiYWRDaGFycywgZXNjYXBlQ2hhciApO1xuICAgIH0sXG4gICAgZ2V0RmFsbGJhY2tMb2NhbGU6IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XG4gICAgICB2YXIgdGFnU2VwYXJhdG9yID0gbG9jYWxlLmluZGV4T2YoXCItXCIpID49IDAgPyBcIi1cIiA6IFwiX1wiO1xuXG4gICAgICAvLyBMZXRzIGp1c3QgYmUgZnJpZW5kcywgZmFsbGJhY2sgdGhyb3VnaCB0aGUgbGFuZ3VhZ2UgdGFnc1xuICAgICAgd2hpbGUgKCAhIE1lc3NhZ2VGb3JtYXQubG9jYWxlLmhhc093blByb3BlcnR5KCBsb2NhbGUgKSApIHtcbiAgICAgICAgbG9jYWxlID0gbG9jYWxlLnN1YnN0cmluZygwLCBsb2NhbGUubGFzdEluZGV4T2YoIHRhZ1NlcGFyYXRvciApKTtcbiAgICAgICAgaWYgKGxvY2FsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9jYWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIGdlbmVyYXRlZCBhbmQgcHVsbGVkIGluIGZvciBicm93c2Vycy5cbiAgdmFyIG1wYXJzZXIgPSAoZnVuY3Rpb24oKXtcbiAgICAvKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuNi4yIChodHRwOi8vcGVnanMubWFqZGEuY3ovKS4gKi9cblxuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAvKlxuICAgICAgKiBQYXJzZXMgdGhlIGlucHV0IHdpdGggYSBnZW5lcmF0ZWQgcGFyc2VyLiBJZiB0aGUgcGFyc2luZyBpcyBzdWNjZXNzZnVsbCxcbiAgICAgICogcmV0dXJucyBhIHZhbHVlIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBzcGVjaWZpZWQgYnkgdGhlIGdyYW1tYXIgZnJvbVxuICAgICAgKiB3aGljaCB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgKHNlZSB8UEVHLmJ1aWxkUGFyc2VyfCkuIElmIHRoZSBwYXJzaW5nIGlzXG4gICAgICAqIHVuc3VjY2Vzc2Z1bCwgdGhyb3dzIHxQRUcucGFyc2VyLlN5bnRheEVycm9yfCBkZXNjcmliaW5nIHRoZSBlcnJvci5cbiAgICAgICovXG4gICAgICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0UnVsZSkge1xuICAgICAgICB2YXIgcGFyc2VGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgXCJfXCI6IHBhcnNlX18sXG4gICAgICAgICAgXCJjaGFyXCI6IHBhcnNlX2NoYXIsXG4gICAgICAgICAgXCJjaGFyc1wiOiBwYXJzZV9jaGFycyxcbiAgICAgICAgICBcImRpZ2l0c1wiOiBwYXJzZV9kaWdpdHMsXG4gICAgICAgICAgXCJlbGVtZW50Rm9ybWF0XCI6IHBhcnNlX2VsZW1lbnRGb3JtYXQsXG4gICAgICAgICAgXCJoZXhEaWdpdFwiOiBwYXJzZV9oZXhEaWdpdCxcbiAgICAgICAgICBcImlkXCI6IHBhcnNlX2lkLFxuICAgICAgICAgIFwibWVzc2FnZUZvcm1hdEVsZW1lbnRcIjogcGFyc2VfbWVzc2FnZUZvcm1hdEVsZW1lbnQsXG4gICAgICAgICAgXCJtZXNzYWdlRm9ybWF0UGF0dGVyblwiOiBwYXJzZV9tZXNzYWdlRm9ybWF0UGF0dGVybixcbiAgICAgICAgICBcIm1lc3NhZ2VGb3JtYXRQYXR0ZXJuUmlnaHRcIjogcGFyc2VfbWVzc2FnZUZvcm1hdFBhdHRlcm5SaWdodCxcbiAgICAgICAgICBcIm9mZnNldFBhdHRlcm5cIjogcGFyc2Vfb2Zmc2V0UGF0dGVybixcbiAgICAgICAgICBcInBsdXJhbEZvcm1hdFBhdHRlcm5cIjogcGFyc2VfcGx1cmFsRm9ybWF0UGF0dGVybixcbiAgICAgICAgICBcInBsdXJhbEZvcm1zXCI6IHBhcnNlX3BsdXJhbEZvcm1zLFxuICAgICAgICAgIFwicGx1cmFsU3R5bGVcIjogcGFyc2VfcGx1cmFsU3R5bGUsXG4gICAgICAgICAgXCJzZWxlY3RGb3JtYXRQYXR0ZXJuXCI6IHBhcnNlX3NlbGVjdEZvcm1hdFBhdHRlcm4sXG4gICAgICAgICAgXCJzZWxlY3RTdHlsZVwiOiBwYXJzZV9zZWxlY3RTdHlsZSxcbiAgICAgICAgICBcInN0YXJ0XCI6IHBhcnNlX3N0YXJ0LFxuICAgICAgICAgIFwic3RyaW5nXCI6IHBhcnNlX3N0cmluZyxcbiAgICAgICAgICBcInN0cmluZ0tleVwiOiBwYXJzZV9zdHJpbmdLZXksXG4gICAgICAgICAgXCJ3aGl0ZXNwYWNlXCI6IHBhcnNlX3doaXRlc3BhY2VcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJ1bGUgbmFtZTogXCIgKyBxdW90ZShzdGFydFJ1bGUpICsgXCIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFJ1bGUgPSBcInN0YXJ0XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIHJlcG9ydE1hdGNoRmFpbHVyZXMgPSB0cnVlO1xuICAgICAgICB2YXIgcmlnaHRtb3N0TWF0Y2hGYWlsdXJlc1BvcyA9IDA7XG4gICAgICAgIHZhciByaWdodG1vc3RNYXRjaEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGNhY2hlID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGlucHV0O1xuXG4gICAgICAgICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgICAgICAgICB2YXIgY2hhckNvZGUgPSBjaC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKGNoYXJDb2RlIDw9IDB4RkYpIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGVDaGFyID0gJ3gnO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlc2NhcGVDaGFyID0gJ3UnO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZUNoYXIgKyBwYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBxdW90ZShzKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYVxuICAgICAgICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgICAgICAqIGNhcnJpYWdlIHJldHVybiwgbGluZSBzZXBhcmF0b3IsIHBhcmFncmFwaCBzZXBhcmF0b3IsIGFuZCBsaW5lIGZlZWQuXG4gICAgICAgICAgKiBBbnkgY2hhcmFjdGVyIG1heSBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuICdcIicgKyBzXG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgICAgICAgICAgICAvLyBiYWNrc2xhc2hcbiAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICAgICAgICAgICAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlclxuICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAgICAgICAgICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgICAgICAgICAgICAvLyBsaW5lIGZlZWRcbiAgICAgICAgICAucmVwbGFjZSgvW1xceDgwLVxcdUZGRkZdL2csIGVzY2FwZSkgLy8gbm9uLUFTQ0lJIGNoYXJhY3RlcnNcbiAgICAgICAgICArICdcIic7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXRjaEZhaWxlZChmYWlsdXJlKSB7XG4gICAgICAgICAgaWYgKHBvcyA8IHJpZ2h0bW9zdE1hdGNoRmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocG9zID4gcmlnaHRtb3N0TWF0Y2hGYWlsdXJlc1Bvcykge1xuICAgICAgICAgICAgcmlnaHRtb3N0TWF0Y2hGYWlsdXJlc1BvcyA9IHBvcztcbiAgICAgICAgICAgIHJpZ2h0bW9zdE1hdGNoRmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJpZ2h0bW9zdE1hdGNoRmFpbHVyZXNFeHBlY3RlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RhcnQoKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ3N0YXJ0QCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgcmVzdWx0MSA9IHBhcnNlX21lc3NhZ2VGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24obWVzc2FnZUZvcm1hdFBhdHRlcm4pIHsgcmV0dXJuIHsgdHlwZTogXCJwcm9ncmFtXCIsIHByb2dyYW06IG1lc3NhZ2VGb3JtYXRQYXR0ZXJuIH07IH0pKHJlc3VsdDEpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgcmVzdWx0OiAgcmVzdWx0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZV9tZXNzYWdlRm9ybWF0UGF0dGVybigpIHtcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSAnbWVzc2FnZUZvcm1hdFBhdHRlcm5AJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB2YXIgc2F2ZWRQb3MwID0gcG9zO1xuICAgICAgICAgIHZhciBzYXZlZFBvczEgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDMgPSBwYXJzZV9zdHJpbmcoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDQgPSBbXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ1ID0gcGFyc2VfbWVzc2FnZUZvcm1hdFBhdHRlcm5SaWdodCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0NC5wdXNoKHJlc3VsdDUpO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IHBhcnNlX21lc3NhZ2VGb3JtYXRQYXR0ZXJuUmlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQxID0gW3Jlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24oczEsIGlubmVyKSB7XG4gICAgICAgICAgICB2YXIgc3QgPSBbXTtcbiAgICAgICAgICAgIGlmICggczEgJiYgczEudmFsICkge1xuICAgICAgICAgICAgICBzdC5wdXNoKCBzMSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKCB2YXIgaSBpbiBpbm5lciApe1xuICAgICAgICAgICAgICBpZiAoIGlubmVyLmhhc093blByb3BlcnR5KCBpICkgKSB7XG4gICAgICAgICAgICAgICAgc3QucHVzaCggaW5uZXJbIGkgXSApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbWVzc2FnZUZvcm1hdFBhdHRlcm4nLCBzdGF0ZW1lbnRzOiBzdCB9O1xuICAgICAgICAgIH0pKHJlc3VsdDFbMF0sIHJlc3VsdDFbMV0pXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgcmVzdWx0OiAgcmVzdWx0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZV9tZXNzYWdlRm9ybWF0UGF0dGVyblJpZ2h0KCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdtZXNzYWdlRm9ybWF0UGF0dGVyblJpZ2h0QCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAxKSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQzID0gXCJ7XCI7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIntcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ0ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IHBhcnNlX21lc3NhZ2VGb3JtYXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NiA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMSkgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NyA9IFwifVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwifVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0OCA9IHBhcnNlX3N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBbcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NSwgcmVzdWx0NiwgcmVzdWx0NywgcmVzdWx0OF07XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHJlc3VsdDEgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbihtZmUsIHMxKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICBpZiAoIG1mZSApIHtcbiAgICAgICAgICAgICAgcmVzLnB1c2gobWZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggczEgJiYgczEudmFsICkge1xuICAgICAgICAgICAgICByZXMucHVzaCggczEgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZUZvcm1hdFBhdHRlcm5SaWdodFwiLCBzdGF0ZW1lbnRzIDogcmVzIH07XG4gICAgICAgICAgfSkocmVzdWx0MVsyXSwgcmVzdWx0MVs1XSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MwO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX21lc3NhZ2VGb3JtYXRFbGVtZW50KCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdtZXNzYWdlRm9ybWF0RWxlbWVudEAnICsgcG9zO1xuICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgdmFyIHNhdmVkUG9zMSA9IHBvcztcbiAgICAgICAgICB2YXIgcmVzdWx0MyA9IHBhcnNlX2lkKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzYXZlZFBvczIgPSBwb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ2ID0gXCIsXCI7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIixcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0NiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NyA9IHBhcnNlX2VsZW1lbnRGb3JtYXQoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IFtyZXN1bHQ2LCByZXN1bHQ3XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQ0ID0gcmVzdWx0NSAhPT0gbnVsbCA/IHJlc3VsdDUgOiAnJztcbiAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQxID0gW3Jlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24oYXJnSWR4LCBlZm10KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VGb3JtYXRFbGVtZW50XCIsXG4gICAgICAgICAgICAgIGFyZ3VtZW50SW5kZXg6IGFyZ0lkeFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICggZWZtdCAmJiBlZm10Lmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgcmVzLmVsZW1lbnRGb3JtYXQgPSBlZm10WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlcy5vdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9KShyZXN1bHQxWzBdLCByZXN1bHQxWzFdKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfZWxlbWVudEZvcm1hdCgpIHtcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSAnZWxlbWVudEZvcm1hdEAnICsgcG9zO1xuICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIHZhciBzYXZlZFBvczIgPSBwb3M7XG4gICAgICAgICAgdmFyIHNhdmVkUG9zMyA9IHBvcztcbiAgICAgICAgICB2YXIgcmVzdWx0MTQgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDE0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwicGx1cmFsXCIpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDE1ID0gXCJwbHVyYWxcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MTUgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInBsdXJhbFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxNSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MTYgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQxNiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAxKSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxNyA9IFwiLFwiO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxNyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIsXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDE3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MTggPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MTggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDE5ID0gcGFyc2VfcGx1cmFsU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDE5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIwID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyMCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gW3Jlc3VsdDE0LCByZXN1bHQxNSwgcmVzdWx0MTYsIHJlc3VsdDE3LCByZXN1bHQxOCwgcmVzdWx0MTksIHJlc3VsdDIwXTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQxMiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEyID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDEzID0gcmVzdWx0MTIgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlIDogXCJlbGVtZW50Rm9ybWF0XCIsXG4gICAgICAgICAgICAgIGtleSAgOiB0LFxuICAgICAgICAgICAgICB2YWwgIDogcy52YWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocmVzdWx0MTJbMV0sIHJlc3VsdDEyWzVdKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MTMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxMSA9IHJlc3VsdDEzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MTEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MTEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDQgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IFwic2VsZWN0XCI7XG4gICAgICAgICAgICAgICAgcG9zICs9IDY7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJzZWxlY3RcXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0NSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ2ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ3ID0gXCIsXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIixcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0OCA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0OSA9IHBhcnNlX3NlbGVjdFN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMCA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxMCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IFtyZXN1bHQ0LCByZXN1bHQ1LCByZXN1bHQ2LCByZXN1bHQ3LCByZXN1bHQ4LCByZXN1bHQ5LCByZXN1bHQxMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQzID0gcmVzdWx0MiAhPT0gbnVsbFxuICAgICAgICAgICAgPyAoZnVuY3Rpb24odCwgcykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGUgOiBcImVsZW1lbnRGb3JtYXRcIixcbiAgICAgICAgICAgICAgICBrZXkgIDogdCxcbiAgICAgICAgICAgICAgICB2YWwgIDogcy52YWxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHJlc3VsdDJbMV0sIHJlc3VsdDJbNV0pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IHJlc3VsdDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDs7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX3BsdXJhbFN0eWxlKCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdwbHVyYWxTdHlsZUAnICsgcG9zO1xuICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDEgPSBwYXJzZV9wbHVyYWxGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24ocGZwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInBsdXJhbFN0eWxlXCIsIHZhbDogcGZwIH07XG4gICAgICAgICAgfSkocmVzdWx0MSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MwO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlbGVjdFN0eWxlKCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdzZWxlY3RTdHlsZUAnICsgcG9zO1xuICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDEgPSBwYXJzZV9zZWxlY3RGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24oc2ZwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInNlbGVjdFN0eWxlXCIsIHZhbDogc2ZwIH07XG4gICAgICAgICAgfSkocmVzdWx0MSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MwO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX3BsdXJhbEZvcm1hdFBhdHRlcm4oKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ3BsdXJhbEZvcm1hdFBhdHRlcm5AJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB2YXIgc2F2ZWRQb3MwID0gcG9zO1xuICAgICAgICAgIHZhciBzYXZlZFBvczEgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDYgPSBwYXJzZV9vZmZzZXRQYXR0ZXJuKCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDMgPSByZXN1bHQ2ICE9PSBudWxsID8gcmVzdWx0NiA6ICcnO1xuICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0NCA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBwYXJzZV9wbHVyYWxGb3JtcygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0NC5wdXNoKHJlc3VsdDUpO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IHBhcnNlX3BsdXJhbEZvcm1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IFtyZXN1bHQzLCByZXN1bHQ0XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gcmVzdWx0MSAhPT0gbnVsbFxuICAgICAgICAgID8gKGZ1bmN0aW9uKG9wLCBwZikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJwbHVyYWxGb3JtYXRQYXR0ZXJuXCIsXG4gICAgICAgICAgICAgIHBsdXJhbEZvcm1zOiBwZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICggb3AgKSB7XG4gICAgICAgICAgICAgIHJlcy5vZmZzZXQgPSBvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXMub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSkocmVzdWx0MVswXSwgcmVzdWx0MVsxXSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MwO1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX29mZnNldFBhdHRlcm4oKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ29mZnNldFBhdHRlcm5AJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB2YXIgc2F2ZWRQb3MwID0gcG9zO1xuICAgICAgICAgIHZhciBzYXZlZFBvczEgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDMgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA2KSA9PT0gXCJvZmZzZXRcIikge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NCA9IFwib2Zmc2V0XCI7XG4gICAgICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDQgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIm9mZnNldFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ1ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0NSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAxKSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ2ID0gXCI6XCI7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydE1hdGNoRmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiOlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NyA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ4ID0gcGFyc2VfZGlnaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDkgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gW3Jlc3VsdDMsIHJlc3VsdDQsIHJlc3VsdDUsIHJlc3VsdDYsIHJlc3VsdDcsIHJlc3VsdDgsIHJlc3VsdDldO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gcmVzdWx0MSAhPT0gbnVsbFxuICAgICAgICAgID8gKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pKHJlc3VsdDFbNV0pXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgcmVzdWx0OiAgcmVzdWx0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZV9zZWxlY3RGb3JtYXRQYXR0ZXJuKCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdzZWxlY3RGb3JtYXRQYXR0ZXJuQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIHZhciByZXN1bHQzID0gcGFyc2VfcGx1cmFsRm9ybXMoKTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDMgPSBwYXJzZV9wbHVyYWxGb3JtcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHJlc3VsdDEgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbihwZikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZWxlY3RGb3JtYXRQYXR0ZXJuXCIsXG4gICAgICAgICAgICAgIHBsdXJhbEZvcm1zOiBwZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KShyZXN1bHQxKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfcGx1cmFsRm9ybXMoKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ3BsdXJhbEZvcm1zQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgIHZhciByZXN1bHQzID0gcGFyc2VfXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0NCA9IHBhcnNlX3N0cmluZ0tleSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQ1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDEpID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSBcIntcIjtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwie1xcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDcgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ4ID0gcGFyc2VfbWVzc2FnZUZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ5ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0OSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAxKSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMCA9IFwifVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MTAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIn1cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MTAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gW3Jlc3VsdDMsIHJlc3VsdDQsIHJlc3VsdDUsIHJlc3VsdDYsIHJlc3VsdDcsIHJlc3VsdDgsIHJlc3VsdDksIHJlc3VsdDEwXTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHJlc3VsdDEgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbihrLCBtZnApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGx1cmFsRm9ybXNcIixcbiAgICAgICAgICAgICAga2V5OiBrLFxuICAgICAgICAgICAgICB2YWw6IG1mcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KShyZXN1bHQxWzFdLCByZXN1bHQxWzVdKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2Vfc3RyaW5nS2V5KCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdzdHJpbmdLZXlAJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB2YXIgc2F2ZWRQb3MyID0gcG9zO1xuICAgICAgICAgIHZhciByZXN1bHQ3ID0gcGFyc2VfaWQoKTtcbiAgICAgICAgICB2YXIgcmVzdWx0OCA9IHJlc3VsdDcgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9KShyZXN1bHQ3KVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0OCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSByZXN1bHQ4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0NiA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQ2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDEpID09PSBcIj1cIikge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NCA9IFwiPVwiO1xuICAgICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydE1hdGNoRmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI9XFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBwYXJzZV9kaWdpdHMoKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IFtyZXN1bHQ0LCByZXN1bHQ1XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQzID0gcmVzdWx0MiAhPT0gbnVsbFxuICAgICAgICAgICAgPyAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH0pKHJlc3VsdDJbMV0pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IHJlc3VsdDM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDs7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZygpIHtcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSAnc3RyaW5nQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgIHZhciByZXN1bHQzID0gcGFyc2VfXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0NCA9IFtdO1xuICAgICAgICAgICAgdmFyIHNhdmVkUG9zMiA9IHBvcztcbiAgICAgICAgICAgIHZhciByZXN1bHQ2ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDcgPSBwYXJzZV9jaGFycygpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0NyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ4ID0gcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IFtyZXN1bHQ2LCByZXN1bHQ3LCByZXN1bHQ4XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQ1ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDQucHVzaChyZXN1bHQ1KTtcbiAgICAgICAgICAgICAgdmFyIHNhdmVkUG9zMiA9IHBvcztcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSBwYXJzZV9fKCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQ2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDcgPSBwYXJzZV9jaGFycygpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0OCA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ1ID0gW3Jlc3VsdDYsIHJlc3VsdDcsIHJlc3VsdDhdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ1ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBbcmVzdWx0MywgcmVzdWx0NF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHJlc3VsdDEgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbih3cywgcykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNbIGkgXS5sZW5ndGg7ICsraiApIHtcbiAgICAgICAgICAgICAgICB0bXAucHVzaChzW2ldW2pdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsOiB3cyArIHRtcC5qb2luKCcnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KShyZXN1bHQxWzBdLCByZXN1bHQxWzFdKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfaWQoKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ2lkQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgIHZhciByZXN1bHQzID0gcGFyc2VfXygpO1xuICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcykubWF0Y2goL15bYS16QS1aJF9dLykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDQgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbYS16QS1aJF9dXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0NSA9IFtdO1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcykubWF0Y2goL15bXiBcdFxcblxcciwuKz17fV0vKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ3ID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlteIFx0XFxcXG5cXFxcciwuKz17fV1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChyZXN1bHQ3ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0NS5wdXNoKHJlc3VsdDcpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zKS5tYXRjaCgvXlteIFx0XFxuXFxyLC4rPXt9XS8pICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ3ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW14gXHRcXFxcblxcXFxyLC4rPXt9XVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NiA9IHBhcnNlX18oKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0NiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBbcmVzdWx0MywgcmVzdWx0NCwgcmVzdWx0NSwgcmVzdWx0Nl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24oczEsIHMyKSB7XG4gICAgICAgICAgICByZXR1cm4gczEgKyAoczIgPyBzMi5qb2luKCcnKSA6ICcnKTtcbiAgICAgICAgICB9KShyZXN1bHQxWzFdLCByZXN1bHQxWzJdKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfY2hhcnMoKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ2NoYXJzQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICB2YXIgcmVzdWx0MyA9IHBhcnNlX2NoYXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDMgPSBwYXJzZV9jaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSByZXN1bHQxICE9PSBudWxsXG4gICAgICAgICAgPyAoZnVuY3Rpb24oY2hhcnMpIHsgcmV0dXJuIGNoYXJzLmpvaW4oJycpOyB9KShyZXN1bHQxKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfY2hhcigpIHtcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSAnY2hhckAnICsgcG9zO1xuICAgICAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgcG9zID0gY2FjaGVkUmVzdWx0Lm5leHRQb3M7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIHZhciBzYXZlZFBvczUgPSBwb3M7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MpLm1hdGNoKC9eW157fVxcXFxcXDAtXHUwMDFmfyBcdFxcblxccl0vKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDE5ID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDE5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRNYXRjaEZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW157fVxcXFxcXFxcXFxcXDAtXHUwMDFmfyBcdFxcXFxuXFxcXHJdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MjAgPSByZXN1bHQxOSAhPT0gbnVsbFxuICAgICAgICAgID8gKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgIH0pKHJlc3VsdDE5KVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MjAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxOCA9IHJlc3VsdDIwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MTggPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3M1O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MTggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gcmVzdWx0MTg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzYXZlZFBvczQgPSBwb3M7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXCNcIikge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MTYgPSBcIlxcXFwjXCI7XG4gICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDE2ID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydE1hdGNoRmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXCNcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0MTcgPSByZXN1bHQxNiAhPT0gbnVsbFxuICAgICAgICAgICAgPyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBcIlxcXFwjXCI7XG4gICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzdWx0MTcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDE1ID0gcmVzdWx0MTc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0MTUgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MTUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQxNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBzYXZlZFBvczMgPSBwb3M7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxce1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEzID0gXCJcXFxce1wiO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHtcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MTQgPSByZXN1bHQxMyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgPyAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcdTAwN0JcIjtcbiAgICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxNCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MTIgPSByZXN1bHQxNDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDEyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhdmVkUG9zMiA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFx9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MTAgPSBcIlxcXFx9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQxMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXH1cXFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcmVzdWx0MTEgPSByZXN1bHQxMCAhPT0gbnVsbFxuICAgICAgICAgICAgICA/IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcXHUwMDdEXCI7XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MTEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0OSA9IHJlc3VsdDExO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhdmVkUG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICB2YXIgc2F2ZWRQb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcdVwiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NCA9IFwiXFxcXHVcIjtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHVcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDUgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDYgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ3ID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDggPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBbcmVzdWx0NCwgcmVzdWx0NSwgcmVzdWx0NiwgcmVzdWx0NywgcmVzdWx0OF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2F2ZWRQb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MyA9IHJlc3VsdDIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IChmdW5jdGlvbihoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoXCIweFwiICsgaDEgKyBoMiArIGgzICsgaDQpKTtcbiAgICAgICAgICAgICAgICB9KShyZXN1bHQyWzFdLCByZXN1bHQyWzJdLCByZXN1bHQyWzNdLCByZXN1bHQyWzRdKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSByZXN1bHQzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDs7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfZGlnaXRzKCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICdkaWdpdHNAJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICB2YXIgc2F2ZWRQb3MwID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zKS5tYXRjaCgvXlswLTldLykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQzID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydE1hdGNoRmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQxID0gW107XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Myk7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zKS5tYXRjaCgvXlswLTldLykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MyA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHJlc3VsdDEgIT09IG51bGxcbiAgICAgICAgICA/IChmdW5jdGlvbihkcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChkcy5qb2luKCcnKSksIDEwKTtcbiAgICAgICAgICB9KShyZXN1bHQxKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSByZXN1bHQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBzYXZlZFBvczA7XG4gICAgICAgICAgfVxuXG5cblxuICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgICAgICAgIG5leHRQb3M6IHBvcyxcbiAgICAgICAgICAgIHJlc3VsdDogIHJlc3VsdDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VfaGV4RGlnaXQoKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ2hleERpZ2l0QCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MpLm1hdGNoKC9eWzAtOWEtZkEtRl0vKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTlhLWZBLUZdXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgICBuZXh0UG9zOiBwb3MsXG4gICAgICAgICAgICByZXN1bHQ6ICByZXN1bHQwXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlX18oKSB7XG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gJ19AJyArIHBvcztcbiAgICAgICAgICB2YXIgY2FjaGVkUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHBvcyA9IGNhY2hlZFJlc3VsdC5uZXh0UG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNhdmVkUmVwb3J0TWF0Y2hGYWlsdXJlcyA9IHJlcG9ydE1hdGNoRmFpbHVyZXM7XG4gICAgICAgICAgcmVwb3J0TWF0Y2hGYWlsdXJlcyA9IGZhbHNlO1xuICAgICAgICAgIHZhciBzYXZlZFBvczAgPSBwb3M7XG4gICAgICAgICAgdmFyIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICB2YXIgcmVzdWx0MyA9IHBhcnNlX3doaXRlc3BhY2UoKTtcbiAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDMpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDMgPSBwYXJzZV93aGl0ZXNwYWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gcmVzdWx0MSAhPT0gbnVsbFxuICAgICAgICAgID8gKGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHcuam9pbignJyk7IH0pKHJlc3VsdDEpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IHJlc3VsdDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHNhdmVkUG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwb3J0TWF0Y2hGYWlsdXJlcyA9IHNhdmVkUmVwb3J0TWF0Y2hGYWlsdXJlcztcbiAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcyAmJiByZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIndoaXRlc3BhY2VcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgcmVzdWx0OiAgcmVzdWx0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZV93aGl0ZXNwYWNlKCkge1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9ICd3aGl0ZXNwYWNlQCcgKyBwb3M7XG4gICAgICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICBwb3MgPSBjYWNoZWRSZXN1bHQubmV4dFBvcztcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQucmVzdWx0O1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MpLm1hdGNoKC9eWyBcdFxcblxccl0vKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0TWF0Y2hGYWlsdXJlcykge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlsgXHRcXFxcblxcXFxyXVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgICAgICAgbmV4dFBvczogcG9zLFxuICAgICAgICAgICAgcmVzdWx0OiAgcmVzdWx0MFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBidWlsZEVycm9yTWVzc2FnZSgpIHtcbiAgICAgICAgICBmdW5jdGlvbiBidWlsZEV4cGVjdGVkKGZhaWx1cmVzRXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGZhaWx1cmVzRXhwZWN0ZWQuc29ydCgpO1xuXG4gICAgICAgICAgICB2YXIgbGFzdEZhaWx1cmUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGZhaWx1cmVzRXhwZWN0ZWRVbmlxdWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmFpbHVyZXNFeHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoZmFpbHVyZXNFeHBlY3RlZFtpXSAhPT0gbGFzdEZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlc0V4cGVjdGVkVW5pcXVlLnB1c2goZmFpbHVyZXNFeHBlY3RlZFtpXSk7XG4gICAgICAgICAgICAgICAgbGFzdEZhaWx1cmUgPSBmYWlsdXJlc0V4cGVjdGVkW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZmFpbHVyZXNFeHBlY3RlZFVuaXF1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZW5kIG9mIGlucHV0JztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsdXJlc0V4cGVjdGVkVW5pcXVlWzBdO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsdXJlc0V4cGVjdGVkVW5pcXVlLnNsaWNlKDAsIGZhaWx1cmVzRXhwZWN0ZWRVbmlxdWUubGVuZ3RoIC0gMSkuam9pbignLCAnKVxuICAgICAgICAgICAgICArICcgb3IgJ1xuICAgICAgICAgICAgICArIGZhaWx1cmVzRXhwZWN0ZWRVbmlxdWVbZmFpbHVyZXNFeHBlY3RlZFVuaXF1ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSBidWlsZEV4cGVjdGVkKHJpZ2h0bW9zdE1hdGNoRmFpbHVyZXNFeHBlY3RlZCk7XG4gICAgICAgICAgdmFyIGFjdHVhbFBvcyA9IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0TWF0Y2hGYWlsdXJlc1Bvcyk7XG4gICAgICAgICAgdmFyIGFjdHVhbCA9IGFjdHVhbFBvcyA8IGlucHV0Lmxlbmd0aFxuICAgICAgICAgID8gcXVvdGUoaW5wdXQuY2hhckF0KGFjdHVhbFBvcykpXG4gICAgICAgICAgOiAnZW5kIG9mIGlucHV0JztcblxuICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIGV4cGVjdGVkICsgJyBidXQgJyArIGFjdHVhbCArICcgZm91bmQuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVFcnJvclBvc2l0aW9uKCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgKiBUaGUgZmlyc3QgaWRlYSB3YXMgdG8gdXNlIHxTdHJpbmcuc3BsaXR8IHRvIGJyZWFrIHRoZSBpbnB1dCB1cCB0byB0aGVcbiAgICAgICAgICAqIGVycm9yIHBvc2l0aW9uIGFsb25nIG5ld2xpbmVzIGFuZCBkZXJpdmUgdGhlIGxpbmUgYW5kIGNvbHVtbiBmcm9tXG4gICAgICAgICAgKiB0aGVyZS4gSG93ZXZlciBJRSdzIHxzcGxpdHwgaW1wbGVtZW50YXRpb24gaXMgc28gYnJva2VuIHRoYXQgaXQgd2FzXG4gICAgICAgICAgKiBlbm91Z2ggdG8gcHJldmVudCBpdC5cbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICAgIHZhciBzZWVuQ1IgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgIHJpZ2h0bW9zdE1hdGNoRmFpbHVyZXNQb3M7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgICBpZiAoIXNlZW5DUikgeyBsaW5lKys7IH1cbiAgICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxyJyB8IGNoID09PSAnXFx1MjAyOCcgfHwgY2ggPT09ICdcXHUyMDI5Jykge1xuICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgIHNlZW5DUiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSgpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAgICAgICAqXG4gICAgICAgICogMS4gVGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSB3aG9sZSBpbnB1dC5cbiAgICAgICAgKlxuICAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHxcbiAgICAgICAgKiAgICAtIHxwb3MgPT09IGlucHV0Lmxlbmd0aHxcbiAgICAgICAgKiAgICAtIHxyaWdodG1vc3RNYXRjaEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgICpcbiAgICAgICAgKiAyLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgb25seSBhIHBhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgICAqXG4gICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICAqICAgIC0gfHBvcyA8IGlucHV0Lmxlbmd0aHxcbiAgICAgICAgKiAgICAtIHxyaWdodG1vc3RNYXRjaEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgICpcbiAgICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKlxuICAgICAgICAqICAgLSB8cmVzdWx0ID09PSBudWxsfFxuICAgICAgICAqICAgLSB8cG9zID09PSAwfFxuICAgICAgICAqICAgLSB8cmlnaHRtb3N0TWF0Y2hGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZVxuICAgICAgICAqXG4gICAgICAgICogQWxsIGNvZGUgZm9sbG93aW5nIHRoaXMgY29tbWVudCAoaW5jbHVkaW5nIGNhbGxlZCBmdW5jdGlvbnMpIG11c3RcbiAgICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLlxuICAgICAgICAqL1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGVycm9yUG9zaXRpb24gPSBjb21wdXRlRXJyb3JQb3NpdGlvbigpO1xuICAgICAgICAgIHRocm93IG5ldyB0aGlzLlN5bnRheEVycm9yKFxuICAgICAgICAgICAgYnVpbGRFcnJvck1lc3NhZ2UoKSxcbiAgICAgICAgICAgIGVycm9yUG9zaXRpb24ubGluZSxcbiAgICAgICAgICAgIGVycm9yUG9zaXRpb24uY29sdW1uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuXG4gICAgICAvKiBSZXR1cm5zIHRoZSBwYXJzZXIgc291cmNlIGNvZGUuICovXG4gICAgICB0b1NvdXJjZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cbiAgICB9O1xuXG4gICAgLyogVGhyb3duIHdoZW4gYSBwYXJzZXIgZW5jb3VudGVycyBhIHN5bnRheCBlcnJvci4gKi9cblxuICAgIHJlc3VsdC5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbikge1xuICAgICAgdGhpcy5uYW1lID0gJ1N5bnRheEVycm9yJztcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgfTtcblxuICAgIHJlc3VsdC5TeW50YXhFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KSgpO1xuXG4gIE1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEJpbmQgdG8gaXRzZWxmIHNvIGVycm9yIGhhbmRsaW5nIHdvcmtzXG4gICAgcmV0dXJuIG1wYXJzZXIucGFyc2UuYXBwbHkoIG1wYXJzZXIsIGFyZ3VtZW50cyApO1xuICB9O1xuXG4gIE1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLnByZWNvbXBpbGUgPSBmdW5jdGlvbiAoIGFzdCApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIG5lZWRPdGhlciA9IGZhbHNlLFxuICAgICAgICBmcCA9IHtcbiAgICAgIGJlZ2luOiAnZnVuY3Rpb24oZCl7XFxudmFyIHIgPSBcIlwiO1xcbicsXG4gICAgICBlbmQgIDogXCJyZXR1cm4gcjtcXG59XCJcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaW50ZXJwTUZQICggYXN0LCBkYXRhICkge1xuICAgICAgLy8gU2V0IHNvbWUgZGVmYXVsdCBkYXRhXG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIHZhciBzID0gJycsIGksIHRtcCwgbGFzdGtleW5hbWU7XG5cbiAgICAgIHN3aXRjaCAoIGFzdC50eXBlICkge1xuICAgICAgICBjYXNlICdwcm9ncmFtJzpcbiAgICAgICAgICByZXR1cm4gaW50ZXJwTUZQKCBhc3QucHJvZ3JhbSApO1xuICAgICAgICBjYXNlICdtZXNzYWdlRm9ybWF0UGF0dGVybic6XG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhc3Quc3RhdGVtZW50cy5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgIHMgKz0gaW50ZXJwTUZQKCBhc3Quc3RhdGVtZW50c1tpXSwgZGF0YSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnAuYmVnaW4gKyBzICsgZnAuZW5kO1xuICAgICAgICBjYXNlICdtZXNzYWdlRm9ybWF0UGF0dGVyblJpZ2h0JzpcbiAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFzdC5zdGF0ZW1lbnRzLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgcyArPSBpbnRlcnBNRlAoIGFzdC5zdGF0ZW1lbnRzW2ldLCBkYXRhICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBjYXNlICdtZXNzYWdlRm9ybWF0RWxlbWVudCc6XG4gICAgICAgICAgZGF0YS5wZl9jb3VudCA9IGRhdGEucGZfY291bnQgfHwgMDtcbiAgICAgICAgICBzICs9ICdpZighZCl7XFxudGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZUZvcm1hdDogTm8gZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb24uXCIpO1xcbn1cXG4nO1xuICAgICAgICAgIGlmICggYXN0Lm91dHB1dCApIHtcbiAgICAgICAgICAgIHMgKz0gJ3IgKz0gZFtcIicgKyBhc3QuYXJndW1lbnRJbmRleCArICdcIl07XFxuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0a2V5bmFtZSA9ICdsYXN0a2V5XycrKGRhdGEucGZfY291bnQrMSk7XG4gICAgICAgICAgICBzICs9ICd2YXIgJytsYXN0a2V5bmFtZSsnID0gXCInK2FzdC5hcmd1bWVudEluZGV4KydcIjtcXG4nO1xuICAgICAgICAgICAgcyArPSAndmFyIGtfJysoZGF0YS5wZl9jb3VudCsxKSsnPWRbJytsYXN0a2V5bmFtZSsnXTtcXG4nO1xuICAgICAgICAgICAgcyArPSBpbnRlcnBNRlAoIGFzdC5lbGVtZW50Rm9ybWF0LCBkYXRhICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICBjYXNlICdlbGVtZW50Rm9ybWF0JzpcbiAgICAgICAgICBpZiAoIGFzdC5rZXkgPT09ICdzZWxlY3QnICkge1xuICAgICAgICAgICAgcyArPSBpbnRlcnBNRlAoIGFzdC52YWwsIGRhdGEgKTtcbiAgICAgICAgICAgIHMgKz0gJ3IgKz0gKHBmXycgK1xuICAgICAgICAgICAgICAgICBkYXRhLnBmX2NvdW50ICtcbiAgICAgICAgICAgICAgICAgJ1sga18nICsgKGRhdGEucGZfY291bnQrMSkgKyAnIF0gfHwgcGZfJytkYXRhLnBmX2NvdW50KydbIFwib3RoZXJcIiBdKSggZCApO1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCBhc3Qua2V5ID09PSAncGx1cmFsJyApIHtcbiAgICAgICAgICAgIHMgKz0gaW50ZXJwTUZQKCBhc3QudmFsLCBkYXRhICk7XG4gICAgICAgICAgICBzICs9ICdpZiAoIHBmXycrKGRhdGEucGZfY291bnQpKydbIGtfJysoZGF0YS5wZl9jb3VudCsxKSsnICsgXCJcIiBdICkge1xcbic7XG4gICAgICAgICAgICBzICs9ICdyICs9IHBmXycrZGF0YS5wZl9jb3VudCsnWyBrXycrKGRhdGEucGZfY291bnQrMSkrJyArIFwiXCIgXSggZCApOyBcXG4nO1xuICAgICAgICAgICAgcyArPSAnfVxcbmVsc2Uge1xcbic7XG4gICAgICAgICAgICBzICs9ICdyICs9IChwZl8nICtcbiAgICAgICAgICAgICAgICAgZGF0YS5wZl9jb3VudCArXG4gICAgICAgICAgICAgICAgICdbIE1lc3NhZ2VGb3JtYXQubG9jYWxlW1wiJyArXG4gICAgICAgICAgICAgICAgIHNlbGYuZmFsbGJhY2tMb2NhbGUgK1xuICAgICAgICAgICAgICAgICAnXCJdKCBrXycrKGRhdGEucGZfY291bnQrMSkrJyAtIG9mZl8nKyhkYXRhLnBmX2NvdW50KSsnICkgXSB8fCBwZl8nK2RhdGEucGZfY291bnQrJ1sgXCJvdGhlclwiIF0gKSggZCApO1xcbic7XG4gICAgICAgICAgICBzICs9ICd9XFxuJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIC8qIC8vIFVucmVhY2hhYmxlIGNhc2VzLlxuICAgICAgICBjYXNlICdwbHVyYWxTdHlsZSc6XG4gICAgICAgIGNhc2UgJ3NlbGVjdFN0eWxlJzoqL1xuICAgICAgICBjYXNlICdwbHVyYWxGb3JtYXRQYXR0ZXJuJzpcbiAgICAgICAgICBkYXRhLnBmX2NvdW50ID0gZGF0YS5wZl9jb3VudCB8fCAwO1xuICAgICAgICAgIHMgKz0gJ3ZhciBvZmZfJytkYXRhLnBmX2NvdW50KycgPSAnK2FzdC5vZmZzZXQrJztcXG4nO1xuICAgICAgICAgIHMgKz0gJ3ZhciBwZl8nICsgZGF0YS5wZl9jb3VudCArICcgPSB7IFxcbic7XG4gICAgICAgICAgbmVlZE90aGVyID0gdHJ1ZTtcbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBzaW11bHRhbmVvdXNseSBjaGVjayB0byBtYWtlIHN1cmUgd2UgaGl0IHRoZSByZXF1aXJlZCAnb3RoZXInIG9wdGlvbi5cblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgYXN0LnBsdXJhbEZvcm1zLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgICAgaWYgKCBhc3QucGx1cmFsRm9ybXNbIGkgXS5rZXkgPT09ICdvdGhlcicgKSB7XG4gICAgICAgICAgICAgIG5lZWRPdGhlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB0bXAgKSB7XG4gICAgICAgICAgICAgIHMgKz0gJyxcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgdG1wID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgKz0gJ1wiJyArIGFzdC5wbHVyYWxGb3Jtc1sgaSBdLmtleSArICdcIiA6ICcgKyBpbnRlcnBNRlAoIGFzdC5wbHVyYWxGb3Jtc1sgaSBdLnZhbCxcbiAgICAgICAgICAoZnVuY3Rpb24oKXsgdmFyIHJlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpOyByZXMucGZfY291bnQrKzsgcmV0dXJuIHJlczsgfSkoKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzICs9ICdcXG59O1xcbic7XG4gICAgICAgICAgaWYgKCBuZWVkT3RoZXIgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyAnb3RoZXInIGZvcm0gZm91bmQgaW4gcGx1cmFsRm9ybWF0UGF0dGVybiBcIiArIGRhdGEucGZfY291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgY2FzZSAnc2VsZWN0Rm9ybWF0UGF0dGVybic6XG5cbiAgICAgICAgICBkYXRhLnBmX2NvdW50ID0gZGF0YS5wZl9jb3VudCB8fCAwO1xuICAgICAgICAgIHMgKz0gJ3ZhciBvZmZfJytkYXRhLnBmX2NvdW50KycgPSAwO1xcbic7XG4gICAgICAgICAgcyArPSAndmFyIHBmXycgKyBkYXRhLnBmX2NvdW50ICsgJyA9IHsgXFxuJztcbiAgICAgICAgICBuZWVkT3RoZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhc3QucGx1cmFsRm9ybXMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgICBpZiAoIGFzdC5wbHVyYWxGb3Jtc1sgaSBdLmtleSA9PT0gJ290aGVyJyApIHtcbiAgICAgICAgICAgICAgbmVlZE90aGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRtcCApIHtcbiAgICAgICAgICAgICAgcyArPSAnLFxcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICB0bXAgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyArPSAnXCInICsgYXN0LnBsdXJhbEZvcm1zWyBpIF0ua2V5ICsgJ1wiIDogJyArIGludGVycE1GUCggYXN0LnBsdXJhbEZvcm1zWyBpIF0udmFsLFxuICAgICAgICAgICAgICAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGRhdGEgKSApO1xuICAgICAgICAgICAgICAgIHJlcy5wZl9jb3VudCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMgKz0gJ1xcbn07XFxuJztcbiAgICAgICAgICBpZiAoIG5lZWRPdGhlciApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vICdvdGhlcicgZm9ybSBmb3VuZCBpbiBzZWxlY3RGb3JtYXRQYXR0ZXJuIFwiICsgZGF0YS5wZl9jb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAvKiAvLyBVbnJlYWNoYWJsZVxuICAgICAgICBjYXNlICdwbHVyYWxGb3Jtcyc6XG4gICAgICAgICovXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcmV0dXJuICdyICs9IFwiJyArIE1lc3NhZ2VGb3JtYXQuVXRpbHMubnVtU3ViKFxuICAgICAgICAgICAgTWVzc2FnZUZvcm1hdC5VdGlscy5lc2NhcGVFeHByZXNzaW9uKCBhc3QudmFsICksXG4gICAgICAgICAgICAna18nICsgZGF0YS5wZl9jb3VudCArICcgLSBvZmZfJyArICggZGF0YS5wZl9jb3VudCAtIDEgKSxcbiAgICAgICAgICAgIGRhdGEucGZfY291bnRcbiAgICAgICAgICApICsgJ1wiO1xcbic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnQmFkIEFTVCB0eXBlOiAnICsgYXN0LnR5cGUgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVycE1GUCggYXN0ICk7XG4gIH07XG5cbiAgTWVzc2FnZUZvcm1hdC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uICggbWVzc2FnZSApIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbiggJ01lc3NhZ2VGb3JtYXQnLFxuICAgICAgJ3JldHVybiAnICtcbiAgICAgICAgdGhpcy5wcmVjb21waWxlKFxuICAgICAgICAgIHRoaXMucGFyc2UoIG1lc3NhZ2UgKVxuICAgICAgICApXG4gICAgKSkoTWVzc2FnZUZvcm1hdCk7XG4gIH07XG5cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlRm9ybWF0O1xuICAgIH1cbiAgICBleHBvcnRzLk1lc3NhZ2VGb3JtYXQgPSBNZXNzYWdlRm9ybWF0O1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNZXNzYWdlRm9ybWF0O1xuICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHJvb3RbJ01lc3NhZ2VGb3JtYXQnXSA9IE1lc3NhZ2VGb3JtYXQ7XG4gIH1cblxufSkoIHRoaXMgKTtcbiIsIi8vIFRoaXMgaXMgYSBzaW1wbGUgcmV3cml0ZSBvZiBtaWNyb2V2ZW50LmpzLiBJJ3ZlIGNoYW5nZWQgdGhlXG4vLyBmdW5jdGlvbiBuYW1lcyB0byBiZSBjb25zaXN0ZW50IHdpdGggbm9kZS5qcyBFdmVudEVtaXR0ZXIuXG4vL1xuLy8gbWljcm9ldmVudC5qcyBpcyBjb3B5cmlnaHQgSmVyb21lIEV0aWVubmUsIGFuZCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vamVyb21lZXRpZW5uZS9taWNyb2V2ZW50LmpzXG5cbnZhciBNaWNyb0V2ZW50ID0gZnVuY3Rpb24oKSB7fTtcblxuTWljcm9FdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgKGV2ZW50c1tldmVudF0gPSBldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTtcbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XSB8fCBbXTtcblxuICAvLyBTYWRseSwgbm8gSUU4IHN1cHBvcnQgZm9yIGluZGV4T2YuXG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgIGxpc3RlbmVyc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaSsrO1xuICB9XG5cbiAgLy8gQ29tcGFjdCB0aGUgbGlzdCB3aGVuIG5vIGV2ZW50IGhhbmRsZXIgaXMgYWN0dWFsbHkgcnVubmluZy5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBldmVudHNbZXZlbnRdID0gW107XG4gICAgdmFyIGZuO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBPbmx5IGFkZCBiYWNrIGV2ZW50IGhhbmRsZXJzIHdoaWNoIGV4aXN0LlxuICAgICAgaWYgKChmbiA9IGxpc3RlbmVyc1tpXSkpIGV2ZW50c1tldmVudF0ucHVzaChmbik7XG4gICAgfVxuICB9LCAwKTtcbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGlmICghZXZlbnRzIHx8ICFldmVudHNbZXZlbnRdKSB7XG4gICAgaWYgKGV2ZW50ID09ICdlcnJvcicpIHtcbiAgICAgIGlmIChjb25zb2xlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbZXZlbnRdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaXN0ZW5lcnNbaV0pIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgdmFyIGxpc3RlbmVyLCBfdGhpcyA9IHRoaXM7XG4gIHRoaXMub24oZXZlbnQsIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG59O1xuXG5NaWNyb0V2ZW50Lm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwcm90byA9IG9iai5wcm90b3R5cGUgfHwgb2JqO1xuICBwcm90by5vbiA9IE1pY3JvRXZlbnQucHJvdG90eXBlLm9uO1xuICBwcm90by5yZW1vdmVMaXN0ZW5lciA9IE1pY3JvRXZlbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuICBwcm90by5lbWl0ID0gTWljcm9FdmVudC5wcm90b3R5cGUuZW1pdDtcbiAgcHJvdG8ub25jZSA9IE1pY3JvRXZlbnQucHJvdG90eXBlLm9uY2U7XG4gIHJldHVybiBvYmo7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIikgbW9kdWxlLmV4cG9ydHMgPSBNaWNyb0V2ZW50O1xuXG4iLCJ2YXIgZmluZGl0ID0gcmVxdWlyZSgnZmluZGl0JylcbiAgLCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gICwgdHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpO1xuXG5leHBvcnRzLmZpbGVzeXN0ZW0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuZGlyZWN0b3J5KSBvcHRpb25zLmRpcmVjdG9yeSA9ICdsb2NhbGUnO1xuICBvcHRpb25zLmRpcmVjdG9yeSA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUocmVxdWlyZS5tYWluLmZpbGVuYW1lKSwgb3B0aW9ucy5kaXJlY3RvcnkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgZmluZCA9IGZpbmRpdChvcHRpb25zLmRpcmVjdG9yeSlcbiAgICAgICwgZm9ybWF0cyA9IHtsb2NhbGU6IHt9fVxuICAgICAgLCB0cmFuc2xhdGlvbnMgPSB7fTtcblxuICAgIGZpbmQub24oJ2ZpbGUnLCBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgdmFyIGV4dG5hbWUgPSBwYXRoLmV4dG5hbWUoZmlsZSk7XG4gICAgICBpZiAoZXh0bmFtZSAhPT0gJy5qcycgJiYgZXh0bmFtZSAhPT0gJy5qc29uJykgcmV0dXJuO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHBhdGgucmVsYXRpdmUob3B0aW9ucy5kaXJlY3RvcnksIGZpbGUpLnNwbGl0KHBhdGguc2VwKTtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmJhc2VuYW1lKG5hbWVzcGFjZS5wb3AoKSwgZXh0bmFtZSk7XG4gICAgICBpZiAoa2V5ICE9PSAnaW5kZXgnKSBuYW1lc3BhY2UucHVzaChrZXkpO1xuICAgICAgaWYgKGV4dG5hbWUgPT09ICcuanMnKSByZXR1cm4gZm9ybWF0cy5sb2NhbGVbbmFtZXNwYWNlWzBdXSA9IHJlcXVpcmUoZmlsZSk7XG4gICAgICBpZiAoZXh0bmFtZSA9PT0gJy5qc29uJykgdHJhdmVyc2UodHJhbnNsYXRpb25zKS5zZXQobmFtZXNwYWNlLCByZXF1aXJlKGZpbGUpKTtcbiAgICB9KTtcblxuICAgIGZpbmQub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGZvcm1hdHMsIHRyYW5zbGF0aW9ucyk7XG4gICAgfSk7XG4gIH07XG59OyIsInZhciBEb2M7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIERvYyA9IHJlcXVpcmUoJy4vZG9jJykuRG9jO1xufVxuXG4vLyBRdWVyaWVzIGFyZSBsaXZlIHJlcXVlc3RzIHRvIHRoZSBkYXRhYmFzZSBmb3IgcGFydGljdWxhciBzZXRzIG9mIGZpZWxkcy5cbi8vXG4vLyBUaGUgc2VydmVyIGFjdGl2ZWx5IHRlbGxzIHRoZSBjbGllbnQgd2hlbiB0aGVyZSdzIG5ldyBkYXRhIHRoYXQgbWF0Y2hlc1xuLy8gYSBzZXQgb2YgY29uZGl0aW9ucy5cbnZhciBRdWVyeSA9IGV4cG9ydHMuUXVlcnkgPSBmdW5jdGlvbih0eXBlLCBjb25uZWN0aW9uLCBpZCwgY29sbGVjdGlvbiwgcXVlcnksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vICdmZXRjaCcgb3IgJ3N1YidcbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gVGhlIHF1ZXJ5IGl0c2VsZi4gRm9yIG1vbmdvLCB0aGlzIHNob3VsZCBsb29rIHNvbWV0aGluZyBsaWtlIHtcImRhdGEueFwiOjV9XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcblxuICAvLyBSZXN1bHRhbnQgZG9jdW1lbnQgYWN0aW9uIGZvciB0aGUgc2VydmVyLiBGZXRjaCBtb2RlIHdpbGwgYXV0b21hdGljYWxseVxuICAvLyBmZXRjaCBhbGwgcmVzdWx0cy4gU3Vic2NyaWJlIG1vZGUgd2lsbCBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZSBhbGxcbiAgLy8gcmVzdWx0cy4gUmVzdWx0cyBhcmUgbmV2ZXIgdW5zdWJzY3JpYmVkLlxuICB0aGlzLmRvY01vZGUgPSBvcHRpb25zLmRvY01vZGU7IC8vIHVuZGVmaW5lZCwgJ2ZldGNoJyBvciAnc3ViJy5cbiAgaWYgKHRoaXMuZG9jTW9kZSA9PT0gJ3N1YnNjcmliZScpIHRoaXMuZG9jTW9kZSA9ICdzdWInO1xuXG4gIC8vIERvIHdlIHJlcG9sbCB0aGUgZW50aXJlIHF1ZXJ5IHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXM/IChBcyBvcHBvc2VkIHRvXG4gIC8vIGp1c3QgcG9sbGluZyB0aGUgY2hhbmdlZCBpdGVtKS4gVGhpcyBuZWVkcyB0byBiZSBlbmFibGVkIHRvIGJlIGFibGUgdG8gdXNlXG4gIC8vIG9yZGVyZWQgcXVlcmllcyAoc29ydGJ5OikgYW5kIHBhZ2luYXRlZCBxdWVyaWVzLiBTZXQgdG8gdW5kZWZpbmVkLCBpdCB3aWxsXG4gIC8vIGJlIGVuYWJsZWQgLyBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBxdWVyeSdzIHByb3BlcnRpZXMuXG4gIHRoaXMucG9sbCA9IG9wdGlvbnMucG9sbDtcblxuICAvLyBUaGUgYmFja2VuZCB3ZSBhY3R1YWxseSBoaXQuIElmIHRoaXMgaXNuJ3QgZGVmaW5lZCwgaXQgaGl0cyB0aGUgc25hcHNob3RcbiAgLy8gZGF0YWJhc2UuIE90aGVyd2lzZSB0aGlzIGNhbiBiZSB1c2VkIHRvIGhpdCBhbm90aGVyIGNvbmZpZ3VyZWQgcXVlcnlcbiAgLy8gaW5kZXguXG4gIHRoaXMuYmFja2VuZCA9IG9wdGlvbnMuYmFja2VuZCB8fCBvcHRpb25zLnNvdXJjZTtcblxuICAvLyBBIGxpc3Qgb2YgcmVzdWx0aW5nIGRvY3VtZW50cy4gVGhlc2UgYXJlIGFjdHVhbCBkb2N1bWVudHMsIGNvbXBsZXRlIHdpdGhcbiAgLy8gZGF0YSBhbmQgYWxsIHRoZSByZXN0LiBJZiBmZXRjaCBpcyBmYWxzZSwgdGhlc2UgZG9jdW1lbnRzIHdpbGwgbm90XG4gIC8vIGhhdmUgYW55IGRhdGEuIFlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCBmZXRjaCgpIG9yIHN1YnNjcmliZSgpIG9uIHRoZW0uXG4gIC8vXG4gIC8vIENhbGxpbmcgc3Vic2NyaWJlKCkgbWlnaHQgYmUgYSBnb29kIGlkZWEgYW55d2F5LCBhcyB5b3Ugd29uJ3QgYmVcbiAgLy8gc3Vic2NyaWJlZCB0byB0aGUgZG9jdW1lbnRzIGJ5IGRlZmF1bHQuXG4gIHRoaXMua25vd25Eb2NzID0gb3B0aW9ucy5rbm93bkRvY3MgfHwgW107XG4gIHRoaXMucmVzdWx0cyA9IFtdO1xuXG4gIC8vIERvIHdlIGhhdmUgc29tZSBpbml0aWFsIGRhdGE/XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcblxuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG59O1xuUXVlcnkucHJvdG90eXBlLmFjdGlvbiA9ICdxc3ViJztcblxuLy8gSGVscGVyIGZvciBzdWJzY3JpYmUgJiBmZXRjaCwgc2luY2UgdGhleSBzaGFyZSB0aGUgc2FtZSBtZXNzYWdlIGZvcm1hdC5cbi8vXG4vLyBUaGlzIGZ1bmN0aW9uIGFjdHVhbGx5IGlzc3VlcyB0aGUgcXVlcnkuXG5RdWVyeS5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCkgcmV0dXJuO1xuXG4gIGlmICh0aGlzLmRvY01vZGUpIHtcbiAgICB2YXIgY29sbGVjdGlvblZlcnNpb25zID0ge307XG4gICAgLy8gQ29sbGVjdCB0aGUgdmVyc2lvbiBvZiBhbGwgdGhlIGRvY3VtZW50cyBpbiB0aGUgY3VycmVudCByZXN1bHQgc2V0IHNvIHdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBiZSBzZW50IHRoZWlyIHNuYXBzaG90cyBhZ2Fpbi5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua25vd25Eb2NzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9jID0gdGhpcy5rbm93bkRvY3NbaV07XG4gICAgICB2YXIgYyA9IGNvbGxlY3Rpb25WZXJzaW9uc1tkb2MuY29sbGVjdGlvbl0gPSBjb2xsZWN0aW9uVmVyc2lvbnNbZG9jLmNvbGxlY3Rpb25dIHx8IHt9O1xuICAgICAgY1tkb2MubmFtZV0gPSBkb2MudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICB2YXIgbXNnID0ge1xuICAgIGE6ICdxJyArIHRoaXMudHlwZSxcbiAgICBpZDogdGhpcy5pZCxcbiAgICBjOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgbzoge30sXG4gICAgcTogdGhpcy5xdWVyeSxcbiAgfTtcblxuICBpZiAodGhpcy5kb2NNb2RlKSB7XG4gICAgbXNnLm8ubSA9IHRoaXMuZG9jTW9kZTtcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvbWl0dGVkIGlmIGVtcHR5LCBidXQgd2hhdGV2ZXIuXG4gICAgbXNnLm8udnMgPSBjb2xsZWN0aW9uVmVyc2lvbnM7XG4gIH1cbiAgaWYgKHRoaXMuYmFja2VuZCAhPSBudWxsKSBtc2cuby5iID0gdGhpcy5iYWNrZW5kO1xuICBpZiAodGhpcy5wb2xsICE9PSB1bmRlZmluZWQpIG1zZy5vLnAgPSB0aGlzLnBvbGw7XG5cbiAgdGhpcy5jb25uZWN0aW9uLnNlbmQobXNnKTtcbn07XG5cbi8vIE1ha2UgYSBsaXN0IG9mIGRvY3VtZW50cyBmcm9tIHRoZSBsaXN0IG9mIHNlcnZlci1yZXR1cm5lZCBkYXRhIG9iamVjdHNcblF1ZXJ5LnByb3RvdHlwZS5fZGF0YVRvRG9jcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgdmFyIGxhc3RUeXBlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZG9jRGF0YSA9IGRhdGFbaV07XG5cbiAgICAvLyBUeXBlcyBhcmUgb25seSBwdXQgaW4gZm9yIHRoZSBmaXJzdCByZXN1bHQgaW4gdGhlIHNldCBhbmQgZXZlcnkgdGltZSB0aGUgdHlwZSBjaGFuZ2VzIGluIHRoZSBsaXN0LlxuICAgIGlmIChkb2NEYXRhLnR5cGUpIHtcbiAgICAgIGxhc3RUeXBlID0gZG9jRGF0YS50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2NEYXRhLnR5cGUgPSBsYXN0VHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGhpcy5jb25uZWN0aW9uLmdldChkb2NEYXRhLmMgfHwgdGhpcy5jb2xsZWN0aW9uLCBkb2NEYXRhLmQsIGRvY0RhdGEpO1xuICAgIC8vIEZvcmNlIHRoZSBkb2N1bWVudCB0byBrbm93IGl0cyBzdWJzY3JpYmVkIGlmIHdlJ3JlIGluIGRvY21vZGU6c3Vic2NyaWJlLlxuICAgIGlmICh0aGlzLmRvY01vZGUgPT09ICdzdWInKSB7XG4gICAgICBkb2Muc3Vic2NyaWJlZCA9IHRydWU7IC8vIFNldCBiZWZvcmUgc2V0V2FudFN1YnNjcmliZSgpIHNvIGZsdXNoIGRvZXNuJ3Qgc2VuZCBhIHN1YnNjcmliZSByZXF1ZXN0LlxuICAgICAgZG9jLl9zZXRXYW50U3Vic2NyaWJlKHRydWUpOyAvLyB0aGlzIHdpbGwgY2FsbCBhbnkgc3Vic2NyaWJlIGNhbGxiYWNrcyBvciB3aGF0ZXZlci5cbiAgICAgIGRvYy5lbWl0KCdzdWJzY3JpYmUnKTtcbiAgICAgIGRvYy5fZmluaXNoU3ViKHRydWUpOyAvLyB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSwgYnV0IGl0cyBtb3JlIGNvcnJlY3QgdG8gaGF2ZSBpdC5cbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBEZXN0cm95IHRoZSBxdWVyeSBvYmplY3QuIEFueSBzdWJzZXF1ZW50IG1lc3NhZ2VzIGZvciB0aGUgcXVlcnkgd2lsbCBiZVxuLy8gaWdub3JlZCBieSB0aGUgY29ubmVjdGlvbi4gWW91IHNob3VsZCB1bnN1YnNjcmliZSBmcm9tIHRoZSBxdWVyeSBiZWZvcmVcbi8vIGRlc3Ryb3lpbmcgaXQuXG5RdWVyeS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLmNhblNlbmQgJiYgdGhpcy50eXBlID09PSAnc3ViJykge1xuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKHthOidxdW5zdWInLCBpZDp0aGlzLmlkfSk7XG4gIH1cblxuICB0aGlzLmNvbm5lY3Rpb24uX2Rlc3Ryb3lRdWVyeSh0aGlzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAodGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICB0aGlzLl9leGVjdXRlKCk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZnJvbSBjb25uZWN0aW9uIHRvIHBhc3Mgc2VydmVyIG1lc3NhZ2VzIHRvIHRoZSBxdWVyeS5cblF1ZXJ5LnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICgobXNnLmEgPT09ICdxZmV0Y2gnKSAhPT0gKHRoaXMudHlwZSA9PT0gJ2ZldGNoJykpIHtcbiAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdJbnZhbGlkIG1lc3NhZ2Ugc2VudCB0byBxdWVyeScsIG1zZywgdGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG1zZy5lcnJvcikgdGhpcy5lbWl0KCdlcnJvcicsIG1zZy5lcnJvcik7XG5cbiAgc3dpdGNoIChtc2cuYSkge1xuICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICB2YXIgcmVzdWx0cyA9IG1zZy5kYXRhID8gdGhpcy5fZGF0YVRvRG9jcyhtc2cuZGF0YSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykgdGhpcy5jYWxsYmFjayhtc2cuZXJyb3IsIHJlc3VsdHMsIG1zZy5leHRyYSk7XG4gICAgICAvLyBPbmNlIGEgZmV0Y2ggcXVlcnkgZ2V0cyBpdHMgZGF0YSwgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgdGhpcy5jb25uZWN0aW9uLl9kZXN0cm95UXVlcnkodGhpcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3EnOlxuICAgICAgLy8gUXVlcnkgZGlmZiBkYXRhIChpbnNlcnRzIGFuZCByZW1vdmVzKVxuICAgICAgaWYgKG1zZy5kaWZmKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgbGlzdCB0d2ljZS4gRmlyc3QsIHdlJ2xsIGluamVzdCBhbGwgdGhlXG4gICAgICAgIC8vIG5ldyBkb2N1bWVudHMgYW5kIHNldCB0aGVtIGFzIHN1YnNjcmliZWQuICBBZnRlciB0aGF0IHdlJ2xsIGVtaXRcbiAgICAgICAgLy8gZXZlbnRzIGFuZCBhY3R1YWxseSB1cGRhdGUgb3VyIGxpc3QuIFRoaXMgYXZvaWRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAvLyBhcm91bmQgc2V0dGluZyBkb2N1bWVudHMgdG8gYmUgc3Vic2NyaWJlZCAmIHVuc3Vic2NyaWJpbmcgZG9jdW1lbnRzXG4gICAgICAgIC8vIGluIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cuZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbXNnLmRpZmZbaV07XG4gICAgICAgICAgaWYgKGQudHlwZSA9PT0gJ2luc2VydCcpIGQudmFsdWVzID0gdGhpcy5fZGF0YVRvRG9jcyhkLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5kaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGQgPSBtc2cuZGlmZltpXTtcbiAgICAgICAgICBzd2l0Y2ggKGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgdmFyIG5ld0RvY3MgPSBkLnZhbHVlcztcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLnJlc3VsdHMsIFtkLmluZGV4LCAwXS5jb25jYXQobmV3RG9jcykpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2luc2VydCcsIG5ld0RvY3MsIGQuaW5kZXgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgIHZhciBob3dNYW55ID0gZC5ob3dNYW55IHx8IDE7XG4gICAgICAgICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yZXN1bHRzLnNwbGljZShkLmluZGV4LCBob3dNYW55KTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCByZW1vdmVkLCBkLmluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgdmFyIGhvd01hbnkgPSBkLmhvd01hbnkgfHwgMTtcbiAgICAgICAgICAgICAgdmFyIGRvY3MgPSB0aGlzLnJlc3VsdHMuc3BsaWNlKGQuZnJvbSwgaG93TWFueSk7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5yZXN1bHRzLCBbZC50bywgMF0uY29uY2F0KGRvY3MpKTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtb3ZlJywgZG9jcywgZC5mcm9tLCBkLnRvKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cuZXh0cmEpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdleHRyYScsIG1zZy5leHRyYSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdxc3ViJzpcbiAgICAgIC8vIFRoaXMgbWVzc2FnZSByZXBsYWNlcyB0aGUgZW50aXJlIHJlc3VsdCBzZXQgd2l0aCB0aGUgc2V0IHBhc3NlZC5cbiAgICAgIGlmICghbXNnLmVycm9yKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMucmVzdWx0cztcblxuICAgICAgICAvLyBUaGVuIGFkZCBldmVyeXRoaW5nIGluIHRoZSBuZXcgcmVzdWx0IHNldC5cbiAgICAgICAgdGhpcy5yZXN1bHRzID0gdGhpcy5rbm93bkRvY3MgPSB0aGlzLl9kYXRhVG9Eb2NzKG1zZy5kYXRhKTtcbiAgICAgICAgdGhpcy5leHRyYSA9IG1zZy5leHRyYTtcblxuICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0aGlzLnJlc3VsdHMsIHByZXZpb3VzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sobXNnLmVycm9yLCB0aGlzLnJlc3VsdHMsIHRoaXMuZXh0cmEpO1xuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDaGFuZ2UgdGhlIHRoaW5nIHdlJ3JlIHNlYXJjaGluZyBmb3IuIFRoaXMgaXNuJ3QgZnVsbHkgc3VwcG9ydGVkIG9uIHRoZVxuLy8gYmFja2VuZCAoaXQgZGVzdHJveXMgdGhlIG9sZCBxdWVyeSBhbmQgbWFrZXMgYSBuZXcgb25lKSAtIGJ1dCBpdHNcbi8vIHByb2dyYW1hdGljYWxseSB1c2VmdWwgYW5kIEkgbWlnaHQgYWRkIGJhY2tlbmQgc3VwcG9ydCBhdCBzb21lIHBvaW50LlxuUXVlcnkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24ocSkge1xuICBpZiAodGhpcy50eXBlICE9PSAnc3ViJykgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGEgZmV0Y2ggcXVlcnknKTtcblxuICB0aGlzLnF1ZXJ5ID0gcTtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5jYW5TZW5kKSB7XG4gICAgLy8gVGhlcmUncyBubyAnY2hhbmdlJyBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIHNlcnZlci4gSnVzdCByZXN1YnNjcmliZS5cbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZCh7YToncXVuc3ViJywgaWQ6dGhpcy5pZH0pO1xuICAgIHRoaXMuX2V4ZWN1dGUoKTtcbiAgfVxufTtcblxudmFyIE1pY3JvRXZlbnQ7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIE1pY3JvRXZlbnQgPSByZXF1aXJlKCcuL21pY3JvZXZlbnQnKTtcbn1cblxuTWljcm9FdmVudC5taXhpbihRdWVyeSk7XG5cbiIsIi8vIEEgQ29ubmVjdGlvbiB3cmFwcyBhIHBlcnNpc3RhbnQgQkMgY29ubmVjdGlvbiB0byBhIHNoYXJlanMgc2VydmVyLlxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgY2xpZW50IHNpZGUgb2YgdGhlIHByb3RvY29sIGRlZmluZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NlcGhnL1NoYXJlSlMvd2lraS9XaXJlLVByb3RvY29sXG4vL1xuLy8gVGhlIGVxdWl2YWxlbnQgc2VydmVyIGNvZGUgaXMgaW4gc3JjL3NlcnZlci9zZXNzaW9uLlxuLy9cbi8vIFRoaXMgZmlsZSBpcyBhIGJpdCBvZiBhIG1lc3MuIEknbSBkcmVhZGZ1bGx5IHNvcnJ5IGFib3V0IHRoYXQuIEl0IHBhc3NlcyBhbGwgdGhlIHRlc3RzLFxuLy8gc28gSSBoYXZlIGhvcGUgdGhhdCBpdHMgKmNvcnJlY3QqIGV2ZW4gaWYgaXRzIG5vdCBjbGVhbi5cbi8vXG4vLyBUbyBtYWtlIGEgY29ubmVjdGlvbiwgdXNlOlxuLy8gIG5ldyBzaGFyZWpzLkNvbm5lY3Rpb24oc29ja2V0KVxuLy9cbi8vIFRoZSBzb2NrZXQgc2hvdWxkIGxvb2sgbGlrZSBhIHdlYnNvY2tldCBjb25uZWN0aW9uLiBJdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vLyAgc2VuZChtc2cpOiBTZW5kIHRoZSBnaXZlbiBtZXNzYWdlLiBtc2cgbWF5IGJlIGFuIG9iamVjdCAtIGlmIHNvLCB5b3UgbWlnaHQgbmVlZCB0byBKU09OLnN0cmluZ2lmeSBpdC5cbi8vICBjbG9zZSgpOiBEaXNjb25uZWN0IHRoZSBzZXNzaW9uXG4vL1xuLy8gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZyl7fTogRXZlbnQgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkLiBUaGUgbWVzc2FnZVxuLy8gICAgIHBhc3NlZCBpbiBzaG91bGQgYWxyZWFkeSBiZSBhbiBvYmplY3QuIChJdCBtYXkgbmVlZCB0byBiZSBKU09OLnBhcnNlZClcbi8vICBvbmNsb3NlXG4vLyAgb25lcnJvclxuLy8gIG9ub3BlblxuLy8gIG9uY29ubmVjdGluZ1xuLy9cbi8vIFRoZSBzb2NrZXQgc2hvdWxkIHByb2JhYmx5IGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0LiBJZiBzbywgaXQgc2hvdWxkIGVtaXQgdGhlIGFwcHJvcHJpYXRlIGV2ZW50cyBhcyBpdFxuLy8gZGlzY29ubmVjdHMgJiByZWNvbm5lY3RzLiAob25jbG9zZSgpLCBvbmNvbm5lY3RpbmcoKSwgb25vcGVuKCkpLlxuXG52YXIgdHlwZXMsIERvYztcbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdHlwZXMgPSByZXF1aXJlKCdvdHR5cGVzJyk7XG4gIERvYyA9IHJlcXVpcmUoJy4vZG9jJykuRG9jO1xuICBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKS5RdWVyeTtcbn0gZWxzZSB7XG4gIHR5cGVzID0gd2luZG93Lm90dHlwZXM7XG4gIERvYyA9IGV4cG9ydHMuRG9jO1xufVxuXG52YXIgQ29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgLy8gTWFwIG9mIGNvbGxlY3Rpb24gLT4gZG9jTmFtZSAtPiBkb2Mgb2JqZWN0IGZvciBjcmVhdGVkIGRvY3VtZW50cy5cbiAgLy8gKGNyZWF0ZWQgZG9jdW1lbnRzIE1VU1QgQkUgVU5JUVVFKVxuICB0aGlzLmNvbGxlY3Rpb25zID0ge307XG5cbiAgLy8gRWFjaCBxdWVyeSBpcyBjcmVhdGVkIHdpdGggYW4gaWQgdGhhdCB0aGUgc2VydmVyIHVzZXMgd2hlbiBpdCBzZW5kcyB1c1xuICAvLyBpbmZvIGFib3V0IHRoZSBxdWVyeSAodXBkYXRlcywgZXRjKS5cbiAgLy90aGlzLm5leHRRdWVyeUlkID0gKE1hdGgucmFuZG9tKCkgKiAxMDAwKSB8MDtcbiAgdGhpcy5uZXh0UXVlcnlJZCA9IDE7XG5cbiAgLy8gTWFwIGZyb20gcXVlcnkgSUQgLT4gcXVlcnkgb2JqZWN0LlxuICB0aGlzLnF1ZXJpZXMgPSB7fTtcblxuICAvLyBDb25uZWN0aW9uIHN0YXRlLlxuICAvLyBcbiAgLy8gU3RhdGVzOlxuICAvLyAtICdjb25uZWN0aW5nJzogVGhlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIGJ1dCB3ZSBkb24ndCBoYXZlIG91ciBjbGllbnQgSUQgeWV0XG4gIC8vIC0gJ2Nvbm5lY3RlZCc6IFdlIGhhdmUgY29ubmVjdGVkIGFuZCByZWNpZXZlZCBvdXIgY2xpZW50IElELiBSZWFkeSBmb3IgZGF0YS5cbiAgLy8gLSAnZGlzY29ubmVjdGVkJzogVGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkLCBidXQgaXQgd2lsbCByZWNvbm5lY3QgYXV0b21hdGljYWxseS5cbiAgLy8gLSAnc3RvcHBlZCc6IFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCwgYW5kIHNob3VsZCBub3QgcmVjb25uZWN0LlxuICB0aGlzLnN0YXRlID0gKHNvY2tldC5yZWFkeVN0YXRlID09PSAwIHx8IHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSA/ICdjb25uZWN0aW5nJyA6ICdkaXNjb25uZWN0ZWQnO1xuXG4gIC8vIFRoaXMgaXMgYSBoZWxwZXIgdmFyaWFibGUgdGhlIGRvY3VtZW50IHVzZXMgdG8gc2VlIHdoZXRoZXIgd2UncmUgY3VycmVudGx5XG4gIC8vIGluIGEgJ2xpdmUnIHN0YXRlLiBJdCBpcyB0cnVlIGlmIHRoZSBzdGF0ZSBpcyAnY29ubmVjdGluZycgb3IgJ2Nvbm5lY3RlZCcuXG4gIHRoaXMuY2FuU2VuZCA9IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJztcblxuICAvLyBSZXNldCBzb21lIG1vcmUgc3RhdGUgdmFyaWFibGVzLlxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAvLyBJJ2xsIHN0b3JlIHRoZSBtb3N0IHJlY2VudCAxMDAgbWVzc2FnZXMgc28gd2hlbiBlcnJvcnMgb2NjdXIgd2UgY2FuIHNlZSB3aGF0IGhhcHBlbmVkLlxuICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcblxuICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgdmFyIGhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAvLyBTd2l0Y2ggb24gdGhlIG1lc3NhZ2UgYWN0aW9uLiBNb3N0IG1lc3NhZ2VzIGFyZSBmb3IgZG9jdW1lbnRzIGFuZCBhcmVcbiAgICAvLyBoYW5kbGVkIGluIHRoZSBkb2MgY2xhc3MuXG4gICAgc3dpdGNoIChtc2cuYSkge1xuICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgIC8vIENsaWVudCBpbml0aWFsaXphdGlvbiBwYWNrZXQuIFRoaXMgYnVuZGxlIG9mIGpveSBjb250YWlucyBvdXIgY2xpZW50XG4gICAgICAgIC8vIElELlxuICAgICAgICBpZiAobXNnLnByb3RvY29sICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpO1xuICAgICAgICBpZiAodHlwZW9mIG1zZy5pZCAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNsaWVudCBpZCcpO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uaWQgPSBtc2cuaWQ7XG4gICAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3FmZXRjaCc6XG4gICAgICBjYXNlICdxc3ViJzpcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgY2FzZSAncXVuc3ViJzpcbiAgICAgICAgLy8gUXVlcnkgbWVzc2FnZS4gUGFzcyB0aGlzIHRvIHRoZSBhcHByb3ByaWF0ZSBxdWVyeSBvYmplY3QuXG4gICAgICAgIHZhciBxdWVyeSA9IGNvbm5lY3Rpb24ucXVlcmllc1ttc2cuaWRdO1xuICAgICAgICBpZiAocXVlcnkpIHF1ZXJ5Ll9vbk1lc3NhZ2UobXNnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JzJzpcbiAgICAgICAgLy8gQnVsayBzdWJzY3JpYmUgcmVzcG9uc2UuIFRoZSByZXNwb25zZXMgZm9yIGVhY2ggZG9jdW1lbnQgYXJlIGNvbnRhaW5lZCB3aXRoaW4uXG4gICAgICAgIHZhciByZXN1bHQgPSBtc2cucztcbiAgICAgICAgZm9yICh2YXIgY05hbWUgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgZm9yICh2YXIgZG9jTmFtZSBpbiByZXN1bHRbY05hbWVdKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gY29ubmVjdGlvbi5nZXQoY05hbWUsIGRvY05hbWUpO1xuICAgICAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2UgZm9yIHVua25vd24gZG9jLiBJZ25vcmluZy4nLCBtc2cpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1zZyA9IHJlc3VsdFtjTmFtZV1bZG9jTmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgZG9jLl9oYW5kbGVTdWJzY3JpYmUobXNnLmVycm9yLCBtc2cuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGUgbXNnIHdpbGwgYmUgdHJ1ZSBpZiB3ZSBzaW1wbHkgcmVzdWJzY3JpYmVkLlxuICAgICAgICAgICAgICBkb2MuX2hhbmRsZVN1YnNjcmliZShudWxsLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERvY3VtZW50IG1lc3NhZ2UuIFB1bGwgb3V0IHRoZSByZWZlcmVuY2VkIGRvY3VtZW50IGFuZCBmb3J3YXJkIHRoZVxuICAgICAgICAvLyBtZXNzYWdlLlxuICAgICAgICB2YXIgY29sbGVjdGlvbiwgZG9jTmFtZSwgZG9jO1xuICAgICAgICBpZiAobXNnLmQpIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gY29ubmVjdGlvbi5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbiA9IG1zZy5jO1xuICAgICAgICAgIGRvY05hbWUgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWREb2MgPSBtc2cuZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xsZWN0aW9uID0gbXNnLmMgPSBjb25uZWN0aW9uLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uO1xuICAgICAgICAgIGRvY05hbWUgPSBtc2cuZCA9IGNvbm5lY3Rpb24uX2xhc3RSZWNlaXZlZERvYztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvYyA9IGNvbm5lY3Rpb24uZ2V0KGNvbGxlY3Rpb24sIGRvY05hbWUpO1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGZvciB1bmtub3duIGRvYy4gSWdub3JpbmcuJywgbXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkb2MuX29uTWVzc2FnZShtc2cpO1xuICAgIH1cbiAgfTtcblxuICAvLyBBdHRhY2ggZXZlbnQgaGFuZGxlcnMgdG8gdGhlIHNvY2tldC5cbiAgc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgIGlmIChjb25uZWN0aW9uLmRlYnVnKSBjb25zb2xlLmxvZygnUkVDVicsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5wdXNoKHt0OihuZXcgRGF0ZSgpKS50b1RpbWVTdHJpbmcoKSwgcmVjdjpKU09OLnN0cmluZ2lmeShtc2cpfSk7XG4gICAgd2hpbGUgKGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICAgIGNvbm5lY3Rpb24ubWVzc2FnZUJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBoYW5kbGVNZXNzYWdlKG1zZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29ubmVjdGlvbi5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgLy8gV2UgY291bGQgYWxzbyByZXN0YXJ0IHRoZSBjb25uZWN0aW9uIGhlcmUsIGFsdGhvdWdoIHRoYXQgbWlnaHQgcmVzdWx0XG4gICAgICAvLyBpbiBpbmZpbml0ZSByZWNvbm5lY3Rpb24gYnVncy5cbiAgICB9XG4gIH1cblxuICBzb2NrZXQub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgfTtcblxuICBzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAvLyBUaGlzIGlzbid0IHRoZSBzYW1lIGFzIGEgcmVndWxhciBlcnJvciwgYmVjYXVzZSBpdCB3aWxsIGhhcHBlbiBub3JtYWxseVxuICAgIC8vIGZyb20gdGltZSB0byB0aW1lLiBZb3VyIGNvbm5lY3Rpb24gc2hvdWxkIHByb2JhYmx5IGF1dG9tYXRpY2FsbHlcbiAgICAvLyByZWNvbm5lY3QgYW55d2F5LCBidXQgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIG9mZiBvbmNsb3NlIG5vdCBvbmVycm9yLlxuICAgIC8vIChvbmNsb3NlIGhhcHBlbnMgd2hlbiBvbmVycm9yIGdldHMgY2FsbGVkIGFueXdheSkuXG4gICAgY29ubmVjdGlvbi5lbWl0KCdjb25uZWN0aW9uIGVycm9yJywgZSk7XG4gIH07XG5cbiAgc29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnZGlzY29ubmVjdGVkJywgcmVhc29uKTtcbiAgICBpZiAocmVhc29uID09PSAnQ2xvc2VkJyB8fCByZWFzb24gPT09ICdTdG9wcGVkIGJ5IHNlcnZlcicpIHtcbiAgICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdzdG9wcGVkJywgcmVhc29uKTtcbiAgICB9XG4gIH07XG59XG5cbi8qIFdoeSBkb2VzIHRoaXMgZnVuY3Rpb24gZXhpc3Q/IElzIGl0IGltcG9ydGFudD9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5fc2V0U3RhdGUoJ3N0b3BwZWQnLCBlKTtcbiAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdChlKTtcbn07XG4qL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlkID0gdGhpcy5sYXN0RXJyb3IgPVxuICAgIHRoaXMuX2xhc3RSZWNlaXZlZENvbGxlY3Rpb24gPSB0aGlzLl9sYXN0UmVjZWl2ZWREb2MgPVxuICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IHRoaXMuX2xhc3RTZW50RG9jID0gbnVsbDtcblxuICB0aGlzLnNlcSA9IDE7XG59O1xuXG4vLyBTZXQgdGhlIGNvbm5lY3Rpb24ncyBzdGF0ZS4gVGhlIGNvbm5lY3Rpb24gaXMgYmFzaWNhbGx5IGEgc3RhdGUgbWFjaGluZS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlLCBkYXRhKSB7XG4gIGlmICh0aGlzLnN0YXRlID09PSBuZXdTdGF0ZSkgcmV0dXJuO1xuXG4gIC8vIEkgbWFkZSBhIHN0YXRlIGRpYWdyYW0uIFRoZSBvbmx5IGludmFsaWQgdHJhbnNpdGlvbnMgYXJlIGdldHRpbmcgdG9cbiAgLy8gJ2Nvbm5lY3RpbmcnIGZyb20gYW55d2hlcmUgb3RoZXIgdGhhbiAnZGlzY29ubmVjdGVkJyBhbmQgZ2V0dGluZyB0b1xuICAvLyAnY29ubmVjdGVkJyBmcm9tIGFueXdoZXJlIG90aGVyIHRoYW4gJ2Nvbm5lY3RpbmcnLlxuICBpZiAoKG5ld1N0YXRlID09PSAnY29ubmVjdGluZycgJiYgKHRoaXMuc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdzdG9wcGVkJykpXG4gICAgICB8fCAobmV3U3RhdGUgPT09ICdjb25uZWN0ZWQnICYmIHRoaXMuc3RhdGUgIT09ICdjb25uZWN0aW5nJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdHJhbnNpdGlvbiBkaXJlY3RseSBmcm9tIFwiICsgdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICB9XG5cbiAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICB0aGlzLmNhblNlbmQgPSBuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IG5ld1N0YXRlID09PSAnY29ubmVjdGVkJztcblxuICBpZiAobmV3U3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB0aGlzLnJlc2V0KCk7XG5cbiAgdGhpcy5lbWl0KG5ld1N0YXRlLCBkYXRhKTtcblxuICAvLyAmIEVtaXQgdGhlIGV2ZW50IHRvIGFsbCBkb2N1bWVudHMgJiBxdWVyaWVzLiBJdCBtaWdodCBtYWtlIHNlbnNlIGZvclxuICAvLyBkb2N1bWVudHMgdG8ganVzdCByZWdpc3RlciBmb3IgdGhpcyBzdHVmZiB1c2luZyBldmVudHMsIGJ1dCB0aGF0IGNvdXBsZXNcbiAgLy8gY29ubmVjdGlvbnMgYW5kIGRvY3VtZW50cyBhIGJpdCBtdWNoLiBJdHMgbm90IGEgYmlnIGRlYWwgZWl0aGVyIHdheS5cbiAgdGhpcy5vcFF1ZXVlID0gW107XG4gIHRoaXMuc3Vic2NyaWJlRGF0YSA9IHt9O1xuICBmb3IgKHZhciBjIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbnNbY107XG4gICAgZm9yICh2YXIgZG9jTmFtZSBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uW2RvY05hbWVdLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQobmV3U3RhdGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gSXRzIGltcG9ydGFudCB0aGF0IG9wZXJhdGlvbnMgYXJlIHJlc2VudCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgd2VyZVxuICAvLyBvcmlnaW5hbGx5IHNlbnQuIElmIHdlIGRvbid0IHNvcnQsIGFuIG9wIHdpdGggYSBoaWdoIHNlcXVlbmNlIG51bWJlciB3aWxsXG4gIC8vIGNvbnZpbmNlIHRoZSBzZXJ2ZXIgbm90IHRvIGFjY2VwdCBhbnkgb3BzIHdpdGggZWFybGllciBzZXF1ZW5jZSBudW1iZXJzLlxuICB0aGlzLm9wUXVldWUuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnNlcSAtIGIuc2VxOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNlbmQodGhpcy5vcFF1ZXVlW2ldKTtcbiAgfVxuXG4gIC8vIE9ubHkgc2VuZCBidWxrIHN1YnNjcmliZSBpZiBub3QgZW1wdHkuIEl0cyB3ZWlyZCB1c2luZyBhIGZvciBsb29wIGZvclxuICAvLyB0aGlzLCBidXQgaXQgd29ya3MgcHJldHR5IHdlbGwuXG4gIGZvciAodmFyIF9fdW51c2VkIGluIHRoaXMuc3Vic2NyaWJlRGF0YSkgeyBcbiAgICB0aGlzLnNlbmQoe2E6J2JzJywgczp0aGlzLnN1YnNjcmliZURhdGF9KTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHRoaXMub3BRdWV1ZSA9IG51bGw7XG4gIHRoaXMuc3Vic2NyaWJlRGF0YSA9IG51bGw7XG4gIFxuICAvLyBObyBidWxrIHN1YnNjcmliZSBmb3IgcXVlcmllcyB5ZXQuXG4gIGZvciAodmFyIGlkIGluIHRoaXMucXVlcmllcykge1xuICAgIHRoaXMucXVlcmllc1tpZF0uX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZChuZXdTdGF0ZSwgZGF0YSk7XG4gIH1cbn07XG5cbi8vIFNvLCB0aGVyZSdzIGFuIGF3ZnVsIGVycm9yIGNhc2Ugd2hlcmUgdGhlIGNsaWVudCBzZW5kcyB0d28gcmVxdWVzdHMgKHdoaWNoXG4vLyBmYWlsKSwgdGhlbiByZWNvbm5lY3RzLiBUaGUgZG9jdW1lbnRzIGNvdWxkIGhhdmUgX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZFxuLy8gY2FsbGVkIGluIHRoZSB3cm9uZyBvcmRlciBhbmQgdGhlIG9wZXJhdGlvbnMgdGhlbiBnZXQgc2VudCB3aXRoIHJldmVyc2VkXG4vLyBzZXF1ZW5jZSBudW1iZXJzLiBUaGlzIGNhdXNlcyB0aGUgc2VydmVyIHRvIGluY29ycmVjdGx5IHJlamVjdCB0aGUgc2Vjb25kXG4vLyBzZW50IG9wLiBTbyB3ZSBuZWVkIHRvIHF1ZXVlIHRoZSBvcGVyYXRpb25zIHdoaWxlIHdlJ3JlIHJlY29ubmVjdGluZyBhbmRcbi8vIHJlc2VuZCB0aGVtIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZE9wID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5vcFF1ZXVlKSB7XG4gICAgdGhpcy5vcFF1ZXVlLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kKGRhdGEpO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgZG9jdW1lbnQgY2xhc3Mgd2hlbiB0aGUgZG9jdW1lbnQgd2FudHMgdG8gc3Vic2NyaWJlLlxuLy8gV2UgY291bGQganVzdCBzZW5kIGEgc3Vic2NyaWJlIG1lc3NhZ2UsIGJ1dCBkdXJpbmcgcmVjb25uZWN0IHRoYXQgY2F1c2VzIGFcbi8vIGJhamlsbGlvbiBtZXNzYWdlcyBvdmVyIGJyb3dzZXJjaGFubmVsLiBEdXJpbmcgcmVjb25uZWN0IHdlJ2xsIGFnZ3JlZ2F0ZSxcbi8vIHNpbWlsYXIgdG8gc2VuZE9wLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFN1YnNjcmliZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIHYpIHtcbiAgaWYgKHRoaXMuc3Vic2NyaWJlRGF0YSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5zdWJzY3JpYmVEYXRhO1xuICAgIGlmICghZGF0YVtjb2xsZWN0aW9uXSkgZGF0YVtjb2xsZWN0aW9uXSA9IHt9O1xuXG4gICAgZGF0YVtjb2xsZWN0aW9uXVtuYW1lXSA9IHYgfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbXNnID0ge2E6J3N1YicsIGM6Y29sbGVjdGlvbiwgZDpuYW1lfTtcbiAgICBpZiAodiAhPSBudWxsKSBtc2cudiA9IHY7XG4gICAgdGhpcy5zZW5kKG1zZyk7XG4gIH1cbn07XG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coXCJTRU5EXCIsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaCh7dDpEYXRlLm5vdygpLCBzZW5kOkpTT04uc3RyaW5naWZ5KG1zZyl9KTtcbiAgd2hpbGUgKHRoaXMubWVzc2FnZUJ1ZmZlci5sZW5ndGggPiAxMDApIHtcbiAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuc2hpZnQoKTtcbiAgfVxuXG4gIGlmIChtc2cuZCkgeyAvLyBUaGUgZG9jdW1lbnQgdGhlIG1lc3NhZ2UgcmVmZXJzIHRvLiBOb3Qgc2V0IGZvciBxdWVyaWVzLlxuICAgIHZhciBjb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgdmFyIGRvY05hbWUgPSBtc2cuZDtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uICYmIGRvY05hbWUgPT09IHRoaXMuX2xhc3RTZW50RG9jKSB7XG4gICAgICBkZWxldGUgbXNnLmM7XG4gICAgICBkZWxldGUgbXNnLmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB0aGlzLl9sYXN0U2VudERvYyA9IGRvY05hbWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zb2NrZXQuc2VuZChtc2cpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIHdpbGwgY2FsbCBAc29ja2V0Lm9uY2xvc2UoKSwgd2hpY2ggaW4gdHVybiB3aWxsIGVtaXQgdGhlICdkaXNjb25uZWN0ZWQnIGV2ZW50LlxuICB0aGlzLnNvY2tldC5jbG9zZSgpO1xufTtcblxuXG4vLyAqKioqKiBEb2N1bWVudCBtYW5hZ2VtZW50XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldEV4aXN0aW5nID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSkge1xuICBpZiAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSkgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl1bbmFtZV07XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgY29uc29sZS50cmFjZSgnZ2V0T3JDcmVhdGUgaXMgZGVwcmVjYXRlZC4gVXNlIGdldCgpIGluc3RlYWQnKTtcbiAgcmV0dXJuIHRoaXMuZ2V0KGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpO1xufTtcblxuLy8gQ3JlYXRlIGEgZG9jdW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC4gUmV0dXJucyB0aGUgZG9jdW1lbnQgc3luY2hyb25vdXNseS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUsIGRhdGEpIHtcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0RXhpc3RpbmcoY29sbGVjdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFkb2MpIHtcbiAgICAvLyBDcmVhdGUgaXQuXG4gICAgZG9jID0gbmV3IERvYyh0aGlzLCBjb2xsZWN0aW9uLCBuYW1lKTtcblxuICAgIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSA9XG4gICAgICAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSB8fCB7fSk7XG4gICAgY29sbGVjdGlvbk9iamVjdFtuYW1lXSA9IGRvYztcbiAgfVxuXG4gIC8vIEV2ZW4gaWYgdGhlIGRvY3VtZW50IGlzbid0IG5ldywgaXRzIHBvc3NpYmxlIHRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZFxuICAvLyBtYW51YWxseSBhbmQgdGhlbiB0cmllZCB0byBiZSByZS1jcmVhdGVkIHdpdGggZGF0YSAoc3VwcG9zZSBhIHF1ZXJ5XG4gIC8vIHJldHVybnMgd2l0aCBkYXRhIGZvciB0aGUgZG9jdW1lbnQpLiBXZSBzaG91bGQgaHlkcmF0ZSB0aGUgZG9jdW1lbnRcbiAgLy8gaW1tZWRpYXRlbHkgaWYgd2UgY2FuIGJlY2F1c2UgdGhlIHF1ZXJ5IGNhbGxiYWNrIHdpbGwgZXhwZWN0IHRoZSBkb2N1bWVudFxuICAvLyB0byBoYXZlIGRhdGEuXG4gIGlmIChkYXRhICYmIGRhdGEuZGF0YSAhPT0gdW5kZWZpbmVkICYmICFkb2Muc3RhdGUpIHtcbiAgICBkb2MuaW5qZXN0RGF0YShkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBkb2M7XG59O1xuXG4vLyBDYWxsIGRvYy5kZXN0cm95KClcbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95RG9jID0gZnVuY3Rpb24oZG9jKSB7XG4gIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tkb2MuY29sbGVjdGlvbl07XG4gIGlmICghY29sbGVjdGlvbk9iamVjdCkgcmV0dXJuO1xuXG4gIGRlbGV0ZSBjb2xsZWN0aW9uT2JqZWN0W2RvYy5uYW1lXTtcblxuICAvLyBEZWxldGUgdGhlIGNvbGxlY3Rpb24gY29udGFpbmVyIGlmIGl0cyBlbXB0eS4gVGhpcyBjb3VsZCBiZSBhIHNvdXJjZSBvZlxuICAvLyBtZW1vcnkgbGVha3MgaWYgeW91IHNsb3dseSBtYWtlIGEgYmlsbGlvbiBjb2xsZWN0aW9ucywgd2hpY2ggeW91IHByb2JhYmx5XG4gIC8vIHdvbid0IGRvIGFueXdheSwgYnV0IHdoYXRldmVyLlxuICBpZiAoIWhhc0tleXMoY29sbGVjdGlvbk9iamVjdCkpXG4gICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xufTtcbiBcbmZ1bmN0aW9uIGhhc0tleXMob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyAqKioqIFF1ZXJpZXMuXG5cbi8vIEhlbHBlciBmb3IgY3JlYXRlRmV0Y2hRdWVyeSBhbmQgY3JlYXRlU3Vic2NyaWJlUXVlcnksIGJlbG93LlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZVF1ZXJ5ID0gZnVuY3Rpb24odHlwZSwgY29sbGVjdGlvbiwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGUgIT09ICdmZXRjaCcgJiYgdHlwZSAhPT0gJ3N1YicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXJ5IHR5cGU6ICcgKyB0eXBlKTtcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGlkID0gdGhpcy5uZXh0UXVlcnlJZCsrO1xuICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodHlwZSwgdGhpcywgaWQsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgdGhpcy5xdWVyaWVzW2lkXSA9IHF1ZXJ5O1xuICBxdWVyeS5fZXhlY3V0ZSgpO1xuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vLyBJbnRlcm5hbCBmdW5jdGlvbi4gVXNlIHF1ZXJ5LmRlc3Ryb3koKSB0byByZW1vdmUgcXVlcmllcy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95UXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBkZWxldGUgdGhpcy5xdWVyaWVzW3F1ZXJ5LmlkXTtcbn07XG5cbi8vIFRoZSBxdWVyeSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbi8vXG4vLyBkb2NNb2RlOiBXaGF0IHRvIGRvIHdpdGggZG9jdW1lbnRzIHRoYXQgYXJlIGluIHRoZSByZXN1bHQgc2V0LiBDYW4gYmVcbi8vICAgbnVsbC91bmRlZmluZWQgKGRlZmF1bHQpLCAnZmV0Y2gnIG9yICdzdWJzY3JpYmUnLiBGZXRjaCBtb2RlIGluZGljYXRlc1xuLy8gICB0aGF0IHRoZSBzZXJ2ZXIgc2hvdWxkIHNlbmQgZG9jdW1lbnQgc25hcHNob3RzIHRvIHRoZSBjbGllbnQgZm9yIGFsbCBxdWVyeVxuLy8gICByZXN1bHRzLiBUaGVzZSB3aWxsIGJlIGh5ZHJhdGVkIGludG8gdGhlIGRvY3VtZW50IG9iamVjdHMgYmVmb3JlIHRoZSBxdWVyeVxuLy8gICByZXN1bHQgY2FsbGJhY2tzIGFyZSByZXR1cm5lZC4gU3Vic2NyaWJlIG1vZGUgZ2V0cyBkb2N1bWVudCBzbmFwc2hvdHMgYW5kXG4vLyAgIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlcyB0aGUgY2xpZW50IHRvIGFsbCByZXN1bHRzLiBOb3RlIHRoYXQgdGhlXG4vLyAgIGRvY3VtZW50cyAqV0lMTCBOT1QqIGJlIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmVkIHdoZW4gdGhlIHF1ZXJ5IGlzXG4vLyAgIGRlc3Ryb3llZC4gKFNoYXJlSlMgZG9lc24ndCBoYXZlIGVub3VnaCBpbmZvcm1hdGlvbiB0byBkbyB0aGF0IHNhZmVseSkuXG4vLyAgIEJld2FyZSBvZiBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyB0aGlzIG9wdGlvbi5cbi8vXG4vLyBwb2xsOiBGb3JjYWJseSBlbmFibGUgb3IgZGlzYWJsZSBwb2xsaW5nIG1vZGUuIFBvbGxpbmcgbW9kZSB3aWxsIHJlaXNzdWUgdGhlIHF1ZXJ5XG4vLyAgIGV2ZXJ5IHRpbWUgYW55dGhpbmcgaW4gdGhlIGNvbGxlY3Rpb24gY2hhbmdlcyAoISEpIHNvLCBpdHMgcXVpdGVcbi8vICAgZXhwZW5zaXZlLiAgSXQgaXMgYXV0b21hdGljYWxseSBlbmFibGVkIGZvciBwYWdpbmF0ZWQgYW5kIHNvcnRlZCBxdWVyaWVzLlxuLy8gICBCeSBkZWZhdWx0IHF1ZXJpZXMgcnVuIHdpdGggcG9sbGluZyBtb2RlIGRpc2FibGVkOyB3aGljaCB3aWxsIG9ubHkgY2hlY2tcbi8vICAgY2hhbmdlZCBkb2N1bWVudHMgdG8gdGVzdCBpZiB0aGV5IG5vdyBtYXRjaCB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuLy8gICBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwb2xsaW5nIG1vZGUsIG9yIHRydWUgdG8gZW5hYmxlIGl0LiBJZiB5b3UgZG9uJ3Rcbi8vICAgc3BlY2lmeSBhIHBvbGwgb3B0aW9uLCBwb2xsaW5nIG1vZGUgaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBhdXRvbWF0aWNhbGx5XG4vLyAgIGJ5IHRoZSBxdWVyeSdzIGJhY2tlbmQuXG4vL1xuLy8gYmFja2VuZDogU2V0IHRoZSBiYWNrZW5kIHNvdXJjZSBmb3IgdGhlIHF1ZXJ5LiBZb3UgY2FuIGF0dGFjaCBkaWZmZXJlbnRcbi8vICAgcXVlcnkgYmFja2VuZHMgdG8gbGl2ZWRiIGFuZCBwaWNrIHdoaWNoIG9uZSB0aGUgcXVlcnkgc2hvdWxkIGhpdCB1c2luZ1xuLy8gICB0aGlzIHBhcmFtZXRlci5cbi8vXG4vLyByZXN1bHRzOiAoZXhwZXJpbWVudGFsKSBJbml0aWFsIGxpc3Qgb2YgcmVzdWx0YW50IGRvY3VtZW50cy4gVGhpcyBpc1xuLy8gICB1c2VmdWwgZm9yIHJlaHlkcmF0aW5nIHF1ZXJpZXMgd2hlbiB5b3UncmUgdXNpbmcgYXV0b0ZldGNoIC8gYXV0b1N1YnNjcmliZVxuLy8gICBzbyB0aGUgc2VydmVyIGRvZXNuJ3QgaGF2ZSB0byBzZW5kIG92ZXIgc25hcHNob3RzIGZvciBkb2N1bWVudHMgdGhlIGNsaWVudFxuLy8gICBhbHJlYWR5IGtub3dzIGFib3V0LiBUaGlzIGlzIGV4cGVyaW1lbnRhbCAtIHRoZSBBUEkgbWF5IGNoYW5nZSBpbiB1cGNvbWluZ1xuLy8gICB2ZXJzaW9ucy5cblxuLy8gQ3JlYXRlIGEgZmV0Y2ggcXVlcnkuIEZldGNoIHF1ZXJpZXMgYXJlIG9ubHkgaXNzdWVkIG9uY2UsIHJldHVybmluZyB0aGVcbi8vIHJlc3VsdHMgZGlyZWN0bHkgaW50byB0aGUgY2FsbGJhY2suXG4vL1xuLy8gVGhlIGluZGV4IGlzIHNwZWNpZmljIHRvIHRoZSBzb3VyY2UsIGJ1dCBpZiB5b3UncmUgdXNpbmcgbW9uZ29kYiBpdCdsbCBiZVxuLy8gdGhlIGNvbGxlY3Rpb24gdG8gd2hpY2ggdGhlIHF1ZXJ5IGlzIG1hZGUuXG4vLyBUaGUgY2FsbGJhY2sgc2hvdWxkIGhhdmUgdGhlIHNpZ25hdHVyZSBmdW5jdGlvbihlcnJvciwgcmVzdWx0cywgZXh0cmFEYXRhKVxuLy8gd2hlcmUgcmVzdWx0cyBpcyBhIGxpc3Qgb2YgRG9jIG9iamVjdHMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVGZXRjaFF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnZmV0Y2gnLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLy8gQ3JlYXRlIGEgc3Vic2NyaWJlIHF1ZXJ5LiBTdWJzY3JpYmUgcXVlcmllcyByZXR1cm4gd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4vLyB0aHJvdWdoIHRoZSBjYWxsYmFjaywgdGhlbiB1cGRhdGUgdGhlbXNlbHZlcyB3aGVuZXZlciB0aGUgcXVlcnkgcmVzdWx0IHNldFxuLy8gY2hhbmdlcyB2aWEgdGhlaXIgb3duIGV2ZW50IGVtaXR0ZXIuXG4vL1xuLy8gSWYgcHJlc2VudCwgdGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaWJlUXVlcnkgPSBmdW5jdGlvbihpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVF1ZXJ5KCdzdWInLCBpbmRleCwgcSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oQ29ubmVjdGlvbik7XG5cbiIsInZhciB0eXBlcywgTWljcm9FdmVudDtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHR5cGVzID0gcmVxdWlyZSgnb3R0eXBlcycpO1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59IGVsc2Uge1xuICB0eXBlcyA9IHdpbmRvdy5vdHR5cGVzO1xufVxuXG4vKlxuICogQSBEb2MgaXMgYSBjbGllbnQncyB2aWV3IG9uIGEgc2hhcmVqcyBkb2N1bWVudC5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIG5vdCBiZSBjcmVhdGVkIGRpcmVjdGx5LiBDcmVhdGUgdGhlbSBieSBjYWxsaW5nIHRoZVxuICogZG9jdW1lbnQgZ2V0dGluZyBmdW5jdGlvbnMgaW4gY29ubmVjdGlvbi5cbiAqXG4gKiBEb2N1bWVudHMgYXJlIGV2ZW50IGVtaXR0ZXJzLiBVc2UgZG9jLm9uKGV2ZW50bmFtZSwgZm4pIHRvIHN1YnNjcmliZS5cbiAqXG4gKiBEb2N1bWVudHMgY3VycmVudGx5IGdldCBtaXhlZCBpbiB3aXRoIHRoZWlyIHR5cGUncyBBUEkgbWV0aG9kcy4gU28sIHlvdSBjYW5cbiAqIC5pbnNlcnQoJ2ZvbycsIDApIGludG8gYSB0ZXh0IGRvY3VtZW50IGFuZCBzdHVmZiBsaWtlIHRoYXQuXG4gKlxuICogRXZlbnRzOlxuICogLSBiZWZvcmUgb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCBiZWZvcmUgYW4gb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gdGhlXG4gKiAgIGRvY3VtZW50LlxuICogLSBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIHJpZ2h0IGFmdGVyIGFuIG9wZXJhdGlvbiAob3IgcGFydCBvZiBhblxuICogICBvcGVyYXRpb24pIGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50LiBTdWJtaXR0aW5nIGFub3RoZXIgb3AgaGVyZSBpc1xuICogICBpbnZhbGlkIC0gd2FpdCB1bnRpbCAnYWZ0ZXIgb3AnIGlmIHlvdSB3YW50IHRvIHN1Ym1pdCBtb3JlIG9wZXJhdGlvbnMuICAtXG4gKiAgIGNoYW5nZWQgKG9wKVxuICogLSBhZnRlciBvcCAob3AsIGxvY2FsU2l0ZSk6IEZpcmVkIGFmdGVyIGFuIG9wZXJhdGlvbiBoYXMgYmVlbiBhcHBsaWVkLiBZb3VcbiAqICAgY2FuIHN1Ym1pdCBtb3JlIG9wcyBoZXJlLlxuICogLSBzdWJzY3JpYmVkIChlcnJvcik6IFRoZSBkb2N1bWVudCB3YXMgc3Vic2NyaWJlZFxuICogLSB1bnN1YnNjcmliZWQgKGVycm9yKTogVGhlIGRvY3VtZW50IHdhcyB1bnN1YnNjcmliZWRcbiAqIC0gY3JlYXRlZDogVGhlIGRvY3VtZW50IHdhcyBjcmVhdGVkLiBUaGF0IG1lYW5zIGl0cyB0eXBlIHdhcyBzZXQgYW5kIGl0IGhhc1xuICogICBzb21lIGluaXRpYWwgZGF0YS5cbiAqIC0gZXJyb3JcbiAqL1xudmFyIERvYyA9IGV4cG9ydHMuRG9jID0gZnVuY3Rpb24oY29ubmVjdGlvbiwgY29sbGVjdGlvbiwgbmFtZSkge1xuICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG4gIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgdGhpcy52ZXJzaW9uID0gdGhpcy50eXBlID0gbnVsbDtcblxuICAvLyAqKioqIFN0YXRlIGluIGRvY3VtZW50OlxuIFxuICAvLyBBY3Rpb24uIFRoaXMgaXMgZWl0aGVyIG51bGwsIG9yIG9uZSBvZiB0aGUgYWN0aW9ucyAoc3Vic2NyaWJlLFxuICAvLyB1bnN1YnNjcmliZSwgZmV0Y2gsIHN1Ym1pdCkuIE9ubHkgb25lIGFjdGlvbiBjYW4gYmUgaGFwcGVuaW5nIGF0IGEgdGltZSB0b1xuICAvLyBwcmV2ZW50IG1lIGZyb20gZ29pbmcgbWFkLlxuICAvL1xuICAvLyBQb3NzaWJsZSB2YWx1ZXM6XG4gIC8vIC0gc3Vic2NyaWJlXG4gIC8vIC0gdW5zdWJzY3JpYmVcbiAgLy8gLSBmZXRjaFxuICAvLyAtIHN1Ym1pdFxuICB0aGlzLmFjdGlvbiA9IG51bGw7XG4gXG4gIC8vIFRoZSBkYXRhIHRoZSBkb2N1bWVudCBvYmplY3Qgc3RvcmVzIGNhbiBiZSBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyB0aHJlZSBzdGF0ZXM6XG4gIC8vICAgLSBObyBkYXRhLiAobnVsbCkgV2UgaG9uZXN0bHkgZG9uJ3Qga25vdyB3aGF0cyBnb2luZyBvbi5cbiAgLy8gICAtIEZsb2F0aW5nICgnZmxvYXRpbmcnKTogd2UgaGF2ZSBhIGxvY2FsbHkgY3JlYXRlZCBkb2N1bWVudCB0aGF0IGhhc24ndFxuICAvLyAgICAgYmVlbiBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIgeWV0KVxuICAvLyAgIC0gTGl2ZSAoJ3JlYWR5JykgKHdlIGhhdmUgZGF0YSB0aGF0cyBjdXJyZW50IG9uIHRoZSBzZXJ2ZXIgYXQgc29tZSB2ZXJzaW9uKS5cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgLy8gT3VyIHN1YnNjcmlwdGlvbiBzdGF0dXMuIEVpdGhlciB3ZSdyZSBzdWJzY3JpYmVkIG9uIHRoZSBzZXJ2ZXIsIG9yIHdlIGFyZW4ndC5cbiAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gIC8vIEVpdGhlciB3ZSB3YW50IHRvIGJlIHN1YnNjcmliZWQgKHRydWUpLCB3ZSB3YW50IGEgbmV3IHNuYXBzaG90IGZyb20gdGhlXG4gIC8vIHNlcnZlciAoJ2ZldGNoJyksIG9yIHdlIGRvbid0IGNhcmUgKGZhbHNlKS4gIFRoaXMgaXMgYWxzbyB1c2VkIHdoZW4gd2VcbiAgLy8gZGlzY29ubmVjdCAmIHJlY29ubmVjdCB0byBkZWNpZGUgd2hhdCB0byBkby5cbiAgdGhpcy53YW50U3Vic2NyaWJlID0gZmFsc2U7XG4gIC8vIFRoaXMgbGlzdCBpcyB1c2VkIGZvciBzdWJzY3JpYmUgYW5kIHVuc3Vic2NyaWJlLCBzaW5jZSB3ZSdsbCBvbmx5IHdhbnQgdG9cbiAgLy8gZG8gb25lIHRoaW5nIGF0IGEgdGltZS5cbiAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzID0gW107XG5cblxuICAvLyAqKiogZW5kIHN0YXRlIHN0dWZmLlxuXG4gIC8vIFRoaXMgZG9lc24ndCBwcm92aWRlIGFueSBzdGFuZGFyZCBBUEkgYWNjZXNzIHJpZ2h0IG5vdy5cbiAgdGhpcy5wcm92aWRlcyA9IHt9O1xuXG4gIC8vIFRoZSBlZGl0aW5nIGNvbnRleHRzLiBUaGVzZSBhcmUgdXN1YWxseSBpbnN0YW5jZXMgb2YgdGhlIHR5cGUgQVBJIHdoZW4gdGhlXG4gIC8vIGRvY3VtZW50IGlzIHJlYWR5IGZvciBlZGl0cy5cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMgPSBbXTtcbiAgXG4gIC8vIFRoZSBvcCB0aGF0IGlzIGN1cnJlbnRseSByb3VuZHRyaXBwaW5nIHRvIHRoZSBzZXJ2ZXIsIG9yIG51bGwuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGNvbm5lY3Rpb24gcmVjb25uZWN0cywgdGhlIGluZmxpZ2h0IG9wIGlzIHJlc3VibWl0dGVkLlxuICAvL1xuICAvLyBUaGlzIGhhcyB0aGUgc2FtZSBmb3JtYXQgYXMgYW4gZW50cnkgaW4gcGVuZGluZ0RhdGEsIHdoaWNoIGlzOlxuICAvLyB7W2NyZWF0ZTp7Li4ufV0sIFtkZWw6dHJ1ZV0sIFtvcDouLi5dLCBjYWxsYmFja3M6Wy4uLl0sIHNyYzosIHNlcTp9XG4gIHRoaXMuaW5mbGlnaHREYXRhID0gbnVsbDtcblxuICAvLyBBbGwgb3BzIHRoYXQgYXJlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2ZXIgdG8gYWNrbm93bGVkZ2UgQGluZmxpZ2h0RGF0YVxuICAvLyBUaGlzIHVzZWQgdG8ganVzdCBiZSBhIHNpbmdsZSBvcGVyYXRpb24sIGJ1dCBjcmVhdGVzICYgZGVsZXRlcyBjYW4ndCBiZSBjb21wb3NlZCB3aXRoXG4gIC8vIHJlZ3VsYXIgb3BlcmF0aW9ucy5cbiAgLy9cbiAgLy8gVGhpcyBpcyBhIGxpc3Qgb2Yge1tjcmVhdGU6ey4uLn1dLCBbZGVsOnRydWVdLCBbb3A6Li4uXSwgY2FsbGJhY2tzOlsuLi5dfVxuICB0aGlzLnBlbmRpbmdEYXRhID0gW107XG59O1xuXG5NaWNyb0V2ZW50Lm1peGluKERvYyk7XG5cbkRvYy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBkb2MgPSB0aGlzO1xuICB0aGlzLnVuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIC8vIERvbid0IGNhcmUgaWYgdGhlcmUncyBhbiBlcnJvciB1bnN1YnNjcmliaW5nLlxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRoZXJlJ2xsIHByb2JhYmx5IGJlIG5vdGhpbmcgaGVyZSBzZWVpbmcgYXMgaG93IHdlIGp1c3QgdW5zdWJzY3JpYmVkLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrc1tpXSgnRG9jdW1lbnQgZGVzdHJveWVkJyk7XG4gICAgICB9XG4gICAgICBkb2MuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0sIDApO1xuXG4gICAgZG9jLmNvbm5lY3Rpb24uX2Rlc3Ryb3lEb2MoZG9jKTtcbiAgICBkb2MucmVtb3ZlQ29udGV4dHMoKTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxuXG4vLyAqKioqKiogTWFuaXB1bGF0aW5nIHRoZSBkb2N1bWVudCBzbmFwc2hvdCwgdmVyc2lvbiBhbmQgdHlwZS5cblxuLy8gU2V0IHRoZSBkb2N1bWVudCdzIHR5cGUsIGFuZCBhc3NvY2lhdGVkIHByb3BlcnRpZXMuIE1vc3Qgb2YgdGhlIGxvZ2ljIGluXG4vLyB0aGlzIGZ1bmN0aW9uIGV4aXN0cyB0byB1cGRhdGUgdGhlIGRvY3VtZW50IGJhc2VkIG9uIGFueSBhZGRlZCAmIHJlbW92ZWQgQVBJXG4vLyBtZXRob2RzLlxuRG9jLnByb3RvdHlwZS5fc2V0VHlwZSA9IGZ1bmN0aW9uKG5ld1R5cGUpIHtcbiAgaWYgKHR5cGVvZiBuZXdUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghdHlwZXNbbmV3VHlwZV0pIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdHlwZSBcIiArIG5ld1R5cGUpO1xuICAgIG5ld1R5cGUgPSB0eXBlc1tuZXdUeXBlXTtcbiAgfVxuICB0aGlzLnJlbW92ZUNvbnRleHRzKCk7XG5cbiAgLy8gU2V0IHRoZSBuZXcgdHlwZVxuICB0aGlzLnR5cGUgPSBuZXdUeXBlO1xuXG4gIC8vIElmIHdlIHJlbW92ZWQgdGhlIHR5cGUgZnJvbSB0aGUgb2JqZWN0LCBhbHNvIHJlbW92ZSBpdHMgc25hcHNob3QuXG4gIGlmICghbmV3VHlwZSkge1xuICAgIHRoaXMucHJvdmlkZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChuZXdUeXBlLmFwaSkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgdHlwZSdzIEFQSS5cbiAgICB0aGlzLnByb3ZpZGVzID0gbmV3VHlwZS5hcGkucHJvdmlkZXM7XG4gIH1cbn07XG5cbi8vIEluamVzdCBzbmFwc2hvdCBkYXRhLiBUaGlzIGRhdGEgbXVzdCBpbmNsdWRlIGEgdmVyc2lvbiwgc25hcHNob3QgYW5kIHR5cGUuXG4vLyBUaGlzIGlzIHVzZWQgYm90aCB0byBpbmplc3QgZGF0YSB0aGF0IHdhcyBleHBvcnRlZCB3aXRoIGEgd2VicGFnZSBhbmQgZGF0YVxuLy8gdGhhdCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGR1cmluZyBhIGZldGNoLlxuRG9jLnByb3RvdHlwZS5pbmplc3REYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAodGhpcy5zdGF0ZSkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKCdJZ25vcmluZyBhdHRlbXB0IHRvIGluamVzdCBkYXRhIGluIHN0YXRlJywgdGhpcy5zdGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGF0YS52ICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gaW4gaW5qZXN0ZWQgZGF0YScpO1xuXG5cbiAgdGhpcy52ZXJzaW9uID0gZGF0YS52O1xuICAvLyBkYXRhLmRhdGEgaXMgd2hhdCB0aGUgc2VydmVyIHdpbGwgYWN0dWFsbHkgc2VuZC4gZGF0YS5zbmFwc2hvdCBpcyB0aGUgb2xkXG4gIC8vIGZpZWxkIG5hbWUgLSBzdXBwb3J0ZWQgbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgdGhpcy5zbmFwc2hvdCA9IGRhdGEuZGF0YSB8fCBkYXRhLnNuYXBzaG90O1xuICB0aGlzLl9zZXRUeXBlKGRhdGEudHlwZSk7XG5cbiAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gIHRoaXMuZW1pdCgncmVhZHknKTtcbn07XG5cbi8vIEdldCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IGRvY3VtZW50IHNuYXBzaG90LlxuRG9jLnByb3RvdHlwZS5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zbmFwc2hvdDtcbn07XG5cbi8vIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhdCBhIHRpbWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGEgc25hcHNob3QgYW5kXG4vLyB5b3UgY2FuIHN0YXJ0IGFwcGx5aW5nIG9wZXJhdGlvbnMuIFRoaXMgbWF5IGJlIGltbWVkaWF0ZWx5LlxuRG9jLnByb3RvdHlwZS53aGVuUmVhZHkgPSBmdW5jdGlvbihmbikge1xuICBpZiAodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5Jykge1xuICAgIGZuKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gIH1cbn07XG5cbkRvYy5wcm90b3R5cGUuaGFzUGVuZGluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5pbmZsaWdodERhdGEgIT0gbnVsbCB8fCAhIXRoaXMucGVuZGluZ0RhdGEubGVuZ3RoO1xufTtcblxuXG4vLyAqKioqIEhlbHBlcnMgZm9yIG5ldHdvcmsgbWVzc2FnZXNcblxuLy8gU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIGNvbm5lY3Rpb24gZnJvbSB0aGlzIGRvY3VtZW50LlxuRG9jLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgbWVzc2FnZS5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtZXNzYWdlLmQgPSB0aGlzLm5hbWU7XG4gIHRoaXMuY29ubmVjdGlvbi5zZW5kKG1lc3NhZ2UpO1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBleGlzdHMgc28gY29ubmVjdGlvbiBjYW4gY2FsbCBpdCBkaXJlY3RseSBmb3IgYnVsayBzdWJzY3JpYmVzLlxuLy8gSXQgY291bGQganVzdCBtYWtlIGEgdGVtcG9yYXJ5IG9iamVjdCBsaXRlcmFsLCB0aGF0cyBwcmV0dHkgc2xvdy5cbkRvYy5wcm90b3R5cGUuX2hhbmRsZVN1YnNjcmliZSA9IGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICBpZiAoZXJyICYmIGVyciAhPT0gJ0FscmVhZHkgc3Vic2NyaWJlZCcpIHtcbiAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBzdWJzY3JpYmU6IFwiICsgZXJyKTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAvLyBUaGVyZSdzIHByb2JhYmx5IGEgcmVhc29uIHdlIGNvdWxkbid0IHN1YnNjcmliZS4gRG9uJ3QgcmV0cnkuXG4gICAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgbnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIGlmIChkYXRhKSB0aGlzLmluamVzdERhdGEoZGF0YSk7XG4gICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScpO1xuICAgIHRoaXMuX2ZpbmlzaFN1Yih0cnVlKTtcbiAgfVxuXG4gIHRoaXMuX2NsZWFyQWN0aW9uKCdzdWJzY3JpYmUnKTtcbn07XG5cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBjb25uZWN0aW9uIHdoZW4gaXQgcmVjZWl2ZXMgYSBtZXNzYWdlIGZvciB0aGUgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgaWYgKCEobXNnLmMgPT09IHRoaXMuY29sbGVjdGlvbiAmJiBtc2cuZCA9PT0gdGhpcy5uYW1lKSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIGl0cyBhIHNhbml0eSBjaGVjayBmb3IgYnVncyBpbiB0aGUgY29ubmVjdGlvbiBjb2RlLlxuICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCBtZXNzYWdlIGZvciB3cm9uZyBkb2N1bWVudC5cIik7XG4gIH1cblxuICAvLyBtc2cuYSA9IHRoZSBhY3Rpb24uXG4gIHN3aXRjaCAobXNnLmEpIHtcbiAgICBjYXNlICdmZXRjaCc6XG4gICAgICAvLyBXZSdyZSBkb25lIGZldGNoaW5nLiBUaGlzIG1lc3NhZ2UgaGFzIG5vIG90aGVyIGluZm9ybWF0aW9uLlxuICAgICAgaWYgKG1zZy5kYXRhKSB0aGlzLmluamVzdERhdGEobXNnLmRhdGEpO1xuICAgICAgdGhpcy5fZmluaXNoU3ViKCdmZXRjaCcsIG1zZy5lcnJvcik7XG4gICAgICBpZiAodGhpcy53YW50U3Vic2NyaWJlID09PSAnZmV0Y2gnKSB0aGlzLndhbnRTdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCdmZXRjaCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzdWInOlxuICAgICAgLy8gU3Vic2NyaWJlIHJlcGx5LlxuICAgICAgdGhpcy5faGFuZGxlU3Vic2NyaWJlKG1zZy5lcnJvciwgbXNnLmRhdGEpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1bnN1Yic6XG4gICAgICAvLyBVbnN1YnNjcmliZSByZXBseVxuICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlJyk7XG5cbiAgICAgIHRoaXMuX2ZpbmlzaFN1YihmYWxzZSwgbXNnLmVycm9yKTtcbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCd1bnN1YnNjcmliZScpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhY2snOlxuICAgICAgLy8gQWNrbm93bGVkZ2UgYSBsb2NhbGx5IHN1Ym1pdHRlZCBvcGVyYXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gVXN1YWxseSB3ZSBkbyBub3RoaW5nIGhlcmUgLSBhbGwgdGhlIGludGVyZXN0aW5nIGxvZ2ljIGhhcHBlbnMgd2hlbiB3ZVxuICAgICAgLy8gZ2V0IHNlbnQgb3VyIG9wIGJhY2sgaW4gdGhlIG9wIHN0cmVhbSAod2hpY2ggaGFwcGVucyBldmVuIGlmIHdlIGFyZW4ndFxuICAgICAgLy8gc3Vic2NyaWJlZCkuIEhvd2V2ZXIsIGlmIHRoZSBvcCBkb2Vzbid0IGdldCBhY2NlcHRlZCwgd2Ugc3RpbGwgbmVlZCB0b1xuICAgICAgLy8gY2xlYXIgc29tZSBzdGF0ZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB0aGUgbWVzc2FnZSBlcnJvciBpcyAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnLCB0aGF0IG1lYW5zIHdlJ3ZlXG4gICAgICAvLyByZXNlbnQgYW4gb3AgdGhhdCB0aGUgc2VydmVyIGFscmVhZHkgZ290LiBJdCB3aWxsIGFsc28gYmUgY29uZmlybWVkXG4gICAgICAvLyBub3JtYWxseS5cbiAgICAgIGlmIChtc2cuZXJyb3IgJiYgbXNnLmVycm9yICE9PSAnT3AgYWxyZWFkeSBzdWJtaXR0ZWQnKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgaGFzIHJlamVjdGVkIGFuIG9wIGZyb20gdGhlIGNsaWVudCBmb3Igc29tZSByZWFzb24uXG4gICAgICAgIC8vIFdlJ2xsIHNlbmQgdGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhlIHVzZXIgYW5kIHRyeSB0byByb2xsIGJhY2sgdGhlIGNoYW5nZS5cbiAgICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdPcGVyYXRpb24gd2FzIHJlamVjdGVkICgnICsgbXNnLmVycm9yICsgJykuIFRyeWluZyB0byByb2xsYmFjayBjaGFuZ2UgbG9jYWxseS4nKTtcbiAgICAgICAgICB0aGlzLl90cnlSb2xsYmFjayh0aGlzLmluZmxpZ2h0RGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSSBtYW5hZ2VkIHRvIGdldCBpbnRvIHRoaXMgc3RhdGUgb25jZS4gSSdtIG5vdCBzdXJlIGhvdyBpdCBoYXBwZW5lZC5cbiAgICAgICAgICAvLyBUaGUgb3Agd2FzIG1heWJlIGRvdWJsZS1hY2tub3dsZWRnZWQ/XG4gICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignU2Vjb25kIGFja25vd2xlZGdlbWVudCBtZXNzYWdlIChlcnJvcikgcmVjZWl2ZWQnLCBtc2csIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIHRoaXMuX2NsZWFySW5mbGlnaHRPcChtc2cuZXJyb3IpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcCc6XG4gICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEgJiZcbiAgICAgICAgICBtc2cuc3JjID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zcmMgJiZcbiAgICAgICAgICBtc2cuc2VxID09PSB0aGlzLmluZmxpZ2h0RGF0YS5zZXEpIHtcbiAgICAgICAgLy8gVGhpcyBvbmUgaXMgbWluZS4gQWNjZXB0IGl0IGFzIGFja25vd2xlZGdlZC5cbiAgICAgICAgdGhpcy5fb3BBY2tub3dsZWRnZWQobXNnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cudiAhPT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBoYXBwZW4gbmF0dXJhbGx5IGluIHRoZSBmb2xsb3dpbmcgKG9yIHNpbWlsYXIpIGNhc2VzOlxuICAgICAgICAvL1xuICAgICAgICAvLyBDbGllbnQgaXMgbm90IHN1YnNjcmliZWQgdG8gZG9jdW1lbnQuXG4gICAgICAgIC8vIC0+IGNsaWVudCBzdWJtaXRzIGFuIG9wZXJhdGlvbiAodj0xMClcbiAgICAgICAgLy8gLT4gY2xpZW50IHN1YnNjcmliZXMgdG8gYSBxdWVyeSB3aGljaCBtYXRjaGVzIHRoaXMgZG9jdW1lbnQuIFNheXMgd2VcbiAgICAgICAgLy8gICAgaGF2ZSB2PTEwIG9mIHRoZSBkb2MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDwtIHNlcnZlciBhY2tub3dsZWRnZXMgdGhlIG9wZXJhdGlvbiAodj0xMSkuIFNlcnZlciBhY2tub3dsZWRnZXMgdGhlXG4gICAgICAgIC8vICAgIG9wZXJhdGlvbiBiZWNhdXNlIHRoZSBkb2MgaXNuJ3Qgc3Vic2NyaWJlZFxuICAgICAgICAvLyA8LSBzZXJ2ZXIgcHJvY2Vzc2VzIHRoZSBxdWVyeSwgd2hpY2ggc2F5cyB0aGUgY2xpZW50IG9ubHkgaGFzIHY9MTAuXG4gICAgICAgIC8vICAgIFNlcnZlciBzdWJzY3JpYmVzIGF0IHY9MTAgbm90IHY9MTEsIHNvIHdlIGdldCBhbm90aGVyIGNvcHkgb2YgdGhlXG4gICAgICAgIC8vICAgIHY9MTAgb3BlcmF0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGNhbiBzYWZlbHkgaWdub3JlIHRoZSBvbGQgKGR1cGxpY2F0ZSkgb3BlcmF0aW9uLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB4Zih0aGlzLmluZmxpZ2h0RGF0YSwgbXNnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhmKHRoaXMucGVuZGluZ0RhdGFbaV0sIG1zZyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgdGhpcy5fb3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIHRoaXMuX2FmdGVyT3RBcHBseShtc2csIGZhbHNlKTtcbiAgICAgIC8vY29uc29sZS5sb2coJ2FwcGxpZWQnLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWV0YSc6XG4gICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgbWV0YSBvcDonLCBtc2cpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignVW5oYW5kbGVkIGRvY3VtZW50IG1lc3NhZ2U6JywgbXNnKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyBDYWxsZWQgd2hlbmV2ZXIgKHlvdSBndWVzc2VkIGl0ISkgdGhlIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcy4gVGhpcyB3aWxsXG4vLyBoYXBwZW4gd2hlbiB3ZSBnZXQgZGlzY29ubmVjdGVkICYgcmVjb25uZWN0LlxuRG9jLnByb3RvdHlwZS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkge1xuICAgICAgdGhpcy5fc2VuZE9wRGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgIC8vIFdlIGdvIGludG8gdGhlIGNvbm5lY3RlZCBzdGF0ZSBvbmNlIHdlIGhhdmUgYSBzZXNzaW9uSUQuIFdlIGNhbid0IHNlbmRcbiAgICAvLyBuZXcgb3BzIHVudGlsIHRoZW4sIHNvIHdlIG5lZWQgdG8gZmx1c2ggYWdhaW4uXG4gICAgdGhpcy5mbHVzaCgpO1xuICB9IGVsc2UgaWYgKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB0aGlzLmVtaXQoJ3Vuc3Vic2NyaWJlZCcpO1xuICB9XG59O1xuXG5cblxuXG4vLyAqKioqKiogRGVhbGluZyB3aXRoIGFjdGlvbnNcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJBY3Rpb24gPSBmdW5jdGlvbihleHBlY3RlZEFjdGlvbikge1xuICBpZiAodGhpcy5hY3Rpb24gIT09IGV4cGVjdGVkQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdVbmV4cGVjdGVkIGFjdGlvbiAnICsgdGhpcy5hY3Rpb24gKyAnIGV4cGVjdGVkOiAnICsgZXhwZWN0ZWRBY3Rpb24pO1xuICB9XG4gIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuXG5cbi8vIFNlbmQgdGhlIG5leHQgcGVuZGluZyBvcCB0byB0aGUgc2VydmVyLCBpZiB3ZSBjYW4uXG4vL1xuLy8gT25seSBvbmUgb3BlcmF0aW9uIGNhbiBiZSBpbi1mbGlnaHQgYXQgYSB0aW1lLiBJZiBhbiBvcGVyYXRpb24gaXMgYWxyZWFkeSBvblxuLy8gaXRzIHdheSwgb3Igd2UncmUgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbkRvYy5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCB8fCB0aGlzLmFjdGlvbikgcmV0dXJuO1xuXG4gIHZhciBvcERhdGE7XG4gIC8vIFB1bXAgYW5kIGR1bXAgYW55IG5vLW9wcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcGVuZGluZyBvcCBsaXN0LlxuICB3aGlsZSAodGhpcy5wZW5kaW5nRGF0YS5sZW5ndGggJiYgaXNOb09wKG9wRGF0YSA9IHRoaXMucGVuZGluZ0RhdGFbMF0pKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IG9wRGF0YS5jYWxsYmFja3M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrc1tpXShvcERhdGEuZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG4gIH1cblxuICAvLyBGaXJzdCBjb25zaWRlciBjaGFuZ2luZyBzdGF0ZVxuICBpZiAodGhpcy5zdWJzY3JpYmVkICYmICF0aGlzLndhbnRTdWJzY3JpYmUpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICd1bnN1YnNjcmliZSc7XG4gICAgdGhpcy5fc2VuZCh7YTondW5zdWInfSk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuc3Vic2NyaWJlZCAmJiB0aGlzLndhbnRTdWJzY3JpYmUgPT09ICdmZXRjaCcpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICdmZXRjaCc7XG4gICAgdGhpcy5fc2VuZCh0aGlzLnN0YXRlID09PSAncmVhZHknID8ge2E6J2ZldGNoJywgdjp0aGlzLnZlcnNpb259IDoge2E6J2ZldGNoJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnN1YnNjcmliZWQgJiYgdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgdGhpcy5hY3Rpb24gPSAnc3Vic2NyaWJlJztcbiAgICAvLyBTcGVjaWFsIHNlbmQgbWV0aG9kIG5lZWRlZCBmb3IgYnVsayBzdWJzY3JpYmVzIG9uIHJlY29ubmVjdC5cbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZFN1YnNjcmliZSh0aGlzLmNvbGxlY3Rpb24sIHRoaXMubmFtZSwgdGhpcy5zdGF0ZSA9PT0gJ3JlYWR5JyA/IHRoaXMudmVyc2lvbiA6IG51bGwpO1xuICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gVHJ5IGFuZCBzZW5kIGFueSBwZW5kaW5nIG9wcy4gV2UgY2FuJ3Qgc2VuZCBvcHMgd2hpbGUgaW4gXG4gICAgdGhpcy5pbmZsaWdodERhdGEgPSB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG5cbiAgICAvLyBEZWxheSBmb3IgZGVidWdnaW5nLlxuICAgIC8vdmFyIHRoYXQgPSB0aGlzO1xuICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5fc2VuZE9wRGF0YSgpOyB9LCAxMDAwKTtcblxuICAgIC8vIFRoaXMgYWxzbyBzZXRzIGFjdGlvbiB0byAnc3VibWl0Jy5cbiAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gIH1cbn07XG5cblxuLy8gKioqKioqIFN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIGFuZCBmZXRjaGluZ1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgaWFyZSBjb3BpZWQgaW50byB0aGUgcXVlcnkgY2xhc3MgYXMgd2VsbCwgc28gYmUgY2FyZWZ1bCBtYWtpbmdcbi8vIGNoYW5nZXMgaGVyZS5cblxuLy8gVmFsdWUgaXMgdHJ1ZSwgZmFsc2Ugb3IgJ2ZldGNoJy5cbkRvYy5wcm90b3R5cGUuX3NldFdhbnRTdWJzY3JpYmUgPSBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2ssIGVycikge1xuICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSB0aGlzLndhbnRTdWJzY3JpYmUgJiZcbiAgICAgICh0aGlzLnN1YnNjcmliZWQgPT09IHZhbHVlIHx8IHZhbHVlID09PSAnZmV0Y2gnICYmIHRoaXMuc3Vic2NyaWJlZCkpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIXRoaXMud2FudFN1YnNjcmliZSAhPT0gIXZhbHVlKSB7XG4gICAgLy8gQ2FsbCBhbGwgdGhlIGN1cnJlbnQgc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGNhbGxiYWNrcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gU2hvdWxkIEkgcmV0dXJuIGFuIGVycm9yIGhlcmU/IFdoYXQgaGFwcGVuZWQgaXMgdGhlIHVzZXIgdW5zdWJjcmliZWRcbiAgICAgIC8vIHdpdGggYSBjYWxsYmFjayB0aGVuIHJlc3Vic2NyaWJlZCBzdHJhaWdodCBhZnRlci4gRG9lcyB0aGF0IG1lYW4gdGhlXG4gICAgICAvLyB1bnN1YnNjcmliZSBmYWlsZWQ/XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvLyBJZiB3ZSB3YW50IHRvIHN1YnNjcmliZSwgZG9uJ3Qgd2Vha2VuIGl0IHRvIGEgZmV0Y2guXG4gIGlmICh2YWx1ZSAhPT0gJ2ZldGNoJyB8fCB0aGlzLndhbnRTdWJzY3JpYmUgIT09IHRydWUpXG4gICAgdGhpcy53YW50U3Vic2NyaWJlID0gdmFsdWU7XG5cbiAgaWYgKGNhbGxiYWNrKSB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8vIE9wZW4gdGhlIGRvY3VtZW50LiBUaGVyZSBpcyBubyBjYWxsYmFjayBhbmQgbm8gZXJyb3IgaGFuZGxpbmcgaWYgeW91J3JlXG4vLyBhbHJlYWR5IGNvbm5lY3RlZC5cbi8vXG4vLyBPbmx5IGNhbGwgdGhpcyBvbmNlIHBlciBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSh0cnVlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBVbnN1YnNjcmliZS4gVGhlIGRhdGEgd2lsbCBzdGF5IGFyb3VuZCBpbiBsb2NhbCBtZW1vcnksIGJ1dCB3ZSdsbCBzdG9wXG4vLyByZWNlaXZpbmcgdXBkYXRlcy5cbkRvYy5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl9zZXRXYW50U3Vic2NyaWJlKGZhbHNlLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsIHRvIHJlcXVlc3QgZnJlc2ggZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSgnZmV0Y2gnLCBjYWxsYmFjayk7XG59O1xuXG4vLyBDYWxsZWQgd2hlbiBvdXIgc3Vic2NyaWJlLCBmZXRjaCBvciB1bnN1YnNjcmliZSBtZXNzYWdlcyBhcmUgYWNrbm93bGVkZ2VkLlxuRG9jLnByb3RvdHlwZS5fZmluaXNoU3ViID0gZnVuY3Rpb24odmFsdWUsIGVycm9yKSB7XG4gIGlmICh2YWx1ZSA9PT0gdGhpcy53YW50U3Vic2NyaWJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrc1tpXShlcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9XG59O1xuXG5cbi8vIE9wZXJhdGlvbnNcblxuXG4vLyAqKioqKioqKioqKiogRGVhbGluZyB3aXRoIG9wZXJhdGlvbnMuXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgb3BEYXRhIHRvIGNvbnRhaW4gYSBuby1vcC5cbnZhciBzZXROb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIGRlbGV0ZSBvcERhdGEub3A7XG4gIGRlbGV0ZSBvcERhdGEuY3JlYXRlO1xuICBkZWxldGUgb3BEYXRhLmRlbDtcbn07XG5cbnZhciBpc05vT3AgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgcmV0dXJuICFvcERhdGEub3AgJiYgIW9wRGF0YS5jcmVhdGUgJiYgIW9wRGF0YS5kZWw7XG59XG5cbi8vIFRyeSB0byBjb21wb3NlIGRhdGEyIGludG8gZGF0YTEuIFJldHVybnMgdHJ1dGh5IGlmIGl0IHN1Y2NlZWRzLCBvdGhlcndpc2UgZmFsc3kuXG52YXIgdHJ5Q29tcG9zZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGExLCBkYXRhMikge1xuICBpZiAoZGF0YTEuY3JlYXRlICYmIGRhdGEyLmRlbCkge1xuICAgIHNldE5vT3AoZGF0YTEpO1xuICB9IGVsc2UgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5vcCkge1xuICAgIC8vIENvbXBvc2UgdGhlIGRhdGEgaW50byB0aGUgY3JlYXRlIGRhdGEuXG4gICAgdmFyIGRhdGEgPSAoZGF0YTEuY3JlYXRlLmRhdGEgPT09IHVuZGVmaW5lZCkgPyB0eXBlLmNyZWF0ZSgpIDogZGF0YTEuY3JlYXRlLmRhdGE7XG4gICAgZGF0YTEuY3JlYXRlLmRhdGEgPSB0eXBlLmFwcGx5KGRhdGEsIGRhdGEyLm9wKTtcbiAgfSBlbHNlIGlmIChpc05vT3AoZGF0YTEpKSB7XG4gICAgZGF0YTEuY3JlYXRlID0gZGF0YTIuY3JlYXRlO1xuICAgIGRhdGExLmRlbCA9IGRhdGEyLmRlbDtcbiAgICBkYXRhMS5vcCA9IGRhdGEyLm9wO1xuICB9IGVsc2UgaWYgKGRhdGExLm9wICYmIGRhdGEyLm9wICYmIHR5cGUuY29tcG9zZSkge1xuICAgIGRhdGExLm9wID0gdHlwZS5jb21wb3NlKGRhdGExLm9wLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gVHJhbnNmb3JtIHNlcnZlciBvcCBkYXRhIGJ5IGEgY2xpZW50IG9wLCBhbmQgdmljZSB2ZXJzYS4gT3BzIGFyZSBlZGl0ZWQgaW4gcGxhY2UuXG52YXIgeGYgPSBmdW5jdGlvbihjbGllbnQsIHNlcnZlcikge1xuICAvLyBJbiB0aGlzIGNhc2UsIHdlJ3JlIGluIGZvciBzb21lIGZ1bi4gVGhlcmUgYXJlIHNvbWUgbG9jYWwgb3BlcmF0aW9uc1xuICAvLyB3aGljaCBhcmUgdG90YWxseSBpbnZhbGlkIC0gZWl0aGVyIHRoZSBjbGllbnQgY29udGludWVkIGVkaXRpbmcgYVxuICAvLyBkb2N1bWVudCB0aGF0IHNvbWVvbmUgZWxzZSBkZWxldGVkIG9yIGEgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYm90aCBvbiB0aGVcbiAgLy8gY2xpZW50IGFuZCBvbiB0aGUgc2VydmVyLiBJbiBlaXRoZXIgY2FzZSwgdGhlIGxvY2FsIGRvY3VtZW50IGlzIHdheVxuICAvLyBpbnZhbGlkIGFuZCB0aGUgY2xpZW50J3Mgb3BzIGFyZSB1c2VsZXNzLlxuICAvL1xuICAvLyBUaGUgY2xpZW50IGJlY29tZXMgYSBuby1vcCwgYW5kIHdlIGtlZXAgdGhlIHNlcnZlciBvcCBlbnRpcmVseS5cbiAgaWYgKHNlcnZlci5jcmVhdGUgfHwgc2VydmVyLmRlbCkgcmV0dXJuIHNldE5vT3AoY2xpZW50KTtcbiAgaWYgKGNsaWVudC5jcmVhdGUpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZS4gVGhpcyBpcyBhIGJ1Zy4nKTtcblxuICAvLyBUaGUgY2xpZW50IGhhcyBkZWxldGVkIHRoZSBkb2N1bWVudCB3aGlsZSB0aGUgc2VydmVyIGVkaXRlZCBpdC4gS2lsbCB0aGVcbiAgLy8gc2VydmVyJ3Mgb3AuXG4gIGlmIChjbGllbnQuZGVsKSByZXR1cm4gc2V0Tm9PcChzZXJ2ZXIpO1xuXG4gIC8vIFdlIG9ubHkgZ2V0IGhlcmUgaWYgZWl0aGVyIHRoZSBzZXJ2ZXIgb3IgY2xpZW50IG9wcyBhcmUgbm8tb3AuIENhcnJ5IG9uLFxuICAvLyBub3RoaW5nIHRvIHNlZSBoZXJlLlxuICBpZiAoIXNlcnZlci5vcCB8fCAhY2xpZW50Lm9wKSByZXR1cm47XG5cbiAgLy8gVGhleSBib3RoIGVkaXRlZCB0aGUgZG9jdW1lbnQuIFRoaXMgaXMgdGhlIG5vcm1hbCBjYXNlIGZvciB0aGlzIGZ1bmN0aW9uIC1cbiAgLy8gYXMgaW4sIG1vc3Qgb2YgdGhlIHRpbWUgd2UnbGwgZW5kIHVwIGRvd24gaGVyZS5cbiAgLy9cbiAgLy8gWW91IHNob3VsZCBiZSB3b25kZXJpbmcgd2h5IEknbSB1c2luZyBjbGllbnQudHlwZSBpbnN0ZWFkIG9mIHRoaXMudHlwZS5cbiAgLy8gVGhlIHJlYXNvbiBpcywgaWYgd2UgZ2V0IG9wcyBhdCBhbiBvbGQgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQsIHRoaXMudHlwZVxuICAvLyBtaWdodCBiZSB1bmRlZmluZWQgb3IgYSB0b3RhbGx5IGRpZmZlcmVudCB0eXBlLiBCeSBwaW5uaW5nIHRoZSB0eXBlIHRvIHRoZVxuICAvLyBvcCBkYXRhLCB3ZSBtYWtlIHN1cmUgdGhlIHJpZ2h0IHR5cGUgaGFzIGl0cyB0cmFuc2Zvcm0gZnVuY3Rpb24gY2FsbGVkLlxuICBpZiAoY2xpZW50LnR5cGUudHJhbnNmb3JtWCkge1xuICAgIHZhciByZXN1bHQgPSBjbGllbnQudHlwZS50cmFuc2Zvcm1YKGNsaWVudC5vcCwgc2VydmVyLm9wKTtcbiAgICBjbGllbnQub3AgPSByZXN1bHRbMF07XG4gICAgc2VydmVyLm9wID0gcmVzdWx0WzFdO1xuICB9IGVsc2Uge1xuICAgIC8vY29uc29sZS5sb2coJ3hmJywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gICAgdmFyIF9jID0gY2xpZW50LnR5cGUudHJhbnNmb3JtKGNsaWVudC5vcCwgc2VydmVyLm9wLCAnbGVmdCcpO1xuICAgIHZhciBfcyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShzZXJ2ZXIub3AsIGNsaWVudC5vcCwgJ3JpZ2h0Jyk7XG4gICAgY2xpZW50Lm9wID0gX2M7IHNlcnZlci5vcCA9IF9zO1xuICAgIC8vY29uc29sZS5sb2coJy0+JywgSlNPTi5zdHJpbmdpZnkoY2xpZW50Lm9wKSwgSlNPTi5zdHJpbmdpZnkoc2VydmVyLm9wKSk7XG4gIH1cbn07XG5cbi8vIEludGVybmFsIG1ldGhvZCB0byBhY3R1YWxseSBhcHBseSB0aGUgZ2l2ZW4gb3AgZGF0YSB0byBvdXIgbG9jYWwgbW9kZWwuXG4vL1xuLy8gX2FmdGVyT3RBcHBseSgpIHNob3VsZCBhbHdheXMgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgYWZ0ZXJ3YXJkcy5cbkRvYy5wcm90b3R5cGUuX290QXBwbHkgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQpIHtcbiAgLy8gTG9jayB0aGUgZG9jdW1lbnQuIE5vYm9keSBpcyBhbGxvd2VkIHRvIGNhbGwgc3VibWl0T3AoKSB1bnRpbCBfYWZ0ZXJPdEFwcGx5IGlzIGNhbGxlZC5cbiAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgLy8gSWYgdGhlIHR5cGUgaXMgY3VycmVudGx5IHNldCwgaXQgbWVhbnMgd2UgdHJpZWQgY3JlYXRpbmcgdGhlIGRvY3VtZW50XG4gICAgLy8gYW5kIHNvbWVvbmUgZWxzZSB3b24uIGNsaWVudCBjcmVhdGUgeCBzZXJ2ZXIgY3JlYXRlID0gc2VydmVyIGNyZWF0ZS5cbiAgICB2YXIgY3JlYXRlID0gb3BEYXRhLmNyZWF0ZTtcbiAgICB0aGlzLl9zZXRUeXBlKGNyZWF0ZS50eXBlKTtcbiAgICB0aGlzLnNuYXBzaG90ID0gdGhpcy50eXBlLmNyZWF0ZShjcmVhdGUuZGF0YSk7XG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IGhlYXZ5d2VpZ2h0LCBidXQgSSB3YW50IHRoZSBjcmVhdGVkIGV2ZW50IHRvIGZpcmUgb3V0c2lkZSBvZiB0aGUgbG9jay5cbiAgICB0aGlzLm9uY2UoJ3VubG9jaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdjcmVhdGUnLCBjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhlIHR5cGUgc2hvdWxkIGFsd2F5cyBleGlzdCBpbiB0aGlzIGNhc2UuIGRlbCB4IF8gPSBkZWxcbiAgICB2YXIgb2xkU25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnZGVsJywgY29udGV4dCwgb2xkU25hcHNob3QpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCkge1xuICAgIGlmICghdGhpcy50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIHZhciBvcCA9IG9wRGF0YS5vcDtcbiAgICBcbiAgICAvLyBUaGUgY29udGV4dCBuZWVkcyB0byBiZSB0b2xkIHdlJ3JlIGFib3V0IHRvIGVkaXQsIGp1c3QgaW4gY2FzZSBpdCBuZWVkc1xuICAgIC8vIHRvIHN0b3JlIGFueSBleHRyYSBkYXRhLiAodGV4dC10cDIgaGFzIHRoaXMgY29uc3RyYWludC4pXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVkaXRpbmdDb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSB0aGlzLmVkaXRpbmdDb250ZXh0c1tpXTtcbiAgICAgIGlmIChjICE9IGNvbnRleHQgJiYgYy5fYmVmb3JlT3ApIGMuX2JlZm9yZU9wKG9wRGF0YS5vcCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdiZWZvcmUgb3AnLCBvcCwgY29udGV4dCk7XG5cbiAgICAvLyBUaGlzIGV4aXN0cyBzbyBjbGllbnRzIGNhbiBwdWxsIGFueSBuZWNlc3NhcnkgZGF0YSBvdXQgb2YgdGhlIHNuYXBzaG90XG4gICAgLy8gYmVmb3JlIGl0IGdldHMgY2hhbmdlZC4gIFByZXZpb3VzbHkgd2Uga2VwdCB0aGUgb2xkIHNuYXBzaG90IG9iamVjdCBhbmRcbiAgICAvLyBwYXNzZWQgaXQgdG8gdGhlIG9wIGV2ZW50IGhhbmRsZXIuIEhvd2V2ZXIsIGFwcGx5IG5vIGxvbmdlciBndWFyYW50ZWVzXG4gICAgLy8gdGhlIG9sZCBvYmplY3QgaXMgc3RpbGwgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBCZWNhdXNlIHRoaXMgY291bGQgYmUgdG90YWxseSB1bm5lY2Vzc2FyeSB3b3JrLCBpdHMgYmVoaW5kIGEgZmxhZy4gc2V0XG4gICAgLy8gZG9jLmluY3JlbWVudGFsIHRvIGVuYWJsZS5cbiAgICBpZiAodGhpcy5pbmNyZW1lbnRhbCAmJiB0eXBlLmluY3JlbWVudGFsQXBwbHkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0eXBlLmluY3JlbWVudGFsQXBwbHkodGhpcy5zbmFwc2hvdCwgb3AsIGZ1bmN0aW9uKG8sIHNuYXBzaG90KSB7XG4gICAgICAgIF90aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICAgIF90aGlzLmVtaXQoJ29wJywgbywgY29udGV4dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gY2FzZSwgc2ltcGx5IGFwcGx5aW5nIHRoZSBvcGVyYXRpb24gdG8gdGhlIGxvY2FsIHNuYXBzaG90LlxuICAgICAgdGhpcy5zbmFwc2hvdCA9IHR5cGUuYXBwbHkodGhpcy5zbmFwc2hvdCwgb3ApO1xuICAgICAgdGhpcy5lbWl0KCdvcCcsIG9wLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgLy8gSXRzIHBvc3NpYmxlIGZvciBub25lIG9mIHRoZSBhYm92ZSBjYXNlcyB0byBtYXRjaCwgaW4gd2hpY2ggY2FzZSB0aGUgb3AgaXNcbiAgLy8gYSBuby1vcC4gVGhpcyB3aWxsIGhhcHBlbiB3aGVuIGEgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBsb2NhbGx5IGFuZFxuICAvLyByZW1vdGUgb3BzIGVkaXQgdGhlIGRvY3VtZW50LlxufTtcblxuLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIF9vdEFwcGx5LlxuRG9jLnByb3RvdHlwZS5fYWZ0ZXJPdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gIGlmIChvcERhdGEub3ApIHtcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLmVkaXRpbmdDb250ZXh0cztcbiAgICAvLyBOb3RpZnkgYWxsIHRoZSBjb250ZXh0cyBhYm91dCB0aGUgb3AgKHdlbGwsIGFsbCB0aGUgY29udGV4dHMgZXhjZXB0XG4gICAgLy8gdGhlIG9uZSB3aGljaCBpbml0aWF0ZWQgdGhlIHN1Ym1pdCBpbiB0aGUgZmlyc3QgcGxhY2UpLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX29uT3ApIGMuX29uT3Aob3BEYXRhLm9wKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNvbnRleHRzLnJlbW92ZSkgY29udGV4dHMuc3BsaWNlKGktLSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnYWZ0ZXIgb3AnLCBvcERhdGEub3AsIGNvbnRleHQpO1xuICB9XG59O1xuXG5cblxuLy8gKioqKiogU2VuZGluZyBvcGVyYXRpb25zXG5cblxuLy8gQWN0dWFsbHkgc2VuZCBvcCBkYXRhIHRvIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLl9zZW5kT3BEYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gdGhpcy5pbmZsaWdodERhdGE7XG5cbiAgaWYgKHRoaXMuYWN0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUgJyArIHRoaXMuYWN0aW9uICsgJyBmb3Igc2VuZE9wRGF0YScpO1xuICB0aGlzLmFjdGlvbiA9ICdzdWJtaXQnO1xuXG4gIHZhciBtc2cgPSB7YTonb3AnLCB2OnRoaXMudmVyc2lvbn07XG4gIGlmIChkLnNyYykge1xuICAgIG1zZy5zcmMgPSBkLnNyYztcbiAgICBtc2cuc2VxID0gZC5zZXE7XG4gIH1cblxuICAvLyBUaGUgc2VydmVyIGF1dG9kZXRlY3RzIHRoaXMuXG4gIC8vaWYgKHRoaXMuc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSBtc2cuZiA9IHRydWU7IC8vIGZldGNoIGludGVybWVkaWF0ZSBvcHNcblxuICBpZiAoZC5vcCkgbXNnLm9wID0gZC5vcDtcbiAgaWYgKGQuY3JlYXRlKSBtc2cuY3JlYXRlID0gZC5jcmVhdGU7XG4gIGlmIChkLmRlbCkgbXNnLmRlbCA9IGQuZGVsO1xuXG4gIG1zZy5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtc2cuZCA9IHRoaXMubmFtZTtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZE9wKG1zZyk7XG4gICBcbiAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugc2VuZCBhbiBvcCwgaXRzIGlkIGFuZCBzZXF1ZW5jZSBudW1iZXIgaXMgaW1wbGljaXQuXG4gIGlmICghZC5zcmMpIHtcbiAgICBkLnNyYyA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICBkLnNlcSA9IHRoaXMuY29ubmVjdGlvbi5zZXErKztcbiAgfVxufTtcblxuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIHRvIGRvIHRoZSBhY3R1YWwgd29yayBmb3Igc3VibWl0T3AoKSwgY3JlYXRlKCkgYW5kIGRlbCgpLlxuLy9cbi8vIGNvbnRleHQgaXMgb3B0aW9uYWwuXG5Eb2MucHJvdG90eXBlLl9zdWJtaXRPcERhdGEgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIC8vY29uc29sZS5sb2coJ3N1Ym1pdCcsIEpTT04uc3RyaW5naWZ5KG9wRGF0YSksICd2PScsIHRoaXMudmVyc2lvbik7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb250ZXh0O1xuICAgIGNvbnRleHQgPSB0cnVlOyAvLyBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIHRydWUuXG4gIH1cbiAgaWYgKGNvbnRleHQgPT0gbnVsbCkgY29udGV4dCA9IHRydWU7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIGVsc2UgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignRmFpbGVkIGF0dGVtcHQgdG8gc3VibWl0T3A6JywgZXJyKTtcbiAgfTtcblxuICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICByZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCBzdWJtaXRPcCBmcm9tIGluc2lkZSBhbiAnb3AnIGV2ZW50IGhhbmRsZXJcIik7XG4gIH1cblxuICAvLyBUaGUgb3BEYXRhIGNvbnRhaW5zIGVpdGhlciBvcCwgY3JlYXRlLCBkZWxldGUsIG9yIG5vbmUgb2YgdGhlIGFib3ZlIChhIG5vLW9wKS5cblxuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBlcnJvcignRG9jdW1lbnQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQnKTtcblxuICAgIC8vIFRyeSB0byBub3JtYWxpemUgdGhlIG9wLiBUaGlzIHJlbW92ZXMgdHJhaWxpbmcgc2tpcDowJ3MgYW5kIHRoaW5ncyBsaWtlIHRoYXQuXG4gICAgaWYgKHRoaXMudHlwZS5ub3JtYWxpemUpIG9wRGF0YS5vcCA9IHRoaXMudHlwZS5ub3JtYWxpemUob3BEYXRhLm9wKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSAnZmxvYXRpbmcnO1xuICB9XG5cbiAgLy8gQWN0dWFsbHkgYXBwbHkgdGhlIG9wZXJhdGlvbiBsb2NhbGx5LlxuICB0aGlzLl9vdEFwcGx5KG9wRGF0YSwgY29udGV4dCk7XG5cbiAgLy8gSWYgdGhlIHR5cGUgc3VwcG9ydHMgY29tcG9zZXMsIHRyeSB0byBjb21wb3NlIHRoZSBvcGVyYXRpb24gb250byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBsYXN0IHBlbmRpbmcgb3BlcmF0aW9uLlxuICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoICYmXG4gICAgICAoZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV0sXG4gICAgICAgdHJ5Q29tcG9zZSh0aGlzLnR5cGUsIGVudHJ5LCBvcERhdGEpKSkge1xuICB9IGVsc2Uge1xuICAgIGVudHJ5ID0gb3BEYXRhO1xuICAgIG9wRGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIG9wRGF0YS5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdEYXRhLnB1c2gob3BEYXRhKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgZW50cnkuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gIHRoaXMuX2FmdGVyT3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIC8vIFRoZSBjYWxsIHRvIGZsdXNoIGlzIGluIGEgdGltZW91dCBzbyBpZiBzdWJtaXRPcCgpIGlzIGNhbGxlZCBtdWx0aXBsZVxuICAvLyB0aW1lcyBpbiBhIGNsb3N1cmUgYWxsIHRoZSBvcHMgYXJlIGNvbWJpbmVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZVxuICAvLyBzZXJ2ZXIuIEl0IGRvZXNuJ3QgbWF0dGVyIGlmIGZsdXNoIGlzIGNhbGxlZCBhIGJ1bmNoIG9mIHRpbWVzLlxuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHsgX3RoaXMuZmx1c2goKTsgfSksIDApO1xufTtcblxuXG4vLyAqKiogQ2xpZW50IE9UIGVudHJ5cG9pbnRzLlxuXG4vLyBTdWJtaXQgYW4gb3BlcmF0aW9uIHRvIHRoZSBkb2N1bWVudC4gVGhlIG9wIG11c3QgYmUgdmFsaWQgZ2l2ZW4gdGhlIGN1cnJlbnQgT1QgdHlwZS5cbkRvYy5wcm90b3R5cGUuc3VibWl0T3AgPSBmdW5jdGlvbihvcCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtvcDogb3B9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIGRvY3VtZW50LCB3aGljaCBpbiBTaGFyZUpTIHNlbWFudGljcyBtZWFucyB0byBzZXQgaXRzIHR5cGUuIEV2ZXJ5XG4vLyBvYmplY3QgaW1wbGljaXRseSBleGlzdHMgaW4gdGhlIGRhdGFiYXNlIGJ1dCBoYXMgbm8gZGF0YSBhbmQgbm8gdHlwZS4gQ3JlYXRlXG4vLyBzZXRzIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYW5kIGNhbiBvcHRpb25hbGx5IHNldCBzb21lIGluaXRpYWwgZGF0YSBvbiB0aGVcbi8vIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbih0eXBlLCBkYXRhLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBTZXR0aW5nIHRoZSBjb250ZXh0IHRvIGJlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpbiB0aGlzIGNhc2Ugc28gX3N1Ym1pdE9wRGF0YVxuICAgIC8vIGNhbiBoYW5kbGUgdGhlIGRlZmF1bHQgdmFsdWUgdGhpbmcuXG4gICAgY29udGV4dCA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodGhpcy50eXBlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygnRG9jdW1lbnQgYWxyZWFkeSBleGlzdHMnKTtcbiAgICByZXR1cm4gXG4gIH1cblxuICB0aGlzLl9zdWJtaXRPcERhdGEoe2NyZWF0ZToge3R5cGU6dHlwZSwgZGF0YTpkYXRhfX0sIGNvbnRleHQsIGNhbGxiYWNrKTtcbn07XG5cbi8vIERlbGV0ZSB0aGUgZG9jdW1lbnQuIFRoaXMgY3JlYXRlcyBhbmQgc3VibWl0cyBhIGRlbGV0ZSBvcGVyYXRpb24gdG8gdGhlXG4vLyBzZXJ2ZXIuIERlbGV0aW5nIHJlc2V0cyB0aGUgb2JqZWN0J3MgdHlwZSB0byBudWxsIGFuZCBkZWxldGVzIGl0cyBkYXRhLiBUaGVcbi8vIGRvY3VtZW50IHN0aWxsIGV4aXN0cywgYW5kIHN0aWxsIGhhcyB0aGUgdmVyc2lvbiBpdCB1c2VkIHRvIGhhdmUgYmVmb3JlIHlvdVxuLy8gZGVsZXRlZCBpdCAod2VsbCwgb2xkIHZlcnNpb24gKzEpLlxuRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihjb250ZXh0LCBjYWxsYmFjaykge1xuICBpZiAoIXRoaXMudHlwZSkge1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soJ0RvY3VtZW50IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fc3VibWl0T3BEYXRhKHtkZWw6IHRydWV9LCBjb250ZXh0LCBjYWxsYmFjayk7XG59O1xuXG5cbi8vIFBhdXNpbmcgc3RvcHMgdGhlIGRvY3VtZW50IGZyb20gc2VuZGluZyBhbnkgb3BlcmF0aW9ucyB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IHRydWU7XG59O1xuXG5Eb2MucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cbi8vICoqKiBSZWNlaXZpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlamVjdHMgb3VyIG9wZXJhdGlvbnMgZm9yIHNvbWUgcmVhc29uLlxuLy8gVGhlcmUncyBub3QgbXVjaCB3ZSBjYW4gZG8gaGVyZSBpZiB0aGUgT1QgdHlwZSBpcyBub25pbnZlcnRhYmxlLCBidXQgdGhhdFxuLy8gc2hvdWxkbid0IGhhcHBlbiB0b28gbXVjaCBpbiByZWFsIGxpZmUgYmVjYXVzZSByZWFkb25seSBkb2N1bWVudHMgc2hvdWxkIGJlXG4vLyBmbGFnZ2VkIGFzIHN1Y2guIChJIHNob3VsZCBwcm9iYWJseSBmaWd1cmUgb3V0IGEgZmxhZyBmb3IgdGhhdCkuXG4vL1xuLy8gVGhpcyBkb2VzIE5PVCBnZXQgY2FsbGVkIGlmIG91ciBvcCBmYWlscyB0byByZWFjaCB0aGUgc2VydmVyIGZvciBzb21lIHJlYXNvblxuLy8gLSB3ZSBvcHRpbWlzdGljYWxseSBhc3N1bWUgaXQnbGwgbWFrZSBpdCB0aGVyZSBldmVudHVhbGx5LlxuRG9jLnByb3RvdHlwZS5fdHJ5Um9sbGJhY2sgPSBmdW5jdGlvbihvcERhdGEpIHtcbiAgLy8gVGhpcyBpcyBwcm9iYWJseSBob3JyaWJseSBicm9rZW4uXG4gIGlmIChvcERhdGEuY3JlYXRlKSB7XG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcblxuICAgIC8vIEkgZG9uJ3QgdGhpbmsgaXRzIHBvc3NpYmxlIHRvIGdldCBoZXJlIGlmIHdlIGFyZW4ndCBpbiBhIGZsb2F0aW5nIHN0YXRlLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSAnZmxvYXRpbmcnKVxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgZWxzZVxuICAgICAgY29uc29sZS53YXJuKCdSb2xsYmFjayBhIGNyZWF0ZSBmcm9tIHN0YXRlICcgKyB0aGlzLnN0YXRlKTtcblxuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCAmJiBvcERhdGEudHlwZS5pbnZlcnQpIHtcbiAgICBvcERhdGEub3AgPSBvcERhdGEudHlwZS5pbnZlcnQob3BEYXRhLm9wKTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgdW5kbyBvcGVyYXRpb24gYnkgYW55IHBlbmRpbmcgb3BzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgeGYodGhpcy5wZW5kaW5nRGF0YVtpXSwgb3BEYXRhKTtcbiAgICB9XG5cbiAgICAvLyAuLi4gYW5kIGFwcGx5IGl0IGxvY2FsbHksIHJldmVydGluZyB0aGUgY2hhbmdlcy5cbiAgICAvLyBcbiAgICAvLyBUaGlzIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIGxvb2sgbGlrZSBpdCBjb21lcyBmcm9tIGEgcmVtb3RlIGNvbnRleHQuXG4gICAgLy8gSSdtIHN0aWxsIG5vdCAxMDAlIHN1cmUgYWJvdXQgdGhpcyBmdW5jdGlvbmFsaXR5LCBiZWNhdXNlIGl0cyByZWFsbHkgYVxuICAgIC8vIGxvY2FsIG9wLiBCYXNpY2FsbHksIHRoZSBwcm9ibGVtIGlzIHRoYXQgaWYgdGhlIGNsaWVudCdzIG9wIGlzIHJlamVjdGVkXG4gICAgLy8gYnkgdGhlIHNlcnZlciwgdGhlIGVkaXRvciB3aW5kb3cgc2hvdWxkIHVwZGF0ZSB0byByZWZsZWN0IHRoZSB1bmRvLlxuICAgIHRoaXMuX290QXBwbHkob3BEYXRhLCBmYWxzZSk7XG4gICAgdGhpcy5fYWZ0ZXJPdEFwcGx5KG9wRGF0YSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKG9wRGF0YS5vcCB8fCBvcERhdGEuZGVsKSB7XG4gICAgLy8gVGhpcyBpcyB3aGVyZSBhbiB1bmRvIHN0YWNrIHdvdWxkIGNvbWUgaW4gaGFuZHkuXG4gICAgdGhpcy5fc2V0VHlwZShudWxsKTtcbiAgICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBcIk9wIGFwcGx5IGZhaWxlZCBhbmQgdGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgcmV2ZXJ0ZWRcIik7XG5cbiAgICAvLyBUcmlnZ2VyIGEgZmV0Y2guIEluIG91ciBpbnZhbGlkIHN0YXRlLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmcuXG4gICAgdGhpcy5mZXRjaCgpO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuRG9jLnByb3RvdHlwZS5fY2xlYXJJbmZsaWdodE9wID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuaW5mbGlnaHREYXRhLmNhbGxiYWNrcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYWxsYmFja3NbaV0oZXJyb3IgfHwgdGhpcy5pbmZsaWdodERhdGEuZXJyb3IpO1xuICB9XG5cbiAgdGhpcy5pbmZsaWdodERhdGEgPSBudWxsO1xuICB0aGlzLl9jbGVhckFjdGlvbignc3VibWl0Jyk7XG5cbiAgaWYgKCF0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2QgbmFtZS5cbiAgICB0aGlzLmVtaXQoJ25vdGhpbmcgcGVuZGluZycpO1xuICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIGFuIG9wZXJhdGlvbiBmcm9tIHRoZSBjbGllbnQuXG5Eb2MucHJvdG90eXBlLl9vcEFja25vd2xlZGdlZCA9IGZ1bmN0aW9uKG1zZykge1xuICAvLyBPdXIgaW5mbGlnaHQgb3AgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLCBzbyB3ZSBjYW4gdGhyb3cgYXdheSB0aGUgaW5mbGlnaHQgZGF0YS5cbiAgLy8gKFdlIHdlcmUgb25seSBob2xkaW5nIG9uIHRvIGl0IGluY2FzZSB3ZSBuZWVkZWQgdG8gcmVzZW5kIHRoZSBvcC4pXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignb3BBY2tub3dsZWRnZWQgY2FsbGVkIGZyb20gYSBudWxsIHN0YXRlLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgIGlmICghdGhpcy5pbmZsaWdodERhdGEuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2tub3dsZWRnZSBhbiBvcC4nKTtcblxuICAgIC8vIE91ciBjcmVhdGUgaGFzIGJlZW4gYWNrbm93bGVkZ2VkLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGluamVzdGluZyBzb21lIGRhdGEuXG4gICAgdGhpcy52ZXJzaW9uID0gbXNnLnY7XG4gICAgdGhpcy5zdGF0ZSA9ICdyZWFkeSc7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy5lbWl0KCdyZWFkeScpOyB9LCAwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYSBzbmFwc2hvdC4gVGhlIHNuYXBzaG90IHNob3VsZCBiZSBhdCB0aGUgYWNrbm93bGVkZ2VkXG4gICAgLy8gdmVyc2lvbiwgYmVjYXVzZSB0aGUgc2VydmVyIGhhcyBzZW50IHVzIGFsbCB0aGUgb3BzIHRoYXQgaGF2ZSBoYXBwZW5lZFxuICAgIC8vIGJlZm9yZSBhY2tub3dsZWRnaW5nIG91ciBvcC5cblxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiAtIHNvbWV0aGluZyBpcyBvdXQgb2Ygb3JkZXIuXG4gICAgaWYgKG1zZy52ICE9PSB0aGlzLnZlcnNpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbiBmcm9tIHNlcnZlci4gVGhpcyBjYW4gaGFwcGVuIHdoZW4geW91IHN1Ym1pdCBvcHMgaW4gYSBzdWJtaXRPcCBjYWxsYmFjay4nKTtcbiAgfVxuICBcbiAgLy8gVGhlIG9wIHdhcyBjb21taXR0ZWQgc3VjY2Vzc2Z1bGx5LiBJbmNyZW1lbnQgdGhlIHZlcnNpb24gbnVtYmVyXG4gIHRoaXMudmVyc2lvbisrO1xuXG4gIHRoaXMuX2NsZWFySW5mbGlnaHRPcCgpO1xufTtcblxuXG4vLyBBUEkgQ29udGV4dHNcblxuLy8gVGhpcyBjcmVhdGVzIGFuZCByZXR1cm5zIGFuIGVkaXRpbmcgY29udGV4dCB1c2luZyB0aGUgY3VycmVudCBPVCB0eXBlLlxuRG9jLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlJyk7XG5cbiAgLy8gSSBjb3VsZCB1c2UgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBkbyB0aGlzIGluc3RlYWQsIGJ1dCBPYmplY3QuY3JlYXRlXG4gIC8vIGlzbid0IGRlZmluZWQgb24gb2xkIGJyb3dzZXJzLiBUaGlzIHdpbGwgYmUgZmluZS5cbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0ge1xuICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkb2Muc25hcHNob3Q7XG4gICAgfSxcbiAgICBzdWJtaXRPcDogZnVuY3Rpb24ob3AsIGNhbGxiYWNrKSB7XG4gICAgICBkb2Muc3VibWl0T3Aob3AsIGNvbnRleHQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZGV0YWNoKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIC8vIERvbid0IGRvdWJsZS1kZXRhY2guXG4gICAgICAgIGRlbGV0ZSB0aGlzLmRldGFjaDtcbiAgICAgIH1cbiAgICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBhY3R1YWwgZWRpdGluZ0NvbnRleHRzIGxpc3QgbmV4dCB0aW1lXG4gICAgICAvLyB3ZSByZWNlaXZlIGFuIG9wIG9uIHRoZSBkb2N1bWVudCAoYW5kIHRoZSBsaXN0IGlzIGl0ZXJhdGVkIHRocm91Z2gpLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgcG90ZW50aWFsbHkgZG9kZ3ksIGFsbG93aW5nIGEgbWVtb3J5IGxlYWsgaWYgeW91IGNyZWF0ZSAmXG4gICAgICAvLyBkZXN0cm95IGEgd2hvbGUgYnVuY2ggb2YgY29udGV4dHMgd2l0aG91dCByZWNlaXZpbmcgb3Igc2VuZGluZyBhbnkgb3BzXG4gICAgICAvLyB0byB0aGUgZG9jdW1lbnQuXG4gICAgICBkZWxldGUgdGhpcy5fb25PcDtcbiAgICAgIHRoaXMucmVtb3ZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBpcyBkYW5nZXJvdXMsIGJ1dCByZWFsbHkgcmVhbGx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nLiBJIGhvcGUgcGVvcGxlXG4gICAgLy8gZG9uJ3QgZGVwZW5kIG9uIGl0LlxuICAgIF9kb2M6IHRoaXMsXG4gIH07XG5cbiAgaWYgKHR5cGUuYXBpKSB7XG4gICAgLy8gQ29weSBldmVyeXRoaW5nIGVsc2UgZnJvbSB0aGUgdHlwZSdzIEFQSSBpbnRvIHRoZSBlZGl0aW5nIGNvbnRleHQuXG4gICAgZm9yICh2YXIgayBpbiB0eXBlLmFwaSkge1xuICAgICAgY29udGV4dFtrXSA9IHR5cGUuYXBpW2tdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnByb3ZpZGVzID0ge307XG4gIH1cblxuICB0aGlzLmVkaXRpbmdDb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuRG9jLnByb3RvdHlwZS5yZW1vdmVDb250ZXh0cyA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5lZGl0aW5nQ29udGV4dHNbaV0uZGVzdHJveSgpO1xuICB9XG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzLmxlbmd0aCA9IDA7XG59O1xuXG4iLCJcbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgZXhwb3J0c1t0eXBlLm5hbWVdID0gdHlwZTtcbiAgaWYgKHR5cGUudXJpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHNbdHlwZS51cmldID0gdHlwZTtcbiAgfVxufTtcblxuLy8gSW1wb3J0IGFsbCB0aGUgYnVpbHQtaW4gdHlwZXMuIFJlcXVpcmluZyBkaXJlY3RseSByYXRoZXIgdGhhbiBpbiByZWdpc3RlcigpXG4vLyBzbyBicm93c2VyaWZ5IHdvcmtzLlxucmVnaXN0ZXIocmVxdWlyZSgnLi9zaW1wbGUnKSk7XG5cbnJlZ2lzdGVyKHJlcXVpcmUoJy4vdGV4dCcpKTtcbnJlZ2lzdGVyKHJlcXVpcmUoJy4vdGV4dC10cDInKSk7XG5cbnJlZ2lzdGVyKHJlcXVpcmUoJy4vanNvbjAnKSk7XG5cbiIsIi8vIFRoaXMgaXMgYSByZWFsbHkgc2ltcGxlIE9UIHR5cGUuIEl0cyBub3QgY29tcGlsZWQgd2l0aCB0aGUgd2ViIGNsaWVudCwgYnV0IGl0IGNvdWxkIGJlLlxuLy9cbi8vIEl0cyBtb3N0bHkgaW5jbHVkZWQgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMgYW5kIGl0cyB1c2VkIGluIHRoZSBtZXRhIHVuaXQgdGVzdHMuXG4vL1xuLy8gVGhpcyBkZWZpbmVzIGEgcmVhbGx5IHNpbXBsZSB0ZXh0IE9UIHR5cGUgd2hpY2ggb25seSBhbGxvd3MgaW5zZXJ0cy4gKE5vIGRlbGV0ZXMpLlxuLy9cbi8vIE9wcyBsb29rIGxpa2U6XG4vLyAgIHtwb3NpdGlvbjojLCB0ZXh0OlwiYXNkZlwifVxuLy9cbi8vIERvY3VtZW50IHNuYXBzaG90cyBsb29rIGxpa2U6XG4vLyAgIHtzdHI6c3RyaW5nfVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhlIE9UIHR5cGUuIFRoZSB0eXBlIGl0c2VsZiBpcyBleHBvc2VkIHRvIG90dHlwZXNbdHlwZS5uYW1lXSBhbmQgb3R0eXBlc1t0eXBlLnVyaV0uXG4gIC8vIFRoZSBuYW1lIGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0eXBlIGluIGFsbCBBUEkgbWV0aG9kcyBpbiBTaGFyZUpTLlxuICBuYW1lOiAnc2ltcGxlJyxcblxuICAvLyBDYW5vbmljYWwgbmFtZS5cbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3NpbXBsZScsXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGRvY3VtZW50IHNuYXBzaG90LiBJbml0aWFsIGRhdGEgY2FuIGJlIHBhc3NlZCBpbi5cbiAgY3JlYXRlOiBmdW5jdGlvbihpbml0aWFsKSB7XG4gICAgaWYgKGluaXRpYWwgPT0gbnVsbClcbiAgICAgIGluaXRpYWwgPSAnJztcblxuICAgIHJldHVybiB7c3RyOiBpbml0aWFsfTtcbiAgfSxcblxuICAvLyBBcHBseSB0aGUgZ2l2ZW4gb3AgdG8gdGhlIGRvY3VtZW50IHNuYXBzaG90LiBSZXR1cm5zIHRoZSBuZXcgc25hcHNob3QuXG4gIGFwcGx5OiBmdW5jdGlvbihzbmFwc2hvdCwgb3ApIHtcbiAgICBpZiAob3AucG9zaXRpb24gPCAwIHx8IG9wLnBvc2l0aW9uID4gc25hcHNob3Quc3RyLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwb3NpdGlvbicpO1xuXG4gICAgdmFyIHN0ciA9IHNuYXBzaG90LnN0cjtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMCwgb3AucG9zaXRpb24pICsgb3AudGV4dCArIHN0ci5zbGljZShvcC5wb3NpdGlvbik7XG4gICAgcmV0dXJuIHtzdHI6IHN0cn07XG4gIH0sXG5cbiAgLy8gVHJhbnNmb3JtIG9wMSBieSBvcDIuIFJldHVybnMgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiBvcDEuXG4gIC8vIFN5bSBkZXNjcmliZXMgdGhlIHN5bW1ldHJ5IG9mIHRoZSBvcGVyYXRpb24uIEl0cyBlaXRoZXIgJ2xlZnQnIG9yICdyaWdodCdcbiAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG9wIGJlaW5nIHRyYW5zZm9ybWVkIGNvbWVzIGZyb20gdGhlIGNsaWVudCBvciB0aGVcbiAgLy8gc2VydmVyLlxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKG9wMSwgb3AyLCBzeW0pIHtcbiAgICB2YXIgcG9zID0gb3AxLnBvc2l0aW9uO1xuXG4gICAgaWYgKG9wMi5wb3NpdGlvbiA8IHBvcyB8fCAob3AyLnBvc2l0aW9uID09PSBwb3MgJiYgc3ltID09PSAnbGVmdCcpKSB7XG4gICAgICBwb3MgKz0gb3AyLnRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB7cG9zaXRpb246IHBvcywgdGV4dDogb3AxLnRleHR9O1xuICB9XG59O1xuXG4iLCIvKiBUZXh0IE9UIVxuICpcbiAqIFRoaXMgaXMgYW4gT1QgaW1wbGVtZW50YXRpb24gZm9yIHRleHQuIEl0IGlzIHRoZSBzdGFuZGFyZCBpbXBsZW1lbnRhdGlvbiBvZlxuICogdGV4dCB1c2VkIGJ5IFNoYXJlSlMuXG4gKlxuICogVGhpcyB0eXBlIGlzIGNvbXBvc2FibGUgYnV0IG5vbi1pbnZlcnRhYmxlLiBJdHMgc2ltaWxhciB0byBTaGFyZUpTJ3Mgb2xkXG4gKiB0ZXh0LWNvbXBvc2FibGUgdHlwZSwgYnV0IGl0cyBub3QgaW52ZXJ0YWJsZSBhbmQgaXRzIHZlcnkgc2ltaWxhciB0byB0aGVcbiAqIHRleHQtdHAyIGltcGxlbWVudGF0aW9uIGJ1dCBpdCBkb2Vzbid0IHN1cHBvcnQgdG9tYnN0b25lcyBvciBwdXJnaW5nLlxuICpcbiAqIE9wcyBhcmUgbGlzdHMgb2YgY29tcG9uZW50cyB3aGljaCBpdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LlxuICogQ29tcG9uZW50cyBhcmUgZWl0aGVyOlxuICogICBBIG51bWJlciBOOiBTa2lwIE4gY2hhcmFjdGVycyBpbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnRcbiAqICAgXCJzdHJcIiAgICAgOiBJbnNlcnQgXCJzdHJcIiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbiAqICAge2Q6J3N0cid9IDogRGVsZXRlICdzdHInLCB3aGljaCBhcHBlYXJzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuICpcbiAqIEVnOiBbMywgJ2hpJywgNSwge2Q6OH1dXG4gKlxuICogVGhlIG9wZXJhdGlvbiBkb2VzIG5vdCBoYXZlIHRvIHNraXAgdGhlIGxhc3QgY2hhcmFjdGVycyBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogU25hcHNob3RzIGFyZSBzdHJpbmdzLlxuICpcbiAqIEN1cnNvcnMgYXJlIGVpdGhlciBhIHNpbmdsZSBudW1iZXIgKHdoaWNoIGlzIHRoZSBjdXJzb3IgcG9zaXRpb24pIG9yIGEgcGFpciBvZlxuICogW2FuY2hvciwgZm9jdXNdIChha2EgW3N0YXJ0LCBlbmRdKS4gQmUgYXdhcmUgdGhhdCBlbmQgY2FuIGJlIGJlZm9yZSBzdGFydC5cbiAqL1xuXG4vKiogQG1vZHVsZSB0ZXh0ICovXG5cbmV4cG9ydHMubmFtZSA9ICd0ZXh0JztcbmV4cG9ydHMudXJpID0gJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0djEnO1xuXG4vKiogQ3JlYXRlIGEgbmV3IHRleHQgc25hcHNob3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWwgLSBpbml0aWFsIHNuYXBzaG90IGRhdGEuIE9wdGlvbmFsLiBEZWZhdWx0cyB0byAnJy5cbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihpbml0aWFsKSB7XG4gIGlmICgoaW5pdGlhbCAhPSBudWxsKSAmJiB0eXBlb2YgaW5pdGlhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luaXRpYWwgZGF0YSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGluaXRpYWwgfHwgJyc7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufTtcblxuLyoqIENoZWNrIHRoZSBvcGVyYXRpb24gaXMgdmFsaWQuIFRocm93cyBpZiBub3QgdmFsaWQuICovXG52YXIgY2hlY2tPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGlmICghaXNBcnJheShvcCkpIHRocm93IG5ldyBFcnJvcignT3AgbXVzdCBiZSBhbiBhcnJheSBvZiBjb21wb25lbnRzJyk7XG5cbiAgdmFyIGxhc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAvLyBUaGUgb25seSB2YWxpZCBvYmplY3RzIGFyZSB7ZDpYfSBmb3IgK2l2ZSB2YWx1ZXMgb2YgWC5cbiAgICAgICAgaWYgKCEodHlwZW9mIGMuZCA9PT0gJ251bWJlcicgJiYgYy5kID4gMCkpIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGNvbXBvbmVudHMgbXVzdCBiZSBkZWxldGVzIG9mIHNpemUgPiAwJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgLy8gU3RyaW5ncyBhcmUgaW5zZXJ0cy5cbiAgICAgICAgaWYgKCEoYy5sZW5ndGggPiAwKSkgdGhyb3cgbmV3IEVycm9yKCdJbnNlcnRzIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIC8vIE51bWJlcnMgbXVzdCBiZSBza2lwcy4gVGhleSBoYXZlIHRvIGJlICtpdmUgbnVtYmVycy5cbiAgICAgICAgaWYgKCEoYyA+IDApKSB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgY29tcG9uZW50cyBtdXN0IGJlID4wJyk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignQWRqYWNlbnQgc2tpcCBjb21wb25lbnRzIHNob3VsZCBiZSBjb21iaW5lZCcpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGFzdCA9IGM7XG4gIH1cblxuICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ09wIGhhcyBhIHRyYWlsaW5nIHNraXAnKTtcbn07XG5cbi8qKiBNYWtlIGEgZnVuY3Rpb24gdGhhdCBhcHBlbmRzIHRvIHRoZSBnaXZlbiBvcGVyYXRpb24uICovXG52YXIgbWFrZUFwcGVuZCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCBjb21wb25lbnQuZCA9PT0gMCkge1xuICAgICAgLy8gVGhlIGNvbXBvbmVudCBpcyBhIG5vLW9wLiBJZ25vcmUhXG4gXG4gICAgfSBlbHNlIGlmIChvcC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvcC5wdXNoKGNvbXBvbmVudCk7XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09IHR5cGVvZiBvcFtvcC5sZW5ndGggLSAxXSkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvcFtvcC5sZW5ndGggLSAxXS5kICs9IGNvbXBvbmVudC5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wW29wLmxlbmd0aCAtIDFdICs9IGNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gIH07XG59O1xuXG4vKiogTWFrZXMgYW5kIHJldHVybnMgdXRpbGl0eSBmdW5jdGlvbnMgdGFrZSBhbmQgcGVlay4gKi9cbnZhciBtYWtlVGFrZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIC8vIFRoZSBpbmRleCBvZiB0aGUgbmV4dCBjb21wb25lbnQgdG8gdGFrZVxuICB2YXIgaWR4ID0gMDtcbiAgLy8gVGhlIG9mZnNldCBpbnRvIHRoZSBjb21wb25lbnRcbiAgdmFyIG9mZnNldCA9IDA7XG5cbiAgLy8gVGFrZSB1cCB0byBsZW5ndGggbiBmcm9tIHRoZSBmcm9udCBvZiBvcC4gSWYgbiBpcyAtMSwgdGFrZSB0aGUgZW50aXJlIG5leHRcbiAgLy8gb3AgY29tcG9uZW50LiBJZiBpbmRpdmlzYWJsZUZpZWxkID09ICdkJywgZGVsZXRlIGNvbXBvbmVudHMgd29uJ3QgYmUgc2VwYXJhdGVkLlxuICAvLyBJZiBpbmRpdmlzYWJsZUZpZWxkID09ICdpJywgaW5zZXJ0IGNvbXBvbmVudHMgd29uJ3QgYmUgc2VwYXJhdGVkLlxuICB2YXIgdGFrZSA9IGZ1bmN0aW9uKG4sIGluZGl2aXNhYmxlRmllbGQpIHtcbiAgICAvLyBXZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24uIFRoZSBvcCBoYXMgc2tpcHMsIGZvcmV2ZXIuIEluZmluaXR5XG4gICAgLy8gbWlnaHQgbWFrZSBtb3JlIHNlbnNlIHRoYW4gbnVsbCBoZXJlLlxuICAgIGlmIChpZHggPT09IG9wLmxlbmd0aClcbiAgICAgIHJldHVybiBuID09PSAtMSA/IG51bGwgOiBuO1xuXG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGMgPSBvcFtpZHhdO1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNraXBcbiAgICAgIGlmIChuID09PSAtMSB8fCBjIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IGMgLSBvZmZzZXQ7XG4gICAgICAgICsraWR4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICBpZiAobiA9PT0gLTEgfHwgaW5kaXZpc2FibGVGaWVsZCA9PT0gJ2knIHx8IGMubGVuZ3RoIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IGMuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgKytpZHg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydCA9IGMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBuKTtcbiAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWxldGVcbiAgICAgIGlmIChuID09PSAtMSB8fCBpbmRpdmlzYWJsZUZpZWxkID09PSAnZCcgfHwgYy5kIC0gb2Zmc2V0IDw9IG4pIHtcbiAgICAgICAgcGFydCA9IHtkOiBjLmQgLSBvZmZzZXR9O1xuICAgICAgICArK2lkeDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgcmV0dXJuIHtkOiBufTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUGVlayBhdCB0aGUgbmV4dCBvcCB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gIHZhciBwZWVrVHlwZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gb3BbaWR4XTsgfTtcblxuICByZXR1cm4gW3Rha2UsIHBlZWtUeXBlXTtcbn07XG5cbi8qKiBHZXQgdGhlIGxlbmd0aCBvZiBhIGNvbXBvbmVudCAqL1xudmFyIGNvbXBvbmVudExlbmd0aCA9IGZ1bmN0aW9uKGMpIHtcbiAgLy8gVWdsaWZ5IHdpbGwgY29tcHJlc3MgdGhpcyBkb3duIGludG8gYSB0ZXJuYXJ5XG4gIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYy5sZW5ndGggfHwgYy5kO1xuICB9XG59O1xuXG4vKiogVHJpbSBhbnkgZXhjZXNzIHNraXBzIGZyb20gdGhlIGVuZCBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgYXQgbW9zdCBvbmUsIGJlY2F1c2UgdGhlIG9wZXJhdGlvbiB3YXMgbWFkZSB3aXRoIGFwcGVuZC5cbiAqL1xudmFyIHRyaW0gPSBmdW5jdGlvbihvcCkge1xuICBpZiAob3AubGVuZ3RoID4gMCAmJiB0eXBlb2Ygb3Bbb3AubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7XG4gICAgb3AucG9wKCk7XG4gIH1cbiAgcmV0dXJuIG9wO1xufTtcblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQobmV3T3ApO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kKG9wW2ldKTtcbiAgfVxuICByZXR1cm4gdHJpbShuZXdPcCk7XG59O1xuXG4vKiogQXBwbHkgYW4gb3BlcmF0aW9uIHRvIGEgZG9jdW1lbnQgc25hcHNob3QgKi9cbmV4cG9ydHMuYXBwbHkgPSBmdW5jdGlvbihzdHIsIG9wKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU25hcHNob3Qgc2hvdWxkIGJlIGEgc3RyaW5nJyk7XG4gIH1cbiAgY2hlY2tPcChvcCk7XG5cbiAgLy8gV2UnbGwgZ2F0aGVyIHRoZSBuZXcgZG9jdW1lbnQgaGVyZSBhbmQgam9pbiBhdCB0aGUgZW5kLlxuICB2YXIgbmV3RG9jID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvcFtpXTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGlmIChjb21wb25lbnQgPiBzdHIubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCBpcyB0b28gbG9uZyBmb3IgdGhpcyBkb2N1bWVudCcpO1xuXG4gICAgICAgIG5ld0RvYy5wdXNoKHN0ci5zbGljZSgwLCBjb21wb25lbnQpKTtcbiAgICAgICAgLy8gVGhpcyBtaWdodCBiZSBzbG93IGZvciBiaWcgc3RyaW5ncy4gQ29uc2lkZXIgc3RvcmluZyB0aGUgb2Zmc2V0IGluXG4gICAgICAgIC8vIHN0ciBpbnN0ZWFkIG9mIHJld3JpdGluZyBpdCBlYWNoIHRpbWUuXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShjb21wb25lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIG5ld0RvYy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKGNvbXBvbmVudC5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0RvYy5qb2luKCcnKSArIHN0cjtcbn07XG5cbi8qKiBUcmFuc2Zvcm0gb3AgYnkgb3RoZXJPcC5cbiAqXG4gKiBAcGFyYW0gb3AgLSBUaGUgb3BlcmF0aW9uIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIG90aGVyT3AgLSBPcGVyYXRpb24gdG8gdHJhbnNmb3JtIGl0IGJ5XG4gKiBAcGFyYW0gc2lkZSAtIEVpdGhlciAnbGVmdCcgb3IgJ3JpZ2h0J1xuICovXG5leHBvcnRzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCBzaWRlKSB7XG4gIGlmIChzaWRlICE9ICdsZWZ0JyAmJiBzaWRlICE9ICdyaWdodCcpIHRocm93IG5ldyBFcnJvcihcInNpZGUgKFwiICsgc2lkZSArIFwiKSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuXG4gIGNoZWNrT3Aob3ApO1xuICBjaGVja09wKG90aGVyT3ApO1xuXG4gIHZhciBuZXdPcCA9IFtdO1xuICB2YXIgYXBwZW5kID0gbWFrZUFwcGVuZChuZXdPcCk7XG5cbiAgdmFyIF9mbnMgPSBtYWtlVGFrZShvcCk7XG4gIHZhciB0YWtlID0gX2Zuc1swXSxcbiAgICAgIHBlZWsgPSBfZm5zWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJPcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvdGhlck9wW2ldO1xuXG4gICAgdmFyIGxlbmd0aCwgY2h1bms7XG4gICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XG4gICAgICBjYXNlICdudW1iZXInOiAvLyBTa2lwXG4gICAgICAgIGxlbmd0aCA9IGNvbXBvbmVudDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnaScpO1xuICAgICAgICAgIGFwcGVuZChjaHVuayk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxlbmd0aCAtPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzogLy8gSW5zZXJ0XG4gICAgICAgIGlmIChzaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAvLyBUaGUgbGVmdCBpbnNlcnQgc2hvdWxkIGdvIGZpcnN0LlxuICAgICAgICAgIGlmICh0eXBlb2YgcGVlaygpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXBwZW5kKHRha2UoLTEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPdGhlcndpc2Ugc2tpcCB0aGUgaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgYXBwZW5kKGNvbXBvbmVudC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzogLy8gRGVsZXRlXG4gICAgICAgIGxlbmd0aCA9IGNvbXBvbmVudC5kO1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdpJyk7XG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2h1bmspIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgIGxlbmd0aCAtPSBjaHVuaztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgIC8vIFRoZSBkZWxldGUgaXMgdW5uZWNlc3Nhcnkgbm93IC0gdGhlIHRleHQgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkLlxuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bmsuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICAvLyBBcHBlbmQgYW55IGV4dHJhIGRhdGEgaW4gb3AxLlxuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoLTEpKSlcbiAgICBhcHBlbmQoY29tcG9uZW50KTtcbiAgXG4gIHJldHVybiB0cmltKG5ld09wKTtcbn07XG5cbi8qKiBDb21wb3NlIG9wMSBhbmQgb3AyIHRvZ2V0aGVyIGFuZCByZXR1cm4gdGhlIHJlc3VsdCAqL1xuZXhwb3J0cy5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgY2hlY2tPcChvcDEpO1xuICBjaGVja09wKG9wMik7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgYXBwZW5kID0gbWFrZUFwcGVuZChyZXN1bHQpO1xuICB2YXIgdGFrZSA9IG1ha2VUYWtlKG9wMSlbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3AyW2ldO1xuICAgIHZhciBsZW5ndGgsIGNodW5rO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzogLy8gU2tpcFxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmsgPSB0YWtlKGxlbmd0aCwgJ2QnKTtcbiAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6IC8vIEluc2VydFxuICAgICAgICBhcHBlbmQoY29tcG9uZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIERlbGV0ZVxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQuZDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdkJyk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBjaHVuaykge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgYXBwZW5kKHtkOiBjaHVua30pO1xuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bms7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoLTEpKSlcbiAgICBhcHBlbmQoY29tcG9uZW50KTtcblxuICByZXR1cm4gdHJpbShyZXN1bHQpO1xufTtcblxudmFyIHRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24oY3Vyc29yLCBvcCkge1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKGN1cnNvciA8PSBwb3MpIGJyZWFrO1xuXG4gICAgLy8gSSBjb3VsZCBhY3R1YWxseSB1c2UgdGhlIG9wX2l0ZXIgc3R1ZmYgYWJvdmUgLSBidXQgSSB0aGluayBpdHMgc2ltcGxlclxuICAgIC8vIGxpa2UgdGhpcy5cbiAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoY3Vyc29yIDw9IHBvcyArIGMpXG4gICAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgICAgcG9zICs9IGM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBwb3MgKz0gYy5sZW5ndGg7XG4gICAgICAgIGN1cnNvciArPSBjLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGN1cnNvciAtPSBNYXRoLm1pbihjLmQsIGN1cnNvciAtIHBvcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3Vyc29yO1xufTtcblxuZXhwb3J0cy50cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihjdXJzb3IsIG9wLCBpc093bk9wKSB7XG4gIHZhciBwb3MgPSAwO1xuICBpZiAoaXNPd25PcCkge1xuICAgIC8vIEp1c3QgdHJhY2sgdGhlIHBvc2l0aW9uLiBXZSdsbCB0ZWxlcG9ydCB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgYW55d2F5LlxuICAgIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0ZXh0IG9wcyBkb24ndCBoYXZlIGFueSB0cmFpbGluZyBza2lwcyBhdCB0aGUgZW5kIC0gc28gdGhlIGxhc3RcbiAgICAvLyBjb21wb25lbnQgaXMgdGhlIGxhc3QgdGhpbmcuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBvcFtpXTtcbiAgICAgIHN3aXRjaCAodHlwZW9mIGMpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBwb3MgKz0gYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBwb3MgKz0gYy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEp1c3QgZWF0IGRlbGV0ZXMuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcG9zLCBwb3NdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbdHJhbnNmb3JtUG9zaXRpb24oY3Vyc29yWzBdLCBvcCksIHRyYW5zZm9ybVBvc2l0aW9uKGN1cnNvclsxXSwgb3ApXTtcbiAgfVxufTtcbiIsIihmdW5jdGlvbigpey8vIEEgVFAyIGltcGxlbWVudGF0aW9uIG9mIHRleHQsIGZvbGxvd2luZyB0aGlzIHNwZWM6XG4vLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvbGlnaHR3YXZlL3NvdXJjZS9icm93c2UvdHJ1bmsvZXhwZXJpbWVudGFsL290L1JFQURNRVxuLy9cbi8vIEEgZG9jdW1lbnQgaXMgbWFkZSB1cCBvZiBhIHN0cmluZyBhbmQgYSBzZXQgb2YgdG9tYnN0b25lcyBpbnNlcnRlZCB0aHJvdWdob3V0XG4vLyB0aGUgc3RyaW5nLiBGb3IgZXhhbXBsZSwgJ3NvbWUgJywgKDIgdG9tYnN0b25lcyksICdzdHJpbmcnLlxuLy9cbi8vIFRoaXMgaXMgZW5jb2RlZCBpbiBhIGRvY3VtZW50IGFzOiB7czonc29tZSBzdHJpbmcnLCB0Ols1LCAtMiwgNl19XG4vL1xuLy8gT3BzIGFyZSBsaXN0cyBvZiBjb21wb25lbnRzIHdoaWNoIGl0ZXJhdGUgb3ZlciB0aGUgd2hvbGUgZG9jdW1lbnQuIChJIG1pZ2h0XG4vLyBjaGFuZ2UgdGhpcyBhdCBzb21lIHBvaW50LCBidXQgYSB2ZXJzaW9uIHRoYXRzIGxlc3Mgc3RyaWN0IGlzIGJhY2t3YXJkc1xuLy8gY29tcGF0aWJsZS4pXG4vL1xuLy8gQ29tcG9uZW50cyBhcmUgZWl0aGVyOlxuLy8gICBOOiAgICAgICAgIFNraXAgTiBjaGFyYWN0ZXJzIGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudFxuLy8gICB7aTonc3RyJ306IEluc2VydCAnc3RyJyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbi8vICAge2k6Tn06ICAgICBJbnNlcnQgTiB0b21ic3RvbmVzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuLy8gICB7ZDpOfTogICAgIERlbGV0ZSAodG9tYnN0b25lKSBOIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4vL1xuLy8gRWc6IFszLCB7aTonaGknfSwgNSwge2Q6OH1dXG4vL1xuLy8gU25hcHNob3RzIGFyZSBsaXN0cyB3aXRoIGNoYXJhY3RlcnMgYW5kIHRvbWJzdG9uZXMuIENoYXJhY3RlcnMgYXJlIHN0b3JlZCBpbiBzdHJpbmdzXG4vLyBhbmQgYWRqYWNlbnQgdG9tYnN0b25lcyBhcmUgZmxhdHRlbmVkIGludG8gbnVtYmVycy5cbi8vXG4vLyBFZywgdGhlIGRvY3VtZW50OiAnSGVsbG8gLi4uLi53b3JsZCcgKCcuJyBkZW5vdGVzIHRvbWJzdG9uZWQgKGRlbGV0ZWQpIGNoYXJhY3RlcnMpXG4vLyB3b3VsZCBiZSByZXByZXNlbnRlZCBieSBhIGRvY3VtZW50IHNuYXBzaG90IG9mIFsnSGVsbG8gJywgNSwgJ3dvcmxkJ11cblxuLy92YXIgYXBwZW5kLCBhcHBlbmREb2MsIGNvbXBvbmVudExlbmd0aCwgbWFrZVRha2UsIHRha2VEb2MsIHRyYW5zZm9ybWVyO1xuXG52YXIgdHlwZSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndGV4dC10cDInLFxuICB0cDI6IHRydWUsXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy90ZXh0LXRwMnYxJyxcbiAgY3JlYXRlOiBmdW5jdGlvbihpbml0aWFsKSB7XG4gICAgaWYgKGluaXRpYWwgPT0gbnVsbCkge1xuICAgICAgaW5pdGlhbCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGluaXRpYWwgIT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignSW5pdGlhbCBkYXRhIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhckxlbmd0aDogaW5pdGlhbC5sZW5ndGgsXG4gICAgICB0b3RhbExlbmd0aDogaW5pdGlhbC5sZW5ndGgsXG4gICAgICBkYXRhOiBpbml0aWFsLmxlbmd0aCA/IFtpbml0aWFsXSA6IFtdXG4gICAgfTtcbiAgfSxcblxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKGRvYykge1xuICAgIGlmICghZG9jLmRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkb2Mgc25hcHNob3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYy5kYXRhO1xuICB9LFxuXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGRvYyA9IHR5cGUuY3JlYXRlKCk7XG4gICAgZG9jLmRhdGEgPSBkYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gZGF0YVtpXTtcblxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRvYy5jaGFyTGVuZ3RoICs9IGNvbXBvbmVudC5sZW5ndGg7XG4gICAgICAgIGRvYy50b3RhbExlbmd0aCArPSBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLnRvdGFsTGVuZ3RoICs9IGNvbXBvbmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZG9jO1xuICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIGNoZWNrT3AgPSBmdW5jdGlvbihvcCkge1xuICBpZiAoIWlzQXJyYXkob3ApKSB0aHJvdyBuZXcgRXJyb3IoJ09wIG11c3QgYmUgYW4gYXJyYXkgb2YgY29tcG9uZW50cycpO1xuXG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKHR5cGVvZiBjID09ICdvYmplY3QnKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50IGlzIGFuIGluc2VydCBvciBhIGRlbGV0ZS5cbiAgICAgIGlmIChjLmkgIT09IHVuZGVmaW5lZCkgeyAvLyBJbnNlcnQuXG4gICAgICAgIGlmICghKCh0eXBlb2YgYy5pID09PSAnc3RyaW5nJyAmJiBjLmkubGVuZ3RoID4gMCkgLy8gU3RyaW5nIGluc2VydHNcbiAgICAgICAgICAgICAgfHwgKHR5cGVvZiBjLmkgPT09ICdudW1iZXInICYmIGMuaSA+IDApKSkgLy8gVG9tYnN0b25lIGluc2VydHNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc2VydHMgbXVzdCBpbnNlcnQgYSBzdHJpbmcgb3IgYSAraXZlIG51bWJlcicpO1xuXG4gICAgICB9IGVsc2UgaWYgKGMuZCAhPT0gdW5kZWZpbmVkKSB7IC8vIERlbGV0ZVxuICAgICAgICBpZiAoISh0eXBlb2YgYy5kID09PSAnbnVtYmVyJyAmJiBjLmQgPiAwKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZXMgbXVzdCBiZSBhICtpdmUgbnVtYmVyJyk7XG5cbiAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBjb21wb25lbnQgbXVzdCBkZWZpbmUgLmkgb3IgLmQnKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50IG11c3QgYmUgYSBza2lwLlxuICAgICAgaWYgKHR5cGVvZiBjICE9ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ09wIGNvbXBvbmVudHMgbXVzdCBiZSBvYmplY3RzIG9yIG51bWJlcnMnKTtcblxuICAgICAgaWYgKGMgPD0gMCkgdGhyb3cgbmV3IEVycm9yKCdTa2lwIGNvbXBvbmVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdBZGphY2VudCBza2lwIGNvbXBvbmVudHMgc2hvdWxkIGJlIGNvbWJpbmVkJyk7XG4gICAgfVxuXG4gICAgbGFzdCA9IGM7XG4gIH1cbn07XG5cbi8vIFRha2UgdGhlIG5leHQgcGFydCBmcm9tIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gYSBkb2N1bWVudCBzbmFwc2hvdC5cbi8vIHBvc2l0aW9uID0ge2luZGV4LCBvZmZzZXR9LiBJdCB3aWxsIGJlIHVwZGF0ZWQuXG52YXIgdGFrZURvYyA9IHR5cGUuX3Rha2VEb2MgPSBmdW5jdGlvbihkb2MsIHBvc2l0aW9uLCBtYXhsZW5ndGgsIHRvbWJzSW5kaXZpc2libGUpIHtcbiAgaWYgKHBvc2l0aW9uLmluZGV4ID49IGRvYy5kYXRhLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBnb2VzIHBhc3QgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQnKTtcblxuICB2YXIgcGFydCA9IGRvYy5kYXRhW3Bvc2l0aW9uLmluZGV4XTtcblxuICAvLyBUaGlzIGNhbiBiZSB3cml0dGVuIGFzIGFuIHVnbHktYXJzZWQgZ2lhbnQgdGVybmFyeSBzdGF0ZW1lbnQsIGJ1dCBpdHMgbXVjaFxuICAvLyBtb3JlIHJlYWRhYmxlIGxpa2UgdGhpcy4gVWdsaWZ5IHdpbGwgY29udmVydCBpdCBpbnRvIHNhaWQgdGVybmFyeSBhbnl3YXkuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh0eXBlb2YgcGFydCA9PSAnc3RyaW5nJykge1xuICAgIGlmIChtYXhsZW5ndGggIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGFydC5zbGljZShwb3NpdGlvbi5vZmZzZXQsIHBvc2l0aW9uLm9mZnNldCArIG1heGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHBhcnQuc2xpY2UocG9zaXRpb24ub2Zmc2V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1heGxlbmd0aCA9PSBudWxsIHx8IHRvbWJzSW5kaXZpc2libGUpIHtcbiAgICAgIHJlc3VsdCA9IHBhcnQgLSBwb3NpdGlvbi5vZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IE1hdGgubWluKG1heGxlbmd0aCwgcGFydCAtIHBvc2l0aW9uLm9mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdExlbiA9IHJlc3VsdC5sZW5ndGggfHwgcmVzdWx0O1xuXG4gIGlmICgocGFydC5sZW5ndGggfHwgcGFydCkgLSBwb3NpdGlvbi5vZmZzZXQgPiByZXN1bHRMZW4pIHtcbiAgICBwb3NpdGlvbi5vZmZzZXQgKz0gcmVzdWx0TGVuO1xuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uLmluZGV4Kys7XG4gICAgcG9zaXRpb24ub2Zmc2V0ID0gMDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBBcHBlbmQgYSBwYXJ0IHRvIHRoZSBlbmQgb2YgYSBkb2N1bWVudFxudmFyIGFwcGVuZERvYyA9IHR5cGUuX2FwcGVuZERvYyA9IGZ1bmN0aW9uKGRvYywgcCkge1xuICBpZiAocCA9PT0gMCB8fCBwID09PSAnJykgcmV0dXJuO1xuXG4gIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICBkb2MuY2hhckxlbmd0aCArPSBwLmxlbmd0aDtcbiAgICBkb2MudG90YWxMZW5ndGggKz0gcC5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgZG9jLnRvdGFsTGVuZ3RoICs9IHA7XG4gIH1cblxuICB2YXIgZGF0YSA9IGRvYy5kYXRhO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICBkYXRhLnB1c2gocCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gdHlwZW9mIHApIHtcbiAgICBkYXRhW2RhdGEubGVuZ3RoIC0gMV0gKz0gcDtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnB1c2gocCk7XG4gIH1cbn07XG5cbi8vIEFwcGx5IHRoZSBvcCB0byB0aGUgZG9jdW1lbnQuIFRoZSBkb2N1bWVudCBpcyBub3QgbW9kaWZpZWQgaW4gdGhlIHByb2Nlc3MuXG50eXBlLmFwcGx5ID0gZnVuY3Rpb24oZG9jLCBvcCkge1xuICBpZiAoZG9jLnRvdGFsTGVuZ3RoID09IG51bGwgfHwgZG9jLmNoYXJMZW5ndGggPT0gbnVsbCB8fCAhaXNBcnJheShkb2MuZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NuYXBzaG90IGlzIGludmFsaWQnKTtcbiAgfVxuICBjaGVja09wKG9wKTtcblxuICB2YXIgbmV3RG9jID0gdHlwZS5jcmVhdGUoKTtcbiAgdmFyIHBvc2l0aW9uID0ge2luZGV4OiAwLCBvZmZzZXQ6IDB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XG4gICAgdmFyIHJlbWFpbmRlciwgcGFydDtcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09ICdudW1iZXInKSB7IC8vIFNraXBcbiAgICAgIHJlbWFpbmRlciA9IGNvbXBvbmVudDtcbiAgICAgIHdoaWxlIChyZW1haW5kZXIgPiAwKSB7XG4gICAgICAgIHBhcnQgPSB0YWtlRG9jKGRvYywgcG9zaXRpb24sIHJlbWFpbmRlcik7XG4gICAgICAgIGFwcGVuZERvYyhuZXdEb2MsIHBhcnQpO1xuICAgICAgICByZW1haW5kZXIgLT0gcGFydC5sZW5ndGggfHwgcGFydDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmkgIT09IHVuZGVmaW5lZCkgeyAvLyBJbnNlcnRcbiAgICAgIGFwcGVuZERvYyhuZXdEb2MsIGNvbXBvbmVudC5pKTtcblxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmQgIT09IHVuZGVmaW5lZCkgeyAvLyBEZWxldGVcbiAgICAgIHJlbWFpbmRlciA9IGNvbXBvbmVudC5kO1xuICAgICAgd2hpbGUgKHJlbWFpbmRlciA+IDApIHtcbiAgICAgICAgcGFydCA9IHRha2VEb2MoZG9jLCBwb3NpdGlvbiwgcmVtYWluZGVyKTtcbiAgICAgICAgcmVtYWluZGVyIC09IHBhcnQubGVuZ3RoIHx8IHBhcnQ7XG4gICAgICB9XG4gICAgICBhcHBlbmREb2MobmV3RG9jLCBjb21wb25lbnQuZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdEb2M7XG59O1xuXG4vLyBBcHBlbmQgYW4gb3AgY29tcG9uZW50IHRvIHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBvcC4gIEV4cG9ydGVkIGZvciB0aGVcbi8vIHJhbmRvbU9wR2VuZXJhdG9yLlxudmFyIGFwcGVuZCA9IHR5cGUuX2FwcGVuZCA9IGZ1bmN0aW9uKG9wLCBjb21wb25lbnQpIHtcbiAgdmFyIGxhc3Q7XG5cbiAgaWYgKGNvbXBvbmVudCA9PT0gMCB8fCBjb21wb25lbnQuaSA9PT0gJycgfHwgY29tcG9uZW50LmkgPT09IDAgfHwgY29tcG9uZW50LmQgPT09IDApIHtcbiAgICAvLyBEcm9wIHRoZSBuZXcgY29tcG9uZW50LlxuICB9IGVsc2UgaWYgKG9wLmxlbmd0aCA9PT0gMCkge1xuICAgIG9wLnB1c2goY29tcG9uZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0ID0gb3Bbb3AubGVuZ3RoIC0gMV07XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhc3QgPT0gJ251bWJlcicpIHtcbiAgICAgIG9wW29wLmxlbmd0aCAtIDFdICs9IGNvbXBvbmVudDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5pICE9IG51bGwgJiYgKGxhc3QuaSAhPSBudWxsKSAmJiB0eXBlb2YgbGFzdC5pID09PSB0eXBlb2YgY29tcG9uZW50LmkpIHtcbiAgICAgIGxhc3QuaSArPSBjb21wb25lbnQuaTtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5kICE9IG51bGwgJiYgKGxhc3QuZCAhPSBudWxsKSkge1xuICAgICAgbGFzdC5kICs9IGNvbXBvbmVudC5kO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBNYWtlcyAyIGZ1bmN0aW9ucyBmb3IgdGFraW5nIGNvbXBvbmVudHMgZnJvbSB0aGUgc3RhcnQgb2YgYW4gb3AsIGFuZCBmb3Jcbi8vIHBlZWtpbmcgYXQgdGhlIG5leHQgb3AgdGhhdCBjb3VsZCBiZSB0YWtlbi5cbnZhciBtYWtlVGFrZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIC8vIFRoZSBpbmRleCBvZiB0aGUgbmV4dCBjb21wb25lbnQgdG8gdGFrZVxuICB2YXIgaW5kZXggPSAwO1xuICAvLyBUaGUgb2Zmc2V0IGludG8gdGhlIGNvbXBvbmVudFxuICB2YXIgb2Zmc2V0ID0gMDtcblxuICB2YXIgdGFrZSA9IGZ1bmN0aW9uKG1heGxlbmd0aCwgaW5zZXJ0c0luZGl2aXNpYmxlKSB7XG4gICAgaWYgKGluZGV4ID09PSBvcC5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIHZhciBlID0gb3BbaW5kZXhdO1xuICAgIHZhciBjdXJyZW50O1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBpZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgc2tpcCwgYW4gaW5zZXJ0IG9mIGEgbnVtYmVyIG9yIGEgZGVsZXRlXG4gICAgaWYgKHR5cGVvZiAoY3VycmVudCA9IGUpID09ICdudW1iZXInIHx8IHR5cGVvZiAoY3VycmVudCA9IGUuaSkgPT0gJ251bWJlcicgfHwgKGN1cnJlbnQgPSBlLmQpICE9IG51bGwpIHtcbiAgICAgIHZhciBjO1xuICAgICAgaWYgKChtYXhsZW5ndGggPT0gbnVsbCkgfHwgY3VycmVudCAtIG9mZnNldCA8PSBtYXhsZW5ndGggfHwgKGluc2VydHNJbmRpdmlzaWJsZSAmJiBlLmkgIT0gbnVsbCkpIHtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN0IG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuXG4gICAgICAgIGMgPSBjdXJyZW50IC0gb2Zmc2V0O1xuICAgICAgICArK2luZGV4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ICs9IG1heGxlbmd0aDtcbiAgICAgICAgYyA9IG1heGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFja2FnZSB0aGUgY29tcG9uZW50IGJhY2sgdXAuXG4gICAgICBpZiAoZS5pICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtpOiBjfTtcbiAgICAgIH0gZWxzZSBpZiAoZS5kICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtkOiBjfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIEluc2VydCBvZiBhIHN0cmluZy5cbiAgICAgIGlmICgobWF4bGVuZ3RoID09IG51bGwpIHx8IGUuaS5sZW5ndGggLSBvZmZzZXQgPD0gbWF4bGVuZ3RoIHx8IGluc2VydHNJbmRpdmlzaWJsZSkge1xuICAgICAgICByZXN1bHQgPSB7aTogZS5pLnNsaWNlKG9mZnNldCl9O1xuICAgICAgICArK2luZGV4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge2k6IGUuaS5zbGljZShvZmZzZXQsIG9mZnNldCArIG1heGxlbmd0aCl9O1xuICAgICAgICBvZmZzZXQgKz0gbWF4bGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlZWtUeXBlID0gZnVuY3Rpb24oKSB7cmV0dXJuIG9wW2luZGV4XTt9O1xuICByZXR1cm4gW3Rha2UsIHBlZWtUeXBlXTtcbn07XG5cbi8vIEZpbmQgYW5kIHJldHVybiB0aGUgbGVuZ3RoIG9mIGFuIG9wIGNvbXBvbmVudFxudmFyIGNvbXBvbmVudExlbmd0aCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb21wb25lbnQuaSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LmkubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb21wb25lbnQuZCB8fCBjb21wb25lbnQuaTtcbiAgfVxufTtcblxuLy8gTm9ybWFsaXplIGFuIG9wLCByZW1vdmluZyBhbGwgZW1wdHkgc2tpcHMgYW5kIGVtcHR5IGluc2VydHMgLyBkZWxldGVzLlxuLy8gQ29uY2F0ZW5hdGUgYWRqYWNlbnQgaW5zZXJ0cyBhbmQgZGVsZXRlcy5cbnR5cGUubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmQobmV3T3AsIG9wW2ldKTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyBUaGlzIGlzIGEgaGVscGVyIG1ldGhvZCB0byB0cmFuc2Zvcm0gYW5kIHBydW5lLiBnb0ZvcndhcmRzIGlzIHRydWUgZm9yIHRyYW5zZm9ybSwgZmFsc2UgZm9yIHBydW5lLlxudmFyIHRyYW5zZm9ybWVyID0gZnVuY3Rpb24ob3AsIG90aGVyT3AsIGdvRm9yd2FyZHMsIHNpZGUpIHtcbiAgY2hlY2tPcChvcCk7XG4gIGNoZWNrT3Aob3RoZXJPcCk7XG5cbiAgdmFyIG5ld09wID0gW107XG5cbiAgdmFyIGZucyA9IG1ha2VUYWtlKG9wKSxcbiAgICAgIHRha2UgPSBmbnNbMF0sXG4gICAgICBwZWVrID0gZm5zWzFdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJPcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvdGhlck9wW2ldO1xuICAgIHZhciBsZW4gPSBjb21wb25lbnRMZW5ndGgoY29tcG9uZW50KTtcbiAgICB2YXIgY2h1bms7XG5cbiAgICBpZiAoY29tcG9uZW50LmkgIT0gbnVsbCkgeyAvLyBJbnNlcnQgdGV4dCBvciB0b21ic1xuICAgICAgaWYgKGdvRm9yd2FyZHMpIHsgLy8gVHJhbnNmb3JtIC0gaW5zZXJ0IHNraXBzIG92ZXIgZGVsZXRlZCBwYXJ0cy5cbiAgICAgICAgaWYgKHNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIC8vIFRoZSBsZWZ0IHNpZGUgaW5zZXJ0IHNob3VsZCBnbyBmaXJzdC5cbiAgICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgICB3aGlsZSAoKG5leHQgPSBwZWVrKCkpICYmIG5leHQuaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcHBlbmQobmV3T3AsIHRha2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIGFueSBjYXNlLCBza2lwIHRoZSBpbnNlcnRlZCB0ZXh0LlxuICAgICAgICBhcHBlbmQobmV3T3AsIGxlbik7XG5cbiAgICAgIH0gZWxzZSB7IC8vIFBydW5lLiBSZW1vdmUgc2tpcHMgZm9yIGluc2VydHMuXG4gICAgICAgIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgICAgICAgY2h1bmsgPSB0YWtlKGxlbiwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBUaGUgY2h1bmsgd2lsbCBiZSBudWxsIGlmIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyBpbiB0aGUgb3RoZXIgb3AuXG4gICAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0cmFuc2Zvcm1lZCBvcCBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgaWYgKGNodW5rLmQgIT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVkIG9wIGRlbGV0ZXMgbG9jYWxseSBpbnNlcnRlZCBjaGFyYWN0ZXJzIC0gaXQgY2Fubm90IGJlIHB1cmdlZCBvZiB0aGUgaW5zZXJ0LicpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGxlbiAtPSBjaHVuaztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcHBlbmQobmV3T3AsIGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIFNraXBzIG9yIGRlbGV0ZXMuXG4gICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICBjaHVuayA9IHRha2UobGVuLCB0cnVlKTtcbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBvcCB0cmF2ZXJzZXMgbW9yZSBlbGVtZW50cyB0aGFuIHRoZSBkb2N1bWVudCBoYXMnKTtcblxuICAgICAgICBhcHBlbmQobmV3T3AsIGNodW5rKTtcbiAgICAgICAgaWYgKCFjaHVuay5pKSBsZW4gLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBcHBlbmQgZXh0cmFzIGZyb20gb3AxLlxuICB2YXIgY29tcG9uZW50O1xuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoKSkpIHtcbiAgICBpZiAoY29tcG9uZW50LmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVtYWluaW5nIGZyYWdtZW50cyBpbiB0aGUgb3A6IFwiICsgY29tcG9uZW50KTtcbiAgICB9XG4gICAgYXBwZW5kKG5ld09wLCBjb21wb25lbnQpO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIHRyYW5zZm9ybSBvcDEgYnkgb3AyLiBSZXR1cm4gdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiBvcDEuIG9wMSBhbmQgb3AyIGFyZVxuLy8gdW5jaGFuZ2VkIGJ5IHRyYW5zZm9ybS4gU2lkZSBzaG91bGQgYmUgJ2xlZnQnIG9yICdyaWdodCcsIGRlcGVuZGluZyBvbiBpZlxuLy8gb3AxLmlkIDw+IG9wMi5pZC5cbi8vXG4vLyAnbGVmdCcgPT0gY2xpZW50IG9wIGZvciBTaGFyZUpTLlxudHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgc2lkZSkge1xuICBpZiAoc2lkZSAhPSAnbGVmdCcgJiYgc2lkZSAhPSAncmlnaHQnKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZGUgKFwiICsgc2lkZSArIFwiKSBzaG91bGQgYmUgJ2xlZnQnIG9yICdyaWdodCdcIik7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybWVyKG9wLCBvdGhlck9wLCB0cnVlLCBzaWRlKTtcbn07XG5cbnR5cGUucHJ1bmUgPSBmdW5jdGlvbihvcCwgb3RoZXJPcCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIob3AsIG90aGVyT3AsIGZhbHNlKTtcbn07XG5cbnR5cGUuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIC8vdmFyIGNodW5rLCBjaHVua0xlbmd0aCwgY29tcG9uZW50LCBsZW5ndGgsIHJlc3VsdCwgdGFrZSwgXywgX2ksIF9sZW4sIF9yZWY7XG4gIGlmIChvcDEgPT0gbnVsbCkgcmV0dXJuIG9wMjtcblxuICBjaGVja09wKG9wMSk7XG4gIGNoZWNrT3Aob3AyKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0YWtlID0gbWFrZVRha2Uob3AxKVswXTtcbiAgdmFyIGNvbXBvbmVudDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wMi5sZW5ndGg7IGkrKykge1xuICAgIGNvbXBvbmVudCA9IG9wMltpXTtcbiAgICB2YXIgbGVuLCBjaHVuaztcblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnbnVtYmVyJykgeyAvLyBTa2lwXG4gICAgICAvLyBKdXN0IGNvcHkgZnJvbSBvcDEuXG4gICAgICBsZW4gPSBjb21wb25lbnQ7XG4gICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICBjaHVuayA9IHRha2UobGVuKTtcbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG9wIHRyYXZlcnNlcyBtb3JlIGVsZW1lbnRzIHRoYW4gdGhlIGRvY3VtZW50IGhhcycpO1xuXG4gICAgICAgIGFwcGVuZChyZXN1bHQsIGNodW5rKTtcbiAgICAgICAgbGVuIC09IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudC5pICE9PSB1bmRlZmluZWQpIHsgLy8gSW5zZXJ0XG4gICAgICBhcHBlbmQocmVzdWx0LCB7aTogY29tcG9uZW50Lml9KTtcblxuICAgIH0gZWxzZSB7IC8vIERlbGV0ZVxuICAgICAgbGVuID0gY29tcG9uZW50LmQ7XG4gICAgICB3aGlsZSAobGVuID4gMCkge1xuICAgICAgICBjaHVuayA9IHRha2UobGVuKTtcbiAgICAgICAgaWYgKGNodW5rID09PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG9wIHRyYXZlcnNlcyBtb3JlIGVsZW1lbnRzIHRoYW4gdGhlIGRvY3VtZW50IGhhcycpO1xuXG4gICAgICAgIHZhciBjaHVua0xlbmd0aCA9IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG5cbiAgICAgICAgaWYgKGNodW5rLmkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICBhcHBlbmQocmVzdWx0LCB7aTogY2h1bmtMZW5ndGh9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFwcGVuZChyZXN1bHQsIHtkOiBjaHVua0xlbmd0aH0pO1xuXG4gICAgICAgIGxlbiAtPSBjaHVua0xlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBcHBlbmQgZXh0cmFzIGZyb20gb3AxLlxuICB3aGlsZSAoKGNvbXBvbmVudCA9IHRha2UoKSkpIHtcbiAgICBpZiAoY29tcG9uZW50LmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVtYWluaW5nIGZyYWdtZW50cyBpbiBvcDE6IFwiICsgY29tcG9uZW50KTtcbiAgICB9XG4gICAgYXBwZW5kKHJlc3VsdCwgY29tcG9uZW50KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG59KSgpIiwiLypcbiBUaGlzIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSlNPTiBPVCB0eXBlLlxuXG4gU3BlYyBpcyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvSlNPTi1PcGVyYXRpb25zXG5cbiBOb3RlOiBUaGlzIGlzIGJlaW5nIG1hZGUgb2Jzb2xldGUuIEl0IHdpbGwgc29vbiBiZSByZXBsYWNlZCBieSB0aGUgSlNPTjIgdHlwZS5cbiovXG5cbi8qKlxuICogVVRJTElUWSBGVU5DVElPTlNcbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbiBBcnJheSBpbnN0YW5jZS4gQ2FuJ3QgdXNlIEFycmF5LmlzQXJyYXlcbiAqIHlldCBiZWNhdXNlIGl0cyBub3Qgc3VwcG9ydGVkIG9uIElFOC5cbiAqXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIENsb25lcyB0aGUgcGFzc2VkIG9iamVjdCB1c2luZyBKU09OIHNlcmlhbGl6YXRpb24gKHdoaWNoIGlzIHNsb3cpLlxuICpcbiAqIGhheCwgY29waWVkIGZyb20gdGVzdC90eXBlcy9qc29uLiBBcHBhcmVudGx5IHRoaXMgaXMgc3RpbGwgdGhlIGZhc3Rlc3Qgd2F5XG4gKiB0byBkZWVwIGNsb25lIGFuIG9iamVjdCwgYXNzdW1pbmcgd2UgaGF2ZSBicm93c2VyIHN1cHBvcnQgZm9yIEpTT04uICBAc2VlXG4gKiBodHRwOi8vanNwZXJmLmNvbS9jbG9uaW5nLWFuLW9iamVjdC8xMlxuICovXG52YXIgY2xvbmUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcbn07XG5cblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgVGV4dCBPVCB0eXBlLiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBKU09OIFN0cmluZyBvcGVyYXRpb25zLlxuICogQHR5cGUgeyp9XG4gKi9cbnZhciB0ZXh0ID0gdHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1aXJlKCcuL3RleHQtb2xkJykgOiB3aW5kb3cub3R0eXBlcy50ZXh0O1xuXG5cblxuLyoqXG4gKiBKU09OIE9UIFR5cGVcbiAqIEB0eXBlIHsqfVxuICovXG52YXIganNvbiA9IHsgXG4gIG5hbWU6ICdqc29uMCcsXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy9KU09OdjAnXG59O1xuXG5qc29uLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gTnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCBpZiB5b3UgZG9uJ3QgcGFzcyBhbiBhcmd1bWVudC5cbiAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkYXRhO1xufTtcblxuanNvbi5pbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciBjXyA9IHtwOiBjLnB9O1xuXG4gIGlmIChjLnNpICE9PSB2b2lkIDApIGNfLnNkID0gYy5zaTtcbiAgaWYgKGMuc2QgIT09IHZvaWQgMCkgY18uc2kgPSBjLnNkO1xuICBpZiAoYy5vaSAhPT0gdm9pZCAwKSBjXy5vZCA9IGMub2k7XG4gIGlmIChjLm9kICE9PSB2b2lkIDApIGNfLm9pID0gYy5vZDtcbiAgaWYgKGMubGkgIT09IHZvaWQgMCkgY18ubGQgPSBjLmxpO1xuICBpZiAoYy5sZCAhPT0gdm9pZCAwKSBjXy5saSA9IGMubGQ7XG4gIGlmIChjLm5hICE9PSB2b2lkIDApIGNfLm5hID0gLWMubmE7XG5cbiAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgIGNfLmxtID0gYy5wW2MucC5sZW5ndGgtMV07XG4gICAgY18ucCA9IGMucC5zbGljZSgwLGMucC5sZW5ndGgtMSkuY29uY2F0KFtjLmxtXSk7XG4gIH1cblxuICByZXR1cm4gY187XG59O1xuXG5qc29uLmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBvcF8gPSBvcC5zbGljZSgpLnJldmVyc2UoKTtcbiAgdmFyIGlvcCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wXy5sZW5ndGg7IGkrKykge1xuICAgIGlvcC5wdXNoKGpzb24uaW52ZXJ0Q29tcG9uZW50KG9wX1tpXSkpO1xuICB9XG4gIHJldHVybiBpb3A7XG59O1xuXG5qc29uLmNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgaWYgKCFpc0FycmF5KG9wW2ldLnApKVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwYXRoJyk7XG4gIH1cbn07XG5cbmpzb24uY2hlY2tMaXN0ID0gZnVuY3Rpb24oZWxlbSkge1xuICBpZiAoIWlzQXJyYXkoZWxlbSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgbGlzdCcpO1xufTtcblxuanNvbi5jaGVja09iaiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgaWYgKGVsZW0uY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlZmVyZW5jZWQgZWxlbWVudCBub3QgYW4gb2JqZWN0IChpdCB3YXMgXCIgKyBKU09OLnN0cmluZ2lmeShlbGVtKSArIFwiKVwiKTtcbiAgfVxufTtcblxuanNvbi5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICBqc29uLmNoZWNrVmFsaWRPcChvcCk7XG5cbiAgb3AgPSBjbG9uZShvcCk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IHtcbiAgICBkYXRhOiBzbmFwc2hvdFxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuXG4gICAgdmFyIHBhcmVudCA9IG51bGw7XG4gICAgdmFyIHBhcmVudEtleSA9IG51bGw7XG4gICAgdmFyIGVsZW0gPSBjb250YWluZXI7XG4gICAgdmFyIGtleSA9ICdkYXRhJztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5wLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IGMucFtqXTtcblxuICAgICAgcGFyZW50ID0gZWxlbTtcbiAgICAgIHBhcmVudEtleSA9IGtleTtcbiAgICAgIGVsZW0gPSBlbGVtW2tleV07XG4gICAgICBrZXkgPSBwO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gTnVtYmVyIGFkZFxuICAgIGlmIChjLm5hICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbVtrZXldICE9ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBudW1iZXInKTtcblxuICAgICAgZWxlbVtrZXldICs9IGMubmE7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nIGluc2VydFxuICAgIGVsc2UgaWYgKGMuc2kgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtICE9ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBzdHJpbmcgKGl0IHdhcyAnK0pTT04uc3RyaW5naWZ5KGVsZW0pKycpJyk7XG5cbiAgICAgIHBhcmVudFtwYXJlbnRLZXldID0gZWxlbS5zbGljZSgwLGtleSkgKyBjLnNpICsgZWxlbS5zbGljZShrZXkpO1xuICAgIH1cblxuICAgIC8vIFN0cmluZyBkZWxldGVcbiAgICBlbHNlIGlmIChjLnNkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGEgc3RyaW5nJyk7XG5cbiAgICAgIGlmIChlbGVtLnNsaWNlKGtleSxrZXkgKyBjLnNkLmxlbmd0aCkgIT09IGMuc2QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlZCBzdHJpbmcgZG9lcyBub3QgbWF0Y2gnKTtcblxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGVsZW0uc2xpY2Uoa2V5ICsgYy5zZC5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8vIExpc3QgcmVwbGFjZVxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkXG4gICAgICBlbGVtW2tleV0gPSBjLmxpO1xuICAgIH1cblxuICAgIC8vIExpc3QgaW5zZXJ0XG4gICAgZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIGVsZW0uc3BsaWNlKGtleSwwLCBjLmxpKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhlIGxpc3QgZWxlbWVudCBtYXRjaGVzIGMubGQgaGVyZSB0b28uXG4gICAgICBlbGVtLnNwbGljZShrZXksMSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBtb3ZlXG4gICAgZWxzZSBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIGlmIChjLmxtICE9IGtleSkge1xuICAgICAgICB2YXIgZSA9IGVsZW1ba2V5XTtcbiAgICAgICAgLy8gUmVtb3ZlIGl0Li4uXG4gICAgICAgIGVsZW0uc3BsaWNlKGtleSwxKTtcbiAgICAgICAgLy8gQW5kIGluc2VydCBpdCBiYWNrLlxuICAgICAgICBlbGVtLnNwbGljZShjLmxtLDAsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGluc2VydCAvIHJlcGxhY2VcbiAgICBlbHNlIGlmIChjLm9pICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tPYmooZWxlbSk7XG5cbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGF0IGVsZW1ba2V5XSA9PSBjLm9kXG4gICAgICBlbGVtW2tleV0gPSBjLm9pO1xuICAgIH1cblxuICAgIC8vIE9iamVjdCBkZWxldGVcbiAgICBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tPYmooZWxlbSk7XG5cbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGF0IGVsZW1ba2V5XSA9PSBjLm9kXG4gICAgICBkZWxldGUgZWxlbVtrZXldO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIC8gbWlzc2luZyBpbnN0cnVjdGlvbiBpbiBvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250YWluZXIuZGF0YTtcbn07XG5cbi8vIEhlbHBlciBmb3IgaW5jcmVtZW50YWxseSBhcHBseWluZyBhbiBvcGVyYXRpb24gdG8gYSBzbmFwc2hvdC4gQ2FsbHMgeWllbGRcbi8vIGFmdGVyIGVhY2ggb3AgY29tcG9uZW50IGhhcyBiZWVuIGFwcGxpZWQuXG5qc29uLmluY3JlbWVudGFsQXBwbHkgPSBmdW5jdGlvbihzbmFwc2hvdCwgb3AsIF95aWVsZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNtYWxsT3AgPSBbb3BbaV1dO1xuICAgIHNuYXBzaG90ID0ganNvbi5hcHBseShzbmFwc2hvdCwgc21hbGxPcCk7XG4gICAgLy8gSSdkIGp1c3QgY2FsbCB0aGlzIHlpZWxkLCBidXQgdGhhdHMgYSByZXNlcnZlZCBrZXl3b3JkLiBCYWghXG4gICAgX3lpZWxkKHNtYWxsT3AsIHNuYXBzaG90KTtcbiAgfVxuICBcbiAgcmV0dXJuIHNuYXBzaG90O1xufTtcblxuLy8gQ2hlY2tzIGlmIHR3byBwYXRocywgcDEgYW5kIHAyIG1hdGNoLlxudmFyIHBhdGhNYXRjaGVzID0ganNvbi5wYXRoTWF0Y2hlcyA9IGZ1bmN0aW9uKHAxLCBwMiwgaWdub3JlTGFzdCkge1xuICBpZiAocDEubGVuZ3RoICE9IHAyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwMVtpXSAhPT0gcDJbaV0gJiYgKCFpZ25vcmVMYXN0IHx8IGkgIT09IHAxLmxlbmd0aCAtIDEpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2NvbnZlcnRUb1RleHRDb21wb25lbnQgPSBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgdmFyIG5ld0MgPSB7cDogY29tcG9uZW50LnBbY29tcG9uZW50LnAubGVuZ3RoIC0gMV19O1xuICBpZiAoY29tcG9uZW50LnNpICE9IG51bGwpIHtcbiAgICBuZXdDLmkgPSBjb21wb25lbnQuc2k7XG4gIH0gZWxzZSB7XG4gICAgbmV3Qy5kID0gY29tcG9uZW50LnNkO1xuICB9XG4gIHJldHVybiBuZXdDO1xufTtcblxuanNvbi5hcHBlbmQgPSBmdW5jdGlvbihkZXN0LGMpIHtcbiAgYyA9IGNsb25lKGMpO1xuXG4gIHZhciBsYXN0O1xuXG4gIGlmIChkZXN0Lmxlbmd0aCAhPSAwICYmIHBhdGhNYXRjaGVzKGMucCwgKGxhc3QgPSBkZXN0W2Rlc3QubGVuZ3RoIC0gMV0pLnApKSB7XG4gICAgaWYgKGxhc3QubmEgIT0gbnVsbCAmJiBjLm5hICE9IG51bGwpIHtcbiAgICAgIGRlc3RbZGVzdC5sZW5ndGggLSAxXSA9IHtwOiBsYXN0LnAsIG5hOiBsYXN0Lm5hICsgYy5uYX07XG4gICAgfSBlbHNlIGlmIChsYXN0LmxpICE9PSB1bmRlZmluZWQgJiYgYy5saSA9PT0gdW5kZWZpbmVkICYmIGMubGQgPT09IGxhc3QubGkpIHtcbiAgICAgIC8vIGluc2VydCBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBkZWxldGUgYmVjb21lcyBhIG5vb3AuXG4gICAgICBpZiAobGFzdC5sZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGxlYXZlIHRoZSBkZWxldGUgcGFydCBvZiB0aGUgcmVwbGFjZVxuICAgICAgICBkZWxldGUgbGFzdC5saTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQgJiYgbGFzdC5vaSA9PT0gdW5kZWZpbmVkICYmIGMub2kgIT09IHVuZGVmaW5lZCAmJiBjLm9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxhc3Qub2kgPSBjLm9pO1xuICAgIH0gZWxzZSBpZiAobGFzdC5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhlIGxhc3QgcGF0aCBjb21wb25lbnQgaW5zZXJ0ZWQgc29tZXRoaW5nIHRoYXQgdGhlIG5ldyBjb21wb25lbnQgZGVsZXRlcyAob3IgcmVwbGFjZXMpLlxuICAgICAgLy8gSnVzdCBtZXJnZSB0aGVtLlxuICAgICAgaWYgKGMub2kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsYXN0Lm9pID0gYy5vaTtcbiAgICAgIH0gZWxzZSBpZiAobGFzdC5vZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBsYXN0Lm9pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gaW5zZXJ0IGRpcmVjdGx5IGZvbGxvd2VkIGJ5IGEgZGVsZXRlIHR1cm5zIGludG8gYSBuby1vcCBhbmQgY2FuIGJlIHJlbW92ZWQuXG4gICAgICAgIGRlc3QucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjLmxtICE9PSB1bmRlZmluZWQgJiYgYy5wW2MucC5sZW5ndGggLSAxXSA9PT0gYy5sbSkge1xuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdC5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZXN0Lmxlbmd0aCAhPSAwICYmIHBhdGhNYXRjaGVzKGMucCwgbGFzdC5wLCB0cnVlKSkge1xuICAgIGlmICgoYy5zaSAhPSBudWxsIHx8IGMuc2QgIT0gbnVsbCkgJiYgKGxhc3Quc2kgIT0gbnVsbCB8fCBsYXN0LnNkICE9IG51bGwpKSB7XG4gICAgICAvLyBUcnkgdG8gY29tcG9zZSB0aGUgc3RyaW5nIG9wcyB0b2dldGhlciB1c2luZyB0ZXh0J3MgZXF1aXZhbGVudCBtZXRob2RzXG4gICAgICB2YXIgdGV4dE9wID0gW19jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGxhc3QpXTtcbiAgICAgIHRleHQuX2FwcGVuZCh0ZXh0T3AsIF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KGMpKTtcbiAgICAgIFxuICAgICAgLy8gVGhlbiBjb252ZXJ0IGJhY2suXG4gICAgICBpZiAodGV4dE9wLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICBkZXN0LnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGV4dEMgPSB0ZXh0T3BbMF07XG4gICAgICAgIGxhc3QucFtsYXN0LnAubGVuZ3RoIC0gMV0gPSB0ZXh0Qy5wO1xuICAgICAgICBpZiAodGV4dEMuaSAhPSBudWxsKVxuICAgICAgICAgIGxhc3Quc2kgPSB0ZXh0Qy5pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGFzdC5zZCA9IHRleHRDLmQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3QucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVzdC5wdXNoKGMpO1xuICB9XG59O1xuXG5qc29uLmNvbXBvc2UgPSBmdW5jdGlvbihvcDEsb3AyKSB7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wMSk7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wMik7XG5cbiAgdmFyIG5ld09wID0gY2xvbmUob3AxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wMi5sZW5ndGg7IGkrKykge1xuICAgIGpzb24uYXBwZW5kKG5ld09wLG9wMltpXSk7XG4gIH1cblxuICByZXR1cm4gbmV3T3A7XG59O1xuXG5qc29uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBuZXdPcCA9IFtdO1xuXG4gIG9wID0gaXNBcnJheShvcCkgPyBvcCA6IFtvcF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKGMucCA9PSBudWxsKSBjLnAgPSBbXTtcblxuICAgIGpzb24uYXBwZW5kKG5ld09wLGMpO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gUmV0dXJucyB0cnVlIGlmIGFuIG9wIGF0IG90aGVyUGF0aCBtYXkgYWZmZWN0IGFuIG9wIGF0IHBhdGhcbmpzb24uY2FuT3BBZmZlY3RPcCA9IGZ1bmN0aW9uKG90aGVyUGF0aCxwYXRoKSB7XG4gIGlmIChvdGhlclBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgcGF0aCA9IHBhdGguc2xpY2UoMCxwYXRoLmxlbmd0aCAtIDEpO1xuICBvdGhlclBhdGggPSBvdGhlclBhdGguc2xpY2UoMCxvdGhlclBhdGgubGVuZ3RoIC0gMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlclBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IG90aGVyUGF0aFtpXTtcbiAgICBpZiAoaSA+PSBwYXRoLmxlbmd0aCB8fCBwICE9IHBhdGhbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFNhbWVcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyB0cmFuc2Zvcm0gYyBzbyBpdCBhcHBsaWVzIHRvIGEgZG9jdW1lbnQgd2l0aCBvdGhlckMgYXBwbGllZC5cbmpzb24udHJhbnNmb3JtQ29tcG9uZW50ID0gZnVuY3Rpb24oZGVzdCwgYywgb3RoZXJDLCB0eXBlKSB7XG4gIGMgPSBjbG9uZShjKTtcblxuICBpZiAoYy5uYSAhPT0gdm9pZCAwKVxuICAgIGMucC5wdXNoKDApO1xuXG4gIGlmIChvdGhlckMubmEgIT09IHZvaWQgMClcbiAgICBvdGhlckMucC5wdXNoKDApO1xuXG4gIHZhciBjb21tb247XG4gIGlmIChqc29uLmNhbk9wQWZmZWN0T3Aob3RoZXJDLnAsIGMucCkpXG4gICAgY29tbW9uID0gb3RoZXJDLnAubGVuZ3RoIC0gMTtcblxuICB2YXIgY29tbW9uMjtcbiAgaWYgKGpzb24uY2FuT3BBZmZlY3RPcChjLnAsb3RoZXJDLnApKVxuICAgIGNvbW1vbjIgPSBjLnAubGVuZ3RoIC0gMTtcblxuICB2YXIgY3BsZW5ndGggPSBjLnAubGVuZ3RoO1xuICB2YXIgb3RoZXJDcGxlbmd0aCA9IG90aGVyQy5wLmxlbmd0aDtcblxuICBpZiAoYy5uYSAhPT0gdm9pZCAwKSAvLyBoYXhcbiAgICBjLnAucG9wKCk7XG5cbiAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKVxuICAgIG90aGVyQy5wLnBvcCgpO1xuXG4gIGlmIChvdGhlckMubmEpIHtcbiAgICBpZiAoY29tbW9uMiAhPSBudWxsICYmIG90aGVyQ3BsZW5ndGggPj0gY3BsZW5ndGggJiYgb3RoZXJDLnBbY29tbW9uMl0gPT0gYy5wW2NvbW1vbjJdKSB7XG4gICAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XG4gICAgICB9IGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICAgIGMub2QgPSBqc29uLmFwcGx5KGNsb25lKGMub2QpLFtvY10pO1xuICAgICAgfVxuICAgIH1cbiAgICBqc29uLmFwcGVuZChkZXN0LGMpO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLy8gaWYgYyBpcyBkZWxldGluZyBzb21ldGhpbmcsIGFuZCB0aGF0IHRoaW5nIGlzIGNoYW5nZWQgYnkgb3RoZXJDLCB3ZSBuZWVkIHRvXG4gIC8vIHVwZGF0ZSBjIHRvIHJlZmxlY3QgdGhhdCBjaGFuZ2UgZm9yIGludmVydGliaWxpdHkuXG4gIC8vIFRPRE8gdGhpcyBpcyBwcm9iYWJseSBub3QgbmVlZGVkIHNpbmNlIHdlIGRvbid0IGhhdmUgaW52ZXJ0aWJpbGl0eVxuICBpZiAoY29tbW9uMiAhPSBudWxsICYmIG90aGVyQ3BsZW5ndGggPiBjcGxlbmd0aCAmJiBjLnBbY29tbW9uMl0gPT0gb3RoZXJDLnBbY29tbW9uMl0pIHtcbiAgICBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgYy5sZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5sZCksW29jXSk7XG4gICAgfSBlbHNlIGlmIChjLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICBjLm9kID0ganNvbi5hcHBseShjbG9uZShjLm9kKSxbb2NdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tbW9uICE9IG51bGwpIHtcbiAgICB2YXIgY29tbW9uT3BlcmFuZCA9IGNwbGVuZ3RoID09IG90aGVyQ3BsZW5ndGg7XG5cbiAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gb3RoZXJDXG4gICAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKSB7XG4gICAgICAvLyB0aGlzIGNhc2UgaXMgaGFuZGxlZCBhYm92ZSBkdWUgdG8gaWNreSBwYXRoIGhheFxuICAgIH0gZWxzZSBpZiAob3RoZXJDLnNpICE9PSB2b2lkIDAgfHwgb3RoZXJDLnNkICE9PSB2b2lkIDApIHtcbiAgICAgIC8vIFN0cmluZyBvcCB2cyBzdHJpbmcgb3AgLSBwYXNzIHRocm91Z2ggdG8gdGV4dCB0eXBlXG4gICAgICBpZiAoYy5zaSAhPT0gdm9pZCAwIHx8IGMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBhIHN0cmluZz8nKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGFuIG9wIGNvbXBvbmVudCB0byBhIHRleHQgb3AgY29tcG9uZW50IHNvIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgIC8vIHRleHQgdHlwZSdzIHRyYW5zZm9ybSBmdW5jdGlvblxuICAgICAgICB2YXIgdGMxID0gX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYyk7XG4gICAgICAgIHZhciB0YzIgPSBfY29udmVydFRvVGV4dENvbXBvbmVudChvdGhlckMpO1xuXG4gICAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgICAvLyBhY3R1YWxseSB0cmFuc2Zvcm1cbiAgICAgICAgdGV4dC5fdGMocmVzLCB0YzEsIHRjMiwgdHlwZSk7XG4gICAgICAgIFxuICAgICAgICAvLyAuLi4uIHRoZW4gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgaW50byBhIEpTT04gb3AgYWdhaW4uXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gVGV4dCBjb21wb25lbnRcbiAgICAgICAgICB2YXIgdGMgPSByZXNbaV07XG4gICAgICAgICAgLy8gSlNPTiBjb21wb25lbnRcbiAgICAgICAgICB2YXIgamMgPSB7cDogYy5wLnNsaWNlKDAsIGNvbW1vbil9O1xuICAgICAgICAgIGpjLnAucHVzaCh0Yy5wKTtcblxuICAgICAgICAgIGlmICh0Yy5pICE9IG51bGwpIGpjLnNpID0gdGMuaTtcbiAgICAgICAgICBpZiAodGMuZCAhPSBudWxsKSBqYy5zZCA9IHRjLmQ7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCwgamMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxpICE9PSB2b2lkIDAgJiYgb3RoZXJDLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBub29wXG5cbiAgICAgICAgaWYgKCFjb21tb25PcGVyYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgLy8gd2UncmUgdHJ5aW5nIHRvIGRlbGV0ZSB0aGUgc2FtZSBlbGVtZW50LCAtPiBub29wXG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCAmJiB0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGJvdGggcmVwbGFjaW5nIG9uZSBlbGVtZW50IHdpdGggYW5vdGhlci4gb25seSBvbmUgY2FuIHN1cnZpdmVcbiAgICAgICAgICAgIGMubGQgPSBjbG9uZShvdGhlckMubGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5saSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgPT09IHVuZGVmaW5lZCAmJiBjb21tb25PcGVyYW5kICYmIGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIGluIGxpIHZzLiBsaSwgbGVmdCB3aW5zLlxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0JylcbiAgICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckMucFtjb21tb25dIDw9IGMucFtjb21tb25dKSB7XG4gICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICAvLyBvdGhlckMgZWRpdHMgdGhlIHNhbWUgbGlzdCB3ZSBlZGl0XG4gICAgICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5sbSlcbiAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAvLyBjaGFuZ2luZyBjLmZyb20gaXMgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA9PT0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgICAgIC8vIHRoZXkgZGVsZXRlZCB0aGUgdGhpbmcgd2UncmUgdHJ5aW5nIHRvIG1vdmVcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvdGhlckMgZWRpdHMgdGhlIHNhbWUgbGlzdCB3ZSBlZGl0XG4gICAgICAgICAgdmFyIHAgPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICAgIHZhciBmcm9tID0gYy5wW2NvbW1vbl07XG4gICAgICAgICAgdmFyIHRvID0gYy5sbTtcbiAgICAgICAgICBpZiAocCA8IHRvIHx8IChwID09PSB0byAmJiBmcm9tIDwgdG8pKVxuICAgICAgICAgICAgYy5sbS0tO1xuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPCBjLnBbY29tbW9uXSkge1xuICAgICAgICBjLnBbY29tbW9uXS0tO1xuICAgICAgfSBlbHNlIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAob3RoZXJDcGxlbmd0aCA8IGNwbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gd2UncmUgYmVsb3cgdGhlIGRlbGV0ZWQgZWxlbWVudCwgc28gLT4gbm9vcFxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9IGVsc2UgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChjLmxpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHJlcGxhY2luZywgdGhleSdyZSBkZWxldGluZy4gd2UgYmVjb21lIGFuIGluc2VydC5cbiAgICAgICAgICAgIGRlbGV0ZSBjLmxkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSB0cnlpbmcgdG8gZGVsZXRlIHRoZSBzYW1lIGVsZW1lbnQsIC0+IG5vb3BcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvdGhlckMubG0gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCAmJiBjcGxlbmd0aCA9PT0gb3RoZXJDcGxlbmd0aCkge1xuICAgICAgICAvLyBsbSB2cyBsbSwgaGVyZSB3ZSBnbyFcbiAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gYy5sbTtcbiAgICAgICAgdmFyIG90aGVyRnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciBvdGhlclRvID0gb3RoZXJDLmxtO1xuICAgICAgICBpZiAob3RoZXJGcm9tICE9PSBvdGhlclRvKSB7XG4gICAgICAgICAgLy8gaWYgb3RoZXJGcm9tID09IG90aGVyVG8sIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIG91ciBvcC5cblxuICAgICAgICAgIC8vIHdoZXJlIGRpZCBteSB0aGluZyBnbz9cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAvLyB0aGV5IG1vdmVkIGl0ISB0aWUgYnJlYWsuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgIGMucFtjb21tb25dID0gb3RoZXJUbztcbiAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSAvLyB1Z2hcbiAgICAgICAgICAgICAgICBjLmxtID0gb3RoZXJUbztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGV5IG1vdmVkIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGZyb20gPiBvdGhlckZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG90aGVyVG8pIGMucFtjb21tb25dKys7XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tID09PSBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIGlmIChvdGhlckZyb20gPiBvdGhlclRvKSB7XG4gICAgICAgICAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIC8vIHVnaCwgYWdhaW5cbiAgICAgICAgICAgICAgICAgIGMubG0rKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdGVwIDI6IHdoZXJlIGFtIGkgZ29pbmcgdG8gcHV0IGl0P1xuICAgICAgICAgICAgaWYgKHRvID4gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAgIGMubG0tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG8gPT09IG90aGVyRnJvbSkge1xuICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgICAgIGMubG0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0byA+IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJUbykge1xuICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBib3RoIG1vdmluZyBpbiB0aGUgc2FtZSBkaXJlY3Rpb24sIHRpZSBicmVha1xuICAgICAgICAgICAgICBpZiAoKG90aGVyVG8gPiBvdGhlckZyb20gJiYgdG8gPiBmcm9tKSB8fFxuICAgICAgICAgICAgICAgICAgKG90aGVyVG8gPCBvdGhlckZyb20gJiYgdG8gPCBmcm9tKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKSBjLmxtKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZnJvbSkgYy5sbSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSBvdGhlckZyb20pIGMubG0tLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCA9PT0gdW5kZWZpbmVkICYmIGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgLy8gbGlcbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBvdGhlckMubG07XG4gICAgICAgIHAgPSBjLnBbY29tbW9uXTtcbiAgICAgICAgaWYgKHAgPiBmcm9tKSBjLnBbY29tbW9uXS0tO1xuICAgICAgICBpZiAocCA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbGQsIGxkK2xpLCBzaSwgc2QsIG5hLCBvaSwgb2QsIG9pK29kLCBhbnkgbGkgb24gYW4gZWxlbWVudCBiZW5lYXRoXG4gICAgICAgIC8vIHRoZSBsbVxuICAgICAgICAvL1xuICAgICAgICAvLyBpLmUuIHRoaW5ncyBjYXJlIGFib3V0IHdoZXJlIHRoZWlyIGl0ZW0gaXMgYWZ0ZXIgdGhlIG1vdmUuXG4gICAgICAgIHZhciBmcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIHRvID0gb3RoZXJDLmxtO1xuICAgICAgICBwID0gYy5wW2NvbW1vbl07XG4gICAgICAgIGlmIChwID09PSBmcm9tKSB7XG4gICAgICAgICAgYy5wW2NvbW1vbl0gPSB0bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocCA+IGZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgICAgaWYgKHAgPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICBlbHNlIGlmIChwID09PSB0byAmJiBmcm9tID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAob3RoZXJDLm9pICE9PSB2b2lkIDAgJiYgb3RoZXJDLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAoYy5vaSAhPT0gdm9pZCAwICYmIGNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICAvLyB3ZSBpbnNlcnRlZCB3aGVyZSBzb21lb25lIGVsc2UgcmVwbGFjZWRcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gbGVmdCB3aW5zXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2Ugd2luLCBtYWtlIG91ciBvcCByZXBsYWNlIHdoYXQgdGhleSBpbnNlcnRlZFxuICAgICAgICAgICAgYy5vZCA9IG90aGVyQy5vaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLT4gbm9vcCBpZiB0aGUgb3RoZXIgY29tcG9uZW50IGlzIGRlbGV0aW5nIHRoZSBzYW1lIG9iamVjdCAob3IgYW55IHBhcmVudClcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLm9pICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gbGVmdCB3aW5zIGlmIHdlIHRyeSB0byBpbnNlcnQgYXQgdGhlIHNhbWUgcGxhY2VcbiAgICAgICAgaWYgKHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGpzb24uYXBwZW5kKGRlc3Qse3A6IGMucCwgb2Q6b3RoZXJDLm9pfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5wW2NvbW1vbl0gPT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBkZWxldGUgYy5vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGpzb24uYXBwZW5kKGRlc3QsYyk7XG4gIHJldHVybiBkZXN0O1xufTtcblxuaWYgKHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlcXVpcmUoJy4vaGVscGVycycpLl9ib290c3RyYXBUcmFuc2Zvcm0oanNvbiwganNvbi50cmFuc2Zvcm1Db21wb25lbnQsIGpzb24uY2hlY2tWYWxpZE9wLCBqc29uLmFwcGVuZCk7XG59IGVsc2Uge1xuICAvLyBUaGlzIGlzIGtpbmQgb2YgYXdmdWwgLSBjb21lIHVwIHdpdGggYSBiZXR0ZXIgd2F5IHRvIGhvb2sgdGhpcyBoZWxwZXIgY29kZSB1cC5cbiAgZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtKGpzb24sIGpzb24udHJhbnNmb3JtQ29tcG9uZW50LCBqc29uLmNoZWNrVmFsaWRPcCwganNvbi5hcHBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpzb247XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4yXG5leHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0gPSBmdW5jdGlvbih0eXBlLCB0cmFuc2Zvcm1Db21wb25lbnQsIGNoZWNrVmFsaWRPcCwgYXBwZW5kKSB7XG4gIHZhciB0cmFuc2Zvcm1Db21wb25lbnRYLCB0cmFuc2Zvcm1YO1xuXG4gIHRyYW5zZm9ybUNvbXBvbmVudFggPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgZGVzdExlZnQsIGRlc3RSaWdodCkge1xuICAgIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0TGVmdCwgbGVmdCwgcmlnaHQsICdsZWZ0Jyk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUNvbXBvbmVudChkZXN0UmlnaHQsIHJpZ2h0LCBsZWZ0LCAncmlnaHQnKTtcbiAgfTtcbiAgdHlwZS50cmFuc2Zvcm1YID0gdHlwZS50cmFuc2Zvcm1YID0gdHJhbnNmb3JtWCA9IGZ1bmN0aW9uKGxlZnRPcCwgcmlnaHRPcCkge1xuICAgIHZhciBrLCBsLCBsXywgbmV3TGVmdE9wLCBuZXdSaWdodE9wLCBuZXh0Qywgciwgcl8sIHJpZ2h0Q29tcG9uZW50LCBfaSwgX2osIF9rLCBfbCwgX2xlbiwgX2xlbjEsIF9sZW4yLCBfbGVuMywgX3JlZiwgX3JlZjE7XG5cbiAgICBjaGVja1ZhbGlkT3AobGVmdE9wKTtcbiAgICBjaGVja1ZhbGlkT3AocmlnaHRPcCk7XG4gICAgbmV3UmlnaHRPcCA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcmlnaHRPcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgcmlnaHRDb21wb25lbnQgPSByaWdodE9wW19pXTtcbiAgICAgIG5ld0xlZnRPcCA9IFtdO1xuICAgICAgayA9IDA7XG4gICAgICB3aGlsZSAoayA8IGxlZnRPcC5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEMgPSBbXTtcbiAgICAgICAgdHJhbnNmb3JtQ29tcG9uZW50WChsZWZ0T3Bba10sIHJpZ2h0Q29tcG9uZW50LCBuZXdMZWZ0T3AsIG5leHRDKTtcbiAgICAgICAgaysrO1xuICAgICAgICBpZiAobmV4dEMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBuZXh0Q1swXTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0Qy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBfcmVmID0gbGVmdE9wLnNsaWNlKGspO1xuICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBsID0gX3JlZltfal07XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmlnaHRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZWYxID0gdHJhbnNmb3JtWChsZWZ0T3Auc2xpY2UoayksIG5leHRDKSwgbF8gPSBfcmVmMVswXSwgcl8gPSBfcmVmMVsxXTtcbiAgICAgICAgICBmb3IgKF9rID0gMCwgX2xlbjIgPSBsXy5sZW5ndGg7IF9rIDwgX2xlbjI7IF9rKyspIHtcbiAgICAgICAgICAgIGwgPSBsX1tfa107XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChfbCA9IDAsIF9sZW4zID0gcl8ubGVuZ3RoOyBfbCA8IF9sZW4zOyBfbCsrKSB7XG4gICAgICAgICAgICByID0gcl9bX2xdO1xuICAgICAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyaWdodENvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIGFwcGVuZChuZXdSaWdodE9wLCByaWdodENvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBsZWZ0T3AgPSBuZXdMZWZ0T3A7XG4gICAgfVxuICAgIHJldHVybiBbbGVmdE9wLCBuZXdSaWdodE9wXTtcbiAgfTtcbiAgcmV0dXJuIHR5cGUudHJhbnNmb3JtID0gdHlwZVsndHJhbnNmb3JtJ10gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgdHlwZSkge1xuICAgIGlmICghKHR5cGUgPT09ICdsZWZ0JyB8fCB0eXBlID09PSAncmlnaHQnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlICdsZWZ0JyBvciAncmlnaHQnXCIpO1xuICAgIH1cbiAgICBpZiAob3RoZXJPcC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvcDtcbiAgICB9XG4gICAgaWYgKG9wLmxlbmd0aCA9PT0gMSAmJiBvdGhlck9wLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUNvbXBvbmVudChbXSwgb3BbMF0sIG90aGVyT3BbMF0sIHR5cGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvcCwgb3RoZXJPcClbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1YKG90aGVyT3AsIG9wKVsxXTtcbiAgICB9XG4gIH07XG59O1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjYuMlxudmFyIGFwcGVuZCwgY2hlY2tWYWxpZENvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBpbnZlcnRDb21wb25lbnQsIHN0ckluamVjdCwgdGV4dCwgdHJhbnNmb3JtQ29tcG9uZW50LCB0cmFuc2Zvcm1Qb3NpdGlvbjtcblxudGV4dCA9IHtcbiAgbmFtZTogJ3RleHQtb2xkJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3RleHR2MCcsXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5zdHJJbmplY3QgPSBmdW5jdGlvbihzMSwgcG9zLCBzMikge1xuICByZXR1cm4gczEuc2xpY2UoMCwgcG9zKSArIHMyICsgczEuc2xpY2UocG9zKTtcbn07XG5cbmNoZWNrVmFsaWRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIHZhciBkX3R5cGUsIGlfdHlwZTtcblxuICBpZiAodHlwZW9mIGMucCAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvbmVudCBtaXNzaW5nIHBvc2l0aW9uIGZpZWxkJyk7XG4gIH1cbiAgaV90eXBlID0gdHlwZW9mIGMuaTtcbiAgZF90eXBlID0gdHlwZW9mIGMuZDtcbiAgaWYgKCEoKGlfdHlwZSA9PT0gJ3N0cmluZycpIF4gKGRfdHlwZSA9PT0gJ3N0cmluZycpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG5lZWRzIGFuIGkgb3IgZCBmaWVsZCcpO1xuICB9XG4gIGlmICghKGMucCA+PSAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpb24gY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG4gIH1cbn07XG5cbmNoZWNrVmFsaWRPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBjLCBfaSwgX2xlbjtcblxuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wW19pXTtcbiAgICBjaGVja1ZhbGlkQ29tcG9uZW50KGMpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudGV4dC5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICB2YXIgY29tcG9uZW50LCBkZWxldGVkLCBfaSwgX2xlbjtcblxuICBjaGVja1ZhbGlkT3Aob3ApO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgY29tcG9uZW50ID0gb3BbX2ldO1xuICAgIGlmIChjb21wb25lbnQuaSAhPSBudWxsKSB7XG4gICAgICBzbmFwc2hvdCA9IHN0ckluamVjdChzbmFwc2hvdCwgY29tcG9uZW50LnAsIGNvbXBvbmVudC5pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlZCA9IHNuYXBzaG90LnNsaWNlKGNvbXBvbmVudC5wLCBjb21wb25lbnQucCArIGNvbXBvbmVudC5kLmxlbmd0aCk7XG4gICAgICBpZiAoY29tcG9uZW50LmQgIT09IGRlbGV0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVsZXRlIGNvbXBvbmVudCAnXCIgKyBjb21wb25lbnQuZCArIFwiJyBkb2VzIG5vdCBtYXRjaCBkZWxldGVkIHRleHQgJ1wiICsgZGVsZXRlZCArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIHNuYXBzaG90ID0gc25hcHNob3Quc2xpY2UoMCwgY29tcG9uZW50LnApICsgc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc25hcHNob3Q7XG59O1xuXG50ZXh0Ll9hcHBlbmQgPSBhcHBlbmQgPSBmdW5jdGlvbihuZXdPcCwgYykge1xuICB2YXIgbGFzdCwgX3JlZiwgX3JlZjE7XG5cbiAgaWYgKGMuaSA9PT0gJycgfHwgYy5kID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobmV3T3AubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ld09wLnB1c2goYyk7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IG5ld09wW25ld09wLmxlbmd0aCAtIDFdO1xuICAgIGlmICgobGFzdC5pICE9IG51bGwpICYmIChjLmkgIT0gbnVsbCkgJiYgKGxhc3QucCA8PSAoX3JlZiA9IGMucCkgJiYgX3JlZiA8PSAobGFzdC5wICsgbGFzdC5pLmxlbmd0aCkpKSB7XG4gICAgICByZXR1cm4gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIGk6IHN0ckluamVjdChsYXN0LmksIGMucCAtIGxhc3QucCwgYy5pKSxcbiAgICAgICAgcDogbGFzdC5wXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoKGxhc3QuZCAhPSBudWxsKSAmJiAoYy5kICE9IG51bGwpICYmIChjLnAgPD0gKF9yZWYxID0gbGFzdC5wKSAmJiBfcmVmMSA8PSAoYy5wICsgYy5kLmxlbmd0aCkpKSB7XG4gICAgICByZXR1cm4gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV0gPSB7XG4gICAgICAgIGQ6IHN0ckluamVjdChjLmQsIGxhc3QucCAtIGMucCwgbGFzdC5kKSxcbiAgICAgICAgcDogYy5wXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3T3AucHVzaChjKTtcbiAgICB9XG4gIH1cbn07XG5cbnRleHQuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIHZhciBjLCBuZXdPcCwgX2ksIF9sZW47XG5cbiAgY2hlY2tWYWxpZE9wKG9wMSk7XG4gIGNoZWNrVmFsaWRPcChvcDIpO1xuICBuZXdPcCA9IG9wMS5zbGljZSgpO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcDJbX2ldO1xuICAgIGFwcGVuZChuZXdPcCwgYyk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxudGV4dC5jb21wcmVzcyA9IGZ1bmN0aW9uKG9wKSB7XG4gIHJldHVybiB0ZXh0LmNvbXBvc2UoW10sIG9wKTtcbn07XG5cbnRleHQubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIGMsIG5ld09wLCBfaSwgX2xlbiwgX3JlZjtcblxuICBuZXdPcCA9IFtdO1xuICBpZiAoKG9wLmkgIT0gbnVsbCkgfHwgKG9wLnAgIT0gbnVsbCkpIHtcbiAgICBvcCA9IFtvcF07XG4gIH1cbiAgZm9yIChfaSA9IDAsIF9sZW4gPSBvcC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBvcFtfaV07XG4gICAgaWYgKChfcmVmID0gYy5wKSA9PSBudWxsKSB7XG4gICAgICBjLnAgPSAwO1xuICAgIH1cbiAgICBhcHBlbmQobmV3T3AsIGMpO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbnRyYW5zZm9ybVBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCBjLCBpbnNlcnRBZnRlcikge1xuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICBpZiAoYy5wIDwgcG9zIHx8IChjLnAgPT09IHBvcyAmJiBpbnNlcnRBZnRlcikpIHtcbiAgICAgIHJldHVybiBwb3MgKyBjLmkubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocG9zIDw9IGMucCkge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGVsc2UgaWYgKHBvcyA8PSBjLnAgKyBjLmQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYy5wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcG9zIC0gYy5kLmxlbmd0aDtcbiAgICB9XG4gIH1cbn07XG5cbnRleHQudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24ocG9zaXRpb24sIG9wLCBzaWRlKSB7XG4gIHZhciBjLCBpbnNlcnRBZnRlciwgX2ksIF9sZW47XG5cbiAgaW5zZXJ0QWZ0ZXIgPSBzaWRlID09PSAncmlnaHQnO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wW19pXTtcbiAgICBwb3NpdGlvbiA9IHRyYW5zZm9ybVBvc2l0aW9uKHBvc2l0aW9uLCBjLCBpbnNlcnRBZnRlcik7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uO1xufTtcblxudGV4dC5fdGMgPSB0cmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHNpZGUpIHtcbiAgdmFyIGNJbnRlcnNlY3QsIGludGVyc2VjdEVuZCwgaW50ZXJzZWN0U3RhcnQsIG5ld0MsIG90aGVySW50ZXJzZWN0LCBzO1xuXG4gIGNoZWNrVmFsaWRPcChbY10pO1xuICBjaGVja1ZhbGlkT3AoW290aGVyQ10pO1xuICBpZiAoYy5pICE9IG51bGwpIHtcbiAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgaTogYy5pLFxuICAgICAgcDogdHJhbnNmb3JtUG9zaXRpb24oYy5wLCBvdGhlckMsIHNpZGUgPT09ICdyaWdodCcpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG90aGVyQy5pICE9IG51bGwpIHtcbiAgICAgIHMgPSBjLmQ7XG4gICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtcbiAgICAgICAgICBkOiBzLnNsaWNlKDAsIG90aGVyQy5wIC0gYy5wKSxcbiAgICAgICAgICBwOiBjLnBcbiAgICAgICAgfSk7XG4gICAgICAgIHMgPSBzLnNsaWNlKG90aGVyQy5wIC0gYy5wKTtcbiAgICAgIH1cbiAgICAgIGlmIChzICE9PSAnJykge1xuICAgICAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgICAgIGQ6IHMsXG4gICAgICAgICAgcDogYy5wICsgb3RoZXJDLmkubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy5wID49IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCB7XG4gICAgICAgICAgZDogYy5kLFxuICAgICAgICAgIHA6IGMucCAtIG90aGVyQy5kLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoYy5wICsgYy5kLmxlbmd0aCA8PSBvdGhlckMucCkge1xuICAgICAgICBhcHBlbmQoZGVzdCwgYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdDID0ge1xuICAgICAgICAgIGQ6ICcnLFxuICAgICAgICAgIHA6IGMucFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYy5wIDwgb3RoZXJDLnApIHtcbiAgICAgICAgICBuZXdDLmQgPSBjLmQuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnAgKyBjLmQubGVuZ3RoID4gb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpIHtcbiAgICAgICAgICBuZXdDLmQgKz0gYy5kLnNsaWNlKG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoIC0gYy5wKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcnNlY3RTdGFydCA9IE1hdGgubWF4KGMucCwgb3RoZXJDLnApO1xuICAgICAgICBpbnRlcnNlY3RFbmQgPSBNYXRoLm1pbihjLnAgKyBjLmQubGVuZ3RoLCBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCk7XG4gICAgICAgIGNJbnRlcnNlY3QgPSBjLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBjLnAsIGludGVyc2VjdEVuZCAtIGMucCk7XG4gICAgICAgIG90aGVySW50ZXJzZWN0ID0gb3RoZXJDLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBvdGhlckMucCwgaW50ZXJzZWN0RW5kIC0gb3RoZXJDLnApO1xuICAgICAgICBpZiAoY0ludGVyc2VjdCAhPT0gb3RoZXJJbnRlcnNlY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlbGV0ZSBvcHMgZGVsZXRlIGRpZmZlcmVudCB0ZXh0IGluIHRoZSBzYW1lIHJlZ2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Qy5kICE9PSAnJykge1xuICAgICAgICAgIG5ld0MucCA9IHRyYW5zZm9ybVBvc2l0aW9uKG5ld0MucCwgb3RoZXJDKTtcbiAgICAgICAgICBhcHBlbmQoZGVzdCwgbmV3Qyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5pbnZlcnRDb21wb25lbnQgPSBmdW5jdGlvbihjKSB7XG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBkOiBjLmksXG4gICAgICBwOiBjLnBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBpOiBjLmQsXG4gICAgICBwOiBjLnBcbiAgICB9O1xuICB9XG59O1xuXG50ZXh0LmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBjLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG5cbiAgX3JlZiA9IG9wLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBfcmVzdWx0cyA9IFtdO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gX3JlZltfaV07XG4gICAgX3Jlc3VsdHMucHVzaChpbnZlcnRDb21wb25lbnQoYykpO1xuICB9XG4gIHJldHVybiBfcmVzdWx0cztcbn07XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5fYm9vdHN0cmFwVHJhbnNmb3JtKHRleHQsIHRleHQudHJhbnNmb3JtQ29tcG9uZW50LCB0ZXh0LmNoZWNrVmFsaWRPcCwgdGV4dC5hcHBlbmQpO1xufSBlbHNlIHtcbiAgcmVxdWlyZSgnLi9oZWxwZXJzJykuX2Jvb3RzdHJhcFRyYW5zZm9ybSh0ZXh0LCB0ZXh0LnRyYW5zZm9ybUNvbXBvbmVudCwgdGV4dC5jaGVja1ZhbGlkT3AsIHRleHQuYXBwZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZXh0O1xuIl19
;
(function() {
var view = require("derby").app.view;
view._makeAll({
  "app/403.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>403</h1></div><p class=\"lead\">{__(_session.locale, 'Sorry_page_forbidden')}</p></div>",
  "app/403.html:title": "403",
  "app/404.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>404</h1></div><p class=\"lead\">{__(_session.locale, 'Sorry_page_not_found')}</p></div>",
  "app/404.html:title": "404",
  "app/500.html:body": "<div class=\"container\"><div class=\"page-header\"><h1>500</h1></div><p class=\"lead\">{__(_session.locale, 'Sorry_something_went_wrong')}</p></div>",
  "app/500.html:title": "500",
  "app/home.html:body": "<div class=\"jumbotron\"><div class=\"container\"><h1><i class=\"fa fa-flag\"></i> Derby Lang</h1><p>{unescaped __(_session.locale, 'A_translation_library_for_name', 'name', link('http://derbyjs.com', 'Derby JS'))}</p><p><a class=\"btn btn-primary btn-lg\" role=\"button\" href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> {__(_session.locale, 'View_on_name', 'name', 'GitHub')}</a></p><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"watch\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"fork\" width=\"90\"><ghbtns:button count=\"true\" giturl=\"{{$config.repository.url}}\" type=\"follow\" width=\"180\"></div></div>",
  "app/home.html:title": "Derby Lang",
  "app/index.html:footer": "<hr><div class=\"container\"><div id=\"footer\"><p class=\"text-muted credit\">Derby Lang {{$config.version}}  <a href=\"{{$config.repository.url}}\"><i class=\"fa fa-github\"></i> {__(_session.locale, 'Name_Project', 'name', 'GitHub')}</a></p></div></div>",
  "app/index.html:header": "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link href=\"/shared/bower_components/bootstrap/dist/css/bootstrap.min.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/bootstrap/examples/jumbotron/jumbotron.css\" rel=\"stylesheet\"><link href=\"/shared/bower_components/font-awesome/css/font-awesome.min.css\" rel=\"stylesheet\"><ui:connectionAlert><header class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\"><div class=\"container\"><div class=\"navbar-header\"><button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\"><span class=\"sr-only\">__(_session.locale, 'Toggle_navigation')</span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span><span class=\"icon-bar\"></span></button><a class=\"navbar-brand\" href=\"/\"><i class=\"fa fa-flag\"></i> Derby Lang</a></div><div class=\"navbar-collapse collapse\"><ul class=\"nav navbar-nav\"><app:navitem href=\"/\" title=\"Home\"></ul><form class=\"navbar-form navbar-right\"><label class=\"sr-only\" for=\"languages\">{__(_session.locale, 'Language')}</label><select class=\"form-control\" id=\"languages\">{#each $lang.locales}<option selected=\"{equal(_session.locale, .)}\" value=\"{.}\">{__(., .)}</option>{/}</select></form></div></div></header>",
  "app/index.html:navitem": "<li class=\"{{#if equal($url, @href)}}active{{/}}\"><a href=\"{{@href}}\">{__(_session.locale, @title)}</a></li>",
  "app/index.html:scripts": "<script src=\"/shared/bower_components/jquery/jquery.min.js\"></script><script src=\"/shared/bower_components/bootstrap/dist/js/bootstrap.min.js\"></script>"
}, {
  "403:body": [
  "app/403.html:body",
  {}
],
  "403:title": [
  "app/403.html:title",
  {}
],
  "404:body": [
  "app/404.html:body",
  {}
],
  "404:title": [
  "app/404.html:title",
  {}
],
  "500:body": [
  "app/500.html:body",
  {}
],
  "500:title": [
  "app/500.html:title",
  {}
],
  "footer": [
  "app/index.html:footer",
  {}
],
  "header": [
  "app/index.html:header",
  {}
],
  "home:body": [
  "app/home.html:body",
  {}
],
  "home:title": [
  "app/home.html:title",
  {}
],
  "navitem": [
  "app/index.html:navitem",
  {}
],
  "scripts": [
  "app/index.html:scripts",
  {}
]
});
view._makeComponents({
  "ghbtns": {
  "instances": {
  "button": [
  "button/index.html:button",
  {}
]
},
  "templates": {
  "button/index.html:button": "{#if :self.show}<iframe allowtransparency=\"true\" frameborder=\"0\" height=\"{:self.height}\" scrolling=\"0\" src=\"{:self.fileurl}?user={:self.user}&repo={:self.repo}&type={@type}{#if @count}&count={@count}{/}{#if @size}&size={@size}{/}\" width=\"{@width}\"></iframe>{/}"
}
},
  "ui": {
  "instances": {
  "connectionalert": [
  "connectionAlert/index.html:connectionalert",
  {}
]
},
  "templates": {
  "connectionAlert/index.html:connectionalert": "{#unless equal($connection.state, 'connected')}<div class=\"alert alert-warning\"><div class=\"container\">{#if equal($connection.state, 'stopped')}Unable to reconnect  <a x-bind=\"click: reload\"><i class=\"fa fa-refresh\"></i> Reload</a>{else}{sentenceCase($connection.state)}  {#if :self.hideReconnect}<i class=\"fa fa-refresh fa-spin\"></i> Reconnecting{else}<a x-bind=\"click: reconnect\"><i class=\"fa fa-refresh\"></i> Reconnect</a>{/}{/}</div></div>{/}"
}
}
});
})();